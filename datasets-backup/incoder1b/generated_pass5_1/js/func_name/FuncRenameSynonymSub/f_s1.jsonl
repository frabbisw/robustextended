{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> receiveCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> receiveCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst receiveCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "receiveCloseElements", "gc": "<|endoftext|>/* Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> receiveCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> receiveCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst receiveCloseElements = (numbers, threshold) => {\n  const closeElements = numbers.filter(n => Math.abs(n - threshold) < 1e-6)\n  return closeElements.length > 0\n}\n\n/**\n * Check if in given list of numbers, are any two numbers closer to each other than\n * given threshold.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered as close to each other.\n * If two numbers are closer to each other, they are considered ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/1", "prompt": "/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> freestandingParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst freestandingParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "freestandingParenGroups", "gc": "<|endoftext|>/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> freestandingParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst freestandingParenGroups = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]+)\\)/g);\n  const paren_group_strings = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const paren_group = paren_groups[i];\n    const paren_group_string = '';\n    for (let j = 0; j < paren_group.length; j++) {\n      const char = paren_group.charAt(j);\n      if (char === '(') {\n        paren_group_string += char;\n      } else if (char === ')') {\n        paren_group_string += char;\n      } else if (char ==='') {\n        paren_group_string += char;\n      } else {\n        paren_group_string += char;\n      }\n    }\n    paren_group_strings.push(paren_group_string);\n  }\n  return paren_group_strings;\n};\n\n/**\n  Given a string containing nested parentheses, return the list of strings that are\n  not nested within each other.\n  >>> freestandingParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst freestandingNotNestedParenGroups = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]+)\\)/g);\n  const paren_group_strings = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const paren_group = paren_groups[i];\n    const paren_group_string = '';\n    for (let j = 0; j < paren_group.length; j++) {\n      const char = paren_group.charAt(j);\n      if (char === ')') {\n        paren_group_string += char;\n      } else if (char ==='') {\n        paren_group_string += char;\n      } else {\n        paren_group_string += char;\n      }\n    }\n    paren_group_strings.push(paren_group_string);\n  }\n  return paren_group_strings;\n};\n\n/**\n  Given a string containing nested parentheses, return the list of strings that are\n  not nested within each other.\n  >>> freestandingNotNestedParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst freestandingNotNestedParenGroupsNoSpaces = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]+)\\)/g);\n  const paren_group_strings = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const paren_group = paren_groups[i];\n    const paren_group_string = '';\n    for (let j = 0; j < paren_group.length; j++) {\n      const char = paren_group.charAt(j);\n      if (char ==='') {\n        paren_group_string += char;\n      } else {\n        paren_group_string += char;\n      }\n    }\n    paren_group_strings.push(paren_group_string);\n  }\n  return paren_group_strings;\n};\n\n/**\n  Given a string containing nested parentheses, return the list of strings that are\n  not nested within each other.\n  >>> freestandingNotNestedParenGroupsNoSpaces('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst freestandingNotNestedParenGroupsNoSpacesNoSpaces = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]+)\\)/g);\n  const paren_group_strings = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const paren_group = paren_groups[i];\n    const paren_group_string = '';\n    for (let j = 0; j < paren_group.length; j++) {\n      const char = paren_group.charAt(j);\n      if (char ==='') {\n        paren_group_string += char;\n      } else {\n        paren_group_string += char;\n      }\n    }\n    paren_group_strings.push(paren_group_string);\n  }\n  return paren_group_strings;\n};\n\n/**\n  Given a string containing nested parentheses, return the list of strings that are\n  not nested within each other.\n  >>> freestandingNotNestedParenGroupsNoSpacesNoSpaces('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst freestandingNotNestedParenGroupsNoSpacesNoSpacesNoSpaces = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]+)\\)/g);\n  const paren_group_strings = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const paren_group = paren_groups[i];\n    const paren_group_string = '';\n    for (let j = 0; j < paren_group.length; j++) {\n      const char = paren_group.charAt(j);\n      if (char ==='') {\n        paren_group_string += char;\n      } else {\n        paren_group_string += char;\n      }\n    }\n    paren_group_strings.push(paren_group_string);\n  }\n  return paren_group_strings;\n};\n\n/**\n  Given a string containing nested parentheses, return the list of strings that are\n  not nested within each other.\n  >>> freestandingNotNestedParenGroupsNoSpacesNoSpacesNoSpaces('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst freestandingNotNestedParenGroupsNoSpacesNoSpacesNoSpacesNoSpacesNoSpaces = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]+)\\)/g);\n  const paren_group_strings = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const paren_group = paren_groups[i];\n    const paren_group_string = '';\n    for (let j = 0; j < paren_group.length; j++) {\n      const char = paren_group.charAt(j);\n      if (char ==='') {\n        paren_group_string += char;\n      } else {\n        paren_group_string += char;\n      }\n    }\n    paren_group_strings.push(paren_group_string);\n  }\n  return paren_group_strings;\n};\n\n/**\n  Given a string containing nested parentheses, return the list of strings that are\n  not nested within each other.\n  >>> freestandingNotNestedParenGroupsNoSpacesNoSpacesNoSpacesNoSpacesNoSpaces('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst freestandingNotNestedParenGroupsNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpaces = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]+)\\)/g);\n  const paren_group_strings = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const paren_group = paren_groups[i];\n    const paren_group_string = '';\n    for (let j = 0; j < paren_group.length; j++) {\n      const char = paren_group.charAt(j);\n      if (char ==='') {\n        paren_group_string += char;\n      } else {\n        paren_group_string += char;\n      }\n    }\n    paren_group_strings.push(paren_group_string);\n  }\n  return paren_group_strings;\n};\n\n/**\n  Given a string containing nested parentheses, return the list of strings that are\n  not nested within each other.\n  >>> freestandingNotNestedParenGroupsNoSpacesNoSpacesNoSpacesNo", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "gc": "<|endoftext|>/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPalindromeLength = 0;\n  let longestPalindromePrefix = '';\n  let longestPalindromeSuffix = '';\n  let palindromeLength = 0;\n  let palindromePrefix = '';\n  let palindromeSuffix = '';\n  let palindromePrefixLength = 0;\n  let palindromeSuffixLength = 0;\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === string[string.length - i - 1]) {\n      palindromeLength++;\n      palindromePrefixLength++;\n      palindromeSuffixLength++;\n    }\n  }\n\n  /* Find the longest palindrome that begins with a supplied string and append the reverse of the string prefix to the string */\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === string[string.length - i - 1]) {\n      palindromeLength++;\n      palindromePrefixLength++;\n      palindromeSuffixLength++;\n    }\n  }\n\n  /* Find the longest palindrome that begins with a supplied string and append the reverse of the string prefix to the string */\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === string[string.length - i - 1]) {\n      palindromeLength++;\n      palindromePrefixLength++;\n      palindromeSuffixLength++;\n    }\n  }\n\n  /* Find the longest palindrome that begins with a supplied string and append the reverse of the string prefix to the string */\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === string[string.length - i - 1]) {\n      palindromeLength++;\n      palindromePrefixLength++;\n      palindromeSuffixLength++;\n    }\n  }\n\n  /* Find the longest palindrome that begins with a supplied string and append the reverse of the string prefix to the string */\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === string[string.length - i - 1]) {\n      palindromeLength++;\n      palindromePrefixLength++;\n      palindromeSuffixLength++;\n    }\n  }\n\n  /* Find the longest palindrome that begins with a supplied string and append the reverse of the string prefix to the string */\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === string[string.length - i - 1]) {\n      palindromeLength++;\n      palindromePrefixLength++;\n      palindromeSuffixLength++;\n    }\n  }\n\n  /* Find the longest palindrome that begins with a supplied string and append the reverse of the string prefix to the string */\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === string[string.length - i - 1]) {\n      palindromeLength++;\n      palindromePrefixLength++;\n      palindromeSuffixLength++;\n    }\n  }\n\n  /* Find the longest palindrome that begins with a supplied string and append the reverse of the string prefix to the string */\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === string[string.length - i - 1]) {\n      palindromeLength++;\n      palindromePrefixLength++;\n      palindromeSuffixLength++;\n    }\n  }\n\n  /* Find the longest palindrome that begins with a supplied string and append the reverse of the string prefix to the string */\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === string[string.length - i - 1]) {\n      palindromeLength++;\n      palindromePrefixLength++;\n      palindromeSuffixLength++;\n    }\n  }\n\n  /* Find the longest palindrome that begins with a supplied string and append the reverse of the string prefix to the string */\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === string[string.length - i - 1]) {\n      palindromeLength++;\n      palindromePrefixLength++;\n      palindromeSuffixLength++;\n    }\n  }\n\n  /* Find the longest palindrome that begins with a supplied string and append the reverse of the string prefix to the string */\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === string[string.length - i - 1]) {\n      palindromeLength++;\n      palindromePrefixLength++;\n      palindromeSuffixLength++;\n    }\n  }\n\n  /* Find the longest palindrome that begins with a supplied string and append the reverse of the string prefix to the string */\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === string[string.length - i - 1]) {\n      palindromeLength++;\n      palindromePrefixLength++;\n      palindromeSuffixLength++;\n    }\n  }\n\n  /* Find the longest palindrome that begins with a supplied string and append the reverse of the string prefix to the string */\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === string[string.length - i - 1]) {\n      palindromeLength++;\n      palindromePrefixLength++;\n      palindromeSuffixLength++;\n    }\n  }\n\n  /* Find the longest palindrome that begins with a supplied string and append the reverse of the string prefix to the string */\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === string[string.length - i - 1]) {\n      palindromeLength++;\n      palindromePrefixLength++;\n      palindromeSuffixLength++;\n    }\n  }\n\n  /* Find the longest palindrome that begins with a supplied string and append the reverse of the string prefix to the string */\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === string[string.length - i - 1]) {\n      palindromeLength++;\n      palindromePrefixLength++;\n      palindromeSuffixLength++;\n    }\n  }\n\n  /* Find the longest palindrome that begins with a supplied string and append the reverse of the string prefix to the string */\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === string[string.length - i - 1]) {\n      palindromeLength++;\n      palindromePrefixLength++;\n      palindromeSuffixLength++;\n    }\n  }\n\n  /* Find the longest palindrome that begins with a supplied string and append the reverse of the string prefix to the string */\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === string[string.length - i - 1]) {\n      palindromeLength++;\n      palindromePrefixLength++;\n      palindromeSuffixLength++;\n    }\n  }\n\n  /* Find the longest palindrome that begins with a supplied string and append the reverse of the string prefix to the string */\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === string[string.length - i - 1]) {\n      palindromeLength++;\n      palindromePrefixLength++;\n      palindromeSuffixLength++;\n    }\n  }\n\n  /* Find the longest palindrome that begins with a supplied string and append the reverse of the string prefix to the string */\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] === string", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(3)\n  [3, 5, 7]\n  */\nconst holdAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "holdAPile", "gc": "<|endoftext|>/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(3)\n  [3, 5, 7]\n  */\nconst holdAPile = (n) => {\n  let level = [];\n  let num = 0;\n  let i = 0;\n  while (num < n) {\n    if (i % 2 === 0) {\n      level.push(num);\n      num += 1;\n    } else {\n      num += 1;\n    }\n    i += 1;\n  }\n  return level;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(3)\n  [3, 5, 7]\n  */\nconst holdAPile = (n) => {\n  let level = [];\n  let num = 0;\n  let i = 0;\n  while (num < n) {\n    if (i % 2 === 0) {\n      level.push(num);\n      num += 1;\n    } else {\n      num += 1;\n    }\n    i += 1;\n  }\n  return level;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(3)\n  [3, 5, 7]\n  */\nconst holdAPile = (n) => {\n  let level = [];\n  let num = 0;\n  let i = 0;\n  while (num < n) {\n    if (i % 2 === 0) {\n      level.push(num);\n      num += 1;\n    } else {\n      num += 1;\n    }\n    i += 1;\n  }\n  return level;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(3)\n  [3, 5, 7]\n  */\nconst holdAPile = (n) => {\n  let level = [];\n  let num = 0;\n  let i = 0;\n  while (num < n) {\n    if (i % 2 === 0) {\n      level.push(num);\n      num += 1;\n    } else {\n      num += 1;\n    }\n    i += 1;\n  }\n  return level;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(3)\n  [3, 5, 7]\n  */\nconst holdAPile = (n) => {\n  let level = [];\n  let num = 0;\n  let i = 0;\n  while (num < n) {\n    if (i % 2 === 0) {\n      level.push(num);\n      num += 1;\n    } else {\n      num += 1;\n    }\n    i += 1;\n  }\n  return level;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(3)\n  [3, 5, 7]\n  */\nconst holdAPile = (n) => {\n  let level = [];\n  let num = 0;\n  let i = 0;\n  while (num < n) {\n    if (i % 2 === 0) {\n      level.push(num);\n      num += 1;\n    } else {\n      num += 1;\n    }\n    i += 1;\n  }\n  return level;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(3)\n  [3, 5, 7]\n  */\nconst holdAPile = (n) => {\n  let level = [];\n  let num = 0;\n  let i = 0;\n  while (num < n) {\n    if (i % 2 === 0) {\n      level.push(num);\n      num += 1;\n    } else {\n      num += 1;\n    }\n    i += 1;\n  }\n  return level;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(3)\n  [3, 5, 7]\n  */\nconst holdAPile = (n) => {\n  let level = [];\n  let num = 0;\n  let i = 0;\n  while (num < n) {\n    if (i % 2 === 0) {\n      level.push(num);\n      num += 1;\n    } else {\n      num += 1;\n    }\n    i += 1;\n  }\n  return level;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(3)\n  [3, 5, 7]\n  */\nconst holdAPile = (n) => {\n  let level = [];\n  let num = 0;\n  let i = 0;\n  while (num < n) {\n    if (i % 2 === 0) {\n      level.push(num);\n      num += 1;\n    } else {\n      num += 1;\n    }\n    i += 1;\n  }\n  return level;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> holdAPile(3)\n  [3, 5, 7]\n  */\nconst holdAPile = (n) => {\n  let level = [];\n  let num = 0;\n  let i = 0;\n  while (num < n) {\n    if (i % ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "bibleString", "gc": "<|endoftext|>/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  bibleString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst bibleString = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words. You will\n  also need to return the number of words in the string.\n  \n  For example:\n  bibleString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  bibleString(\"Hi, my name is John, how are you\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\", \"how\", \"are\", \"you\"]\n  */\nconst bibleStringCount = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words.length;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words. You will\n  also need to return the number of words in the string.\n  \n  For example:\n  bibleString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  bibleString(\"Hi, my name is John, how are you\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\", \"how\", \"are\", \"you\"]\n  */\nconst bibleStringCountAndWords = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words.length + bibleStringCount(s);\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words. You will\n  also need to return the number of words in the string.\n  \n  For example:\n  bibleString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  bibleString(\"Hi, my name is John, how are you\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\", \"how\", \"are\", \"you\"]\n  */\nconst bibleStringCountAndWordsAndWords = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words.length + bibleStringCountAndWords(s);\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words. You will\n  also need to return the number of words in the string.\n  \n  For example:\n  bibleString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  bibleString(\"Hi, my name is John, how are you\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\", \"how\", \"are\", \"you\"]\n  */\nconst bibleStringCountAndWordsAndWordsAndWords = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words.length + bibleStringCountAndWordsAndWords(s);\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words. You will\n  also need to return the number of words in the string.\n  \n  For example:\n  bibleString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  bibleString(\"Hi, my name is John, how are you\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\", \"how\", \"are\", \"you\"]\n  */\nconst bibleStringCountAndWordsAndWordsAndWordsAndWords = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words.length + bibleStringCountAndWordsAndWordsAndWords(s);\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words. You will\n  also need to return the number of words in the string.\n  \n  For example:\n  bibleString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  bibleString(\"Hi, my name is John, how are you\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\", \"how\", \"are\", \"you\"]\n  */\nconst bibleStringCountAndWordsAndWordsAndWordsAndWords = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words.length + bibleStringCountAndWordsAndWordsAndWords(s);\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words. You will\n  also need to return the number of words in the string.\n  \n  For example:\n  bibleString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  bibleString(\"Hi, my name is John, how are you\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\", \"how\", \"are\", \"you\"]\n  */\nconst bibleStringCountAndWordsAndWordsAndWordsAndWordsAndWords = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words.length + bibleStringCountAndWordsAndWordsAndWordsAndWords(s);\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words. You will\n  also need to return the number of words in the string.\n  \n  For example:\n  bibleString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  bibleString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  bibleString(\"Hi, my name is John, how are you\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\", \"how\", \"are\", \"you\"]\n  */\nconst bibleStringCountAndWordsAndWordsAndWordsAndWordsAndWords = (s) => {\n  const words = s.split(/[\\s,]+/);\n  return words.length + bibleStringCountAndWordsAndWordsAndWordsAndWords(s);\n};\n\n/*\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "gc": "<|endoftext|>/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let num = 0;\n  let max = -1;\n  let min = 0;\n  \n  if(x === 0 && y === 0) {\n    return -1;\n  }\n  \n  if(x === y) {\n    return x;\n  }\n  \n  if(x < y) {\n    num = y;\n    max = x;\n    min = y;\n  }\n  else {\n    num = x;\n    max = y;\n    min = x;\n  }\n  \n  if(max % 2 === 0) {\n    return num;\n  }\n  \n  return chooseNum(num, max);\n}\n\n/*This function takes two positive numbers x and y and returns the\n  biggest odd integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let num = 0;\n  let max = -1;\n  let min = 0;\n  \n  if(x === 0 && y === 0) {\n    return -1;\n  }\n  \n  if(x === y) {\n    return x;\n  }\n  \n  if(x < y) {\n    num = y;\n    max = x;\n    min = y;\n  }\n  else {\n    num = x;\n    max = y;\n    min = x;\n  }\n  \n  if(max % 2 === 0) {\n    return num;\n  }\n  \n  return chooseNum(num, max);\n}\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let num = 0;\n  let max = -1;\n  let min = 0;\n  \n  if(x === 0 && y === 0) {\n    return -1;\n  }\n  \n  if(x === y) {\n    return x;\n  }\n  \n  if(x < y) {\n    num = y;\n    max = x;\n    min = y;\n  }\n  else {\n    num = x;\n    max = y;\n    min = x;\n  }\n  \n  if(max % 2 === 0) {\n    return num;\n  }\n  \n  return chooseNum(num, max);\n}\n\n/*This function takes two positive numbers x and y and returns the\n  biggest negative integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let num = 0;\n  let max = -1;\n  let min = 0;\n  \n  if(x === 0 && y === 0) {\n    return -1;\n  }\n  \n  if(x === y) {\n    return x;\n  }\n  \n  if(x < y) {\n    num = y;\n    max = x;\n    min = y;\n  }\n  else {\n    num = x;\n    max = y;\n    min = x;\n  }\n  \n  if(max % 2 === 0) {\n    return num;\n  }\n  \n  return chooseNum(num, max);\n}\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let num = 0;\n  let max = -1;\n  let min = 0;\n  \n  if(x === 0 && y === 0) {\n    return -1;\n  }\n  \n  if(x === y) {\n    return x;\n  }\n  \n  if(x < y) {\n    num = y;\n    max = x;\n    min = y;\n  }\n  else {\n    num = x;\n    max = y;\n    min = x;\n  }\n  \n  if(max % 2 === 0) {\n    return num;\n  }\n  \n  return chooseNum(num, max);\n}\n\n/*This function takes two positive numbers x and y and returns the\n  biggest negative integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let num = 0;\n  let max = -1;\n  let min = 0;\n  \n  if(x === 0 && y === 0) {\n    return -1;\n  }\n  \n  if(x === y) {\n    return x;\n  }\n  \n  if(x < y) {\n    num = y;\n    max = x;\n    min = y;\n  }\n  else {\n    num = x;\n    max = y;\n    min = x;\n  }\n  \n  if(max % 2 === 0) {\n    return num;\n  }\n  \n  return chooseNum(num, max);\n}\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let num = 0;\n  let max = -1;\n  let min = 0;\n  \n  if(x === 0 && y === 0) {\n    return -1;\n  }\n  \n  if(x === y) {\n    return x;\n  }\n  \n  if(x < y) {\n    num = y;\n    max = x;\n    min = y;\n  }\n  else {\n    num = x;\n    max = y;\n    min = x;\n  }\n  \n  if(max % 2 === 0) {\n    return num;\n  }\n  \n  return chooseNum(num, max);\n}\n\n/*This function takes two positive numbers x and y and returns the\n  biggest negative integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let num = 0;\n  let max = -1;\n  let min = 0;\n  \n  if(x === 0 && y === 0) {\n    return -1;\n  }\n  \n  if(x === y) {\n    return x;\n  }\n  \n  if(x < y) {\n    num = y;\n    max = x;\n    min = y;\n  }\n  else {\n    num = x;\n    max = y;\n    min = x;\n  }\n  \n  if(max % 2 === 0) {\n    return num;\n  }\n  \n  return chooseNum(num, max);\n}\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let num = 0;\n  let max = -1;\n  let min = 0;\n  \n  if(x === 0 && y === 0) {\n    return -1;\n  }\n  \n  if(x === y) {\n    return x;\n  }\n  \n  if(x < y) {\n    num = y;\n    max = x;\n    min = y;\n  }\n  else {\n    num = x;\n    max = y;\n    min = x;\n  }\n  \n  if(max % 2 === 0) {\n    return num;\n  }\n  \n  return chooseNum(num, max", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/103", "prompt": "/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "gc": "<|endoftext|>/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  let decimal = 0;\n  let decimalCount = 0;\n  let decimalSum = 0;\n  let decimalSum2 = 0;\n  let decimalSum3 = 0;\n  let decimalSum4 = 0;\n  let decimalSum5 = 0;\n  let decimalSum6 = 0;\n  let decimalSum7 = 0;\n  let decimalSum8 = 0;\n  let decimalSum9 = 0;\n  let decimalSum10 = 0;\n  let decimalSum11 = 0;\n  let decimalSum12 = 0;\n  let decimalSum13 = 0;\n  let decimalSum14 = 0;\n  let decimalSum15 = 0;\n  let decimalSum16 = 0;\n  let decimalSum17 = 0;\n  let decimalSum18 = 0;\n  let decimalSum19 = 0;\n  let decimalSum20 = 0;\n  let decimalSum21 = 0;\n  let decimalSum22 = 0;\n  let decimalSum23 = 0;\n  let decimalSum24 = 0;\n  let decimalSum25 = 0;\n  let decimalSum26 = 0;\n  let decimalSum27 = 0;\n  let decimalSum28 = 0;\n  let decimalSum29 = 0;\n  let decimalSum30 = 0;\n  let decimalSum31 = 0;\n  let decimalSum32 = 0;\n  let decimalSum33 = 0;\n  let decimalSum34 = 0;\n  let decimalSum35 = 0;\n  let decimalSum36 = 0;\n  let decimalSum37 = 0;\n  let decimalSum38 = 0;\n  let decimalSum39 = 0;\n  let decimalSum40 = 0;\n  let decimalSum41 = 0;\n  let decimalSum42 = 0;\n  let decimalSum43 = 0;\n  let decimalSum44 = 0;\n  let decimalSum45 = 0;\n  let decimalSum46 = 0;\n  let decimalSum47 = 0;\n  let decimalSum48 = 0;\n  let decimalSum49 = 0;\n  let decimalSum50 = 0;\n  let decimalSum51 = 0;\n  let decimalSum52 = 0;\n  let decimalSum53 = 0;\n  let decimalSum54 = 0;\n  let decimalSum55 = 0;\n  let decimalSum56 = 0;\n  let decimalSum57 = 0;\n  let decimalSum58 = 0;\n  let decimalSum59 = 0;\n  let decimalSum60 = 0;\n  let decimalSum61 = 0;\n  let decimalSum62 = 0;\n  let decimalSum63 = 0;\n  let decimalSum64 = 0;\n  let decimalSum65 = 0;\n  let decimalSum66 = 0;\n  let decimalSum67 = 0;\n  let decimalSum68 = 0;\n  let decimalSum69 = 0;\n  let decimalSum70 = 0;\n  let decimalSum71 = 0;\n  let decimalSum72 = 0;\n  let decimalSum73 = 0;\n  let decimalSum74 = 0;\n  let decimalSum75 = 0;\n  let decimalSum76 = 0;\n  let decimalSum77 = 0;\n  let decimalSum78 = 0;\n  let decimalSum79 = 0;\n  let decimalSum80 = 0;\n  let decimalSum81 = 0;\n  let decimalSum82 = 0;\n  let decimalSum83 = 0;\n  let decimalSum84 = 0;\n  let decimalSum85 = 0;\n  let decimalSum86 = 0;\n  let decimalSum87 = 0;\n  let decimalSum88 = 0;\n  let decimalSum89 = 0;\n  let decimalSum90 = 0;\n  let decimalSum91 = 0;\n  let decimalSum92 = 0;\n  let decimalSum93 = 0;\n  let decimalSum94 = 0;\n  let decimalSum95 = 0;\n  let decimalSum96 = 0;\n  let decimalSum97 = 0;\n  let decimalSum98 = 0;\n  let decimalSum99 = 0;\n  let decimalSum100 = 0;\n  let decimalSum101 = 0;\n  let decimalSum102 = 0;\n  let decimalSum103 = 0;\n  let decimalSum104 = 0;\n  let decimalSum105 = 0;\n  let decimalSum106 = 0;\n  let decimalSum107 = 0;\n  let decimalSum108 = 0;\n  let decimalSum109 = 0;\n  let decimalSum110 = 0;\n  let decimalSum111 = 0;\n  let decimalSum112 = 0;\n  let decimalSum113 = 0;\n  let decimalSum114 = 0;\n  let decimalSum115 = 0;\n  let decimalSum116 = 0;\n  let decimalSum117 = 0;\n  let decimalSum118 = 0;\n  let decimalSum119 = 0;\n  let decimalSum120 = 0;\n  let decimalSum121 = 0;\n  let decimalSum122 = 0;\n  let decimalSum123 = 0;\n  let decimalSum124 = 0;\n  let decimalSum125 = 0;\n  let decimalSum126 = 0;\n  let decimalSum127 = 0;\n  let decimalSum128 = 0;\n  let decimalSum129 = 0;\n  let decimalSum130 = 0;\n  let decimalSum131 = 0;\n  let decimalSum132 = 0;\n  let decimalSum133 = 0;\n  let decimalSum134 = 0;\n  let decimalSum135 = 0;\n  let decimalSum136 = 0;\n  let decimalSum137 = 0;\n  let decimalSum138 = 0;\n  let decimalSum139 = 0;\n  let decimalSum140 = 0;\n  let decimalSum141 = 0;\n  let decimalSum142 = 0;\n  let decimalSum143 = 0;\n  let decimalSum144 = 0;\n  let decimalSum145 = 0;\n  let decimalSum146 = 0;\n  let decimalSum147 = 0;\n  let decimalSum148 = 0;\n  let decimalSum149 = 0;\n  let decimalSum150 = 0;\n  let decimalSum151 = 0;\n  let decimalSum152 = 0;\n  let decimalSum153 = 0;\n  let decimalSum154 = 0;\n  let decimalSum155 = 0;\n  let decimalSum156 = 0;\n  let decimalSum157 = 0;\n  let decimalSum158 = 0;\n  let decimalSum159 = 0;\n  let decimalSum160 = 0;\n  let decimalSum161 = 0;\n  let decimalSum162 = 0;\n  let decimalSum163 = 0;\n  let decimalSum164 = 0;\n  let decimalSum165 = 0;\n  let decimalSum166 = 0;\n  let decimalSum167 = 0;\n  let decimalSum168 = 0;\n  let decimalSum169 = 0;\n  let decimalSum170 = 0;\n  let decimalSum171 = 0;\n  let decimalSum172 = 0;\n  let decimalSum173 = 0;\n  let decimalSum174 = 0;\n  let decimalSum175 = 0;\n  let decimalSum176 = 0;\n  let decimalSum177 = 0;\n  let decimalSum178 = 0;\n  let decimalSum179 = 0;\n  let decimalSum180 = 0;\n  let decimalSum181 = 0;\n  let decimalSum182 = 0;\n  let decimalSum183 = 0;\n  let decimalSum184 = 0;\n  let decimalSum185 = 0;\n  let decimalSum186 = 0;\n  let decimalSum187 = 0;\n  let decimalSum188 = 0;\n  let decimalSum189 = 0;\n  let decimalSum190 = 0;\n  let decimalSum191 = 0;\n  let decimalSum192 = 0;\n  let decimalSum193 = 0;\n  let decimalSum194 = 0;\n  let decimalSum195 = 0;\n  let decimalSum196 = 0;\n  let decimalSum197 = 0;\n  let decimalSum198 = 0;\n  let decimalSum199 = 0;\n  let decimalSum200 = 0;\n  let decimalSum201 = 0;\n  let decimalSum202 = 0;\n  let decimalSum203 = 0;\n  let decimalSum204 = 0;\n  let decimalSum205 = 0;\n  let decimalSum206 = 0;\n  let decimalSum207 = 0;\n  let decimalSum208 = 0;\n  let decimalSum209 = 0;\n  let decimalSum210 = 0;\n  let decimalSum211 = 0;\n  let decimalSum212 = 0;\n  let decimalSum213 = 0;\n  let decimalSum214 = 0;\n  let decimalSum215 = 0;\n  let decimalSum216 = 0;\n  let decimalSum217 = 0;\n  let decimalSum218 = 0;\n  let decimalSum219 = 0;\n  let decimalSum220 = 0;\n  let decimalSum221 = 0;\n  let decimalSum222 = 0;\n  let decimalSum223 = 0;\n  let decimalSum224 = 0;\n  let decimalSum225 = 0;\n  let decimalSum226 = 0;\n  let decimalSum227 = 0;\n  let decimalSum228 = 0;\n  let decimalSum229 = 0;\n  let decimalSum230 = 0;\n  let decimalSum231 = 0;\n  let decimalSum232 = 0;\n  let decimalSum233 = 0;\n  let decimalSum234", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> aloneDigit([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> aloneDigit([152, 323, 1422, 10])\n  []\n  */\nconst aloneDigit = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "aloneDigit", "gc": "<|endoftext|>/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> aloneDigit([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> aloneDigit([152, 323, 1422, 10])\n  []\n  */\nconst aloneDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2 === 0) {\n      digit++;\n    }\n    if (digit === 9) {\n      result.push(digit);\n      digit = 0;\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> oddDigit([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> oddDigit([152, 323, 1422, 10])\n  []\n  */\nconst oddDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2!== 0) {\n      digit++;\n    }\n    if (digit === 9) {\n      result.push(digit);\n      digit = 0;\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> evenDigit([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> evenDigit([152, 323, 1422, 10])\n  []\n  */\nconst evenDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2!== 0) {\n      digit++;\n    }\n    if (digit === 9) {\n      result.push(digit);\n      digit = 0;\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> oddOrEvenDigit([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> oddOrEvenDigit([152, 323, 1422, 10])\n  []\n  */\nconst oddOrEvenDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2!== 0) {\n      digit++;\n    }\n    if (digit === 9) {\n      result.push(digit);\n      digit = 0;\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit and has even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> oddOrEvenDigit([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> oddOrEvenDigit([152, 323, 1422, 10])\n  []\n  */\nconst oddOrEvenDigitWithEvenDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2!== 0) {\n      digit++;\n    }\n    if (digit === 9) {\n      result.push(digit);\n      digit = 0;\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit and has odd digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> oddOrEvenDigitWithEvenDigit([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> oddOrEvenDigitWithEvenDigit([152, 323, 1422, 10])\n  []\n  */\nconst oddOrEvenDigitWithOddDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2!== 0) {\n      digit++;\n    }\n    if (digit === 9) {\n      result.push(digit);\n      digit = 0;\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit and has even digit and has odd digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> oddOrEvenDigitWithOddDigit([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> oddOrEvenDigitWithOddDigit([152, 323, 1422, 10])\n  []\n  */\nconst oddOrEvenDigitWithOddDigitWithEvenDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2!== 0) {\n      digit++;\n    }\n    if (digit === 9) {\n      result.push(digit);\n      digit = 0;\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit and has even digit and has odd digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> oddOrEvenDigitWithOddDigitWithEvenDigit([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> oddOrEvenDigitWithOddDigitWithEvenDigit([152, 323, 1422, 10])\n  []\n  */\nconst oddOrEvenDigitWithOddDigitWithOddDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2!== 0) {\n      digit++;\n    }\n    if (digit === 9) {\n      result.push(digit);\n      digit = 0;\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit and has even digit and has odd digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> oddOrEvenDigitWithOddDigitWithOddDigitWithEvenDigit([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> oddOrEvenDigitWithOddDigitWithOddDigitWithEvenDigit([152, 323, 1422, 10])\n  []\n  */\nconst oddOrEvenDigitWithOddDigitWithOddDigitWithOddDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2!== 0) {\n      digit++;\n    }\n    if (digit === 9) {\n      result.push(digit);\n      digit = 0;\n    }\n  }\n  return result;\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit and has even digit and has odd digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> oddOrEvenDigitWithOddDigitWithOddDigitWithEvenDigit([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> oddOrEvenDigitWithOddDigitWithOddDigitWithEvenDigit([152, 323, 1422, 10])\n  []\n  */\nconst oddOrEvenDigitWithOddDigitWithOddDigitWithOddDigitWithEvenDigit = (x) => {\n  let result = [];\n  let digit = 0;\n  for (let i = 0; i < x.length; i++) {\n    if (x[i] % 2!== 0) {\n      digit++;\n    }\n    if (digit === 9) {\n      result.push(digit", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byDuration = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byDuration", "gc": "<|endoftext|>/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byDuration = (arr) => {\n  const durations = [\n    { duration: 2, name: \"Two\" },\n    { duration: 1, name: \"One\" },\n    { duration: 4, name: \"Four\" },\n    { duration: 3, name: \"Three\" },\n    { duration: 5, name: \"Five\" },\n    { duration: 6, name: \"Six\" },\n    { duration: 7, name: \"Seven\" },\n    { duration: 8, name: \"Eight\" },\n    { duration: 9, name: \"Nine\" }\n  ]\n  const reversed = arr.slice().reverse()\n  const durationsMap = new Map()\n  durations.forEach(({ duration, name }) => {\n    durationsMap.set(duration, name)\n  })\n  return reversed.map((digit) => {\n    return durationsMap.get(digit)\n  })\n}\n\n/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byDurationAndDuration = (arr) => {\n  const durations = [\n    { duration: 2, name: \"Two\" },\n    { duration: 1, name: \"One\" },\n    { duration: 4, name: \"Four\" },\n    { duration: 3, name: \"Three\" },\n    { duration: 5, name: \"Five\" },\n    { duration: 6, name: \"Six\" },\n    { duration: 7, name: \"Seven\" },\n    { duration: 8, name: \"Eight\" },\n    { duration: 9, name: \"Nine\" }\n  ]\n  const reversed = arr.slice().reverse()\n  const durationsMap = new Map()\n  durations.forEach(({ duration, name }) => {\n    durationsMap.set(duration, name)\n  })\n  return reversed.map((digit) => {\n    return durationsMap.get(digit)\n  })\n}\n\n/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byDurationAndDurationAndDuration = (arr) => {\n  const durations = [\n    { duration: 2, name: \"Two\" },\n    { duration: 1, name: \"One\" },\n    { duration: 4, name: \"Four\" },\n    { duration: 3, name: \"Three\" },\n    { duration: 5, name: \"Five\" },\n    { duration: 6, name: \"Six\" },\n    { duration: 7, name: \"Seven\" },\n    { duration: 8, name: \"Eight\" },\n    { duration: 9, name: \"Nine\" }\n  ]\n  const reversed = arr.slice().reverse()\n  const durationsMap = new Map()\n  durations.forEach(({ duration, name }) => {\n    durationsMap.set(duration, name)\n  })\n  return reversed.map((digit) => {\n    return durationsMap.get(digit)\n  })\n}\n\n/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byDurationAndDurationAndDurationAndDuration = (arr) => {\n  const durations = [\n    { duration: 2, name: \"Two\" },\n    { duration: 1, name: \"One\" },\n    { duration: 4, name: \"Four\" },\n    { duration: 3, name: \"Three\" },\n    { duration: 5, name: \"Five\" },\n    { duration: 6, name: \"Six\" },\n    { duration: 7, name: \"Seven\" },\n    { duration: 8, name: \"Eight\" },\n    { duration: 9, name: \"Nine\" }\n  ]\n  const reversed = arr.slice().reverse()\n  const durationsMap = new Map()\n  durations.forEach(({ duration, name }) => {\n    durationsMap.set(duration, name)\n  })\n  return reversed.map((digit) => {\n    return durationsMap.get(digit)\n  })\n}\n\n/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byDurationAndDurationAndDurationAndDurationAndDuration = (arr) => {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/106", "prompt": "/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "gc": "<|endoftext|>/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(factorial(i));\n    }\n  }\n  return result;\n};\n\n/* Implement the function g that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  g(5) == [1, 2, 6, 24, 15]\n  */\nconst g = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(gcd(i, i));\n    }\n  }\n  return result;\n};\n\n/* Implement the function h that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  h(5) == [1, 2, 6, 24, 15]\n  */\nconst h = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(gcd(i, i));\n    }\n  }\n  return result;\n};\n\n/* Implement the function i that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  i(5) == [1, 2, 6, 24, 15]\n  */\nconst i = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(gcd(i, i));\n    }\n  }\n  return result;\n};\n\n/* Implement the function j that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  j(5) == [1, 2, 6, 24, 15]\n  */\nconst j = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(gcd(i, i));\n    }\n  }\n  return result;\n};\n\n/* Implement the function k that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  k(5) == [1, 2, 6, 24, 15]\n  */\nconst k = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(gcd(i, i));\n    }\n  }\n  return result;\n};\n\n/* Implement the function l that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  l(5) == [1, 2, 6, 24, 15]\n  */\nconst l = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(gcd(i, i));\n    }\n  }\n  return result;\n};\n\n/* Implement the function m that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  m(5) == [1, 2, 6, 24, 15]\n  */\nconst m = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(gcd(i, i));\n    }\n  }\n  return result;\n};\n\n/* Implement the function n that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  n(5) == [1, 2, 6, 24, 15]\n  */\nconst n = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(gcd(i, i));\n    }\n  }\n  return result;\n};\n\n/* Implement the function o that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  o(5) == [1, 2, 6, 24, 15]\n  */\nconst o = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(gcd(i, i));\n    }\n  }\n  return result;\n};\n\n/* Implement the function p that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  p(i) == [1, 2, 6, 24, 15]\n  */\nconst p = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(gcd(i, i));\n    }\n  }\n  return result;\n};\n\n/* Implement the function q that takes n as a parameter,\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "gc": "<|endoftext|>/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  let count = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n    if (evenCount % 2 === 0) {\n      evenPalindromes.push(count);\n      evenCount = 0;\n    }\n    if (oddCount % 2 === 0) {\n      oddPalindromes.push(count);\n      oddCount = 0;\n    }\n    count++;\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n/*\n  Given a positive integer n, return an integer array containing all possible palindromes of length n.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1 <= n <= 10^3\n      All palindromes of length n are valid.\n*/\nconst palindromes = (num) => {\n  const palindromes = [];\n  let count = 0;\n  for (let i = 1; i <= num; i++) {\n    if (num % i === 0) {\n      count++;\n    }\n  }\n  for (let i = count; i < num; i++) {\n    palindromes.push(num - i);\n  }\n  return palindromes;\n};\n\n/*\n  Given a positive integer n, return an integer array containing all possible palindromes of length n.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1 <= n <= 10^3\n      All palindromes of length n are valid.\n*/\nconst palindromesOfLength = (num) => {\n  const palindromes = [];\n  let count = 0;\n  for (let i = 1; i <= num; i++) {\n    if (num % i === 0) {\n      count++;\n    }\n  }\n  for (let i = count; i < num; i++) {\n    palindromes.push(num - i);\n  }\n  return palindromes;\n};\n\n/*\n  Given a positive integer n, return an integer array containing all possible palindromes of length n.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1 <= n <= 10^3\n      All palindromes of length n are valid.\n*/\nconst palindromesOfLengthAndOddEven = (num) => {\n  const palindromes = [];\n  let count = 0;\n  for (let i = 1; i <= num; i++) {\n    if (num % i === 0) {\n      count++;\n    }\n  }\n  for (let i = count; i < num; i++) {\n    palindromes.push(num - i);\n  }\n  return palindromes;\n};\n\n/*\n  Given a positive integer n, return an integer array containing all possible palindromes of length n.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1 <= n <= 10^3\n      All palindromes of length n are valid.\n*/\nconst palindromesOfLengthAndOddEvenAndEven = (num) => {\n  const palindromes = [];\n  let count = 0;\n  for (let i = 1; i <= num; i++) {\n    if (num % i === 0) {\n      count++;\n    }\n  }\n  for (let i = count; i < num; i++) {\n    palindromes.push(num - i);\n  }\n  return palindromes;\n};\n\n/*\n  Given a positive integer n, return an integer array containing all possible palindromes of length n.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1 <= n <= 10^3\n      All palindromes of length n are valid.\n*/\nconst palindromesOfLengthAndOddEvenAndEvenAndOddEven = (num) => {\n  const palindromes = [];\n  let count = 0;\n  for (let i = 1; i <= num; i++) {\n    if (num % i === 0) {\n      count++;\n    }\n  }\n  for (let i = count; i < num; i++) {\n    palindromes.push(num - i);\n  }\n  return palindromes;\n};\n\n/*\n  Given a positive integer n, return an integer array containing all possible palindromes of length n.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1 <= n <= 10^3\n      All palindromes of length n are valid.\n*/\nconst palindromesOfLengthAndOddEvenAndEvenAndOddEvenAndEven = (num) => {\n  const palindromes = [];\n  let count = 0;\n  for (let i = 1; i <= num; i++) {\n    if (num % i === 0) {\n      count++;\n    }\n  }\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a function considerNums which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> considerNums([]) == 0\n  >>> considerNums([-1, 11, -11]) == 1\n  >>> considerNums([1, 1, 2]) == 3\n  */\nconst considerNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "considerNums", "gc": "<|endoftext|>/*\n  Write a function considerNums which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> considerNums([]) == 0\n  >>> considerNums([-1, 11, -11]) == 1\n  >>> considerNums([1, 1, 2]) == 3\n  */\nconst considerNums = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] > 0? arr[i] : 0;\n  }\n  return sum > 0? 1 : 0;\n};\n\n/*\n  Write a function sumDigits which takes an array of integers and returns\n  the number of digits in each of the elements of the array.\n  >>> sumDigits([]) == 0\n  >>> sumDigits([-1, 11, -11]) == 0\n  >>> sumDigits([1, 1, 2]) == 2\n  */\nconst sumDigits = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    count += arr[i].toString().length;\n  }\n  return count;\n};\n\n/*\n  Write a function findMaxDigits which takes an array of integers and returns\n  the largest integer in the array.\n  >>> findMaxDigits([]) == 0\n  >>> findMaxDigits([-1, 11, -11]) == 11\n  >>> findMaxDigits([1, 1, 2]) == 2\n  */\nconst findMaxDigits = (arr) => {\n  let max = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n    }\n  }\n  return max;\n};\n\n/*\n  Write a function findMinDigits which takes an array of integers and returns\n  the smallest integer in the array.\n  >>> findMinDigits([]) == 0\n  >>> findMinDigits([-1, 11, -11]) == -1\n  >>> findMinDigits([1, 1, 2]) == 1\n  */\nconst findMinDigits = (arr) => {\n  let min = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n    }\n  }\n  return min;\n};\n\n/*\n  Write a function findMaxNum which takes an array of integers and returns\n  the largest integer in the array.\n  >>> findMaxNum([]) == 0\n  >>> findMaxNum([-1, 11, -11]) == 11\n  >>> findMaxNum([1, 1, 2]) == 2\n  */\nconst findMaxNum = (arr) => {\n  let max = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n    }\n  }\n  return max;\n};\n\n/*\n  Write a function findMinNum which takes an array of integers and returns\n  the smallest integer in the array.\n  >>> findMinNum([]) == 0\n  >>> findMinNum([-1, 11, -11]) == -1\n  >>> findMinNum([1, 1, 2]) == 1\n  */\nconst findMinNum = (arr) => {\n  let min = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n    }\n  }\n  return min;\n};\n\n/*\n  Write a function findMaxNum which takes an array of integers and returns\n  the largest integer in the array.\n  >>> findMaxNum([]) == 0\n  >>> findMaxNum([-1, 11, -11]) == 11\n  >>> findMaxNum([1, 1, 2]) == 2\n  */\nconst findMinNum = (arr) => {\n  let min = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n    }\n  }\n  return min;\n};\n\n/*\n  Write a function findMaxNum which takes an array of integers and returns\n  the largest integer in the array.\n  >>> findMaxNum([]) == 0\n  >>> findMaxNum([-1, 11, -11]) == 11\n  >>> findMaxNum([1, 1, 2]) == 2\n  */\nconst findMaxNum = (arr) => {\n  let max = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n    }\n  }\n  return max;\n};\n\n/*\n  Write a function findMinNum which takes an array of integers and returns\n  the smallest integer in the array.\n  >>> findMinNum([]) == 0\n  >>> findMinNum([-1, 11, -11]) == -1\n  >>> findMinNum([1, 1, 2]) == 1\n  */\nconst findMinNum = (arr) => {\n  let min = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n    }\n  }\n  return min;\n};\n\n/*\n  Write a function findMaxNum which takes an array of integers and returns\n  the largest integer in the array.\n  >>> findMaxNum([]) == 0\n  >>> findMaxNum([-1, 11, -11]) == 11\n  >>> findMaxNum([1, 1, 2]) == 2\n  */\nconst findMinNum = (arr) => {\n  let min = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n    }\n  }\n  return min;\n};\n\n/*\n  Write a function findMaxNum which takes an array of integers and returns\n  the largest integer in the array.\n  >>> findMaxNum([]) == 0\n  >>> findMaxNum([-1, 11, -11]) == 11\n  >>> findMaxNum([1, 1, 2]) == 2\n  */\nconst findMinNum = (arr) => {\n  let min = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n    }\n  }\n  return min;\n};\n\n/*\n  Write a function findMaxNum which takes an array of integers and returns\n  the largest integer in the array.\n  >>> findMaxNum([]) == 0\n  >>> findMaxNum([-1, 11, -11]) == 11\n  >>> findMaxNum([1, 1, 2]) == 2\n  */\nconst findMinNum = (arr) => {\n  let min = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n    }\n  }\n  return min;\n};\n\n/*\n  Write a function findMaxNum which takes an array of integers and returns\n  the largest integer in the array.\n  >>> findMaxNum([]) == 0\n  >>> findMaxNum([-1, 11, -11]) == 11\n  >>> findMaxNum([1, 1, 2]) == 2\n  */\nconst findMinNum = (arr) => {\n  let min = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n    }\n  }\n  return min;\n};\n\n/*\n  Write a function findMaxNum which takes an array of integers and returns\n  the largest integer in the array.\n  >>> findMaxNum([]) == 0\n  >>> findMaxNum([-1, 11, -11]) == 11\n  >>> findMaxNum([1, 1, 2]) == 2\n  */\nconst findMinNum = (arr) => {\n  let min = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n    }\n  }\n  return min;\n};\n\n/*\n  Write a function findMaxNum which takes an array of integers and returns\n  the largest integer in the array.\n  >>> findMaxNum([]) == 0\n  >>> findMaxNum([-1, 11, -11]) == 11\n  >>> findMaxNum([1, 1, 2]) == 2\n  */\nconst findMinNum = (arr) => {\n  let min = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n    }\n  }\n  return min;\n};\n\n/*\n  Write a function findMaxNum which takes an array of integers and returns", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  affectOneTestis([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  affectOneTestis([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst affectOneTestis = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "affectOneTestis", "gc": "<|endoftext|>/*We have an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  affectOneTestis([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  affectOneTestis([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst affectOneTestis = (arr) => {\n  let arrLength = arr.length;\n  let arrCopy = arr.slice();\n  let arrCopyLength = arrCopy.length;\n  let arrCopyCopy = arrCopy.slice();\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyCopy = arrCopyCopy.slice();\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyCopy = arrCopyCopyCopy.slice();\n  let arrCopyCopyCopyCopyLength = arrCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopy = arrCopyCopyCopyCopy.slice();\n  let arrCopyCopyCopyCopyLength = arrCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyCopyLength = arrCopyCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyCopyLength = arrCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyLength = arrCopyCopyCopyCopy.length;\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let arrCopyCopyLength = arrCopyCopy.length;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/11", "prompt": "/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentXor('010', '110')\n  '100'\n  */\nconst bowedStringedInstrumentXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "bowedStringedInstrumentXor", "gc": "<|endoftext|>/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentXor('010', '110')\n  '100'\n  */\nconst bowedStringedInstrumentXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentAnd(a, b) \n  '100'\n  */\nconst bowedStringedInstrumentAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] & b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentOr(a, b) \n  '100'\n  */\nconst bowedStringedInstrumentOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] | b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary NOT on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentNot(a, b) \n  '100'\n  */\nconst bowedStringedInstrumentNot = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += ~a[i] ^ b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentXor(a, b) \n  '100'\n  */\nconst bowedStringedInstrumentXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentAnd(a, b) \n  '100'\n  */\nconst bowedStringedInstrumentAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] & b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentOr(a, b) \n  '100'\n  */\nconst bowedStringedInstrumentOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] | b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary NOT on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentNot(a, b) \n  '100'\n  */\nconst bowedStringedInstrumentNot = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += ~a[i] ^ b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentXor(a, b) \n  '100'\n  */\nconst bowedStringedInstrumentXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentAnd(a, b) \n  '100'\n  */\nconst bowedStringedInstrumentAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] & b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentOr(a, b) \n  '100'\n  */\nconst bowedStringedInstrumentOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] | b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary NOT on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentNot(a, b) \n  '100'\n  */\nconst bowedStringedInstrumentNot = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += ~a[i] ^ b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentXor(a, b) \n  '100'\n  */\nconst bowedStringedInstrumentXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentAnd(a, b) \n  '100'\n  */\nconst bowedStringedInstrumentAnd = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] & b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary OR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentOr(a, b) \n  '100'\n  */\nconst bowedStringedInstrumentOr = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] | b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary NOT on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentNot(a, b) \n  '100'\n  */\nconst bowedStringedInstrumentNot = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += ~a[i] ^ b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentXor(a, b) \n  '100'\n  */\nconst bowedStringedInstrumentXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary AND on these inputs and return result also as a string.\n  >>> bowedStringedInstrumentAnd(a, b) \n  '100'", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an central of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of centrald elements between lst1 and lst2.\n  If it is possible to central elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  central([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  central([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst central = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "central", "gc": "<|endoftext|>/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an central of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of centrald elements between lst1 and lst2.\n  If it is possible to central elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  central([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  central([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst central = (lst1, lst2) => {\n  let centralElements = 0;\n  let centralElementsCount = 0;\n  let centralElementsSum = 0;\n  let centralElementsSum2 = 0;\n  let centralElementsSum3 = 0;\n  let centralElementsSum4 = 0;\n  let centralElementsSum5 = 0;\n  let centralElementsSum6 = 0;\n  let centralElementsSum7 = 0;\n  let centralElementsSum8 = 0;\n  let centralElementsSum9 = 0;\n  let centralElementsSum10 = 0;\n  let centralElementsSum11 = 0;\n  let centralElementsSum12 = 0;\n  let centralElementsSum13 = 0;\n  let centralElementsSum14 = 0;\n  let centralElementsSum15 = 0;\n  let centralElementsSum16 = 0;\n  let centralElementsSum17 = 0;\n  let centralElementsSum18 = 0;\n  let centralElementsSum19 = 0;\n  let centralElementsSum20 = 0;\n  let centralElementsSum21 = 0;\n  let centralElementsSum22 = 0;\n  let centralElementsSum23 = 0;\n  let centralElementsSum24 = 0;\n  let centralElementsSum25 = 0;\n  let centralElementsSum26 = 0;\n  let centralElementsSum27 = 0;\n  let centralElementsSum28 = 0;\n  let centralElementsSum29 = 0;\n  let centralElementsSum30 = 0;\n  let centralElementsSum31 = 0;\n  let centralElementsSum32 = 0;\n  let centralElementsSum33 = 0;\n  let centralElementsSum34 = 0;\n  let centralElementsSum35 = 0;\n  let centralElementsSum36 = 0;\n  let centralElementsSum37 = 0;\n  let centralElementsSum38 = 0;\n  let centralElementsSum39 = 0;\n  let centralElementsSum40 = 0;\n  let centralElementsSum41 = 0;\n  let centralElementsSum42 = 0;\n  let centralElementsSum43 = 0;\n  let centralElementsSum44 = 0;\n  let centralElementsSum45 = 0;\n  let centralElementsSum46 = 0;\n  let centralElementsSum47 = 0;\n  let centralElementsSum48 = 0;\n  let centralElementsSum49 = 0;\n  let centralElementsSum50 = 0;\n  let centralElementsSum51 = 0;\n  let centralElementsSum52 = 0;\n  let centralElementsSum53 = 0;\n  let centralElementsSum54 = 0;\n  let centralElementsSum55 = 0;\n  let centralElementsSum56 = 0;\n  let centralElementsSum57 = 0;\n  let centralElementsSum58 = 0;\n  let centralElementsSum59 = 0;\n  let centralElementsSum60 = 0;\n  let centralElementsSum61 = 0;\n  let centralElementsSum62 = 0;\n  let centralElementsSum63 = 0;\n  let centralElementsSum64 = 0;\n  let centralElementsSum65 = 0;\n  let centralElementsSum66 = 0;\n  let centralElementsSum67 = 0;\n  let centralElementsSum68 = 0;\n  let centralElementsSum69 = 0;\n  let centralElementsSum70 = 0;\n  let centralElementsSum71 = 0;\n  let centralElementsSum72 = 0;\n  let centralElementsSum73 = 0;\n  let centralElementsSum74 = 0;\n  let centralElementsSum75 = 0;\n  let centralElementsSum76 = 0;\n  let centralElementsSum77 = 0;\n  let centralElementsSum78 = 0;\n  let centralElementsSum79 = 0;\n  let centralElementsSum80 = 0;\n  let centralElementsSum81 = 0;\n  let centralElementsSum82 = 0;\n  let centralElementsSum83 = 0;\n  let centralElementsSum84 = 0;\n  let centralElementsSum85 = 0;\n  let centralElementsSum86 = 0;\n  let centralElementsSum87 = 0;\n  let centralElementsSum88 = 0;\n  let centralElementsSum89 = 0;\n  let centralElementsSum90 = 0;\n  let centralElementsSum91 = 0;\n  let centralElementsSum92 = 0;\n  let centralElementsSum93 = 0;\n  let centralElementsSum94 = 0;\n  let centralElementsSum95 = 0;\n  let centralElementsSum96 = 0;\n  let centralElementsSum97 = 0;\n  let centralElementsSum98 = 0;\n  let centralElementsSum99 = 0;\n  let centralElementsSum100 = 0;\n  let centralElementsSum101 = 0;\n  let centralElementsSum102 = 0;\n  let centralElementsSum103 = 0;\n  let centralElementsSum104 = 0;\n  let centralElementsSum105 = 0;\n  let centralElementsSum106 = 0;\n  let centralElementsSum107 = 0;\n  let centralElementsSum108 = 0;\n  let centralElementsSum109 = 0;\n  let centralElementsSum110 = 0;\n  let centralElementsSum111 = 0;\n  let centralElementsSum112 = 0;\n  let centralElementsSum113 = 0;\n  let centralElementsSum114 = 0;\n  let centralElementsSum115 = 0;\n  let centralElementsSum116 = 0;\n  let centralElementsSum117 = 0;\n  let centralElementsSum118 = 0;\n  let centralElementsSum119 = 0;\n  let centralElementsSum120 = 0;\n  let centralElementsSum121 = 0;\n  let centralElementsSum122 = 0;\n  let centralElementsSum123 = 0;\n  let centralElementsSum124 = 0;\n  let centralElementsSum125 = 0;\n  let centralElementsSum126 = 0;\n  let centralElementsSum127 = 0;\n  let centralElementsSum128 = 0;\n  let centralElementsSum129 = 0;\n  let centralElementsSum130 = 0;\n  let centralElementsSum131 = 0;\n  let centralElementsSum132 = 0;\n  let centralElementsSum133 = 0;\n  let centralElementsSum134 = 0;\n  let centralElementsSum135 = 0;\n  let centralElementsSum136 = 0;\n  let centralElementsSum137 = 0;\n  let centralElementsSum138 = 0;\n  let centralElementsSum139 = 0;\n  let centralElementsSum140 = 0;\n  let centralElementsSum141 = 0;\n  let centralElementsSum142 = 0;\n  let centralElementsSum143 = 0;\n  let centralElementsSum144 = 0;\n  let centralElementsSum145 = 0;\n  let centralElementsSum146 = 0;\n  let centralElementsSum147 = 0;\n  let centralElementsSum148 = 0;\n  let centralElementsSum149 = 0;\n  let centralElementsSum150 = 0;\n  let centralElementsSum151 = 0;\n  let centralElementsSum152 = 0;\n  let centralElementsSum153 = 0;\n  let centralElementsSum154 = 0;\n  let centralElementsSum155 = 0;\n  let centralElementsSum156 = 0;\n  let centralElementsSum157 = 0;\n  let centralElementsSum158 = 0;\n  let centralElementsSum159 = 0;\n  let centralElementsSum160 = 0;\n  let centralElementsSum161 = 0;\n  let centralElementsSum162 = 0;\n  let centralElementsSum163 = 0;\n  let centralElementsSum164 = 0;\n  let centralElementsSum165 = 0;\n  let centralElementsSum166 = 0;\n  let centralElementsSum167 = 0;\n  let centralElementsSum168 = 0;\n  let centralElementsSum169 = 0;\n  let centralElementsSum170 = 0;\n  let centralElementsSum171 = 0;\n  let centralElementsSum172 = 0;\n  let centralElementsSum173 = 0;\n  let centralElementsSum174 = 0;\n  let centralElement", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/111", "prompt": "/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "gc": "<|endoftext|>/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = {}\n  let counts = {}\n  let letterCounts = {}\n  let letterCount = 0\n  let letterCounts = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n  let letterCountIndexs = []\n  let letterCountIndex = 0\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst invertDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "invertDelete", "gc": "<|endoftext|>/*Task\n  We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst invertDelete = (s, c) => {\n  let result = '';\n  let reverse = '';\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let flag = false;\n  let temp = '';\n  let temp2 = '';\n  let temp3 = '';\n  let temp4 = '';\n  let temp5 = '';\n  let temp6 = '';\n  let temp7 = '';\n  let temp8 = '';\n  let temp9 = '';\n  let temp10 = '';\n  let temp11 = '';\n  let temp12 = '';\n  let temp13 = '';\n  let temp14 = '';\n  let temp15 = '';\n  let temp16 = '';\n  let temp17 = '';\n  let temp18 = '';\n  let temp19 = '';\n  let temp20 = '';\n  let temp21 = '';\n  let temp22 = '';\n  let temp23 = '';\n  let temp24 = '';\n  let temp25 = '';\n  let temp26 = '';\n  let temp27 = '';\n  let temp28 = '';\n  let temp29 = '';\n  let temp30 = '';\n  let temp31 = '';\n  let temp32 = '';\n  let temp33 = '';\n  let temp34 = '';\n  let temp35 = '';\n  let temp36 = '';\n  let temp37 = '';\n  let temp38 = '';\n  let temp39 = '';\n  let temp40 = '';\n  let temp41 = '';\n  let temp42 = '';\n  let temp43 = '';\n  let temp44 = '';\n  let temp45 = '';\n  let temp46 = '';\n  let temp47 = '';\n  let temp48 = '';\n  let temp49 = '';\n  let temp50 = '';\n  let temp51 = '';\n  let temp52 = '';\n  let temp53 = '';\n  let temp54 = '';\n  let temp55 = '';\n  let temp56 = '';\n  let temp57 = '';\n  let temp58 = '';\n  let temp59 = '';\n  let temp60 = '';\n  let temp61 = '';\n  let temp62 = '';\n  let temp63 = '';\n  let temp64 = '';\n  let temp65 = '';\n  let temp66 = '';\n  let temp67 = '';\n  let temp68 = '';\n  let temp69 = '';\n  let temp70 = '';\n  let temp71 = '';\n  let temp72 = '';\n  let temp73 = '';\n  let temp74 = '';\n  let temp75 = '';\n  let temp76 = '';\n  let temp77 = '';\n  let temp78 = '';\n  let temp79 = '';\n  let temp80 = '';\n  let temp81 = '';\n  let temp82 = '';\n  let temp83 = '';\n  let temp84 = '';\n  let temp85 = '';\n  let temp86 = '';\n  let temp87 = '';\n  let temp88 = '';\n  let temp89 = '';\n  let temp90 = '';\n  let temp91 = '';\n  let temp92 = '';\n  let temp93 = '';\n  let temp94 = '';\n  let temp95 = '';\n  let temp96 = '';\n  let temp97 = '';\n  let temp98 = '';\n  let temp99 = '';\n  let temp100 = '';\n  let temp101 = '';\n  let temp102 = '';\n  let temp103 = '';\n  let temp104 = '';\n  let temp105 = '';\n  let temp106 = '';\n  let temp107 = '';\n  let temp108 = '';\n  let temp109 = '';\n  let temp110 = '';\n  let temp111 = '';\n  let temp112 = '';\n  let temp113 = '';\n  let temp114 = '';\n  let temp115 = '';\n  let temp116 = '';\n  let temp117 = '';\n  let temp118 = '';\n  let temp119 = '';\n  let temp120 = '';\n  let temp121 = '';\n  let temp122 = '';\n  let temp123 = '';\n  let temp124 = '';\n  let temp125 = '';\n  let temp126 = '';\n  let temp127 = '';\n  let temp128 = '';\n  let temp129 = '';\n  let temp130 = '';\n  let temp131 = '';\n  let temp132 = '';\n  let temp133 = '';\n  let temp134 = '';\n  let temp135 = '';\n  let temp136 = '';\n  let temp137 = '';\n  let temp138 = '';\n  let temp139 = '';\n  let temp140 = '';\n  let temp141 = '';\n  let temp142 = '';\n  let temp143 = '';\n  let temp144 = '';\n  let temp145 = '';\n  let temp146 = '';\n  let temp147 = '';\n  let temp148 = '';\n  let temp149 = '';\n  let temp150 = '';\n  let temp151 = '';\n  let temp152 = '';\n  let temp153 = '';\n  let temp154 = '';\n  let temp155 = '';\n  let temp156 = '';\n  let temp157 = '';\n  let temp158 = '';\n  let temp159 = '';\n  let temp160 = '';\n  let temp161 = '';\n  let temp162 = '';\n  let temp163 = '';\n  let temp164 = '';\n  let temp165 = '';\n  let temp166 = '';\n  let temp167 = '';\n  let temp168 = '';\n  let temp169 = '';\n  let temp170 = '';\n  let temp171 = '';\n  let temp172 = '';\n  let temp173 = '';\n  let temp174 = '';\n  let temp175 = '';\n  let temp176 = '';\n  let temp177 = '';\n  let temp178 = '';\n  let temp179 = '';\n  let temp180 = '';\n  let temp181 = '';\n  let temp182 = '';\n  let temp183 = '';\n  let temp184 = '';\n  let temp185 = '';\n  let temp186 = '';\n  let temp187 = '';\n  let temp188 = '';\n  let temp189 = '';\n  let temp190 = '';\n  let temp191 = '';\n  let temp192 = '';\n  let temp193 = '';\n  let temp194 = '';\n  let temp195 = '';\n  let temp196 = '';\n  let temp197 = '';\n  let temp198 = '';\n  let temp199 = '';\n  let temp200 = '';\n  let temp201 = '';\n  let temp202 = '';\n  let temp203 = '';\n  let temp204 = '';\n  let temp205 = '';\n  let temp206 = '';\n  let temp207 = '';\n  let temp208 = '';\n  let temp209 = '';\n  let temp210 = '';\n  let temp211 = '';\n  let temp212 = '';\n  let temp213 = '';\n  let temp214 = '';\n  let temp215 = '';\n  let temp216 = '';\n  let temp217 = '';\n  let temp218 = '';\n  let temp219 = '';\n  let temp220 = '';\n  let temp221 = '';\n  let temp222 = '';\n  let temp223 = '';\n  let temp224 = '';\n  let temp225 = '';\n  let temp226 = '';\n  let temp227 = '';\n  let temp228 = '';\n  let temp229 = '';\n  let temp230 = '';\n  let temp231 = '';\n  let temp232 = '';\n  let temp233 = '';\n  let temp234 = '';\n  let temp235 = '';\n  let temp236 = '';\n  let temp237 = '';\n  let temp238 = '';\n  let temp239 = '';\n  let temp240 = '';\n  let temp241 = '';\n  let temp242 = '';\n  let temp243 = '';\n  let temp244 = '';\n  let temp245 = '';\n  let temp246 = '';\n  let temp247 = '';\n  let temp248 = '';\n  let temp249 = '';\n  let temp250 = '';\n  let temp251 = '';\n  let temp252 = '';\n  let temp253 = '';\n  let temp254 = '';\n  let temp255 = '';\n  let temp256 = '';\n  let temp257 = '';\n  let temp258 = '';\n  let temp259 = '';\n  let temp260 = '';\n  let temp261 = '';\n  let temp262 = '';\n  let temp263 = '';\n  let temp264 = '';\n  let temp265 = '';\n  let temp266 = '';\n  let temp267 = '';\n  let temp268 = '';\n  let temp269 = '';\n  let temp", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> curiousCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> curiousCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst curiousCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "curiousCount", "gc": "<|endoftext|>/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> curiousCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> curiousCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst curiousCount = (lst) => {\n  let oddCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].toString().length == 1) {\n      oddCount++;\n    }\n  }\n  return [oddCount].concat(lst);\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].toString().length == 1) {\n      evenCount++;\n    }\n  }\n  return [evenCount].concat(lst);\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let oddCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].toString().length == 1) {\n      oddCount++;\n    }\n  }\n  return [oddCount].concat(lst);\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].toString().length == 1) {\n      evenCount++;\n    }\n  }\n  return [evenCount].concat(lst);\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let oddCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].toString().length == 1) {\n      oddCount++;\n    }\n  }\n  return [oddCount].concat(lst);\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].toString().length == 1) {\n      evenCount++;\n    }\n  }\n  return [evenCount].concat(lst);\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let oddCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].toString().length == 1) {\n      oddCount++;\n    }\n  }\n  return [oddCount].concat(lst);\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].toString().length == 1) {\n      evenCount++;\n    }\n  }\n  return [evenCount].concat(lst);\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minuteSubArraySum([-1, -2, -3]) == -6\n  */\nconst minuteSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minuteSubArraySum", "gc": "<|endoftext|>/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minuteSubArraySum([-1, -2, -3]) == -6\n  */\nconst minuteSubArraySum = (nums) => {\n  const sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    const sum = sum + nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySum([-1, -2, -3]) == -6\n  */\nconst minuteSubArrayMax = (nums) => {\n  const maxSum = nums[0];\n  let maxSumNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    const sum = sum + nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n      maxSumNum = nums[i];\n    }\n  }\n  return maxSumNum;\n};\n\n/*\n  Given an array of integers nums, find the minimum number of non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySum([-1, -2, -3]) == -6\n  */\nconst minuteSubArrayMin = (nums) => {\n  const minSum = nums[0];\n  let minSumNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    const sum = sum + nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n      minSumNum = nums[i];\n    }\n  }\n  return minSumNum;\n};\n\n/*\n  Given an array of integers nums, find the maximum number of non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySum([-1, -2, -3]) == -6\n  */\nconst minuteSubArrayMaxNum = (nums) => {\n  const maxSum = nums[0];\n  let maxSumNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    const sum = sum + nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n      maxSumNum = nums[i];\n    }\n  }\n  return maxSumNum;\n};\n\n/*\n  Given an array of integers nums, find the minimum number of non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySum([-1, -2, -3]) == -6\n  */\nconst minuteSubArrayMinNum = (nums) => {\n  const minSum = nums[0];\n  let minSumNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    const sum = sum + nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n      minSumNum = nums[i];\n    }\n  }\n  return minSumNum;\n};\n\n/*\n  Given an array of integers nums, find the maximum number of non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySum([-1, -2, -3]) == -6\n  */\nconst minuteSubArrayMaxNumNum = (nums) => {\n  const maxSum = nums[0];\n  let maxSumNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    const sum = sum + nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n      maxSumNum = nums[i];\n    }\n  }\n  return maxSumNum;\n};\n\n/*\n  Given an array of integers nums, find the minimum number of non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySum([-1, -2, -3]) == -6\n  */\nconst minuteSubArrayMinNumNum = (nums) => {\n  const minSum = nums[0];\n  let minSumNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    const sum = sum + nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n      minSumNum = nums[i];\n    }\n  }\n  return minSumNum;\n};\n\n/*\n  Given an array of integers nums, find the maximum number of non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySum([-1, -2, -3]) == -6\n  */\nconst minuteSubArrayMaxNumNum = (nums) => {\n  const maxSum = nums[0];\n  let maxSumNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    const sum = sum + nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n      maxSumNum = nums[i];\n    }\n  }\n  return maxSumNum;\n};\n\n/*\n  Given an array of integers nums, find the minimum number of non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySum([-1, -2, -3]) == -6\n  */\nconst minuteSubArrayMinNumNum = (nums) => {\n  const minSum = nums[0];\n  let minSumNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    const sum = sum + nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n      minSumNum = nums[i];\n    }\n  }\n  return minSumNum;\n};\n\n/*\n  Given an array of integers nums, find the maximum number of non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySum([-1, -2, -3]) == -6\n  */\nconst minuteSubArrayMaxNumNum = (nums) => {\n  const maxSum = nums[0];\n  let maxSumNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    const sum = sum + nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n      maxSumNum = nums[i];\n    }\n  }\n  return maxSumNum;\n};\n\n/*\n  Given an array of integers nums, find the minimum number of non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySum([-1, -2, -3]) == -6\n  */\nconst minuteSubArrayMinNumNum = (nums) => {\n  const minSum = nums[0];\n  let minSumNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    const sum = sum + nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n      minSumNum = nums[i];\n    }\n  }\n  return minSumNum;\n};\n\n/*\n  Given an array of integers nums, find the maximum number of non-empty sub-array\n  of nums.\n  Example\n  minuteSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  minuteSubArraySum([-1, -2, -3]) == -6\n  */\nconst minuteSubArrayMaxNumNum = (nums) => {\n  const maxSum = nums[0];\n  let maxSumNum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    const sum = sum + nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n      maxSumNum = nums[i];\n    }\n  }\n  return maxSumNum;\n};\n\n/*\n  Given an array of integers nums, find the minimum number of non-empty sub-array\n  of num", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst soapFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "soapFill", "gc": "<|endoftext|>/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst soapFill = (grid, capacity) => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = [];\n    \n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(grid[i][j] === 1) {\n                result.push([i, j]);\n            }\n        }\n    }\n    \n    result.sort((a, b) => a[1] - b[1]);\n    \n    const lower = result.slice(0, result.length - capacity);\n    \n    for(let i = 0; i < result.length - capacity; i++) {\n        for(let j = 0; j < result.length - capacity; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                result.splice(i, 1);\n                result.splice(j, 1);\n            }\n        }\n    }\n    \n    for(let i = 0; i < result.length; i++) {\n        for(let j = 0; j < result.length; j++) {\n            if(result[i][j] === 1) {\n                grid[i][j] = 0;\n                ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "gc": "<|endoftext|>/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  let sortedArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    let ones = arr[i];\n    let onesBin = onesToBin(ones);\n    let onesDec = (onesBin + '').split('').reverse().join('');\n    sortedArr.push(onesDec);\n  }\n  return sortedArr;\n};\n\n/*\n  Given an array of non-negative integers, return an array of binary representations.\n  For example:\n  >>> binaryArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  >>> binaryArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [111, 110, 109, 8, 7, 6, 5, 4, 3, 2, 1]\n  >>> binaryArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [1111, 1101, 1099, 1088, 1087, 1086, 1085,\n  1084, 1083, 1082, 1081, 1080, 1079, 1078, 1077, 1076]\n  >>> binaryArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [1111, 1101, 1099, 1088, 1087, 1086,\n  1085, 1084, 1083, 1082, 1081, 1080, 1079, 1078, 1077, 1076]\n  >>> binaryArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [1111, 1101, 1099, 1088, 1087, 1086,\n  1085, 1084, 1083, 1082, 1081, 1080, 1079, 1078, 1077, 1076]\n  >>> binaryArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [1111, 1101, 1099, 1088, 1087, 1086,\n  1085, 1084, 1083, 1082, 1081, 1080, 1079, 1078, 1077, 1076]\n  >>> binaryArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [1111, 1101, 1099, 1088, 1087, 1086,\n  1085, 1084, 1083, 1082, 1081, 1080, 1079, 1078, 1077, 1076]\n  >>> binaryArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [1111, 1101, 1099, 1088, 1087, 1086,\n  1085, 1084, 1083, 1082, 1081, 1080, 1079, 1078, 1077, 1076]\n  >>> binaryArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [1111, 1101, 1099, 1088, 1087, 1086,\n  1085, 1084, 1083, 1082, 1081, 1080, 1079, 1078, 1077, 1076]\n  >>> binaryArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [1111, 1101, 1099, 1088, 1087, 1086,\n  1085, 1084, 1083, 1082, 1081, 1080, 1079, 1078, 1077, 1076]\n  >>> binaryArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [1111, 1101, 1099, 1088, 1087, 1086,\n  1085, 1084, 1083, 1082, 1081, 1080, 1079, 1078, 1077, 1076]\n  >>> binaryArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [1111, 1101, 1099, 1088, 1087, 1086,\n  1085, 1084, 1083, 1082, 1081, 1080, 1079, 1078, 1077, 1076]\n  >>> binaryArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [1111, 1101, 1099, 1088, 1087, 1086,\n  1085, 1084, 1083, 1082, 1081, 1080, 1079, 1078, 1077, 1076]\n  >>> binaryArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [1111, 1101, 1099, 1088, 1087, 1086,\n  1085, 1084, 1083, 1082, 1081, 1080, 1079, 1078, 1077, 1076]\n  >>> binaryArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [1111, 1101, 1099, 1088, 1087, 1086,\n  1085, 1084, 1083, 1082, 1081, 1080, 1079, 1078, 1077, 1076]\n  >>> binaryArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [1111, 1101, 1099, 1088, 1087, 1086,\n  1085, 1084, 1083, 1082, 1081, 1080, 1079, 1078, 1077, 1076]\n  >>> binaryArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [1111, 1101, 1099, 1088, 1087, 1086,\n  1085, 1084, 1083, 1082, 1081, 1080, 1079, 1078, 1077, 1076]\n  >>> binaryArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [1111, 1101, 1099, 1088, 1087, 1086,\n  1085, 1084, 1083, 1082, 1081, 1080, 1079, 1078, 1077, 1076]\n  >>> binaryArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [1111, 1101, 1099, 1088, 1087, 1086,\n  1085, 1084, 1083, 1082, 1081, 1080, 1079, 1078, 1077, 1076]\n  >>> binaryArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [1111, 1101, 1099, 1088, 1087, 1086,\n  1085, 1084, 1083, 1082, 1081, 1080, 1079, 1078, 1077, 1076]\n  >>> binaryArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [1111, 1101, 1099, 1088, 1087, 1086,\n  1085, 1084, 1083, 1082, 1081, 1080, 1079, 1078, 1077, 1076]\n  >>> binaryArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [1111, 1101, 1099, 1088, 1087, 1086,\n  1085, 1084, 1083, 1082, 1081, 1080, 1079, 1078, 1077, 1076]\n  >>> binaryArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [1111, 1101, 1099, 1088, 1087, 1086,\n  1085, 1084, 1083, 1082, 1081, 1080, 1079, 1078, 1077, 1076]\n  >>> binaryArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [1111, 1101, 1099, 1088, 1087, 1086,\n  1085, 1084, 1083, 1082, 1081, 1080, 1079, 1078, 1077, 1076]\n  >>> binaryArray([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]) == [1111, 1101, 10", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  choiceDiscussion(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  choiceDiscussion(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  choiceDiscussion(\"simple white space\", 2) ==> []\n  choiceDiscussion(\"Hello world\", 4) ==> [\"world\"]\n  choiceDiscussion(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst choiceDiscussion = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "choiceDiscussion", "gc": "<|endoftext|>/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  choiceDiscussion(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  choiceDiscussion(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  choiceDiscussion(\"simple white space\", 2) ==> []\n  choiceDiscussion(\"Hello world\", 4) ==> [\"world\"]\n  choiceDiscussion(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst choiceDiscussion = (s, n) => {\n  let words = []\n  let word = ''\n  let count = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/118", "prompt": "/*You are given a word. Your task is to find the closest vowel that stands between \n  two consonants from the right side of the word (case sensitive).\n  \n  Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contains English letter only.\n\n  Example:\n  catchClosestVowel(\"yogurt\") ==> \"u\"\n  catchClosestVowel(\"FULL\") ==> \"U\"\n  catchClosestVowel(\"quick\") ==> \"\"\n  catchClosestVowel(\"ab\") ==> \"\"\n  */\nconst catchClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "catchClosestVowel", "gc": "<|endoftext|>/*You are given a word. Your task is to find the closest vowel that stands between \n  two consonants from the right side of the word (case sensitive).\n  \n  Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contains English letter only.\n\n  Example:\n  catchClosestVowel(\"yogurt\") ==> \"u\"\n  catchClosestVowel(\"FULL\") ==> \"U\"\n  catchClosestVowel(\"quick\") ==> \"\"\n  catchClosestVowel(\"ab\") ==> \"\"\n  */\nconst catchClosestVowel = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelsIndex = 0;\n  let vowelsLength = 0;\n  let vowelsIndex2 = 0;\n  let vowelsLength2 = 0;\n  let vowelsIndex3 = 0;\n  let vowelsLength3 = 0;\n  let vowelsIndex4 = 0;\n  let vowelsLength4 = 0;\n  let vowelsIndex5 = 0;\n  let vowelsLength5 = 0;\n  let vowelsIndex6 = 0;\n  let vowelsLength6 = 0;\n  let vowelsIndex7 = 0;\n  let vowelsLength7 = 0;\n  let vowelsIndex8 = 0;\n  let vowelsLength8 = 0;\n  let vowelsIndex9 = 0;\n  let vowelsLength9 = 0;\n  let vowelsIndex10 = 0;\n  let vowelsLength10 = 0;\n  let vowelsIndex11 = 0;\n  let vowelsLength11 = 0;\n  let vowelsIndex12 = 0;\n  let vowelsLength12 = 0;\n  let vowelsIndex13 = 0;\n  let vowelsLength13 = 0;\n  let vowelsIndex14 = 0;\n  let vowelsLength14 = 0;\n  let vowelsIndex15 = 0;\n  let vowelsLength15 = 0;\n  let vowelsIndex16 = 0;\n  let vowelsLength16 = 0;\n  let vowelsIndex17 = 0;\n  let vowelsLength17 = 0;\n  let vowelsIndex18 = 0;\n  let vowelsLength18 = 0;\n  let vowelsIndex19 = 0;\n  let vowelsLength19 = 0;\n  let vowelsIndex20 = 0;\n  let vowelsLength20 = 0;\n  let vowelsIndex21 = 0;\n  let vowelsLength21 = 0;\n  let vowelsIndex22 = 0;\n  let vowelsLength22 = 0;\n  let vowelsIndex23 = 0;\n  let vowelsLength23 = 0;\n  let vowelsIndex24 = 0;\n  let vowelsLength24 = 0;\n  let vowelsIndex25 = 0;\n  let vowelsLength25 = 0;\n  let vowelsIndex26 = 0;\n  let vowelsLength26 = 0;\n  let vowelsIndex27 = 0;\n  let vowelsLength27 = 0;\n  let vowelsIndex28 = 0;\n  let vowelsLength28 = 0;\n  let vowelsIndex29 = 0;\n  let vowelsLength29 = 0;\n  let vowelsIndex30 = 0;\n  let vowelsLength30 = 0;\n  let vowelsIndex31 = 0;\n  let vowelsLength31 = 0;\n  let vowelsIndex32 = 0;\n  let vowelsLength32 = 0;\n  let vowelsIndex33 = 0;\n  let vowelsLength33 = 0;\n  let vowelsIndex34 = 0;\n  let vowelsLength34 = 0;\n  let vowelsIndex35 = 0;\n  let vowelsLength35 = 0;\n  let vowelsIndex36 = 0;\n  let vowelsLength36 = 0;\n  let vowelsIndex37 = 0;\n  let vowelsLength37 = 0;\n  let vowelsIndex38 = 0;\n  let vowelsLength38 = 0;\n  let vowelsIndex39 = 0;\n  let vowelsLength39 = 0;\n  let vowelsIndex40 = 0;\n  let vowelsLength40 = 0;\n  let vowelsIndex41 = 0;\n  let vowelsLength41 = 0;\n  let vowelsIndex42 = 0;\n  let vowelsLength42 = 0;\n  let vowelsIndex43 = 0;\n  let vowelsLength43 = 0;\n  let vowelsIndex44 = 0;\n  let vowelsLength44 = 0;\n  let vowelsIndex45 = 0;\n  let vowelsLength45 = 0;\n  let vowelsIndex46 = 0;\n  let vowelsLength46 = 0;\n  let vowelsIndex47 = 0;\n  let vowelsLength47 = 0;\n  let vowelsIndex48 = 0;\n  let vowelsLength48 = 0;\n  let vowelsIndex49 = 0;\n  let vowelsLength49 = 0;\n  let vowelsIndex50 = 0;\n  let vowelsLength50 = 0;\n  let vowelsIndex51 = 0;\n  let vowelsLength51 = 0;\n  let vowelsIndex52 = 0;\n  let vowelsLength52 = 0;\n  let vowelsIndex53 = 0;\n  let vowelsLength53 = 0;\n  let vowelsIndex54 = 0;\n  let vowelsLength54 = 0;\n  let vowelsIndex55 = 0;\n  let vowelsLength55 = 0;\n  let vowelsIndex56 = 0;\n  let vowelsLength56 = 0;\n  let vowelsIndex57 = 0;\n  let vowelsLength57 = 0;\n  let vowelsIndex58 = 0;\n  let vowelsLength58 = 0;\n  let vowelsIndex59 = 0;\n  let vowelsLength59 = 0;\n  let vowelsIndex60 = 0;\n  let vowelsLength60 = 0;\n  let vowelsIndex61 = 0;\n  let vowelsLength61 = 0;\n  let vowelsIndex62 = 0;\n  let vowelsLength62 = 0;\n  let vowelsIndex63 = 0;\n  let vowelsLength63 = 0;\n  let vowelsIndex64 = 0;\n  let vowelsLength64 = 0;\n  let vowelsIndex65 = 0;\n  let vowelsLength65 = 0;\n  let vowelsIndex66 = 0;\n  let vowelsLength66 = 0;\n  let vowelsIndex67 = 0;\n  let vowelsLength67 = 0;\n  let vowelsIndex68 = 0;\n  let vowelsLength68 = 0;\n  let vowelsIndex69 = 0;\n  let vowelsLength69 = 0;\n  let vowelsIndex70 = 0;\n  let vowelsLength70 = 0;\n  let vowelsIndex71 = 0;\n  let vowelsLength71 = 0;\n  let vowelsIndex72 = 0;\n  let vowelsLength72 = 0;\n  let vowelsIndex73 = 0;\n  let vowelsLength73 = 0;\n  let vowelsIndex74 = 0;\n  let vowelsLength74 = 0;\n  let vowelsIndex75 = 0;\n  let vowelsLength75 = 0;\n  let vowelsIndex76 = 0;\n  let vowelsLength76 = 0;\n  let vowelsIndex77 = 0;\n  let vowelsLength77 = 0;\n  let vowelsIndex78 = 0;\n  let vowelsLength78 = 0;\n  let vowelsIndex79 = 0;\n  let vowelsLength79 = 0;\n  let vowelsIndex80 = 0;\n  let vowelsLength80 = 0;\n  let vowelsIndex81 = 0;\n  let vowelsLength81 = 0;\n  let vowelsIndex82 = 0;\n  let vowelsLength82 = 0;\n  let vowelsIndex83 = 0;\n  let vowelsLength83 = 0;\n  let vowelsIndex84 = 0;\n  let vowelsLength84 = 0;\n  let vowelsIndex85 = 0;\n  let vowelsLength85 = 0;\n  let vowelsIndex86 = 0;\n  let vowelsLength86 = 0;\n  let vowelsIndex87 = 0;\n  let vowelsLength87 = 0;\n  let vowelsIndex88 = 0;\n  let vowelsLength88 = 0;\n  let vowelsIndex89 = 0;\n  let vowelsLength89 = 0;\n  let vowelsIndex90 = 0;\n  let vowelsLength90 = 0;\n  let vowelsIndex91 = 0;\n  let vowelsLength91 = 0;\n  let vowelsIndex92 = 0;\n  let vowelsLength92 = 0;\n  let vowelsIndex93 = 0;\n  let vowelsLength93 = 0;\n  let vowelsIndex94 = 0;\n  let vowelsLength94 = 0;\n  let vowelsIndex95 = 0;\n  let vowelsLength95 = 0;\n  let vowelsIndex96 = 0;\n  let vowelsLength96 = 0;\n  let vowelsIndex97 = 0;\n  let vowelsLength97 = 0;\n  let vowelsIndex98 = 0;\n  let vowelsLength98 = 0;\n  let vowelsIndex99 = 0;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of two strings, both strings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible to concatenate the two strings in\n  some order, that the resulting string will be good.\n  A string S is considered to be good if and only if all parentheses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  catchParens(['()(', ')']) == 'Yes'\n  catchParens([')', ')']) == 'No'\n  */\nconst catchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "catchParens", "gc": "<|endoftext|>/* You are given a list of two strings, both strings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible to concatenate the two strings in\n  some order, that the resulting string will be good.\n  A string S is considered to be good if and only if all parentheses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  catchParens(['()(', ')']) == 'Yes'\n  catchParens([')', ')']) == 'No'\n  */\nconst catchParens = (lst) => {\n  let stack = []\n  let result = ''\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      stack.push(lst[i])\n    } else if (lst[i] === ')') {\n      if (stack.length!== 0) {\n        result += stack.pop()\n      }\n    }\n  }\n  return result === 'Yes'\n}\n\n/* You are given a string S consisting of only lowercase letters and digits. You are\n  asked to find if there is a way to convert S into another string that has the\n  same letters and digits but in reverse order. For example, the string 'abc'\n  can be converted to 'bca', but 'abc' cannot be converted to 'acb'. Return 'Yes'\n  if there is a way to convert S into another string that has the same\n  letters and digits but in reverse order, and 'No' otherwise.\n  Examples:\n  reverse('abc') == 'bca'\n  reverse('123') == '321'\n  reverse('abc123') == 'bca123'\n  */\nconst reverse = (str) => {\n  let result = ''\n  let stack = []\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] >= 'a' && str[i] <= 'z') {\n      stack.push(str[i])\n    } else if (str[i] >= 'A' && str[i] <= 'Z') {\n      stack.push(str[i])\n    } else if (str[i] >= '0' && str[i] <= '9') {\n      result += stack.pop()\n    }\n  }\n  return result === 'Yes'\n}\n\n/* You are given a string S consisting of only lowercase letters and digits. You are\n  asked to find if there is a way to convert S into another string that has the\n  same letters and digits but in reverse order. For example, the string 'abc'\n  can be converted to 'bca', but 'abc' cannot be converted to 'acb'. Return 'Yes'\n  if there is a way to convert S into another string that has the same\n  letters and digits but in reverse order, and 'No' otherwise.\n  Examples:\n  reverse('abc') == 'bca'\n  reverse('123') == '321'\n  reverse('abc123') == 'bca123'\n  */\nconst reverse2 = (str) => {\n  let result = ''\n  let stack = []\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] >= 'a' && str[i] <= 'z') {\n      stack.push(str[i])\n    } else if (str[i] >= 'A' && str[i] <= 'Z') {\n      stack.push(str[i])\n    } else if (str[i] >= '0' && str[i] <= '9') {\n      result += stack.pop()\n    }\n  }\n  return result === 'Yes'\n}\n\n/* You are given a string S consisting of only lowercase letters and digits. You are\n  asked to find if there is a way to convert S into another string that has the\n  same letters and digits but in reverse order. For example, the string 'abc'\n  can be converted to 'bca', but 'abc' cannot be converted to 'acb'. Return 'Yes'\n  if there is a way to convert S into another string that has the same\n  letters and digits but in reverse order, and 'No' otherwise.\n  Examples:\n  reverse('abc') == 'bca'\n  reverse('123') == '321'\n  reverse('abc123') == 'bca123'\n  */\nconst reverse3 = (str) => {\n  let result = ''\n  let stack = []\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] >= 'a' && str[i] <= 'z') {\n      stack.push(str[i])\n    } else if (str[i] >= 'A' && str[i] <= 'Z') {\n      stack.push(str[i])\n    } else if (str[i] >= '0' && str[i] <= '9') {\n      result += stack.pop()\n    }\n  }\n  return result === 'Yes'\n}\n\n/* You are given a string S consisting of only lowercase letters and digits. You are\n  asked to find if there is a way to convert S into another string that has the\n  same letters and digits but in reverse order. For example, the string 'abc'\n  can be converted to 'bca', but 'abc' cannot be converted to 'acb'. Return 'Yes'\n  if there is a way to convert S into another string that has the same\n  letters and digits but in reverse order, and 'No' otherwise.\n  Examples:\n  reverse('abc') == 'bca'\n  reverse('123') == '321'\n  reverse('abc123') == 'bca123'\n  */\nconst reverse4 = (str) => {\n  let result = ''\n  let stack = []\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] >= 'a' && str[i] <= 'z') {\n      stack.push(str[i])\n    } else if (str[i] >= 'A' && str[i] <= 'Z') {\n      stack.push(str[i])\n    } else if (str[i] >= '0' && str[i] <= '9') {\n      result += stack.pop()\n    }\n  }\n  return result === 'Yes'\n}\n\n/* You are given a string S consisting of only lowercase letters and digits. You are\n  asked to find if there is a way to convert S into another string that has the\n  same letters and digits but in reverse order. For example, the string 'abc'\n  can be converted to 'bca', but 'abc' cannot be converted to 'acb'. Return 'Yes'\n  if there is a way to convert S into another string that has the same\n  letters and digits but in reverse order, and 'No' otherwise.\n  Examples:\n  reverse('abc') == 'bca'\n  reverse('123') == '321'\n  reverse('abc123') == 'bca123'\n  */\nconst reverse5 = (str) => {\n  let result = ''\n  let stack = []\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] >= 'a' && str[i] <= 'z') {\n      stack.push(str[i])\n    } else if (str[i] >= 'A' && str[i] <= 'Z') {\n      stack.push(str[i])\n    } else if (str[i] >= '0' && str[i] <= '9') {\n      result += stack.pop()\n    }\n  }\n  return result === 'Yes'\n}\n\n/* You are given a string S consisting of only lowercase letters and digits. You are\n  asked to find if there is a way to convert S into another string that has the\n  same letters and digits but in reverse order. For example, the string 'abc'\n  can be converted to 'bca', but 'abc' cannot be converted to 'acb'. Return 'Yes'\n  if there is a way to convert S into another string that has the same\n  letters and digits but in reverse order, and 'No' otherwise.\n  Examples:\n  reverse('abc') == 'bca'\n  reverse('123') == '321'\n  reverse('abc123') == 'bca123'\n  */\nconst reverse6 = (str) => {\n  let result = ''\n  let stack = []\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] >= 'a' && str[i] <= 'z') {\n      stack.push(str[i])\n    } else if (str[i] >= 'A' && str[i] <= 'Z') {\n      stack.push(str[i])\n    } else if (str[i] >= '0' && str[i] <= '9') {\n      result += stack.pop()\n    }\n  }\n  return result === 'Yes'\n}\n\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the farseeing one. Return the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> farseeing([])\n\n  >>> farseeing(['a', 'b', 'c'])\n  'a'\n  >>> farseeing(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst farseeing = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "farseeing", "gc": "<|endoftext|>/* Out of list of strings, return the farseeing one. Return the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> farseeing([])\n\n  >>> farseeing(['a', 'b', 'c'])\n  'a'\n  >>> farseeing(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst farseeing = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  const stringLength = strings[0].length\n  const farseeingLength = stringLength - strings[0].length\n  const farseeingStrings = strings.slice(1)\n  return farseeingStrings.reduce((acc, string) => {\n    const stringLength = string.length\n    if (stringLength === farseeingLength) {\n      return string\n    }\n    return `${acc}${string}`\n  }, '')\n}\n\n/**\n  Given a string, return the first character of the string that is a letter\n  or digit.\n\n  >>> first('a')\n  'a'\n  >>> first('123')\n  '1'\n  >>> first('abc')\n  'a'\n  >>> first('abc123')\n  'a'\n  >>> first('abc123def')\n  'a'\n  >>> first('abc123def456')\n  'a'\n  >>> first('abc123def456def')\n  'a'\n  >>> first('abc123def456def456')\n  'a'\n  >>> first('abc123def456def456def456')\n  'a'\n  >>> first('abc123def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n  of length k with the maximal k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximal = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximal", "gc": "<|endoftext|>/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n  of length k with the maximal k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximal = (arr, k) => {\n  const len = arr.length;\n  let res = [];\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (arr[i] > arr[j]) {\n      res.push(arr[i]);\n      i++;\n    } else {\n      res.push(arr[j]);\n      j++;\n    }\n  }\n  return res.sort((a, b) => a - b);\n};\n\n// https://leetcode.com/problems/find-the-k-th-smallest-element-in-an-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar findKthSmallest = function (head, k) {\n  if (!head ||!k) {\n    return null;\n  }\n  let cur = head;\n  let count = 0;\n  while (cur) {\n    if (count === k) {\n      return cur;\n    }\n    cur = cur.next;\n    count++;\n  }\n  return null;\n};\n\n// https://leetcode.com/problems/find-the-k-th-smallest-element-in-an-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar findKthSmallestReverse = function (head, k) {\n  if (!head ||!k) {\n    return null;\n  }\n  let cur = head;\n  let count = 0;\n  while (cur) {\n    if (count === k) {\n      return cur;\n    }\n    cur = cur.next;\n    count++;\n  }\n  return null;\n};\n\n// https://leetcode.com/problems/find-the-k-th-smallest-element-in-an-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar findKthSmallestReverse2Head = function (head, k) {\n  if (!head ||!k) {\n    return null;\n  }\n  let cur = head;\n  let count = 0;\n  while (cur) {\n    if (count === k) {\n      return cur;\n    }\n    cur = cur.next;\n    count++;\n  }\n  return null;\n};\n\n// https://leetcode.com/problems/find-the-k-th-smallest-element-in-an-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar findKthSmallestReverse3Head = function (head, k) {\n  if (!head ||!k) {\n    return null;\n  }\n  let cur = head;\n  let count = 0;\n  while (cur) {\n    if (count === k) {\n      return cur;\n    }\n    cur = cur.next;\n    count++;\n  }\n  return null;\n};\n\n// https://leetcode.com/problems/find-the-k-th-smallest-element-in-an-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar findKthSmallestReverse4Head = function (head, k) {\n  if (!head ||!k) {\n    return null;\n  }\n  let cur = head;\n  let count = 0;\n  while (cur) {\n    if (count === k) {\n      return cur;\n    }\n    cur = cur.next;\n    count++;\n  }\n  return null;\n};\n\n// https://leetcode.com/problems/find-the-k-th-smallest-element-in-an-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar findKthSmallestReverse5Head = function (head, k) {\n  if (!head ||!k) {\n    return null;\n  }\n  let cur = head;\n  let count = 0;\n  while (cur) {\n    if (count === k) {\n      return cur;\n    }\n    cur = cur.next;\n    count++;\n  }\n  return null;\n};\n\n// https://leetcode.com/problems/find-the-k-th-smallest-element-in-an-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar findKthSmallestReverse6Head = function (head, k) {\n  if (!head ||!k) {\n    return null;\n  }\n  let cur = head;\n  let count = 0;\n  while (cur) {\n    if (count === k) {\n      return cur;\n    }\n    cur = cur.next;\n    count++;\n  }\n  return null;\n};\n\n// https://leetcode.com/problems/find-the-k-th-smallest-element-in-an-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar findKthSmallestReverse7Head = function (head, k) {\n  if (!head ||!k) {\n    return null;\n  }\n  let cur = head;\n  let count = 0;\n  while (cur) {\n    if (count === k) {\n      return cur;\n    }\n    cur = cur.next;\n    count++;\n  }\n  return null;\n};\n\n// https://leetcode.com/problems/find-the-k-th-smallest-element-in-an-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar findKthSmallestReverse8Head = function (head, k) {\n  if (!head ||!k) {\n    return null;\n  }\n  let cur = head;\n  let count = 0;\n  while (cur) {\n    if (count === k) {\n      return cur;\n    }\n    cur = cur.next;\n    count++;\n  }\n  return null;\n};\n\n// https://leetcode.com/problems/find-the-k-th-smallest-element-in-an-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {List", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/121", "prompt": "/*Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "gc": "<|endoftext|>/*Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution2 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution3 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution4 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution5 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution6 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution7 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution8 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution9 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution10 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution11 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution12 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution13 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution14 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution15 = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst lendElement = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "lendElement", "gc": "<|endoftext|>/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst lendElement = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 10) {\n      sum += arr[i];\n    } else {\n      sum += arr[i] * Math.pow(10, k - arr[i]);\n    }\n  }\n  return sum;\n};\n\n// Given a non-empty array of integers arr and an integer k, return\n// the sum of the elements with at most three digits from the first k elements of arr.\n\n// Example:\n\n// Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n// Output: 36 # sum of 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9\n\n// Constraints:\n// 1. 1 <= len(arr) <= 100\n// 2. 1 <= k <= len(arr)\n// 3. 1 <= arr[i] <= 10^9\n// 4. 1 <= arr[i] <= 10^9\n// 5. 1 <= arr[i] <= 10^9\n// 6. 1 <= arr[i] <= 10^9\n// 7. 1 <= arr[i] <= 10^9\n// 8. 1 <= arr[i] <= 10^9\n// 9. 1 <= arr[i] <= 10^9\n// 10. 1 <= arr[i] <= 10^9\n// 11. 1 <= arr[i] <= 10^9\n// 12. 1 <= arr[i] <= 10^9\n// 13. 1 <= arr[i] <= 10^9\n// 14. 1 <= arr[i] <= 10^9\n// 15. 1 <= arr[i] <= 10^9\n// 16. 1 <= arr[i] <= 10^9\n// 17. 1 <= arr[i] <= 10^9\n// 18. 1 <= arr[i] <= 10^9\n// 19. 1 <= arr[i] <= 10^9\n// 20. 1 <= arr[i] <= 10^9\n// 21. 1 <= arr[i] <= 10^9\n// 22. 1 <= arr[i] <= 10^9\n// 23. 1 <= arr[i] <= 10^9\n// 24. 1 <= arr[i] <= 10^9\n// 25. 1 <= arr[i] <= 10^9\n// 26. 1 <= arr[i] <= 10^9\n// 27. 1 <= arr[i] <= 10^9\n// 28. 1 <= arr[i] <= 10^9\n// 29. 1 <= arr[i] <= 10^9\n// 30. 1 <= arr[i] <= 10^9\n// 31. 1 <= arr[i] <= 10^9\n// 32. 1 <= arr[i] <= 10^9\n// 33. 1 <= arr[i] <= 10^9\n// 34. 1 <= arr[i] <= 10^9\n// 35. 1 <= arr[i] <= 10^9\n// 36. 1 <= arr[i] <= 10^9\n// 37. 1 <= arr[i] <= 10^9\n// 38. 1 <= arr[i] <= 10^9\n// 39. 1 <= arr[i] <= 10^9\n// 40. 1 <= arr[i] <= 10^9\n// 41. 1 <= arr[i] <= 10^9\n// 42. 1 <= arr[i] <= 10^9\n// 43. 1 <= arr[i] <= 10^9\n// 44. 1 <= arr[i] <= 10^9\n// 45. 1 <= arr[i] <= 10^9\n// 46. 1 <= arr[i] <= 10^9\n// 47. 1 <= arr[i] <= 10^9\n// 48. 1 <= arr[i] <= 10^9\n// 49. 1 <= arr[i] <= 10^9\n// 50. 1 <= arr[i] <= 10^9\n// 51. 1 <= arr[i] <= 10^9\n// 52. 1 <= arr[i] <= 10^9\n// 53. 1 <= arr[i] <= 10^9\n// 54. 1 <= arr[i] <= 10^9\n// 55. 1 <= arr[i] <= 10^9\n// 56. 1 <= arr[i] <= 10^9\n// 57. 1 <= arr[i] <= 10^9\n// 58. 1 <= arr[i] <= 10^9\n// 59. 1 <= arr[i] <= 10^9\n// 60. 1 <= arr[i] <= 10^9\n// 61. 1 <= arr[i] <= 10^9\n// 62. 1 <= arr[i] <= 10^9\n// 63. 1 <= arr[i] <= 10^9\n// 64. 1 <= arr[i] <= 10^9\n// 65. 1 <= arr[i] <= 10^9\n// 66. 1 <= arr[i] <= 10^9\n// 67. 1 <= arr[i] <= 10^9\n// 68. 1 <= arr[i] <= 10^9\n// 69. 1 <= arr[i] <= 10^9\n// 70. 1 <= arr[i] <= 10^9\n// 71. 1 <= arr[i] <= 10^9\n// 72. 1 <= arr[i] <= 10^9\n// 73. 1 <= arr[i] <= 10^9\n// 74. 1 <= arr[i] <= 10^9\n// 75. 1 <= arr[i] <= 10^9\n// 76. 1 <= arr[i] <= 10^9\n// 77. 1 <= arr[i] <= 10^9\n// 78. 1 <= arr[i] <= 10^9\n// 79. 1 <= arr[i] <= 10^9\n// 80. 1 <= arr[i] <= 10^9\n// 81. 1 <= arr[i] <= 10^9\n// 82. 1 <= arr[i] <= 10^9\n// 83. 1 <= arr[i] <= 10^9\n// 84. 1 <= arr[i] <= 10^9\n// 85. 1 <= arr[i] <= 10^9\n// 86. 1 <= arr[i] <= 10^9\n// 87. 1 <= arr[i] <= 10^9\n// 88. 1 <= arr[i] <= 10^9\n// 89. 1 <= arr[i] <= 10^9\n// 90. 1 <= arr[i] <= 10^9\n// 91. 1 <= arr[i] <= 10^9\n// 92. 1 <= arr[i] <= 10^9\n// 93. 1 <= arr[i] <= 10^9\n// 94. 1 <= arr[i] <= 10^9\n// 95. 1 <= arr[i] <= 10^9\n// 96. 1 <= arr[i] <= 10^9\n// 97. 1 <= arr[i] <= 10^9\n// 98. 1 <= arr[i] <= 10^9\n// 99. 1 <= arr[i] <= 10^9\n// 100. 1 <= arr[i] <= 10^9\n// 101. 1 <= arr[i] <= 10^9\n// 102. 1 <= arr[i] <= 10^9\n// 103. 1 <= arr[i] <= 10^9\n// 104. 1 <= arr[i] <= 10^9\n// 105. 1 <= arr[i] <= 10^9\n// 106. 1 <= arr[i] <= 10^9\n// 107. 1 <= arr[i] <= 10^9\n// 108. 1 <= arr[i] <= 10^9\n// 109. 1 <= arr[i] <= 10^9\n// 110. 1 <= arr[i] <= 10^9\n// 111. 1 <= arr[i] <= 10^9\n// 112. 1 <= arr[i] <= 10^9\n// 113. 1 <= arr[i] <= 10^9\n// 114. 1 <= arr[i] <= 10^9\n// 115. 1 <= arr[i] <= 10^9\n// 116. 1 <= arr[i] <= 10^9\n// 117. 1 <= arr[i] <= 10^9\n// 118. 1 <= arr[i] <= 10^9\n// 119. 1 <= arr[i] <= 10^9\n// 120. 1 <= arr[i] <= 10^9\n// 121. 1 <= arr[i] <= 10", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  catchOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst catchOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "catchOddCollatz", "gc": "<|endoftext|>/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  catchOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst catchOddCollatz = (n) => {\n  let list = [];\n  let current = 1;\n  let prev = 1;\n  while (current <= n) {\n    if (current % 2 === 0) {\n      list.push(current);\n      current = prev;\n      prev = current;\n    } else {\n      prev = current;\n      current = current * prev + prev;\n    }\n  }\n  return list;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the even numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  catchEvenCollatz(5) returns [1, 5, 16, 8, 4, 2] # The collatz sequence for 5 is [1, 5, 16, 8, 4, 2, 1], so the even numbers are 1, 5, 16, 8, 4, 2, 5.\n  */\nconst catchEvenCollatz = (n) => {\n  let list = [];\n  let current = 1;\n  let prev = 1;\n  while (current <= n) {\n    if (current % 2 === 0) {\n      list.push(current);\n      current = prev;\n      prev = current;\n    } else {\n      prev = current;\n      current = current * prev + prev;\n    }\n  }\n  return list;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime factors of n.\n\n  The Prime Factorization is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Prime Factorization(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  catchPrimeFactorization(5) returns [1, 5, 7, 11, 13] # The prime factorization of 5 is [1, 3, 5, 7, 11, 13], so the prime factors of 5 is 1, 3, 5, 7, 11, 13.\n  */\nconst catchPrimeFactorization = (n) => {\n  let list = [];\n  let current = 1;\n  let prev = 1;\n  while (current <= n) {\n    if (current % 2 === 0) {\n      list.push(current);\n      current = prev;\n      prev = current;\n    } else {\n      prev = current;\n      current = current * prev + prev;\n    }\n  }\n  return list;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime factors of n that are greater than or equal to n.\n\n  The Prime Factorization is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Prime Factorization(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  catchPrimeFactorizationGreaterThanOrEqual(5) returns [1, 3, 5, 7, 11, 13] # The prime factorization of 5 is [1, 3, 5, 7, 11, 13], so the prime factors of 5 is 1, 3, 5, 7, 11, 13.\n  */\nconst catchPrimeFactorizationGreaterThanOrEqual = (n) => {\n  let list = [];\n  let current = 1;\n  let prev = 1;\n  while (current <= n) {\n    if (current % 2 === 0) {\n      list.push(current);\n      current = prev;\n      prev = current;\n    } else {\n      prev = current;\n      current = current * prev + prev;\n    }\n  }\n  return list;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime factors of n that are less than or equal to n.\n\n  The Prime Factorization is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Prime Factorization(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  catchPrimeFactorizationLessThanOrEqual(5) returns [1, 3, 5, 7, 11, 13] # The prime factorization of 5 is [1, 3, 5, 7, 11, 13], so the prime factors of 5 is 1, 3, 5, 7, 11, 13.\n  */\nconst catchPrimeFactorizationLessThanOrEqual = (n) => {\n  let list = [];\n  let current = 1;\n  let prev = 1;\n  while (current <= n) {\n    if (current % 2 === 0) {\n      list.push(current);\n      current = prev;\n      prev = current;\n    } else {\n      prev = current;\n      current = current * prev + prev;\n    }\n  }\n  return list;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime factors of n that are less than or equal to n and greater than or equal to n.\n\n  The Prime Factorization is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Prime Factorization(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  catchPrimeFactorizationLessThanOrEqualGreaterThanOrEqual(5) returns [1, 3, 5, 7, 11, 13] # The prime factorization of 5 is [1, 3, 5, 7, 11, 13], so the prime factors of 5 is 1, 3, 5, 7, 11, 13.\n  */\nconst catchPrimeFactorizationLessThanOrEqualGreaterThanOrEqual = (n) => {\n  let list = [];\n  let current = 1;\n  let prev = 1;\n  while (current <= n) {", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/124", "prompt": "/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "gc": "<|endoftext|>/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const dateFormat = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const dateParts = date.match(dateFormat);\n  const datePart1 = dateParts[1];\n  const datePart2 = dateParts[2];\n  const datePart3 = dateParts[4];\n  const datePart4 = dateParts[5];\n  const datePart5 = dateParts[6];\n  const datePart6 = dateParts[7];\n  const datePart7 = dateParts[8];\n  const datePart8 = dateParts[9];\n  const datePart9 = dateParts[10];\n  const datePart10 = dateParts[11];\n  const datePart11 = dateParts[12];\n  const datePart12 = dateParts[13];\n  const datePart13 = dateParts[14];\n  const datePart14 = dateParts[15];\n  const datePart15 = dateParts[16];\n  const datePart16 = dateParts[17];\n  const datePart17 = dateParts[18];\n  const datePart18 = dateParts[19];\n  const datePart19 = dateParts[20];\n  const datePart20 = dateParts[21];\n  const datePart21 = dateParts[22];\n  const datePart22 = dateParts[23];\n  const datePart23 = dateParts[24];\n  const datePart24 = dateParts[25];\n  const datePart25 = dateParts[26];\n  const datePart26 = dateParts[27];\n  const datePart27 = dateParts[28];\n  const datePart28 = dateParts[29];\n  const datePart29 = dateParts[30];\n  const datePart30 = dateParts[31];\n  const datePart31 = dateParts[32];\n  const datePart32 = dateParts[33];\n  const datePart33 = dateParts[34];\n  const datePart34 = dateParts[35];\n  const datePart35 = dateParts[36];\n  const datePart36 = dateParts[37];\n  const datePart37 = dateParts[38];\n  const datePart38 = dateParts[39];\n  const datePart39 = dateParts[40];\n  const datePart40 = dateParts[41];\n  const datePart41 = dateParts[42];\n  const datePart42 = dateParts[43];\n  const datePart43 = dateParts[44];\n  const datePart44 = dateParts[45];\n  const datePart45 = dateParts[46];\n  const datePart46 = dateParts[47];\n  const datePart47 = dateParts[48];\n  const datePart48 = dateParts[49];\n  const datePart49 = dateParts[50];\n  const datePart50 = dateParts[51];\n  const datePart51 = dateParts[52];\n  const datePart52 = dateParts[53];\n  const datePart53 = dateParts[54];\n  const datePart54 = dateParts[55];\n  const datePart55 = dateParts[56];\n  const datePart56 = dateParts[57];\n  const datePart57 = dateParts[58];\n  const datePart58 = dateParts[59];\n  const datePart59 = dateParts[60];\n  const datePart60 = dateParts[61];\n  const datePart61 = dateParts[62];\n  const datePart62 = dateParts[63];\n  const datePart63 = dateParts[64];\n  const datePart64 = dateParts[65];\n  const datePart65 = dateParts[66];\n  const datePart66 = dateParts[67];\n  const datePart67 = dateParts[68];\n  const datePart68 = dateParts[69];\n  const datePart69 = dateParts[70];\n  const datePart70 = dateParts[71];\n  const datePart71 = dateParts[72];\n  const datePart72 = dateParts[73];\n  const datePart73 = dateParts[74];\n  const datePart74 = dateParts[75];\n  const datePart75 = dateParts[76];\n  const datePart76 = dateParts[77];\n  const datePart77 = dateParts[78];\n  const datePart78 = dateParts[79];\n  const datePart79 = dateParts[80];\n  const datePart80 = dateParts[81];\n  const datePart81 = dateParts[82];\n  const datePart82 = dateParts[83];\n  const datePart83 = dateParts[84];\n  const datePart84 = dateParts[85];\n  const datePart85 = dateParts[86];\n  const datePart86 = dateParts[87];\n  const datePart87 = dateParts[88];\n  const datePart88 = dateParts[89];\n  const datePart89 = dateParts[90];\n  const datePart90 = dateParts[91];\n  const datePart91 = dateParts[92];\n  const datePart92 = dateParts[93];\n  const datePart93 = dateParts[94];\n  const datePart94 = dateParts[95];\n  const datePart95 = dateParts[96];\n  const datePart96 = dateParts[97];\n  const datePart97 = dateParts[98];\n  const datePart98 = dateParts[99];\n  const datePart99 = dateParts[100];\n  const datePart100 = dateParts[101];\n  const datePart101 = dateParts[102];\n  const datePart102 = dateParts[103];\n  const datePart103 = dateParts[104];\n  const datePart104 = dateParts[105];\n  const datePart105 = dateParts[106];\n  const datePart106 = dateParts[107];\n  const datePart107 = dateParts[108];\n  const datePart108 = dateParts[109];\n  const datePart109 = dateParts[110];\n  const datePart110 = dateParts[111];\n  const datePart111 = dateParts[112];\n  const datePart112 = dateParts[113];\n  const datePart113 = dateParts[114];\n  const datePart114 = dateParts[115];\n  const datePart115 = dateParts[116];\n  const datePart116 = dateParts[117];\n  const datePart117 = dateParts[118];\n  const datePart118 = dateParts[119];\n  const datePart119 = dateParts[120];\n  const datePart120 = dateParts[121];\n  const ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/125", "prompt": "/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  disconnectedWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  disconnectedWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  disconnectedWords(\"abcdef\") == 3\n  */\nconst disconnectedWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "disconnectedWords", "gc": "<|endoftext|>/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  disconnectedWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  disconnectedWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  disconnectedWords(\"abcdef\") == 3\n  */\nconst disconnectedWords = (txt) => {\n  const words = txt.split(',');\n  let disconnectedWords = [];\n  let lowerCaseLetters = 0;\n  let oddOrder = 0;\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].toLowerCase() === 'a' || words[i].toLowerCase() === 'b' || words[i].toLowerCase() === 'c' || words[i].toLowerCase() === 'd' || words[i].toLowerCase() === 'e' || words[i].toLowerCase() === 'f' || words[i].toLowerCase() === 'g' || words[i].toLowerCase() === 'h' || words[i].toLowerCase() === 'i' || words[i].toLowerCase() === 'j' || words[i].toLowerCase() === 'k' || words[i].toLowerCase() === 'l' || words[i].toLowerCase() ==='m' || words[i].toLowerCase() === 'n' || words[i].toLowerCase() === 'o' || words[i].toLowerCase() === 'p' || words[i].toLowerCase() === 'q' || words[i].toLowerCase() === 'r' || words[i].toLowerCase() ==='s' || words[i].toLowerCase() === 't' || words[i].toLowerCase() === 'u' || words[i].toLowerCase() === 'v' || words[i].toLowerCase() === 'w' || words[i].toLowerCase() === 'x' || words[i].toLowerCase() === 'y' || words[i].toLowerCase() === 'z') {\n      lowerCaseLetters++;\n    } else if (words[i].toLowerCase() === 'a' || words[i].toLowerCase() === 'b' || words[i].toLowerCase() === 'c' || words[i].toLowerCase() === 'd' || words[i].toLowerCase() === 'e' || words[i].toLowerCase() === 'f' || words[i].toLowerCase() === 'g' || words[i].toLowerCase() === 'h' || words[i].toLowerCase() === 'i' || words[i].toLowerCase() === 'j' || words[i].toLowerCase() === 'k' || words[i].toLowerCase() === 'l' || words[i].toLowerCase() ==='m' || words[i].toLowerCase() === 'n' || words[i].toLowerCase() === 'o' || words[i].toLowerCase() === 'p' || words[i].toLowerCase() === 'q' || words[i].toLowerCase() === 'r' || words[i].toLowerCase() ==='s' || words[i].toLowerCase() === 't' || words[i].toLowerCase() === 'u' || words[i].toLowerCase() === 'v' || words[i].toLowerCase() === 'w' || words[i].toLowerCase() === 'x' || words[i].toLowerCase() === 'y' || words[i].toLowerCase() === 'z') {\n      oddOrder++;\n    }\n  }\n  return [disconnectedWords, lowerCaseLetters, oddOrder];\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  disconnectedWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  disconnectedWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  disconnectedWords(\"abcdef\") == 3\n  */\nconst disconnectedWordsNoWhitespaces = (txt) => {\n  const words = txt.split(',');\n  let disconnectedWords = [];\n  let lowerCaseLetters = 0;\n  let oddOrder = 0;\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].toLowerCase() === 'a' || words[i].toLowerCase() === 'b' || words[i].toLowerCase() === 'c' || words[i].toLowerCase() === 'd' || words[i].toLowerCase() === 'e' || words[i].toLowerCase() === 'f' || words[i].toLowerCase() === 'g' || words[i].toLowerCase() === 'h' || words[i].toLowerCase() === 'i' || words[i].toLowerCase() === 'j' || words[i].toLowerCase() === 'k' || words[i].toLowerCase() === 'l' || words[i].toLowerCase() ==='m' || words[i].toLowerCase() === 'n' || words[i].toLowerCase() === 'o' || words[i].toLowerCase() === 'p' || words[i].toLowerCase() === 'q' || words[i].toLowerCase() === 'r' || words[i].toLowerCase() ==='s' || words[i].toLowerCase() === 't' || words[i].toLowerCase() === 'u' || words[i].toLowerCase() === 'v' || words[i].toLowerCase() === 'w' || words[i].toLowerCase() === 'x' || words[i].toLowerCase() === 'y' || words[i].toLowerCase() === 'z') {\n      lowerCaseLetters++;\n    } else if (words[i].toLowerCase() === 'a' || words[i].toLowerCase() === 'b' || words[i].toLowerCase() === 'c' || words[i].toLowerCase() === 'd' || words[i].toLowerCase() === 'e' || words[i].toLowerCase() === 'f' || words[i].toLowerCase() === 'g' || words[i].toLowerCase() === 'h' || words[i].toLowerCase() === 'i' || words[i].toLowerCase() === 'j' || words[i].toLowerCase() === 'k' || words[i].toLowerCase() === 'l' || words[i].toLowerCase() ==='m' || words[i].toLowerCase() === 'n' || words[i].toLowerCase() === 'o' || words[i].toLowerCase() === 'p' || words[i].toLowerCase() === 'q' || words[i].toLowerCase() === 'r' || words[i].toLowerCase() ==='s' || words[i].toLowerCase() === 't' || words[i].toLowerCase() === 'u' || words[i].toLowerCase() === 'v' || words[i].toLowerCase() === 'w' || words[i].toLowerCase() === 'x' || words[i].toLowerCase() === 'y' || words[i].toLowerCase() === 'z') {\n      oddOrder++;\n    }\n  }\n  return [disconnectedWords, lowerCaseLetters, oddOrder];\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  disconnectedWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  disconnectedWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  disconnectedWords(\"abcdef\") == 3\n  */\nconst disconnectedWordsNoWhitespaces_noWhitespaces = (txt) => {\n  const words = txt.split(',');\n  let disconnectedWords = [];\n  let lowerCaseLetters = 0;\n  let oddOrder = 0;\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].toLowerCase() === 'a' || words[i].toLowerCase() === 'b' || words[i].toLowerCase() === 'c' || words[i].toLowerCase() === 'd' || words[i].toLowerCase() === 'e' || words[i].toLowerCase() === 'f' || words[i].toLowerCase() === 'g' || words[i].toLowerCase() === 'h' || words[i].toLowerCase() === 'i' || words[i].toLowerCase() === 'j' || words[i].toLowerCase() === 'k' || words[i].toLowerCase() === 'l' || words[i].toLowerCase() ==='m' || words[i].toLowerCase() === 'n' || words[i].toLowerCase() === 'o' || words[i].toLowerCase() === 'p' || words[i].toLowerCase() === 'q' || words[i].toLowerCase() === 'r' || words[i].toLowerCase() ==='s' || words[i].toLowerCase() === 't' || words[i].toLowerCase() === 'u' || words[i].toLowerCase() === 'v' || words[i].toLowerCase() === 'w' || words[i].toLowerCase() === 'x' || words[i].toLowerCase() === 'y' || words[i].toLowerCase() === 'z') {\n      lowerCaseLetters++;\n    } else if (words[i].toLowerCase() === 'a' || words[i].toLowerCase() === 'b' || words[i].toLowerCase() === 'c' || words[i].toLowerCase() === 'd' || words[i].toLowerCase() === 'e' || words[i].toLowerCase() === 'f' || words[i].toLowerCase() === 'g' || words[i].toLowerCase() === 'h' || words[i].toLowerCase() === 'i' || words[i].toLowerCase() === 'j", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isScreen([5]) ➞ true\n  isScreen([1, 2, 3, 4, 5]) ➞ true\n  isScreen([1, 3, 2, 4, 5]) ➞ false\n  isScreen([1, 2, 3, 4, 5, 6]) ➞ true\n  isScreen([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isScreen([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 4]) ➞ true\n  isScreen([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isScreen = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isScreen", "gc": "<|endoftext|>/* Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isScreen([5]) ➞ true\n  isScreen([1, 2, 3, 4, 5]) ➞ true\n  isScreen([1, 3, 2, 4, 5]) ➞ false\n  isScreen([1, 2, 3, 4, 5, 6]) ➞ true\n  isScreen([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isScreen([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 4]) ➞ true\n  isScreen([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isScreen = (lst) => {\n  const seen = new Set()\n  return lst.every((n) => seen.has(n) && seen.has(n + 1))\n}\n\n/* Given a list of numbers, return whether or not they are sorted\n  in descending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isScreen([5]) ➞ false\n  isScreen([1, 2, 3, 4, 5]) ➞ false\n  isScreen([1, 3, 2, 4, 5]) ➞ true\n  isScreen([1, 2, 3, 4, 5, 6]) ➞ false\n  isScreen([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isScreen([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isScreen([1, 2, 2, 3, 3, 4]) ➞ false\n  isScreen([1, 2, 2, 2, 3, 4]) ➞ true\n  isScreen([1, 2, 2, 2, 3, 3]) ➞ false\n  */\nconst isScreenDesc = (lst) => {\n  const seen = new Set()\n  return lst.every((n) => seen.has(n) && seen.has(n + 1))\n}\n\n/* Given a list of numbers, return whether or not they are sorted\n  in ascending order and in descending order. If list has more than 1 duplicate\n  of the same number, return false. Assume no negative numbers and only\n  integers.\n  Examples\n  isScreenDesc([5]) ➞ false\n  isScreenDesc([1, 2, 3, 4, 5]) ➞ false\n  isScreenDesc([1, 3, 2, 4, 5]) ➞ true\n  isScreenDesc([1, 2, 3, 4, 5, 6]) ➞ false\n  isScreenDesc([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isScreenDesc([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isScreenDesc([1, 2, 2, 3, 3, 4]) ➞ false\n  isScreenDesc([1, 2, 2, 2, 3, 4]) ➞ true\n  isScreenDesc([1, 2, 2, 2, 3, 3]) ➞ false\n  */\nconst isScreenDescAsc = (lst) => {\n  const seen = new Set()\n  return lst.every((n) => seen.has(n) && seen.has(n + 1))\n}\n\n/* Given a list of numbers, return whether or not they are sorted\n  in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n  and in ascending order and in descending order and in ascending order\n  and in descending order and in ascending order and in descending order\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/127", "prompt": "/*You are given two intervals,\n  where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of overlap of these two \n  intervals is a prime number.\n  Example, the overlap of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the overlap is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  overlap((1, 2), (2, 3)) ==> \"NO\"\n  overlap((-1, 1), (0, 4)) ==> \"NO\"\n  overlap((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst overlap = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "overlap", "gc": "<|endoftext|>/*You are given two intervals,\n  where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of overlap of these two \n  intervals is a prime number.\n  Example, the overlap of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the overlap is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  overlap((1, 2), (2, 3)) ==> \"NO\"\n  overlap((-1, 1), (0, 4)) ==> \"NO\"\n  overlap((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst overlap = (interval1, interval2) => {\n  let isOverlap = false;\n  let isPrime = true;\n  let start1 = interval1[0];\n  let start2 = interval2[0];\n  let end1 = interval1[1];\n  let end2 = interval2[1];\n  if (start1 > end2) {\n    isOverlap = true;\n    isPrime = false;\n  } else if (start2 > end1) {\n    isOverlap = true;\n    isPrime = false;\n  } else if (start1 < end2) {\n    isOverlap = true;\n    isPrime = false;\n  } else if (start2 < end1) {\n    isOverlap = true;\n    isPrime = false;\n  }\n  if (isOverlap) {\n    if (start2 > start1) {\n      isOverlap = true;\n      isPrime = false;\n    }\n    if (end2 < end1) {\n      isOverlap = true;\n      isPrime = false;\n    }\n  }\n  return isPrime;\n};\n\nmodule.exports = overlap;\n\n},{}],3:[function(require,module,exports){\n/*\n  You are given two intervals, where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of overlap of these two \n  intervals is a prime number.\n  Example, the overlap of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the overlap is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  overlap((1, 2), (2, 3)) ==> \"NO\"\n  overlap((-1, 1), (0, 4)) ==> \"NO\"\n  overlap((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst overlap = (interval1, interval2) => {\n  let isOverlap = false;\n  let isPrime = true;\n  let start1 = interval1[0];\n  let start2 = interval2[0];\n  let end1 = interval1[1];\n  let end2 = interval2[1];\n  if (start1 > end2) {\n    isOverlap = true;\n    isPrime = false;\n  } else if (start2 > end1) {\n    isOverlap = true;\n    isPrime = false;\n  } else if (start1 < end2) {\n    isOverlap = true;\n    isPrime = false;\n  } else if (start2 < end1) {\n    isOverlap = true;\n    isPrime = false;\n  }\n  if (isOverlap) {\n    if (start2 > start1) {\n      isOverlap = true;\n      isPrime = false;\n    }\n    if (end2 < end1) {\n      isOverlap = true;\n      isPrime = false;\n    }\n  }\n  return isPrime;\n};\n\nmodule.exports = overlap;\n\n},{}],4:[function(require,module,exports){\n/*\n  You are given two intervals, where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of overlap of these two \n  intervals is a prime number.\n  Example, the overlap of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the overlap is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  overlap((1, 2), (2, 3)) ==> \"NO\"\n  overlap((-1, 1), (0, 4)) ==> \"NO\"\n  overlap((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst overlap = (interval1, interval2) => {\n  let isOverlap = false;\n  let isPrime = true;\n  let start1 = interval1[0];\n  let start2 = interval2[0];\n  let end1 = interval1[1];\n  let end2 = interval2[1];\n  if (start1 > end2) {\n    isOverlap = true;\n    isPrime = false;\n  } else if (start2 > end1) {\n    isOverlap = true;\n    isPrime = false;\n  } else if (start1 < end2) {\n    isOverlap = true;\n    isPrime = false;\n  } else if (start2 < end1) {\n    isOverlap = true;\n    isPrime = false;\n  }\n  if (isOverlap) {\n    if (start2 > start1) {\n      isOverlap = true;\n      isPrime = false;\n    }\n    if (end2 < end1) {\n      isOverlap = true;\n      isPrime = false;\n    }\n  }\n  return isPrime;\n};\n\nmodule.exports = overlap;\n\n},{}],5:[function(require,module,exports){\n/*\n  You are given two intervals, where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of overlap of these two \n  intervals is a prime number.\n  Example, the overlap of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the overlap is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  overlap((1, 2), (2, 3)) ==> \"NO\"\n  overlap((-1, 1), (0, 4)) ==> \"NO\"\n  overlap((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst overlap = (interval1, interval2) => {\n  let isOverlap = false;\n  let isPrime = true;\n  let start1 = interval1[0];\n  let start2 = interval2[0];\n  let end1 = interval1[1];\n  let end2 = interval2[1];\n  if (start1 > end2) {\n    isOverlap = true;\n    isPrime = false;\n  } else if (start2 > end1) {\n    isOverlap = true;\n    isPrime = false;\n  } else if (start1 < end2) {\n    isOverlap = true;\n    isPrime = false;\n  } else if (start2 < end1) {\n    isOverlap = true;\n    isPrime = false;\n  }\n  if (isOverlap) {\n    if (start2 > start1) {\n      isOverlap = true;\n      isPrime = false;\n    }\n    if (end2 < end1) {\n      isOverlap = true;\n      isPrime = false;\n    }\n  }\n  return isPrime;\n};\n\nmodule.exports = overlap;\n\n},{}],6:[function(require,module,exports){\n/*\n  You are given two intervals, where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given interval", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "goadSigns", "gc": "<|endoftext|>/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = [1, -1, 0]\n  const signsSum = arr.reduce((acc, val) => {\n    return acc + signs[val]\n  }, 0)\n  return signsSum * signsSum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns2 = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = [1, -1, 0]\n  const signsSum = arr.reduce((acc, val) => {\n    return acc + signs[val]\n  }, 0)\n  return signsSum * signsSum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns3 = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = [1, -1, 0]\n  const signsSum = arr.reduce((acc, val) => {\n    return acc + signs[val]\n  }, 0)\n  return signsSum * signsSum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns4 = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = [1, -1, 0]\n  const signsSum = arr.reduce((acc, val) => {\n    return acc + signs[val]\n  }, 0)\n  return signsSum * signsSum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns5 = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = [1, -1, 0]\n  const signsSum = arr.reduce((acc, val) => {\n    return acc + signs[val]\n  }, 0)\n  return signsSum * signsSum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns6 = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = [1, -1, 0]\n  const signsSum = arr.reduce((acc, val) => {\n    return acc + signs[val]\n  }, 0)\n  return signsSum * signsSum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns7 = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = [1, -1, 0]\n  const signsSum = arr.reduce((acc, val) => {\n    return acc + signs[val]\n  }, 0)\n  return signsSum * signsSum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns8 = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = [1, -1, 0]\n  const signsSum = arr.reduce((acc, val) => {\n    return acc + signs[val]\n  }, 0)\n  return signsSum * signsSum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns9 = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = [1, -1, 0]\n  const signsSum = arr.reduce((acc, val) => {\n    return acc + signs[val]\n  }, 0)\n  return signsSum * signsSum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]) == null\n  */\nconst goadSigns10 = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = [1, -1, 0]\n  const signsSum = arr.reduce((acc, val) => {\n    return acc + signs[val]\n  }, 0)\n  return signsSum * signsSum\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> goadSigns([1, 2, 2, -4]) == -9\n  >>> goadSigns([0, 1]) == 0\n  >>> goadSigns([]", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minutePath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minutePath", "gc": "<|endoftext|>/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minutePath = (grid, k) => {\n  const lst_A = new Array(grid.length).fill(0);\n  const lst_B = new Array(grid.length).fill(0);\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        lst_A[count] = i;\n        lst_B[count] = j;\n        count++;\n      }\n    }\n  }\n  let ans = [];\n  for (let i = 0; i < count; i++) {\n    let an = lst_A[i];\n    for (let j = i + 1; j < count; j++) {\n      let b1 = lst_B[i];\n      let b2 = lst_B[j];\n      if (b1 < b2) {\n        ans.push(an);\n        an = b1;\n      }\n      if (b1 > b2) {\n        ans.push(an);\n        an = b2;\n      }\n    }\n  }\n  return ans;\n};\n\n/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minutePath_1 = (grid, k) => {\n  const lst_A = new Array(grid.length).fill(0);\n  const lst_B = new Array(grid.length).fill(0);\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        lst_A[count] = i;\n        lst_B[count] = j;\n        count++;\n      }\n    }\n  }\n  let ans = [];\n  for (let i = 0; i < count; i++) {\n    let an = lst_A[i];\n    for (let j = i + 1; j < count; j++) {\n      let b1 = lst_B[i];\n      let b2 = lst_B[j];\n      if (b1 < b2) {\n        ans.push(an);\n        an = b1;\n      }\n      if (b1 > b2) {\n        ans.push(an);\n        an = b2;\n      }\n    }\n  }\n  return ans;\n};\n\n/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minutePath_2 = (grid, k) => {\n  const lst_A = new Array(grid.length).fill(0);\n  const lst_B = new Array(grid.length).fill(0);\n  let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        lst_A[count] = i;\n        lst_B[count] = j;\n        count++;\n      }\n    }\n  }\n  let ans = [];\n  for (let i = 0; i < count; i++) {\n    let an = lst_A[i];\n    for (let j = i + 1; j < count; j++) {\n      let b1 = lst_B[i];\n      let b2 = lst_B[j];\n      if (b1 < b2) {\n        ans.push(an);\n        an = b1;\n      }\n      if (b1 > b2) {\n        ans.push(an);\n        an = b2;\n      }\n    }\n  }\n  return ans;\n};\n\n/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/13", "prompt": "/* Return a greatest common divisor of two integers a and b\n  >>> capitalCoarseDivisor(3, 5)\n  1\n  >>> capitalCoarseDivisor(25, 15)\n  5\n  */\nconst capitalCoarseDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "capitalCoarseDivisor", "gc": "<|endoftext|>/* Return a greatest common divisor of two integers a and b\n  >>> capitalCoarseDivisor(3, 5)\n  1\n  >>> capitalCoarseDivisor(25, 15)\n  5\n  */\nconst capitalCoarseDivisor = (a, b) => {\n  const gcd = (a, b) => {\n    if (a === 0) return b;\n    if (b === 0) return a;\n    return gcd(b, a % b);\n  };\n  return gcd(a, b);\n};\n\n// Capitalize the first letter of a string\nconst capitalizeFirstLetter = string => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n// Capitalize the first letter of a string\nconst capitalizeFirstLetterInWords = string => {\n  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n};\n\n// Capitalize the first letter of a string\nconst capitalizeFirstLetterInWordsNoCapitalize = string => {\n  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n};\n\n// Capitalize the first letter of a string\nconst capitalizeFirstLetterInWordsNoCapitalizeInWords = string => {\n  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n};\n\n// Capitalize the first letter of a string\nconst capitalizeFirstLetterInWordsNoCapitalizeInWordsNoCapitalize = string => {\n  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n};\n\n// Capitalize the first letter of a string\nconst capitalizeFirstLetterInWordsNoCapitalizeInWordsNoCapitalizeInWords = string => {\n  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n};\n\n// Capitalize the first letter of a string\nconst capitalizeFirstLetterInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalize = string => {\n  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n};\n\n// Capitalize the first letter of a string\nconst capitalizeFirstLetterInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWords = string => {\n  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n};\n\n// Capitalize the first letter of a string\nconst capitalizeFirstLetterInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalize = string => {\n  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n};\n\n// Capitalize the first letter of a string\nconst capitalizeFirstLetterInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWords = string => {\n  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n};\n\n// Capitalize the first letter of a string\nconst capitalizeFirstLetterInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalize = string => {\n  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n};\n\n// Capitalize the first letter of a string\nconst capitalizeFirstLetterInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWords = string => {\n  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n};\n\n// Capitalize the first letter of a string\nconst capitalizeFirstLetterInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalize = string => {\n  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n};\n\n// Capitalize the first letter of a string\nconst capitalizeFirstLetterInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWords = string => {\n  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n};\n\n// Capitalize the first letter of a string\nconst capitalizeFirstLetterInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalize = string => {\n  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n};\n\n// Capitalize the first letter of a string\nconst capitalizeFirstLetterInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalize = string => {\n  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n};\n\n// Capitalize the first letter of a string\nconst capitalizeFirstLetterInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalize = string => {\n  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n};\n\n// Capitalize the first letter of a string\nconst capitalizeFirstLetterInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalize = string => {\n  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n};\n\n// Capitalize the first letter of a string\nconst capitalizeFirstLetterInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalize = string => {\n  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n};\n\n// Capitalize the first letter of a string\nconst capitalizeFirstLetterInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalize = string => {\n  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n};\n\n// Capitalize the first letter of a string\nconst capitalizeFirstLetterInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalizeInWordsNoCapitalize = string => {\n  return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n};\n\n// Capitalize the first letter of a string\nconst capitalizeFirstLetterInWordsNoCapitalizeInWord", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, what people don't know is Tribonacci sequence.\n  Tribonacci sequence is defined by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "gc": "<|endoftext|>/*Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, what people don't know is Tribonacci sequence.\n  Tribonacci sequence is defined by the recurrence:\n  tri(1) = 3\n  tri(n) = 1 + n / 2, if n is even.\n  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  if (n <= 1) {\n    return [1];\n  }\n  return [tri(n - 1) + tri(n - 2) + tri(n + 1)];\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(4) = [1, 1, 2, 3, 5]\n  fib(3) = [1, 1, 2]\n  fib(2) = [1, 1, 1]\n  fib(1) =  [1, 1, 1]\n  */\nconst fib = (n) => {\n  if (n <= 1) {\n    return [1];\n  }\n  return [fib(n - 1) + fib(n - 2) + fib(n - 3)];\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(4) = [1, 1, 2, 3, 5]\n  fib(3) = [1, 1, 2]\n  fib(2) = [1, 1, 1]\n  fib(1) =  [1, 1, 1]\n  */\nconst fib2 = (n) => {\n  if (n <= 1) {\n    return [1];\n  }\n  return [fib(n - 1) + fib(n - 2) + fib(n - 3)];\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(4) = [1, 1, 2, 3, 5]\n  fib(3) = [1, 1, 2]\n  fib(2) = [1, 1, 1]\n  fib(1) =  [1, 1, 1]\n  */\nconst fib3 = (n) => {\n  if (n <= 1) {\n    return [1];\n  }\n  return [fib(n - 1) + fib(n - 2) + fib(n - 3)];\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(4) = [1, 1, 2, 3, 5]\n  fib(3) = [1, 1, 2]\n  fib(2) = [1, 1, 1]\n  fib(1) =  [1, 1, 1]\n  */\nconst fib4 = (n) => {\n  if (n <= 1) {\n    return [1];\n  }\n  return [fib(n - 1) + fib(n - 2) + fib(n - 3)];\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(4) = [1, 1, 2, 3, 5]\n  fib(3) = [1, 1, 2]\n  fib(2) = [1, 1, 1]\n  fib(1) =  [1, 1, 1]\n  */\nconst fib5 = (n) => {\n  if (n <= 1) {\n    return [1];\n  }\n  return [fib(n - 1) + fib(n - 2) + fib(n - 3)];\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(4) = [1, 1, 2, 3, 5]\n  fib(3) = [1, 1, 2]\n  fib(2) = [1, 1, 1]\n  fib(1) =  [1, 1, 1]\n  */\nconst fib6 = (n) => {\n  if (n <= 1) {\n    return [1];\n  }\n  return [fib(n - 1) + fib(n - 2) + fib(n - 3)];\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(4) = [1, 1, 2, 3, 5]\n  fib(3) = [1, 1, 2]\n  fib(2) = [1, 1, 1]\n  fib(1) =  [1, 1, 1]\n  */\nconst fib7 = (n) => {\n  if (n <= 1) {\n    return [1];\n  }\n  return [fib(n - 1) + fib(n - 2) + fib(n - 3)];\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(4) = [1, 1, 2, 3, 5]\n  fib(3) = [1, 1, 2]\n  fib(2) = [1, 1, 1]\n  fib(1) =  [1, 1, 1]\n  */\nconst fib8 = (n) => {\n  if (n <= 1) {\n    return [1];\n  }\n  return [fib(n - 1) + fib(n - 2) + fib(n - 3)];\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(4) = [1, 1, 2, 3, 5]\n  fib(3) = [1, 1, 2]\n  fib(2) = [1, 1, 1]\n  fib(1) =  [1, 1, 1]\n  */\nconst fib9 = (n) => {\n  if (n <= 1) {\n    return [1];\n  }\n  return [fib(n - 1) + fib(n - 2) + fib(n - 3)];\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(4) = [1, 1, 2, 3, 5]\n  fib(3) = [1, 1, 2]\n  fib(2) = [1, 1, 1]\n  fib(1) =  [1, 1, 1]\n  */\nconst fib10 = (n) => {\n  if (n <= 1) {\n    return [1];\n  }\n  return [fib(n - 1) + fib(n - 2) + fib(n - 3)];\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(4) = [1, 1, 2, 3, 5]\n  fib(3) = [1, 1, 2]\n  fib(2) = [1, 1, 1]\n  fib(1) =  [1, 1, 1]\n  */\nconst fib11 = (n) => {\n  if (n <= 1) {\n    return [1];\n  }\n  return [fib(n - 1) + fib(n - 2) + fib(n - 3)];\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(4) = [1, 1, 2, 3, 5]\n  fib(3) = [1, 1, 2]\n  fib(2) = [1, 1, 1]\n  fib(1) =  [1, 1, 1]\n  */\nconst fib12 = (n) => {\n  if (n <= 1) {\n    return [1];\n  }\n  return [fib(n - 1) + fib(n - 2) + fib(n - 3)];\n};\n\n/*\n  Given a non-negative ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive integer n, return the product of the odd digit.\n  Return 0 if all digit are even.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digit = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digit", "gc": "<|endoftext|>/*Given a positive integer n, return the product of the odd digit.\n  Return 0 if all digit are even.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digit = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += n % 10 * Math.pow(10, i);\n    n /= 10;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the product of the even digit.\n  Return 0 if all digit are odd.\n  For example:\n  digit(1)  == 1\n  digit(4)  == 0\n  digit(235) == 15\n  */\nconst digitEven = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += n % 10 * Math.pow(10, i);\n    n /= 10;\n  }\n  return sum % 10 === 0;\n};\n\n/*Given a positive integer n, return the product of the digit of n.\n  Return 0 if n is 0.\n  For example:\n  digit(0)  == 0\n  digit(10) == 10\n  digit(20) == 20\n  */\nconst digitDigit = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += n % 10 * Math.pow(10, i);\n    n /= 10;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the product of the digit of n.\n  Return 0 if n is 0.\n  For example:\n  digit(0)  == 0\n  digit(10) == 10\n  digit(20) == 20\n  */\nconst digitDigitEven = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += n % 10 * Math.pow(10, i);\n    n /= 10;\n  }\n  return sum % 10 === 0;\n};\n\n/*Given a positive integer n, return the product of the digit of n.\n  Return 0 if n is 0.\n  For example:\n  digit(0)  == 0\n  digit(10) == 10\n  digit(20) == 20\n  */\nconst digitDigitOdd = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += n % 10 * Math.pow(10, i);\n    n /= 10;\n  }\n  return sum % 10 === 0;\n};\n\n/*Given a positive integer n, return the product of the digit of n.\n  Return 0 if n is 0.\n  For example:\n  digit(0)  == 0\n  digit(10) == 10\n  digit(20) == 20\n  */\nconst digitOddDigit = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += n % 10 * Math.pow(10, i);\n    n /= 10;\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the product of the digit of n.\n  Return 0 if n is 0.\n  For example:\n  digit(0)  == 0\n  digit(10) == 10\n  digit(20) == 20\n  */\nconst digitOddDigitEven = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += n % 10 * Math.pow(10, i);\n    n /= 10;\n  }\n  return sum % 10 === 0;\n};\n\n/*Given a positive integer n, return the product of the digit of n.\n  Return 0 if n is 0.\n  For example:\n  digit(0)  == 0\n  digit(10) == 10\n  digit(20) == 20\n  */\nconst digitOddDigitOdd = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += n % 10 * Math.pow(10, i);\n    n /= 10;\n  }\n  return sum % 10 === 0;\n};\n\n/*Given a positive integer n, return the product of the digit of n.\n  Return 0 if n is 0.\n  For example:\n  digit(0)  == 0\n  digit(10) == 10\n  digit(20) == 20\n  */\nconst digitOddOddDigit = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += n % 10 * Math.pow(10, i);\n    n /= 10;\n  }\n  return sum % 10 === 0;\n};\n\n/*Given a positive integer n, return the product of the digit of n.\n  Return 0 if n is 0.\n  For example:\n  digit(0)  == 0\n  digit(10) == 10\n  digit(20) == 20\n  */\nconst digitOddOddDigitEven = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += n % 10 * Math.pow(10, i);\n    n /= 10;\n  }\n  return sum % 10 === 0;\n};\n\n/*Given a positive integer n, return the product of the digit of n.\n  Return 0 if n is 0.\n  For example:\n  digit(0)  == 0\n  digit(10) == 10\n  digit(20) == 20\n  */\nconst digitOddOddDigitOdd = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += n % 10 * Math.pow(10, i);\n    n /= 10;\n  }\n  return sum % 10 === 0;\n};\n\n/*Given a positive integer n, return the product of the digit of n.\n  Return 0 if n is 0.\n  For example:\n  digit(0)  == 0\n  digit(10) == 10\n  digit(20) == 20\n  */\nconst digitOddOddOddOddDigit = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += n % 10 * Math.pow(10, i);\n    n /= 10;\n  }\n  return sum % 10 === 0;\n};\n\n/*Given a positive integer n, return the product of the digit of n.\n  Return 0 if n is 0.\n  For example:\n  digit(0)  == 0\n  digit(10) == 10\n  digit(20) == 20\n  */\nconst digitOddOddOddOddDigitEven = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += n % 10 * Math.pow(10, i);\n    n /= 10;\n  }\n  return sum % 10 === 0;\n};\n\n/*Given a positive integer n, return the product of the digit of n.\n  Return 0 if n is 0.\n  For example:\n  digit(0)  == 0\n  digit(10) == 10\n  digit(20) == 20\n  */\nconst digitOddOddOddOddDigitOdd = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += n % 10 * Math.pow(10, i);\n    n /= 10;\n  }\n  return sum % 10 === 0;\n};\n\n/*Given a positive integer n, return the product of the digit of n.\n  Return 0 if n is 0.\n  For example:\n  digit(0)  == 0\n  digit(10) == 10\n  digit(20) == 20\n  */\nconst digitOddOddOddOddOddOddDigit = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += n % 10 * Math.pow(10, i);\n    n /= 10;\n  }\n  return sum % 10 === 0;\n};\n\n/*Given a positive integer n, return the product of the digit of n.\n  Return 0 if n is 0.\n  For example:\n  digit(0)  == 0\n  digit(10) == 10\n  digit(20) == 20\n  */\nconst digitOddOddOddOddOddOddOddDigitEven = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += n % 10 * Math.pow(10, i);\n    n /= 10;\n  }\n  return sum % 10 === 0;\n};\n\n/*Given a positive ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNest('[[]]') ➞ true\n  isNest('[]]]]]]][[[[[]') ➞ false\n  isNest('[][]') ➞ false\n  isNest('[]') ➞ false\n  isNest('[[][]]') ➞ true\n  isNest('[[]][[') ➞ true\n  */\nconst isNest = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNest", "gc": "<|endoftext|>/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNest('[[]]') ➞ true\n  isNest('[]]]]]]][[[[[]') ➞ false\n  isNest('[][]') ➞ false\n  isNest('[]') ➞ false\n  isNest('[[][]]') ➞ true\n  isNest('[[]][[') ➞ true\n  */\nconst isNest = (string) => {\n  const stack = []\n  let current\n  let nesting = 0\n  let last\n  let lastIsNest\n\n  while (stack.length > 0) {\n    current = stack.pop()\n    last = current.slice(-1)\n    lastIsNest = current.includes(']')\n    if (lastIsNest) {\n      nesting++\n    }\n    if (nesting === 1) {\n      if (last.includes('[') && last.includes(']')) {\n        stack.push(current.slice(0, -1))\n      }\n      break\n    }\n  }\n  return nesting === 1\n}\n\n/**\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNest('[[]]') ➞ true\n  isNest('[]]]]]]][[[[[]') ➞ false\n  isNest('[][]') ➞ false\n  isNest('[]') ➞ false\n  isNest('[[][]]') ➞ true\n  isNest('[[]][[') ➞ true\n  */\nconst isNest = (string) => {\n  const stack = []\n  let current\n  let nesting = 0\n  let last\n  let lastIsNest\n\n  while (stack.length > 0) {\n    current = stack.pop()\n    last = current.slice(-1)\n    lastIsNest = current.includes(']')\n    if (lastIsNest) {\n      nesting++\n    }\n    if (nesting === 1) {\n      if (last.includes('[')) {\n        stack.push(current.slice(0, -1))\n      }\n      break\n    }\n  }\n  return nesting === 1\n}\n\n/**\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNest('[[]]') ➞ true\n  isNest('[]]]]]]][[[[[]') ➞ false\n  isNest('[][]') ➞ false\n  isNest('[]') ➞ false\n  isNest('[[][]]') ➞ true\n  isNest('[[]][[') ➞ true\n  */\nconst isNest = (string) => {\n  const stack = []\n  let current\n  let nesting = 0\n  let last\n  let lastIsNest\n\n  while (stack.length > 0) {\n    current = stack.pop()\n    last = current.slice(-1)\n    lastIsNest = current.includes(']')\n    if (lastIsNest) {\n      nesting++\n    }\n    if (nesting === 1) {\n      if (last.includes('[')) {\n        stack.push(current.slice(0, -1))\n      }\n      break\n    }\n  }\n  return nesting === 1\n}\n\n/**\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNest('[[]]') ➞ true\n  isNest('[]]]]]]][[[[[]') ➞ false\n  isNest('[][]') ➞ false\n  isNest('[]') ➞ false\n  isNest('[[][]]') ➞ true\n  isNest('[[]][[') ➞ true\n  */\nconst isNest = (string) => {\n  const stack = []\n  let current\n  let nesting = 0\n  let last\n  let lastIsNest\n\n  while (stack.length > 0) {\n    current = stack.pop()\n    last = current.slice(-1)\n    lastIsNest = current.includes(']')\n    if (lastIsNest) {\n      nesting++\n    }\n    if (nesting === 1) {\n      if (last.includes('[')) {\n        stack.push(current.slice(0, -1))\n      }\n      break\n    }\n  }\n  return nesting === 1\n}\n\n/**\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNest('[[]]') ➞ true\n  isNest('[]]]]]]][[[[[]') ➞ false\n  isNest('[][]') ➞ false\n  isNest('[]') ➞ false\n  isNest('[[][]]') ➞ true\n  isNest('[[]][[') ➞ true\n  */\nconst isNest = (string) => {\n  const stack = []\n  let current\n  let nesting = 0\n  let last\n  let lastIsNest\n\n  while (stack.length > 0) {\n    current = stack.pop()\n    last = current.slice(-1)\n    lastIsNest = current.includes(']')\n    if (lastIsNest) {\n      nesting++\n    }\n    if (nesting === 1) {\n      if (last.includes('[')) {\n        stack.push(current.slice(0, -1))\n      }\n      break\n    }\n  }\n  return nesting === 1\n}\n\n/**\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNest('[[]]') ➞ true\n  isNest('[]]]]]]][[[[[]') ➞ false\n  isNest('[][]') ➞ false\n  isNest('[]') ➞ false\n  isNest('[[][]]') ➞ true\n  isNest('[[]][[') ➞ true\n  */\nconst isNest = (string) => {\n  const stack = []\n  let current\n  let nesting = 0\n  let last\n  let lastIsNest\n\n  while (stack.length > 0) {\n    current = stack.pop()\n    last = current.slice(-1)\n    lastIsNest = current.includes(']')\n    if (lastIsNest) {\n      nesting++\n    }\n    if (nesting === 1) {\n      if (last.includes('[')) {\n        stack.push(current.slice(0, -1))\n      }\n      break\n    }\n  }\n  return nesting === 1\n}\n\n/**\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNest('[[]]') ➞ true\n  isNest('[]]]]]]][[[[[]') ➞ false\n  isNest('[][]') ➞ false\n  isNest('[]') ➞ false\n  isNest('[[][]]') ➞ true\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/133", "prompt": "/*You are given a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst summarizeSquare = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "summarizeSquare", "gc": "<|endoftext|>/*You are given a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst summarizeSquare = (lst) => {\n  let sum = 0;\n  let square = 0;\n  let ceil = Math.ceil(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n    square += Math.pow(lst[i], 2);\n  }\n  return sum + square * ceil;\n};\n\nconst sumSquare = (lst) => {\n  let sum = 0;\n  let square = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n    square += Math.pow(lst[i], 2);\n  }\n  return sum + square;\n};\n\nconst sumSquareAndRound = (lst) => {\n  let sum = 0;\n  let square = 0;\n  let ceil = Math.ceil(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n    square += Math.pow(lst[i], 2);\n  }\n  return sum + square * ceil;\n};\n\nconst sumSquareAndRoundAndSum = (lst) => {\n  let sum = 0;\n  let square = 0;\n  let ceil = Math.ceil(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n    square += Math.pow(lst[i], 2);\n  }\n  return sum + square * ceil + sum;\n};\n\nconst sumSquareAndRoundAndSumAndSum = (lst) => {\n  let sum = 0;\n  let square = 0;\n  let ceil = Math.ceil(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n    square += Math.pow(lst[i], 2);\n  }\n  return sum + square * ceil + sum + sum;\n};\n\nconst sumSquareAndRoundAndSumAndSumAndSum = (lst) => {\n  let sum = 0;\n  let square = 0;\n  let ceil = Math.ceil(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n    square += Math.pow(lst[i], 2);\n  }\n  return sum + square * ceil + sum + sum + sum + sum;\n};\n\nconst sumSquareAndRoundAndSumAndSumAndSumAndSum = (lst) => {\n  let sum = 0;\n  let square = 0;\n  let ceil = Math.ceil(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n    square += Math.pow(lst[i], 2);\n  }\n  return sum + square * ceil + sum + sum + sum + sum + sum;\n};\n\nconst sumSquareAndRoundAndSumAndSumAndSumAndSumAndSum = (lst) => {\n  let sum = 0;\n  let square = 0;\n  let ceil = Math.ceil(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n    square += Math.pow(lst[i], 2);\n  }\n  return sum + square * ceil + sum + sum + sum + sum + sum + sum;\n};\n\nconst sumSquareAndRoundAndSumAndSumAndSumAndSumAndSumAndSum = (lst) => {\n  let sum = 0;\n  let square = 0;\n  let ceil = Math.ceil(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n    square += Math.pow(lst[i], 2);\n  }\n  return sum + square * ceil + sum + sum + sum + sum + sum + sum + sum;\n};\n\nconst sumSquareAndRoundAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSum", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/134", "prompt": "/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") ➞ false\n  determineIfConcludingCharConstituteALetter(\"apple pi e\") ➞ true\n  determineIfConcludingCharConstituteALetter(\"apple pi e \") ➞ false\n  determineIfConcludingCharConstituteALetter(\"\") ➞ false\n  */\nconst determineIfConcludingCharConstituteALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "determineIfConcludingCharConstituteALetter", "gc": "<|endoftext|>/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") ➞ false\n  determineIfConcludingCharConstituteALetter(\"apple pi e\") ➞ true\n  determineIfConcludingCharConstituteALetter(\"apple pi e \") ➞ false\n  determineIfConcludingCharConstituteALetter(\"\") ➞ false\n  */\nconst determineIfConcludingCharConstituteALetter = (txt) => {\n  let lastChar = txt[txt.length - 1];\n  let isConcludingChar = lastChar ==='' || lastChar === '-' || lastChar === '_';\n  return isConcludingChar;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") ➞ false\n  determineIfConcludingCharConstituteALetter(\"apple pi e\") ➞ true\n  determineIfConcludingCharConstituteALetter(\"apple pi e \") ➞ false\n  determineIfConcludingCharConstituteALetter(\"\") ➞ false\n  */\nconst determineIfConcludingCharConstituteALetterNum = (txt) => {\n  let lastChar = txt[txt.length - 1];\n  let isConcludingChar = lastChar ==='' || lastChar === '-' || lastChar === '_';\n  return isConcludingChar;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") ➞ false\n  determineIfConcludingCharConstituteALetter(\"apple pi e\") ➞ true\n  determineIfConcludingCharConstituteALetter(\"apple pi e \") ➞ false\n  determineIfConcludingCharConstituteALetter(\"\") ➞ false\n  */\nconst determineIfConcludingCharConstituteALetterNumAndSpace = (txt) => {\n  let lastChar = txt[txt.length - 1];\n  let isConcludingChar = lastChar ==='' || lastChar === '-' || lastChar === '_';\n  return isConcludingChar;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") ➞ false\n  determineIfConcludingCharConstituteALetter(\"apple pi e\") ➞ true\n  determineIfConcludingCharConstituteALetter(\"apple pi e \") ➞ false\n  determineIfConcludingCharConstituteALetter(\"\") ➞ false\n  */\nconst determineIfConcludingCharConstituteALetterNumAndSpaceAndSpace = (txt) => {\n  let lastChar = txt[txt.length - 1];\n  let isConcludingChar = lastChar ==='' || lastChar === '-' || lastChar === '_';\n  return isConcludingChar;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") ➞ false\n  determineIfConcludingCharConstituteALetter(\"apple pi e\") ➞ true\n  determineIfConcludingCharConstituteALetter(\"apple pi e \") ➞ false\n  determineIfConcludingCharConstituteALetter(\"\") ➞ false\n  */\nconst determineIfConcludingCharConstituteALetterNumAndSpaceAndSpace = (txt) => {\n  let lastChar = txt[txt.length - 1];\n  let isConcludingChar = lastChar ==='' || lastChar === '-' || lastChar === '_';\n  return isConcludingChar;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") ➞ false\n  determineIfConcludingCharConstituteALetter(\"apple pi e\") ➞ true\n  determineIfConcludingCharConstituteALetter(\"apple pi e \") ➞ false\n  determineIfConcludingCharConstituteALetter(\"\") ➞ false\n  */\nconst determineIfConcludingCharConstituteALetterNumAndSpaceAndSpaceAndSpace = (txt) => {\n  let lastChar = txt[txt.length - 1];\n  let isConcludingChar = lastChar ==='' || lastChar === '-' || lastChar === '_';\n  return isConcludingChar;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") ➞ false\n  determineIfConcludingCharConstituteALetter(\"apple pi e\") ➞ true\n  determineIfConcludingCharConstituteALetter(\"apple pi e \") ➞ false\n  determineIfConcludingCharConstituteALetter(\"\") ➞ false\n  */\nconst determineIfConcludingCharConstituteALetterNumAndSpaceAndSpaceAndSpace = (txt) => {\n  let lastChar = txt[txt.length - 1];\n  let isConcludingChar = lastChar ==='' || lastChar === '-' || lastChar === '_';\n  return isConcludingChar;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  determineIfConcludingCharConstituteALetter(\"apple pie\") �", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/135", "prompt": "/*Create a function which returns the largest index of an element which\n  is not greater than or equal to the element immediately preceding it. If\n  no such element exists then return -1. The given array will not contain\n  duplicate values.\n\n  Examples:\n  canStage([1,2,4,3,5]) = 3\n  canStage([1,2,3]) = -1\n  */\nconst canStage = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canStage", "gc": "<|endoftext|>/*Create a function which returns the largest index of an element which\n  is not greater than or equal to the element immediately preceding it. If\n  no such element exists then return -1. The given array will not contain\n  duplicate values.\n\n  Examples:\n  canStage([1,2,4,3,5]) = 3\n  canStage([1,2,3]) = -1\n  */\nconst canStage = (arr) => {\n  let i = arr.length - 1;\n  let j = arr.length - 1;\n  while (i >= 0 && j >= 0) {\n    if (arr[i] > arr[j]) {\n      i = i - 1;\n      j = j - 1;\n    } else {\n      i = i + 1;\n      j = j + 1;\n    }\n  }\n  return i;\n};\n\n/**\n  Given an array of integers, return a new array which contains all the\n  integers except the one at the given index. You may assume that the given\n  array contains at least one element. You may not modify the given array.\n\n  Example:\n  removeIndex([1,2,3,4,5], 2) = [1,3,4]\n  removeIndex([1,2,3,4,5], 3) = [1,2]\n  removeIndex([1,2,3,4,5], 4) = []\n  */\nconst removeIndex = (arr, index) => {\n  let newArr = [];\n  let i = arr.length - 1;\n  while (i >= 0) {\n    if (arr[i] === index) {\n      newArr.push(arr[i]);\n      i--;\n    } else {\n      i--;\n    }\n  }\n  return newArr;\n};\n\n/**\n  Given an array of integers, return a new array which contains all the\n  integers except the one at the given index. You may assume that the given\n  array contains at least one element. You may not modify the given array.\n\n  Example:\n  removeIndex([1,2,3,4,5], 2) = [1,3,4]\n  removeIndex([1,2,3,4,5], 3) = [1,2]\n  removeIndex([1,2,3,4,5], 4) = []\n  */\nconst removeIndex = (arr, index) => {\n  let newArr = [];\n  let i = arr.length - 1;\n  while (i >= 0) {\n    if (arr[i] === index) {\n      newArr.push(arr[i]);\n      i--;\n    } else {\n      i--;\n    }\n  }\n  return newArr;\n};\n\n/**\n  Given an array of integers, return a new array which contains all the\n  integers except the one at the given index. You may assume that the given\n  array contains at least one element. You may not modify the given array.\n\n  Example:\n  removeIndex([1,2,3,4,5], 2) = [1,3,4]\n  removeIndex([1,2,3,4,5], 3) = [1,2]\n  removeIndex([1,2,3,4,5], 4) = []\n  */\nconst removeIndex = (arr, index) => {\n  let newArr = [];\n  let i = arr.length - 1;\n  while (i >= 0) {\n    if (arr[i] === index) {\n      newArr.push(arr[i]);\n      i--;\n    } else {\n      i--;\n    }\n  }\n  return newArr;\n};\n\n/**\n  Given an array of integers, return a new array which contains all the\n  integers except the one at the given index. You may assume that the given\n  array contains at least one element. You may not modify the given array.\n\n  Example:\n  removeIndex([1,2,3,4,5], 2) = [1,3,4]\n  removeIndex([1,2,3,4,5], 3) = [1,2]\n  removeIndex([1,2,3,4,5], 4) = []\n  */\nconst removeIndex = (arr, index) => {\n  let newArr = [];\n  let i = arr.length - 1;\n  while (i >= 0) {\n    if (arr[i] === index) {\n      newArr.push(arr[i]);\n      i--;\n    } else {\n      i--;\n    }\n  }\n  return newArr;\n};\n\n/**\n  Given an array of integers, return a new array which contains all the\n  integers except the one at the given index. You may assume that the given\n  array contains at least one element. You may not modify the given array.\n\n  Example:\n  removeIndex([1,2,3,4,5], 2) = [1,3,4]\n  removeIndex([1,2,3,4,5], 3) = [1,2]\n  removeIndex([1,2,3,4,5], 4) = []\n  */\nconst removeIndex = (arr, index) => {\n  let newArr = [];\n  let i = arr.length - 1;\n  while (i >= 0) {\n    if (arr[i] === index) {\n      newArr.push(arr[i]);\n      i--;\n    } else {\n      i--;\n    }\n  }\n  return newArr;\n};\n\n/**\n  Given an array of integers, return a new array which contains all the\n  integers except the one at the given index. You may assume that the given\n  array contains at least one element. You may not modify the given array.\n\n  Example:\n  removeIndex([1,2,3,4,5], 2) = [1,3,4]\n  removeIndex([1,2,3,4,5], 3) = [1,2]\n  removeIndex([1,2,3,4,5], 4) = []\n  */\nconst removeIndex = (arr, index) => {\n  let newArr = [];\n  let i = arr.length - 1;\n  while (i >= 0) {\n    if (arr[i] === index) {\n      newArr.push(arr[i]);\n      i--;\n    } else {\n      i--;\n    }\n  }\n  return newArr;\n};\n\n/**\n  Given an array of integers, return a new array which contains all the\n  integers except the one at the given index. You may assume that the given\n  array contains at least one element. You may not modify the given array.\n\n  Example:\n  removeIndex([1,2,3,4,5], 2) = [1,3,4]\n  removeIndex([1,2,3,4,5], 3) = [1,2]\n  removeIndex([1,2,3,4,5], 4) = []\n  */\nconst removeIndex = (arr, index) => {\n  let newArr = [];\n  let i = arr.length - 1;\n  while (i >= 0) {\n    if (arr[i] === index) {\n      newArr.push(arr[i]);\n      i--;\n    } else {\n      i--;\n    }\n  }\n  return newArr;\n};\n\n/**\n  Given an array of integers, return a new array which contains all the\n  integers except the one at the given index. You may assume that the given\n  array contains at least one element. You may not modify the given array.\n\n  Example:\n  removeIndex([1,2,3,4,5], 2) = [1,3,4]\n  removeIndex([1,2,3,4,5], 3) = [1,2]\n  removeIndex([1,2,3,4,5], 4) = []\n  */\nconst removeIndex = (arr, index) => {\n  let newArr = [];\n  let i = arr.length - 1;\n  while (i >= 0) {\n    if (arr[i] === index) {\n      newArr.push(arr[i]);\n      i--;\n    } else {\n      i--;\n    }\n  }\n  return newArr;\n};\n\n/**\n  Given an array of integers, return a new array which contains all the\n  integers except the one at the given index. You may assume that the given\n  array contains at least one element. You may not modify the given array.\n\n  Example:\n  removeIndex([1,2,3,4,5], 2) = [1,3,4]\n  removeIndex([1,2,3,4,5], 3) = [1,2]\n  removeIndex([1,2,3,4,5], 4) = []\n  */\nconst removeIndex = (arr, index) => {\n  let newArr = [];\n  let i = arr.length - 1;\n  while (i >= 0) {\n    if (arr[i] === index) {\n      newArr.push(arr[i]);\n      i--;\n    } else {\n      i--;\n    }\n  }\n  return newArr;\n};\n\n/**\n  Given an array of integers, return a new array which contains all the\n  integers except the one at the given index. You may assume that the given\n  array contains at least one element. You may not modify the given array.\n\n  Example:\n  removeIndex([1,2,3,4,5], 2) = [1,3,4]\n  removeIndex([1,2,3,4,5], 3) = [1,2]\n  removeIndex([1,2,3,4,5], 4) = []\n  */\nconst removeIndex = (arr, index) => {\n  let newArr = [];\n  let i = arr.length - 1;\n  while (i >= 0) {\n    if (arr[i] === index) {\n      newArr.push(arr[i]);\n      i--;\n    } else {\n      i--;\n    }\n  }\n  return newArr;\n};\n\n/**\n  Given an array of integer", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 3, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/136", "prompt": "/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  bigSmallIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  bigSmallIntegers([]) == (null, null)\n  bigSmallIntegers([0]) == (null, null)\n  */\nconst bigSmallIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "bigSmallIntegers", "gc": "<|endoftext|>/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  bigSmallIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  bigSmallIntegers([]) == (null, null)\n  bigSmallIntegers([0]) == (null, null)\n  */\nconst bigSmallIntegers = (lst) => {\n  let maxNum = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  let minNum = lst.reduce((acc, val) => Math.min(acc, val), 0);\n  if (maxNum < minNum) {\n    return null;\n  }\n  return [minNum, maxNum];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of positive integers, and 'b' is the smallest\n  of negative integers in a list.\n  If there is no positive or negative integers, return them as null.\n  Examples:\n  bigSmallIntegers([2, 4, 1, 3, 5, 7]) == (2, 4)\n  bigSmallIntegers([]) == (null, null)\n  bigSmallIntegers([0]) == (null, null)\n  */\nconst bigBigIntegers = (lst) => {\n  let maxNum = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  let minNum = lst.reduce((acc, val) => Math.min(acc, val), 0);\n  if (maxNum > minNum) {\n    return null;\n  }\n  return [minNum, maxNum];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of positive integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no positive integers, return them as null.\n  Examples:\n  bigBigIntegers([2, 4, 1, 3, 5, 7]) == (2, 4)\n  bigBigIntegers([]) == (null, null)\n  bigBigIntegers([0]) == (null, null)\n  */\nconst bigPositiveIntegers = (lst) => {\n  let maxNum = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  let minNum = lst.reduce((acc, val) => Math.min(acc, val), 0);\n  if (maxNum < minNum) {\n    return null;\n  }\n  return [minNum, maxNum];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of positive integers, and 'b' is the smallest\n  of negative integers in a list.\n  If there is no negative integers, return them as null.\n  Examples:\n  bigPositiveIntegers([2, 4, 1, 3, 5, 7]) == (2, 4)\n  bigPositiveIntegers([]) == (null, null)\n  bigPositiveIntegers([0]) == (null, null)\n  */\nconst bigNegativeIntegers = (lst) => {\n  let maxNum = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  let minNum = lst.reduce((acc, val) => Math.min(acc, val), 0);\n  if (maxNum > minNum) {\n    return null;\n  }\n  return [minNum, maxNum];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of positive integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no positive integers, return them as null.\n  Examples:\n  bigPositiveIntegers([2, 4, 1, 3, 5, 7]) == (2, 4)\n  bigPositiveIntegers([]) == (null, null)\n  bigPositiveIntegers([0]) == (null, null)\n  */\nconst bigPositiveIntegersAndNegativeIntegers = (lst) => {\n  let maxNum = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  let minNum = lst.reduce((acc, val) => Math.min(acc, val), 0);\n  if (maxNum < minNum) {\n    return null;\n  }\n  return [minNum, maxNum];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of positive integers, and 'b' is the smallest\n  of negative integers in a list.\n  If there is no negative integers, return them as null.\n  Examples:\n  bigPositiveIntegersAndNegativeIntegers([2, 4, 1, 3, 5, 7]) == (2, 4)\n  bigPositiveIntegersAndNegativeIntegers([]) == (null, null)\n  bigPositiveIntegersAndNegativeIntegers([0]) == (null, null)\n  */\nconst bigPositiveIntegersAndNegativeIntegersAndPositiveIntegers = (lst) => {\n  let maxNum = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  let minNum = lst.reduce((acc, val) => Math.min(acc, val), 0);\n  if (maxNum > minNum) {\n    return null;\n  }\n  return [minNum, maxNum];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of positive integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no positive integers, return them as null.\n  Examples:\n  bigPositiveIntegersAndNegativeIntegersAndPositiveIntegers([2, 4, 1, 3, 5, 7]) == (2, 4)\n  bigPositiveIntegersAndNegativeIntegersAndPositiveIntegers([]) == (null, null)\n  bigPositiveIntegersAndNegativeIntegersAndPositiveIntegers([0]) == (null, null)\n  */\nconst bigPositiveIntegersAndNegativeIntegersAndPositiveIntegersAndNegativeIntegers = (lst) => {\n  let maxNum = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  let minNum = lst.reduce((acc, val) => Math.min(acc, val), 0);\n  if (maxNum > minNum) {\n    return null;\n  }\n  return [minNum, maxNum];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of positive integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no positive integers, return them as null.\n  Examples:\n  bigPositiveIntegersAndNegativeIntegersAndPositiveIntegersAndNegativeIntegers([2, 4, 1, 3, 5, 7]) == (2, 4)\n  bigPositiveIntegersAndNegativeIntegersAndPositiveIntegersAndNegativeIntegers([]) == (null, null)\n  bigPositiveIntegersAndNegativeIntegersAndPositiveIntegersAndNegativeIntegers([0]) == (null, null)\n  */\nconst bigPositiveIntegersAndNegativeIntegersAndPositiveIntegersAndNegativeIntegersAndPositiveIntegers = (lst) => {\n  let maxNum = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  let minNum = lst.reduce((acc, val) => Math.min(acc, val), 0);\n  if (maxNum > minNum) {\n    return null;\n  }\n  return [minNum, maxNum];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of positive integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no positive integers, return them as null.\n  Examples:\n  bigPositiveIntegersAndNegativeIntegersAndPositiveIntegersAndNegativeIntegersAndPositiveIntegers([2, 4, 1, 3, 5, 7]) == (2, 4)\n  bigPositiveIntegersAndNegativeIntegersAndPositiveIntegersAndNegativeIntegersAndPositiveIntegers([]) == (null, null)\n  bigPositiveIntegersAndNegativeIntegersAndPositiveIntegersAndNegativeIntegersAndPositiveIntegers([0]) == (null, null)\n  */\nconst bigPositiveIntegersAndNegativeIntegersAndPositiveIntegersAndNegativeIntegersAndPositiveIntegersAndNegativeIntegers = (lst) => {\n  let maxNum = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  let minNum = lst.reduce((acc, val) => Math.min(acc, val), 0);\n  if (maxNum > minNum) {\n    return null;\n  }\n  return [minNum, maxNum];\n};\n\n/* Create a function that returns a tuple (a, b), where ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be . or ,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "gc": "<|endoftext|>/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5) ➞ 2.5\n  compareOne(1, \"2,3\") ➞ \"2,3\"\n  compareOne(\"5,1\", \"6\") ➞ \"6\"\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  const isNumber = Number.isInteger(a) && Number.isInteger(b)\n  const isFloat = Number.isInteger(a) && Number.isFinite(b)\n  const isString = typeof a === \"string\" && typeof b === \"string\"\n  const isEqual = a === b\n  const isEqualNumber = isNumber && isEqual\n  const isEqualFloat = isFloat && isEqual\n  const isEqualString = isString && isEqual\n\n  if (isEqualNumber || isEqualFloat || isEqualString) {\n    return isEqual\n  }\n\n  return null\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the smaller variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5) ➞ 1.5\n  compareOne(1, \"2,3\") ➞ \"2\"\n  compareOne(\"5,1\", \"6\") ➞ \"5\"\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  const isNumber = Number.isInteger(a) && Number.isInteger(b)\n  const isFloat = Number.isInteger(a) && Number.isFinite(b)\n  const isString = typeof a === \"string\" && typeof b === \"string\"\n  const isEqual = a === b\n  const isEqualNumber = isNumber && isEqual\n  const isEqualFloat = isFloat && isEqual\n  const isEqualString = isString && isEqual\n\n  if (isEqualNumber || isEqualFloat || isEqualString) {\n    return isEqual\n  }\n\n  return null\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5) ➞ null\n  compareOne(1, \"2,3\") ➞ null\n  compareOne(\"5,1\", \"6\") ➞ null\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  const isNumber = Number.isInteger(a) && Number.isInteger(b)\n  const isFloat = Number.isInteger(a) && Number.isFinite(b)\n  const isString = typeof a === \"string\" && typeof b === \"string\"\n  const isEqual = a === b\n  const isEqualNumber = isNumber && isEqual\n  const isEqualFloat = isFloat && isEqual\n  const isEqualString = isString && isEqual\n\n  if (isEqualNumber || isEqualFloat || isEqualString) {\n    return isEqual\n  }\n\n  return null\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the smaller variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5) ➞ null\n  compareOne(1, \"2,3\") ➞ null\n  compareOne(\"5,1\", \"6\") ➞ null\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  const isNumber = Number.isInteger(a) && Number.isInteger(b)\n  const isFloat = Number.isInteger(a) && Number.isFinite(b)\n  const isString = typeof a === \"string\" && typeof b === \"string\"\n  const isEqual = a === b\n  const isEqualNumber = isNumber && isEqual\n  const isEqualFloat = isFloat && isEqual\n  const isEqualString = isString && isEqual\n\n  if (isEqualNumber || isEqualFloat || isEqualString) {\n    return isEqual\n  }\n\n  return null\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5) ➞ null\n  compareOne(1, \"2,3\") ➞ null\n  compareOne(\"5,1\", \"6\") ➞ null\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  const isNumber = Number.isInteger(a) && Number.isInteger(b)\n  const isFloat = Number.isInteger(a) && Number.isFinite(b)\n  const isString = typeof a === \"string\" && typeof b === \"string\"\n  const isEqual = a === b\n  const isEqualNumber = isNumber && isEqual\n  const isEqualFloat = isFloat && isEqual\n  const isEqualString = isString && isEqual\n\n  if (isEqualNumber || isEqualFloat || isEqualString) {\n    return isEqual\n  }\n\n  return null\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the smaller variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5) ➞ null\n  compareOne(1, \"2,3\") ➞ null\n  compareOne(\"5,1\", \"6\") ➞ null\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  const isNumber = Number.isInteger(a) && Number.isInteger(b)\n  const isFloat = Number.isInteger(a) && Number.isFinite(b)\n  const isString = typeof a === \"string\" && typeof b === \"string\"\n  const isEqual = a === b\n  const isEqualNumber = isNumber && isEqual\n  const isEqualFloat = isFloat && isEqual\n  const isEqualString = isString && isEqual\n\n  if (isEqualNumber || isEqualFloat || isEqualString) {\n    return isEqual\n  }\n\n  return null\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5) ➞ null\n  compareOne(1, \"2,3\") ➞ null\n  compareOne(\"5,1\", \"6\") ➞ null\n  compareOne(\"1\", 1) ➞ null\n  */\nconst compareOne = (a, b) => {\n  const isNumber = Number.isInteger(a) && Number.isInteger(b)\n  const isFloat = Number.isInteger(a) && Number.isFinite(b)\n  const isString = typeof a === \"string\" && typeof b === \"string\"\n  const isEqual = a === b\n  const isEqualNumber = isNumber && isEqual\n  const isEqualFloat = isFloat && isEqual\n  const isEqualString = isString && isEqual\n\n  if (isEqualNumber || isEqualFloat || isEqualString) {\n    return isEqual\n  }\n\n  return null\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isAdequateToSumEven(4) == false\n  isAdequateToSumEven(6) == false\n  isAdequateToSumEven(8) == true\n  */\nconst isAdequateToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isAdequateToSumEven", "gc": "<|endoftext|>/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isAdequateToSumEven(4) == false\n  isAdequateToSumEven(6) == false\n  isAdequateToSumEven(8) == true\n  */\nconst isAdequateToSumEven = (n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 4 === 0) return false;\n  if (n % 8 === 0) return true;\n  return false;\n};\n\n/*\n  Given a number n, return whether it is possible to write it as the sum of exactly 2 positive odd numbers\n  Example\n  isAdequateToSumOdd(4) == true\n  isAdequateToSumOdd(6) == true\n  isAdequateToSumOdd(8) == false\n  */\nconst isAdequateToSumOdd = (n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return true;\n  if (n % 4 === 0) return false;\n  if (n % 8 === 0) return false;\n  return true;\n};\n\n/*\n  Given a number n, return whether it is possible to write it as the sum of exactly 2 positive even numbers\n  Example\n  isAdequateToSumEven(4) == false\n  isAdequateToSumEven(6) == false\n  isAdequateToSumEven(8) == true\n  */\nconst isAdequateToSumEven = (n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 4 === 0) return true;\n  if (n % 8 === 0) return false;\n  return true;\n};\n\n/*\n  Given a number n, return whether it is possible to write it as the sum of exactly 4 positive odd numbers\n  Example\n  isAdequateToSumOdd(4) == false\n  isAdequateToSumOdd(6) == false\n  isAdequateToSumOdd(8) == false\n  */\nconst isAdequateToSumOdd = (n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 4 === 0) return true;\n  if (n % 8 === 0) return false;\n  return true;\n};\n\n/*\n  Given a number n, return whether it is possible to write it as the sum of exactly 4 positive even numbers\n  Example\n  isAdequateToSumEven(4) == true\n  isAdequateToSumEven(6) == true\n  isAdequateToSumEven(8) == false\n  */\nconst isAdequateToSumEven = (n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 4 === 0) return true;\n  if (n % 8 === 0) return false;\n  return true;\n};\n\n/*\n  Given a number n, return whether it is possible to write it as the sum of exactly 2 positive odd numbers\n  Example\n  isAdequateToSumOdd(4) == false\n  isAdequateToSumOdd(6) == false\n  isAdequateToSumOdd(8) == false\n  */\nconst isAdequateToSumOdd = (n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 4 === 0) return false;\n  if (n % 8 === 0) return false;\n  return true;\n};\n\n/*\n  Given a number n, return whether it is possible to write it as the sum of exactly 2 positive even numbers\n  Example\n  isAdequateToSumEven(4) == false\n  isAdequateToSumEven(6) == false\n  isAdequateToSumEven(8) == false\n  */\nconst isAdequateToSumEven = (n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 4 === 0) return false;\n  if (n % 8 === 0) return false;\n  return true;\n};\n\n/*\n  Given a number n, return whether it is possible to write it as the sum of exactly 4 positive odd numbers\n  Example\n  isAdequateToSumOdd(4) == false\n  isAdequateToSumOdd(6) == false\n  isAdequateToSumOdd(8) == false\n  */\nconst isAdequateToSumOdd = (n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 4 === 0) return true;\n  if (n % 8 === 0) return false;\n  return true;\n};\n\n/*\n  Given a number n, return whether it is possible to write it as the sum of exactly 4 positive even numbers\n  Example\n  isAdequateToSumEven(4) == false\n  isAdequateToSumEven(6) == false\n  isAdequateToSumEven(8) == false\n  */\nconst isAdequateToSumEven = (n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 4 === 0) return false;\n  if (n % 8 === 0) return false;\n  return true;\n};\n\n/*\n  Given a number n, return whether it is possible to write it as the sum of exactly 2 positive odd numbers\n  Example\n  isAdequateToSumOdd(4) == false\n  isAdequateToSumOdd(6) == false\n  isAdequateToSumOdd(8) == false\n  */\nconst isAdequateToSumOdd = (n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 4 === 0) return false;\n  if (n % 8 === 0) return false;\n  return true;\n};\n\n/*\n  Given a number n, return whether it is possible to write it as the sum of exactly 2 positive even numbers\n  Example\n  isAdequateToSumEven(4) == false\n  isAdequateToSumEven(6) == false\n  isAdequateToSumEven(8) == false\n  */\nconst isAdequateToSumEven = (n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 4 === 0) return false;\n  if (n % 8 === 0) return false;\n  return true;\n};\n\n/*\n  Given a number n, return whether it is possible to write it as the sum of exactly 4 positive odd numbers\n  Example\n  isAdequateToSumOdd(4) == false\n  isAdequateToSumOdd(6) == false\n  isAdequateToSumOdd(8) == false\n  */\nconst isAdequateToSumOdd = (n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 4 === 0) return true;\n  if (n % 8 === 0) return false;\n  return true;\n};\n\n/*\n  Given a number n, return whether it is possible to write it as the sum of exactly 4 positive even numbers\n  Example\n  isAdequateToSumEven(4) == false\n  isAdequateToSumEven(6) == false\n  isAdequateToSumEven(8) == false\n  */\nconst isAdequateToSumEven = (n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 4 === 0) return false;\n  if (n % 8 === 0) return false;\n  return true;\n};\n\n/*\n  Given a number n, return whether it is possible to write it as the sum of exactly 2 positive odd numbers\n  Example\n  isAdequateToSumOdd(4) == false\n  isA", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> extraFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst extraFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "extraFactorial", "gc": "<|endoftext|>/*The Brazilian factorial is defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> extraFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst extraFactorial = (n) => {\n  if (n <= 0) {\n    return 0;\n  }\n  return n * extraFactorial(n - 1);\n};\n\n/*\n  Given a positive integer n, return the factorial of n using recursive\n  functions. If the input n exceeds the maximum recursion depth, the function\n  will throw an error.\n  */\nconst factorial = (n) => {\n  if (n <= 0) {\n    throw new Error('The input n must be positive.');\n  }\n  return n * factorial(n - 1);\n};\n\n/*\n  Given a positive integer n, return the factorial of n using iterative\n  functions. If the input n exceeds the maximum recursion depth, the function\n  will throw an error.\n  */\nconst factorialIterative = (n) => {\n  if (n <= 0) {\n    throw new Error('The input n must be positive.');\n  }\n  let res = 1;\n  for (let i = 2; i <= n; i++) {\n    res = res * i;\n  }\n  return res;\n};\n\n/*\n  Given a positive integer n, return the factorial of n using iterative\n  functions. If the input n exceeds the maximum recursion depth, the function\n  will throw an error.\n  */\nconst factorialIterativeRecursive = (n) => {\n  if (n <= 0) {\n    throw new Error('The input n must be positive.');\n  }\n  let res = 1;\n  for (let i = 2; i <= n; i++) {\n    res = res * i;\n  }\n  return res;\n};\n\n/*\n  Given a positive integer n, return the factorial of n using iterative\n  functions. If the input n exceeds the maximum recursion depth, the function\n  will throw an error.\n  */\nconst factorialIterativeRecursiveWithMemo = (n) => {\n  if (n <= 0) {\n    throw new Error('The input n must be positive.');\n  }\n  let res = 1;\n  let memo = {};\n  for (let i = 2; i <= n; i++) {\n    res = res * i;\n  }\n  return memo[res] || (memo[res] = factorialIterativeRecursive(n - 1));\n};\n\n/*\n  Given a positive integer n, return the factorial of n using iterative\n  functions. If the input n exceeds the maximum recursion depth, the function\n  will throw an error.\n  */\nconst factorialIterativeWithMemo = (n) => {\n  if (n <= 0) {\n    throw new Error('The input n must be positive.');\n  }\n  let res = 1;\n  let memo = {};\n  for (let i = 2; i <= n; i++) {\n    res = res * i;\n  }\n  return memo[res] || (memo[res] = factorialIterativeRecursiveWithMemo(n - 1));\n};\n\n/*\n  Given a positive integer n, return the factorial of n using iterative\n  functions. If the input n exceeds the maximum recursion depth, the function\n  will throw an error.\n  */\nconst factorialIterativeWithMemoRecursive = (n) => {\n  if (n <= 0) {\n    throw new Error('The input n must be positive.');\n  }\n  let res = 1;\n  let memo = {};\n  for (let i = 2; i <= n; i++) {\n    res = res * i;\n  }\n  return memo[res] || (memo[res] = factorialIterativeRecursiveWithMemo(n - 1));\n};\n\n/*\n  Given a positive integer n, return the factorial of n using iterative\n  functions. If the input n exceeds the maximum recursion depth, the function\n  will throw an error.\n  */\nconst factorialIterativeWithMemoRecursiveWithMemo = (n) => {\n  if (n <= 0) {\n    throw new Error('The input n must be positive.');\n  }\n  let res = 1;\n  let memo = {};\n  for (let i = 2; i <= n; i++) {\n    res = res * i;\n  }\n  return memo[res] || (memo[res] = factorialIterativeRecursiveWithMemo(n - 1));\n};\n\n/*\n  Given a positive integer n, return the factorial of n using iterative\n  functions. If the input n exceeds the maximum recursion depth, the function\n  will throw an error.\n  */\nconst factorialIterativeWithMemoRecursiveWithMemoWithMemo = (n) => {\n  if (n <= 0) {\n    throw new Error('The input n must be positive.');\n  }\n  let res = 1;\n  let memo = {};\n  for (let i = 2; i <= n; i++) {\n    res = res * i;\n  }\n  return memo[res] || (memo[res] = factorialIterativeRecursiveWithMemoWithMemo(n - 1));\n};\n\n/*\n  Given a positive integer n, return the factorial of n using iterative\n  functions. If the input n exceeds the maximum recursion depth, the function\n  will throw an error.\n  */\nconst factorialIterativeWithMemoRecursiveWithMemoWithMemo = (n) => {\n  if (n <= 0) {\n    throw new Error('The input n must be positive.');\n  }\n  let res = 1;\n  let memo = {};\n  for (let i = 2; i <= n; i++) {\n    res = res * i;\n  }\n  return memo[res] || (memo[res] = factorialIterativeRecursiveWithMemoWithMemo(n - 1));\n};\n\n/*\n  Given a positive integer n, return the factorial of n using iterative\n  functions. If the input n exceeds the maximum recursion depth, the function\n  will throw an error.\n  */\nconst factorialIterativeWithMemoRecursiveWithMemoWithMemoWithMemo = (n) => {\n  if (n <= 0) {\n    throw new Error('The input n must be positive.');\n  }\n  let res = 1;\n  let memo = {};\n  for (let i = 2; i <= n; i++) {\n    res = res * i;\n  }\n  return memo[res] || (memo[res] = factorialIterativeRecursiveWithMemoWithMemo(n - 1));\n};\n\n/*\n  Given a positive integer n, return the factorial of n using iterative\n  functions. If the input n exceeds the maximum recursion depth, the function\n  will throw an error.\n  */\nconst factorialIterativeWithMemoRecursiveWithMemoWithMemoWithMemo = (n) => {\n  if (n <= 0) {\n    throw new Error('The input n must be positive.');\n  }\n  let res = 1;\n  let memo = {};\n  for (let i = 2; i <= n; i++) {\n    res = res * i;\n  }\n  return memo[res] || (memo[res] = factorialIterativeRecursiveWithMemoWithMemo(n - 1));\n};\n\n/*\n  Given a positive integer n, return the factorial of n using iterative\n  functions. If the input n exceeds the maximum recursion depth, the function\n  will throw an error.\n  */\nconst factorialIterativeWithMemoRecursiveWithMemoWithMemoWithMemoWithMemo = (n) => {\n  if (n <= 0) {\n    throw new Error('The input n must be positive.');\n  }\n  let res = 1;\n  let memo = {};\n  for (let i = 2; i <= n; i++) {\n    res = res * i;\n  }\n  return memo[res] || (memo[res] = factorialIterativeRecursiveWithMemoWithMemo(n - 1));\n};\n\n/*\n  Given a positive integer n, return the factorial of n using iterative\n  functions. If the input n exceeds the maximum recursion depth, the function\n  will throw an error.\n  */\nconst factorialIterativeWithMemoRecursiveWithMemoWithMemoWithMemoWithMemo = (n) => {\n  if (n <= 0) {\n    throw new Error('The input n must be positive.');\n  }\n  let res = 1;\n  let memo = {};\n  for (let ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/14", "prompt": "/* Return list of all prefixes from shortest to longest of the input string\n  >>> allPrefix('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefix = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefix", "gc": "<|endoftext|>/* Return list of all prefixes from shortest to longest of the input string\n  >>> allPrefix('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefix = (string) => {\n  let prefixes = [];\n  let prefix = '';\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === prefix) {\n      prefixes.push(prefix);\n      prefix = '';\n    } else {\n      prefix += string.charAt(i);\n    }\n  }\n\n  prefixes.push(prefix);\n\n  return prefixes;\n};\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffix('abc')\n  ['c', 'ba', 'ca']\n  */\nconst allSuffix = (string) => {\n  let suffixes = [];\n  let suffix = '';\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === suffix) {\n      suffixes.push(suffix);\n      suffix = '';\n    } else {\n      suffix += string.charAt(i);\n    }\n  }\n\n  suffixes.push(suffix);\n\n  return suffixes;\n};\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffix('abc')\n  ['c', 'ba', 'ca']\n  */\nconst allSuffix2 = (string) => {\n  let suffixes = [];\n  let suffix = '';\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === suffix) {\n      suffixes.push(suffix);\n      suffix = '';\n    } else {\n      suffix += string.charAt(i);\n    }\n  }\n\n  suffixes.push(suffix);\n\n  return suffixes;\n};\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffix('abc')\n  ['c', 'ba', 'ca']\n  */\nconst allSuffix3 = (string) => {\n  let suffixes = [];\n  let suffix = '';\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === suffix) {\n      suffixes.push(suffix);\n      suffix = '';\n    } else {\n      suffix += string.charAt(i);\n    }\n  }\n\n  suffixes.push(suffix);\n\n  return suffixes;\n};\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffix('abc')\n  ['c', 'ba', 'ca']\n  */\nconst allSuffix4 = (string) => {\n  let suffixes = [];\n  let suffix = '';\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === suffix) {\n      suffixes.push(suffix);\n      suffix = '';\n    } else {\n      suffix += string.charAt(i);\n    }\n  }\n\n  suffixes.push(suffix);\n\n  return suffixes;\n};\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffix('abc')\n  ['c', 'ba', 'ca']\n  */\nconst allSuffix5 = (string) => {\n  let suffixes = [];\n  let suffix = '';\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === suffix) {\n      suffixes.push(suffix);\n      suffix = '';\n    } else {\n      suffix += string.charAt(i);\n    }\n  }\n\n  suffixes.push(suffix);\n\n  return suffixes;\n};\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffix('abc')\n  ['c', 'ba', 'ca']\n  */\nconst allSuffix6 = (string) => {\n  let suffixes = [];\n  let suffix = '';\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === suffix) {\n      suffixes.push(suffix);\n      suffix = '';\n    } else {\n      suffix += string.charAt(i);\n    }\n  }\n\n  suffixes.push(suffix);\n\n  return suffixes;\n};\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffix('abc')\n  ['c', 'ba', 'ca']\n  */\nconst allSuffix7 = (string) => {\n  let suffixes = [];\n  let suffix = '';\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === suffix) {\n      suffixes.push(suffix);\n      suffix = '';\n    } else {\n      suffix += string.charAt(i);\n    }\n  }\n\n  suffixes.push(suffix);\n\n  return suffixes;\n};\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffix('abc')\n  ['c', 'ba', 'ca']\n  */\nconst allSuffix8 = (string) => {\n  let suffixes = [];\n  let suffix = '';\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === suffix) {\n      suffixes.push(suffix);\n      suffix = '';\n    } else {\n      suffix += string.charAt(i);\n    }\n  }\n\n  suffixes.push(suffix);\n\n  return suffixes;\n};\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffix('abc')\n  ['c', 'ba', 'ca']\n  */\nconst allSuffix9 = (string) => {\n  let suffixes = [];\n  let suffix = '';\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === suffix) {\n      suffixes.push(suffix);\n      suffix = '';\n    } else {\n      suffix += string.charAt(i);\n    }\n  }\n\n  suffixes.push(suffix);\n\n  return suffixes;\n};\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffix('abc')\n  ['c', 'ba', 'ca']\n  */\nconst allSuffix10 = (string) => {\n  let suffixes = [];\n  let suffix = '';\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === suffix) {\n      suffixes.push(suffix);\n      suffix = '';\n    } else {\n      suffix += string.charAt(i);\n    }\n  }\n\n  suffixes.push(suffix);\n\n  return suffixes;\n};\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffix('abc')\n  ['c', 'ba', 'ca']\n  */\nconst allSuffix11 = (string) => {\n  let suffixes = [];\n  let suffix = '';\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === suffix) {\n      suffixes.push(suffix);\n      suffix = '';\n    } else {\n      suffix += string.charAt(i);\n    }\n  }\n\n  suffixes.push(suffix);\n\n  return suffixes;\n};\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffix('abc')\n  ['c', 'ba', 'ca']\n  */\nconst allSuffix12 = (string) => {\n  let suffixes = [];\n  let suffix = '';\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === suffix) {\n      suffixes.push(suffix);\n      suffix = '';\n    } else {\n      suffix += string.charAt(i);\n    }\n  }\n\n  suffixes.push(suffix);\n\n  return suffixes;\n};\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffix('abc')\n  ['c', 'ba', 'ca']\n  */\nconst allSuffix13 = (string) => {\n  let suffixes = [];\n  let suffix = '';\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === suffix) {\n      suffixes.push(suffix);\n      suffix = '';\n    } else {\n      suffix += string.charAt(i);\n    }\n  }\n\n  suffixes.push(suffix);\n\n  return suffixes;\n};\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffix('abc')\n  ['c', 'ba', 'ca']\n  */\nconst allSuffix14 = (string) => {\n  let suffixes = [];\n  let suffix = '';\n  let i;\n\n  for (i = 0; i < string.length; i++) {\n    if (string.charAt(i) === suffix) {\n      suffixes.push(suffix);\n      suffix = '';\n    } else {\n      suffix += ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  repairSpace(\"Example\") == \"Example\"\n  repairSpace(\"Example 1\") == \"Example_1\"\n  repairSpace(\" Example 2\") == \"_Example_2\"\n  repairSpace(\" Example   3\") == \"_Example-3\"\n  */\nconst repairSpace = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "repairSpace", "gc": "<|endoftext|>/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  repairSpace(\"Example\") == \"Example\"\n  repairSpace(\"Example 1\") == \"Example_1\"\n  repairSpace(\" Example 2\") == \"_Example_2\"\n  repairSpace(\" Example   3\") == \"_Example-3\"\n  */\nconst repairSpace = (text) => {\n  return text.replace(/\\s+/g,'').trim().replace(/ +/g,'-');\n}\n\n/*\n  Given a string text, replace all consecutive spaces with - \n  \n  repairConsecutiveSpace(\"Example\") == \"Example\"\n  repairConsecutiveSpace(\"Example 1\") == \"Example_1\"\n  repairConsecutiveSpace(\" Example 2\") == \"Example-2\"\n  repairConsecutiveSpace(\" Example   3\") == \"Example-3\"\n  */\nconst repairConsecutiveSpace = (text) => {\n  return text.replace(/\\s+/g,'').trim().replace(/ +/g,'-');\n}\n\n/*\n  Given a string text, replace all consecutive spaces with - \n  \n  repairConsecutiveSpace(\"Example\") == \"Example\"\n  repairConsecutiveSpace(\"Example 1\") == \"Example_1\"\n  repairConsecutiveSpace(\" Example 2\") == \"Example-2\"\n  repairConsecutiveSpace(\" Example   3\") == \"Example-3\"\n  */\nconst repairConsecutiveSpace = (text) => {\n  return text.replace(/\\s+/g,'').trim().replace(/ +/g,'-');\n}\n\n/*\n  Given a string text, replace all consecutive spaces with - \n  \n  repairConsecutiveSpace(\"Example\") == \"Example\"\n  repairConsecutiveSpace(\"Example 1\") == \"Example_1\"\n  repairConsecutiveSpace(\" Example 2\") == \"Example-2\"\n  repairConsecutiveSpace(\" Example   3\") == \"Example-3\"\n  */\nconst repairConsecutiveSpace = (text) => {\n  return text.replace(/\\s+/g,'').trim().replace(/ +/g,'-');\n}\n\n/*\n  Given a string text, replace all consecutive spaces with - \n  \n  repairConsecutiveSpace(\"Example\") == \"Example\"\n  repairConsecutiveSpace(\"Example 1\") == \"Example_1\"\n  repairConsecutiveSpace(\" Example 2\") == \"Example-2\"\n  repairConsecutiveSpace(\" Example   3\") == \"Example-3\"\n  */\nconst repairConsecutiveSpace = (text) => {\n  return text.replace(/\\s+/g,'').trim().replace(/ +/g,'-');\n}\n\n/*\n  Given a string text, replace all consecutive spaces with - \n  \n  repairConsecutiveSpace(\"Example\") == \"Example\"\n  repairConsecutiveSpace(\"Example 1\") == \"Example_1\"\n  repairConsecutiveSpace(\" Example 2\") == \"Example-2\"\n  repairConsecutiveSpace(\" Example   3\") == \"Example-3\"\n  */\nconst repairConsecutiveSpace = (text) => {\n  return text.replace(/\\s+/g,'').trim().replace(/ +/g,'-');\n}\n\n/*\n  Given a string text, replace all consecutive spaces with - \n  \n  repairConsecutiveSpace(\"Example\") == \"Example\"\n  repairConsecutiveSpace(\"Example 1\") == \"Example_1\"\n  repairConsecutiveSpace(\" Example 2\") == \"Example-2\"\n  repairConsecutiveSpace(\" Example   3\") == \"Example-3\"\n  */\nconst repairConsecutiveSpace = (text) => {\n  return text.replace(/\\s+/g,'').trim().replace(/ +/g,'-');\n}\n\n/*\n  Given a string text, replace all consecutive spaces with - \n  \n  repairConsecutiveSpace(\"Example\") == \"Example\"\n  repairConsecutiveSpace(\"Example 1\") == \"Example_1\"\n  repairConsecutiveSpace(\" Example 2\") == \"Example-2\"\n  repairConsecutiveSpace(\" Example   3\") == \"Example-3\"\n  */\nconst repairConsecutiveSpace = (text) => {\n  return text.replace(/\\s+/g,'').trim().replace(/ +/g,'-');\n}\n\n/*\n  Given a string text, replace all consecutive spaces with - \n  \n  repairConsecutiveSpace(\"Example\") == \"Example\"\n  repairConsecutiveSpace(\"Example 1\") == \"Example_1\"\n  repairConsecutiveSpace(\" Example 2\") == \"Example-2\"\n  repairConsecutiveSpace(\" Example   3\") == \"Example-3\"\n  */\nconst repairConsecutiveSpace = (text) => {\n  return text.replace(/\\s+/g,'').trim().replace(/ +/g,'-');\n}\n\n/*\n  Given a string text, replace all consecutive spaces with - \n  \n  repairConsecutiveSpace(\"Example\") == \"Example\"\n  repairConsecutiveSpace(\"Example 1\") == \"Example_1\"\n  repairConsecutiveSpace(\" Example 2\") == \"Example-2\"\n  repairConsecutiveSpace(\" Example   3\") == \"Example-3\"\n  */\nconst repairConsecutiveSpace = (text) => {\n  return text.replace(/\\s+/g,'').trim().replace(/ +/g,'-');\n}\n\n/*\n  Given a string text, replace all consecutive spaces with - \n  \n  repairConsecutiveSpace(\"Example\") == \"Example\"\n  repairConsecutiveSpace(\"Example 1\") == \"Example_1\"\n  repairConsecutiveSpace(\" Example 2\") == \"Example-2\"\n  repairConsecutiveSpace(\" Example   3\") == \"Example-3\"\n  */\nconst repairConsecutiveSpace = (text) => {\n  return text.replace(/\\s+/g,'').trim().replace(/ +/g,'-');\n}\n\n/*\n  Given a string text, replace all consecutive spaces with - \n  \n  repairConsecutiveSpace(\"Example\") == \"Example\"\n  repairConsecutiveSpace(\"Example 1\") == \"Example_1\"\n  repairConsecutiveSpace(\" Example 2\") == \"Example-2\"\n  repairConsecutiveSpace(\" Example   3\") == \"Example-3\"\n  */\nconst repairConsecutiveSpace = (text) => {\n  return text.replace(/\\s+/g,'').trim().replace(/ +/g,'-');\n}\n\n/*\n  Given a string text, replace all consecutive spaces with - \n  \n  repairConsecutiveSpace(\"Example\") == \"Example\"\n  repairConsecutiveSpace(\"Example 1\") == \"Example_1\"\n  repairConsecutiveSpace(\" Example 2\") == \"Example-2\"\n  repairConsecutiveSpace(\" Example   3\") == \"Example-3\"\n  */\nconst repairConsecutiveSpace = (text) => {\n  return text.replace(/\\s+/g,'').trim().replace(/ +/g,'-');\n}\n\n/*\n  Given a string text, replace all consecutive spaces with - \n  \n  repairConsecutiveSpace(\"Example\") == \"Example\"\n  repairConsecutiveSpace(\"Example 1\") == \"Example_1\"\n  repairConsecutiveSpace(\" Example 2\") == \"Example-2\"\n  repairConsecutiveSpace(\" Example   3\") == \"Example-3\"\n  */\nconst re", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "gc": "<|endoftext|>/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const file_name_without_extension = file_name.split(\".\")[0];\n  const file_name_without_extension_length = file_name_without_extension.length;\n  const file_name_without_extension_letter = file_name_without_extension.charAt(0).toLowerCase();\n  const file_name_without_extension_letter_length = file_name_without_extension_letter.length;\n  const file_name_without_extension_letter_position = file_name_without_extension_letter.charCodeAt(0);\n  const file_name_without_extension_letter_position_in_latin_alphabet = \n    file_name_without_extension_letter_position - 65;\n  const file_name_without_extension_letter_position_in_latin_alphabet_length = \n    file_name_without_extension_letter_position_in_latin_alphabet.length;\n  const file_name_without_extension_letter_position_in_latin_alphabet_position = \n    file_name_without_extension_letter_position_in_latin_alphabet.charCodeAt(0);\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_length = \n    file_name_without_extension_letter_position_in_latin_alphabet_position.length;\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position = \n    file_name_without_extension_letter_position_in_latin_alphabet_position.charCodeAt(0);\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_length = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position.length;\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position.charCodeAt(0);\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_length = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position.length;\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position.charCodeAt(0);\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_length = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position.length;\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position.charCodeAt(0);\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_length = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position.length;\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position.charCodeAt(0);\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_length = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position.length;\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position.charCodeAt(0);\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_length = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position.length;\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position.charCodeAt(0);\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_length = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position.length;\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position.charCodeAt(0);\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_length = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position.length;\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position.charCodeAt(0);\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position_length = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position_position.length;\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position.charCodeAt(0);\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position_length = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position_position.length;\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position_position.charCodeAt(0);\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position_length = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position_position.length;\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position_position.charCodeAt(0);\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position_position_length = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position_position.length;\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position_position.charCodeAt(0);\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position_length = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position_position.length;\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position_position.charCodeAt(0);\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position_length = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position_position_position.length;\n  const file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position_position = \n    file_name_without_extension_letter_position_in_latin_alphabet_position_position_position_position_position_position_", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeSquare = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "summarizeSquare", "gc": "<|endoftext|>/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a \n  multiple of 3 and will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeCube = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeCubeAndSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeCubeAndSquareAndSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeCubeAndSquareAndSquareAndSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeCubeAndSquareAndSquareAndSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeCubeAndSquareAndSquareAndSquareAndSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst summarizeCubeAndSquareAndSquareAndSquareAndSquareAndSquare = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will square it if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst bibleInPrisonTerm = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "bibleInPrisonTerm", "gc": "<|endoftext|>/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst bibleInPrisonTerm = (sentence) => {\n  const words = sentence.split(\" \");\n  const result = [];\n  let currentWord = \"\";\n  let currentLength = 0;\n  let currentPrime = 1;\n  let currentPrimeLength = 1;\n  let currentPrimeLengthIndex = 0;\n  let currentPrimeLengthIndex2 = 0;\n  let currentPrimeLengthIndex3 = 0;\n  let currentPrimeLengthIndex4 = 0;\n  let currentPrimeLengthIndex5 = 0;\n  let currentPrimeLengthIndex6 = 0;\n  let currentPrimeLengthIndex7 = 0;\n  let currentPrimeLengthIndex8 = 0;\n  let currentPrimeLengthIndex9 = 0;\n  let currentPrimeLengthIndex10 = 0;\n  let currentPrimeLengthIndex11 = 0;\n  let currentPrimeLengthIndex12 = 0;\n  let currentPrimeLengthIndex13 = 0;\n  let currentPrimeLengthIndex14 = 0;\n  let currentPrimeLengthIndex15 = 0;\n  let currentPrimeLengthIndex16 = 0;\n  let currentPrimeLengthIndex17 = 0;\n  let currentPrimeLengthIndex18 = 0;\n  let currentPrimeLengthIndex19 = 0;\n  let currentPrimeLengthIndex20 = 0;\n  let currentPrimeLengthIndex21 = 0;\n  let currentPrimeLengthIndex22 = 0;\n  let currentPrimeLengthIndex23 = 0;\n  let currentPrimeLengthIndex24 = 0;\n  let currentPrimeLengthIndex25 = 0;\n  let currentPrimeLengthIndex26 = 0;\n  let currentPrimeLengthIndex27 = 0;\n  let currentPrimeLengthIndex28 = 0;\n  let currentPrimeLengthIndex29 = 0;\n  let currentPrimeLengthIndex30 = 0;\n  let currentPrimeLengthIndex31 = 0;\n  let currentPrimeLengthIndex32 = 0;\n  let currentPrimeLengthIndex33 = 0;\n  let currentPrimeLengthIndex34 = 0;\n  let currentPrimeLengthIndex35 = 0;\n  let currentPrimeLengthIndex36 = 0;\n  let currentPrimeLengthIndex37 = 0;\n  let currentPrimeLengthIndex38 = 0;\n  let currentPrimeLengthIndex39 = 0;\n  let currentPrimeLengthIndex40 = 0;\n  let currentPrimeLengthIndex41 = 0;\n  let currentPrimeLengthIndex42 = 0;\n  let currentPrimeLengthIndex43 = 0;\n  let currentPrimeLengthIndex44 = 0;\n  let currentPrimeLengthIndex45 = 0;\n  let currentPrimeLengthIndex46 = 0;\n  let currentPrimeLengthIndex47 = 0;\n  let currentPrimeLengthIndex48 = 0;\n  let currentPrimeLengthIndex49 = 0;\n  let currentPrimeLengthIndex50 = 0;\n  let currentPrimeLengthIndex51 = 0;\n  let currentPrimeLengthIndex52 = 0;\n  let currentPrimeLengthIndex53 = 0;\n  let currentPrimeLengthIndex54 = 0;\n  let currentPrimeLengthIndex55 = 0;\n  let currentPrimeLengthIndex56 = 0;\n  let currentPrimeLengthIndex57 = 0;\n  let currentPrimeLengthIndex58 = 0;\n  let currentPrimeLengthIndex59 = 0;\n  let currentPrimeLengthIndex60 = 0;\n  let currentPrimeLengthIndex61 = 0;\n  let currentPrimeLengthIndex62 = 0;\n  let currentPrimeLengthIndex63 = 0;\n  let currentPrimeLengthIndex64 = 0;\n  let currentPrimeLengthIndex65 = 0;\n  let currentPrimeLengthIndex66 = 0;\n  let currentPrimeLengthIndex67 = 0;\n  let currentPrimeLengthIndex68 = 0;\n  let currentPrimeLengthIndex69 = 0;\n  let currentPrimeLengthIndex70 = 0;\n  let currentPrimeLengthIndex71 = 0;\n  let currentPrimeLengthIndex72 = 0;\n  let currentPrimeLengthIndex73 = 0;\n  let currentPrimeLengthIndex74 = 0;\n  let currentPrimeLengthIndex75 = 0;\n  let currentPrimeLengthIndex76 = 0;\n  let currentPrimeLengthIndex77 = 0;\n  let currentPrimeLengthIndex78 = 0;\n  let currentPrimeLengthIndex79 = 0;\n  let currentPrimeLengthIndex80 = 0;\n  let currentPrimeLengthIndex81 = 0;\n  let currentPrimeLengthIndex82 = 0;\n  let currentPrimeLengthIndex83 = 0;\n  let currentPrimeLengthIndex84 = 0;\n  let currentPrimeLengthIndex85 = 0;\n  let currentPrimeLengthIndex86 = 0;\n  let currentPrimeLengthIndex87 = 0;\n  let currentPrimeLengthIndex88 = 0;\n  let currentPrimeLengthIndex89 = 0;\n  let currentPrimeLengthIndex90 = 0;\n  let currentPrimeLengthIndex91 = 0;\n  let currentPrimeLengthIndex92 = 0;\n  let currentPrimeLengthIndex93 = 0;\n  let currentPrimeLengthIndex94 = 0;\n  let currentPrimeLengthIndex95 = 0;\n  let currentPrimeLengthIndex96 = 0;\n  let currentPrimeLengthIndex97 = 0;\n  let currentPrimeLengthIndex98 = 0;\n  let currentPrimeLengthIndex99 = 0;\n  let currentPrimeLengthIndex100 = 0;\n  let currentPrimeLengthIndex101 = 0;\n  let currentPrimeLengthIndex102 = 0;\n  let currentPrimeLengthIndex103 = 0;\n  let currentPrimeLengthIndex104 = 0;\n  let currentPrimeLengthIndex105 = 0;\n  let currentPrimeLengthIndex106 = 0;\n  let currentPrimeLengthIndex107 = 0;\n  let currentPrimeLengthIndex108 = 0;\n  let currentPrimeLengthIndex109 = 0;\n  let currentPrimeLengthIndex110 = 0;\n  let currentPrimeLengthIndex111 = 0;\n  let currentPrimeLengthIndex112 = 0;\n  let currentPrimeLengthIndex113 = 0;\n  let currentPrimeLengthIndex114 = 0;\n  let currentPrimeLengthIndex115 = 0;\n  let currentPrimeLengthIndex116 = 0;\n  let currentPrimeLengthIndex117 = 0;\n  let currentPrimeLengthIndex118 = 0;\n  let currentPrimeLengthIndex119 = 0;\n  let currentPrimeLengthIndex120 = 0;\n  let currentPrimeLengthIndex121 = 0;\n  let currentPrimeLengthIndex122 = 0;\n  let currentPrimeLengthIndex123 = 0;\n  let currentPrimeLengthIndex124 = 0;\n  let currentPrimeLengthIndex125 = 0;\n  let currentPrimeLengthIndex126 = 0;\n  let currentPrimeLengthIndex127 = 0;\n  let currentPrimeLengthIndex128 = 0;\n  let currentPrimeLengthIndex129 = 0;\n  let currentPrimeLengthIndex130 = 0;\n  let currentPrimeLengthIndex131 = 0;\n  let currentPrimeLengthIndex132 = 0;\n  let currentPrimeLengthIndex133 = 0;\n  let currentPrimeLengthIndex134 = 0;\n  let currentPrimeLengthIndex135 = 0;\n  let currentPrimeLengthIndex136 = 0;\n  let currentPrimeLengthIndex137 = 0;\n  let currentPrimeLengthIndex138 = 0;\n  let currentPrimeLengthIndex139 = 0;\n  let currentPrimeLengthIndex140 = 0;\n  let currentPrimeLengthIndex141 = 0;\n  let currentPrimeLengthIndex142 = 0;\n  let currentPrimeLengthIndex143 = 0;\n  let currentPrimeLengthIndex144 = 0;\n  let currentPrimeLengthIndex145 = 0;\n  let currentPrimeLengthIndex146 = 0;\n  let currentPrimeLengthIndex147 = 0;\n  let currentPrimeLengthIndex148 = 0;\n  let currentPrimeLengthIndex149 = 0;\n  let currentPrimeLengthIndex150 = 0;\n  let currentPrimeLengthIndex151 = 0;\n  let currentPrimeLengthIndex152 = 0;\n  let currentPrimeLengthIndex15", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "gc": "<|endoftext|>/*Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // x is numerator\n  // n is denominator\n  // return true if x is equal to n\n  // return false if x is not equal to n\n  // return false if x is greater than n\n  // return false if x is less than n\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false if x is equal to 0\n  // return false if x is equal to 1\n  // return false if x is greater than 1\n  // return false if x is less than 1\n  // return false ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPoint([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> holyOrderByPoint([]) == []\n  */\nconst holyOrderByPoint = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "holyOrderByPoint", "gc": "<|endoftext|>/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPoint([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> holyOrderByPoint([]) == []\n  */\nconst holyOrderByPoint = (nums) => {\n  const sums = nums.reduce((acc, cur) => {\n    const digit = cur.toString().split('').reduce((acc, digit) => {\n      return acc + parseInt(digit, 10);\n    }, 0);\n    return acc + digit;\n  }, 0);\n  return nums.sort((a, b) => {\n    return sums - a - b;\n  });\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in descending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPoint([-1, -11, -11, 11, -12]) == [11, -11, 1, -11, -12]\n  >>> holyOrderByPoint([]) == []\n  */\nconst holyOrderByPointDesc = (nums) => {\n  const sums = nums.reduce((acc, cur) => {\n    const digit = cur.toString().split('').reduce((acc, digit) => {\n      return acc + parseInt(digit, 10);\n    }, 0);\n    return acc + digit;\n  }, 0);\n  return nums.sort((a, b) => {\n    return sums - a - b;\n  });\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointDesc([1, 11, -1, -11, -12]) == [-11, -11, 1, -12, 11]\n  >>> holyOrderByPointDesc([]) == []\n  */\nconst holyOrderByPointDescr = (nums) => {\n  const sums = nums.reduce((acc, cur) => {\n    const digit = cur.toString().split('').reduce((acc, digit) => {\n      return acc + parseInt(digit, 10);\n    }, 0);\n    return acc + digit;\n  }, 0);\n  return nums.sort((a, b) => {\n    return sums - a - b;\n  });\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointDescr([1, 11, -1, -11, -12]) == [-11, -11, 1, -12, 11]\n  >>> holyOrderByPointDescr([]) == []\n  */\nconst holyOrderByPointDescrr = holyOrderByPointDesc;\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointDescr([-1, -11, -11, 11, -12]) == [11, -11, 1, -11, -12]\n  >>> holyOrderByPointDescr([]) == []\n  */\nconst holyOrderByPointDescrr = holyOrderByPointDesc;\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointDescr([-1, -11, -11, 11, -12]) == [11, -11, 1, -11, -12]\n  >>> holyOrderByPointDescr([]) == []\n  */\nconst holyOrderByPointDescrr = holyOrderByPointDesc;\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointDescr([-1, -11, -11, 11, -12]) == [11, -11, 1, -11, -12]\n  >>> holyOrderByPointDescr([]) == []\n  */\nconst holyOrderByPointDescrr = holyOrderByPointDesc;\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointDescr([-1, -11, -11, 11, -12]) == [11, -11, 1, -11, -12]\n  >>> holyOrderByPointDescr([]) == []\n  */\nconst holyOrderByPointDescrr = holyOrderByPointDesc;\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointDescr([-1, -11, -11, 11, -12]) == [11, -11, 1, -11, -12]\n  >>> holyOrderByPointDescr([]) == []\n  */\nconst holyOrderByPointDescrr = holyOrderByPointDesc;\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointDescr([-1, -11, -11, 11, -12]) == [11, -11, 1, -11, -12]\n  >>> holyOrderByPointDescr([]) == []\n  */\nconst holyOrderByPointDescrr = holyOrderByPointDesc;\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointDescr([-1, -11, -11, 11, -12]) == [11, -11, 1, -11, -12]\n  >>> holyOrderByPointDescr([]) == []\n  */\nconst holyOrderByPointDescrr = holyOrderByPointDesc;\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointDescr([-1, -11, -11, 11, -12]) == [11, -11, 1, -11, -12]\n  >>> holyOrderByPointDescr([]) == []\n  */\nconst holyOrderByPointDescrr = holyOrderByPointDesc;\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> holyOrderByPointDescr([-1, -11, -11, 11, -12]) == [11, -11, 1, -11, -12", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/146", "prompt": "/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "extraFilter", "gc": "<|endoftext|>/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilter = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 0 && num.toString().length === 1) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are even (1, 3, 5, 7, 9).\n  For example:\n  extraFilter([15, -73, 14, -15]) => 0 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 1\n  */\nconst extraFilterEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 0 && num.toString().length === 1) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are divisible by 3.\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilterDivisible = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 3 === 0 && num.toString().length === 1) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are divisible by 3.\n  For example:\n  extraFilter([15, -73, 14, -15]) => 0 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 1\n  */\nconst extraFilterDivisibleEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 3 === 0 && num.toString().length === 1) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are divisible by 3.\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilterDivisibleDivisible = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 3 === 0 && num.toString().length === 1) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are divisible by 3.\n  For example:\n  extraFilter([15, -73, 14, -15]) => 0 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 1\n  */\nconst extraFilterDivisibleDivisibleEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 3 === 0 && num.toString().length === 1) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are divisible by 3.\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilterDivisibleDivisibleDivisible = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 3 === 0 && num.toString().length === 1) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are divisible by 3.\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilterDivisibleDivisibleDivisibleEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 3 === 0 && num.toString().length === 1) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are divisible by 3.\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilterDivisibleDivisibleDivisibleDivisible = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 3 === 0 && num.toString().length === 1) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are divisible by 3.\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilterDivisibleDivisibleDivisibleDivisibleEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 3 === 0 && num.toString().length === 1) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are divisible by 3.\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilterDivisibleDivisibleDivisibleDivisibleDivisible = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 3 === 0 && num.toString().length === 1) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are divisible by 3.\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilterDivisibleDivisibleDivisibleDivisibleDivisibleEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 3 === 0 && num.toString().length === 1) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are divisible by 3.\n  For example:\n  extraFilter([15, -73, 14, -15]) => 1 \n  extraFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst extraFilterDivisibleDivisibleDivisibleDivisibleDivisibleDivisible = (nums) => {\n  let count = 0;\n  nums.forEach", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "catchMaxTriples", "gc": "<|endoftext|>/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 3\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples2 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 4\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples3 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 5\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples4 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 6\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples5 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 7\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples6 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 8\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples7 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 9\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples8 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 10\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst catchMaxTriples9 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 11\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "gc": "<|endoftext|>/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planet1Orbit = orbits[planet1]\n  const planet2Orbit = orbits[planet2]\n  const planet1OrbitDistance = planet1Orbit.distance\n  const planet2OrbitDistance = planet2Orbit.distance\n  const planet1OrbitOrbits = planet1Orbit.orbits\n  const planet2OrbitOrbits = planet2Orbit.orbits\n  const planet1OrbitOrbitDistances = planet1OrbitOrbits.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbits.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.filter(orbitDistance => orbitDistance < planet1OrbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.filter(orbitDistance => orbitDistance < planet2OrbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.filter(orbitDistance => orbitDistance > planet1OrbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.filter(orbitDistance => orbitDistance > planet2OrbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet2OrbitOrbitDistances = planet2OrbitOrbitDistances.map(orbitDistance => orbitDistance)\n  const planet1OrbitOrbitDistances = planet1Orbit", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst screenTiltSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "screenTiltSum", "gc": "<|endoftext|>/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst screenTiltSum = (lst) => {\n  let result = [];\n  let word;\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    word = lst[i];\n    if (word.length % 2 === 0) {\n      sum += word.length;\n    } else {\n      sum += word.length;\n    }\n  }\n  result.push(sum);\n  return result;\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst screenTiltSum2 = (lst, word) => {\n  let result = [];\n  let word;\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    word = lst[i];\n    if (word.length % 2 === 0) {\n      sum += word.length;\n    } else {\n      sum += word.length;\n    }\n  }\n  result.push(sum);\n  return result;\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst screenTiltSum3 = (lst, word) => {\n  let result = [];\n  let word;\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    word = lst[i];\n    if (word.length % 2 === 0) {\n      sum += word.length;\n    } else {\n      sum += word.length;\n    }\n  }\n  result.push(sum);\n  return result;\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst screenTiltSum4 = (lst, word) => {\n  let result = [];\n  let word;\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    word = lst[i];\n    if (word.length % 2 === 0) {\n      sum += word.length;\n    } else {\n      sum += word.length;\n    }\n  }\n  result.push(sum);\n  return result;\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst screenTiltSum5 = (lst, word) => {\n  let result = [];\n  let word;\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    word = lst[i];\n    if (word.length % 2 === 0) {\n      sum += word.length;\n    } else {\n      sum += word.length;\n    }\n  }\n  result.push(sum);\n  return result;\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst screenTiltSum6 = (lst, word) => {\n  let result = [];\n  let word;\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    word = lst[i];\n    if (word.length % 2 === 0) {\n      sum += word.length;\n    } else {\n      sum += word.length;\n    }\n  }\n  result.push(sum);\n  return result;\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst screenTiltSum7 = (lst, word) => {\n  let result = [];\n  let word;\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    word = lst[i];\n    if (word.length % 2 === 0) {\n      sum += word.length;\n    } else {\n      sum += word.length;\n    }\n  }\n  result.push(sum);\n  return result;\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  delete", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/15", "prompt": "/* Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> bowedStringedInstrumentSuccession(0)\n  '0'\n  >>> bowedStringedInstrumentSuccession(5)\n  '0 1 2 3 4 5'\n  */\nconst bowedStringedInstrumentSuccession = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "bowedStringedInstrumentSuccession", "gc": "<|endoftext|>/* Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> bowedStringedInstrumentSuccession(0)\n  '0'\n  >>> bowedStringedInstrumentSuccession(5)\n  '0 1 2 3 4 5'\n  */\nconst bowedStringedInstrumentSuccession = (n) => {\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(`${i} ${i} ${i} ${i} ${i} ${i}`);\n  }\n  return result.join(' ');\n};\n\n/* Return a string containing space-delimited numbers starting from n inclusive.\n  >>> bowedStringedInstrumentSuccession(10)\n  '0 1 2 3 4 5 6 7 8 9 10'\n  */\nconst bowedStringedInstrumentFailing = (n) => {\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(`${i} ${i} ${i} ${i} ${i} ${i} ${i} ${i} ${i} ${i}`);\n  }\n  return result.join(' ');\n};\n\n/* Return a string containing space-delimited numbers starting from n inclusive.\n  >>> bowedStringedInstrumentFailing(10)\n  '0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/150", "prompt": "/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrYttrium", "gc": "<|endoftext|>/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y\n  }\n  if (n % 2 === 0) {\n    return x\n  }\n  return y\n}\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y\n  }\n  if (n % 2 === 0) {\n    return x\n  }\n  return y\n}\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y\n  }\n  if (n % 2 === 0) {\n    return x\n  }\n  return y\n}\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y\n  }\n  if (n % 2 === 0) {\n    return x\n  }\n  return y\n}\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y\n  }\n  if (n % 2 === 0) {\n    return x\n  }\n  return y\n}\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y\n  }\n  if (n % 2 === 0) {\n    return x\n  }\n  return y\n}\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y\n  }\n  if (n % 2 === 0) {\n    return x\n  }\n  return y\n}\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y\n  }\n  if (n % 2 === 0) {\n    return x\n  }\n  return y\n}\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y\n  }\n  if (n % 2 === 0) {\n    return x\n  }\n  return y\n}\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y\n  }\n  if (n % 2 === 0) {\n    return x\n  }\n  return y\n}\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y\n  }\n  if (n % 2 === 0) {\n    return x\n  }\n  return y\n}\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y\n  }\n  if (n % 2 === 0) {\n    return x\n  }\n  return y\n}\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y\n  }\n  if (n % 2 === 0) {\n    return x\n  }\n  return y\n}\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y\n  }\n  if (n % 2 === 0) {\n    return x\n  }\n  return y\n}\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, 34, 12) == 34\n  for xOrYttrium(15, 8, 5) == 5\n  \n  */\nconst xOrYttrium = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y\n  }\n  if (n % 2 === 0) {\n    return x\n  }\n  return y\n}\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrYttrium(7, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDeviation([-1, -2, 0]) == 0\n  doubleTheDeviation([9, -2]) == 81\n  doubleTheDeviation([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDeviation", "gc": "<|endoftext|>/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDeviation([-1, -2, 0]) == 0\n  doubleTheDeviation([9, -2]) == 81\n  doubleTheDeviation([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are even. Ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 10\n  doubleTheDeviation([-1, -2, 0]) == -1\n  doubleTheDeviation([9, -2]) == 9\n  doubleTheDeviation([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 3. Ignore numbers that are negative or not integers.\n  doubleTheDeviation([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 10\n  doubleTheDeviation([-1, -2, 0]) == -1\n  doubleTheDeviation([9, -2]) == 9\n  doubleTheDeviation([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 5. If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 5 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 7. If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 7 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 9. If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 9 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 11. If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 11 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 13. If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 13 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 15. If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 15 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 17. If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 17 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 19. If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 19 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 21. If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 21 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 23. If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 23 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 25. If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 25 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 27. If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 27 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 29. If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 29 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 31. If the input list is empty, return 0.\n  */\nconst doubleTheDeviation = (lst) => {\n  if (lst.length === 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 31 === 0) {\n      sum += lst", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "gc": "<|endoftext|>/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const [gameScore, gameGuess] = game;\n  const [guessScore, guessGuess] = guess;\n  const [gameScoreDiff, gameGuessDiff] = gameGuess - guessGuess;\n  const [guessScoreDiff, guessGuessDiff] = guessGuess - guessGuess;\n  const [gameScoreDiffAbs, gameGuessDiffAbs] = Math.abs(gameScoreDiff);\n  const [guessScoreDiffAbs, guessGuessDiffAbs] = Math.abs(guessScoreDiff);\n  const [gameScoreDiffAbsAbs, gameGuessDiffAbsAbs] = Math.abs(gameScoreDiffAbs);\n  const [guessScoreDiffAbsAbs, guessGuessDiffAbsAbs] = Math.abs(guessScoreDiffAbs);\n  const [gameScoreDiffAbsAbsAbsAbs, gameGuessDiffAbsAbsAbs] = Math.abs(gameScoreDiffAbsAbs);\n  const [guessScoreDiffAbsAbsAbsAbsAbs, guessGuessDiffAbsAbsAbs] = Math.abs(guessScoreDiffAbsAbsAbsAbs);\n  const [gameScoreDiffAbsAbsAbsAbsAbsAbsAbs, gameGuessDiffAbsAbsAbsAbsAbs] = Math.abs(gameScoreDiffAbsAbsAbsAbsAbs);\n  const [guessScoreDiffAbsAbsAbsAbsAbsAbsAbsAbsAbs, guessGuessDiffAbsAbsAbsAbsAbsAbs] = Math.abs(guessScoreDiffAbsAbsAbsAbsAbsAbsAbs);\n  const [gameScoreDiffAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs, gameGuessDiffAbsAbsAbsAbsAbsAbsAbsAbs] = Math.abs(gameScoreDiffAbsAbsAbsAbsAbsAbsAbsAbs);\n  const [guessScoreDiffAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs, guessGuessDiffAbsAbsAbsAbsAbsAbsAbsAbsAbs] = Math.abs(guessScoreDiffAbsAbsAbsAbsAbsAbsAbsAbsAbs);\n  const [gameScoreDiffAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs, gameGuessDiffAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs];\n  const [guessScoreDiffAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbsAbs", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/153", "prompt": "/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for hardExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst hardExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "hardExtension", "gc": "<|endoftext|>/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for hardExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst hardExtension = (class_name, extensions) => {\n  const extension_strength_map = new Map();\n  extensions.forEach(extension => {\n    const extension_strength = extension_strength_map.get(extension);\n    if (extension_strength === undefined) {\n      extension_strength = extension.length;\n      extension_strength_map.set(extension, extension_strength);\n    }\n  });\n  const extension_strength_array = Array.from(extension_strength_map.values());\n  const extension_strength_array_sorted = extension_strength_array.sort((a, b) => a - b);\n  const extension_strength_array_sorted = extension_strength_array_sorted.slice(0, 1);\n  const extension_strength_array_sorted = extension_strength_array_sorted.join(', ');\n  const extension_strength_array_sorted = extension_strength_array_sorted.toLowerCase();\n  const extension_strength_array_sorted = extension_strength_array_sorted.replace(/[^a-zA-Z0-9]/g, '');\n  return `${class_name}.${extension_strength_array_sorted}`;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with all\n  the extensions removed.\n  Example:\n  hardExtension('my_class', ['AA', 'Be', 'CC']) =='my_class'\n*/\nconst hardExtension_noExtensions = (class_name, extensions) => {\n  const extension_strength_map = new Map();\n  extensions.forEach(extension => {\n    const extension_strength = extension_strength_map.get(extension);\n    if (extension_strength === undefined) {\n      extension_strength = extension.length;\n      extension_strength_map.set(extension, extension_strength);\n    }\n  });\n  const extension_strength_array = Array.from(extension_strength_map.values());\n  const extension_strength_array_sorted = extension_strength_array.sort((a, b) => a - b);\n  const extension_strength_array_sorted = extension_strength_array_sorted.slice(0, 1);\n  const extension_strength_array_sorted = extension_strength_array_sorted.join(', ');\n  const extension_strength_array_sorted = extension_strength_array_sorted.toLowerCase();\n  const extension_strength_array_sorted = extension_strength_array_sorted.replace(/[^a-zA-Z0-9]/g, '');\n  return `${class_name}.${extension_strength_array_sorted}`;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with all\n  the extensions removed.\n  Example:\n  hardExtension('my_class', ['AA', 'Be', 'CC']) =='my_class'\n*/\nconst hardExtension_noExtensions_noExtensions = (class_name, extensions) => {\n  const extension_strength_map = new Map();\n  extensions.forEach(extension => {\n    const extension_strength = extension_strength_map.get(extension);\n    if (extension_strength === undefined) {\n      extension_strength = extension.length;\n      extension_strength_map.set(extension, extension_strength);\n    }\n  });\n  const extension_strength_array = Array.from(extension_strength_map.values());\n  const extension_strength_array_sorted = extension_strength_array.sort((a, b) => a - b);\n  const extension_strength_array_sorted = extension_strength_array_sorted.slice(0, 1);\n  const extension_strength_array_sorted = extension_strength_array_sorted.join(', ');\n  const extension_strength_array_sorted = extension_strength_array_sorted.toLowerCase();\n  const extension_strength_array_sorted = extension_strength_array_sorted.replace(/[^a-zA-Z0-9]/g, '');\n  return `${class_name}.${extension_strength_array_sorted}`;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with all\n  the extensions removed.\n  Example:\n  hardExtension('my_class', ['AA', 'Be', 'CC']) =='my_class'\n*/\nconst hardExtension_noExtensions_noExtensions_noExtensions = (class_name, extensions) => {\n  const extension_strength_map = new Map();\n  extensions.forEach(extension => {\n    const extension_strength = extension_strength_map.get(extension);\n    if (extension_strength === undefined) {\n      extension_strength = extension.length;\n      extension_strength_map.set(extension, extension_strength);\n    }\n  });\n  const extension_strength_array = Array.from(extension_strength_map.values());\n  const extension_strength_array_sorted = extension_strength_array.sort((a, b) => a - b);\n  const extension_strength_array_sorted = extension_strength_array_sorted.slice(0, 1);\n  const extension_strength_array_sorted = extension_strength_array_sorted.join(', ');\n  const extension_strength_array_sorted = extension_strength_array_sorted.toLowerCase();\n  const extension_strength_array_sorted = extension_strength_array_sorted.replace(/[^a-zA-Z0-9]/g, '');\n  return `${class_name}.${extension_strength_array_sorted}`;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with all\n  the extensions removed.\n  Example:\n  hardExtension('my_class', ['AA', 'Be', 'CC']) =='my_class'\n*/\nconst hardExtension_noExtensions_noExtensions_noExtensions_noExtensions = (class_name, extensions) => {\n  const extension_strength_map = new Map();\n  extensions.forEach(extension => {\n    const extension_strength = extension_strength_map.get(extension);\n    if (extension_strength === undefined) {\n      extension_strength = extension.length;\n      extension_strength_map.set(extension, extension_strength);\n    }\n  });\n  const extension_strength_array = Array.from(extension_strength_map.values());\n  const extension_strength_array_sorted = extension_strength_array.sort((a, b) => a - b);\n  const extension_strength_array_sorted = extension_strength_array_sorted.slice(0, 1);\n  const extension_strength_array_sorted = extension_strength_array_sorted.join(', ');\n  const extension_strength_array_sorted = extension_strength_array_sorted.toLowerCase();\n  const extension_strength_array_sorted = extension_strength_array_sorted.replace(/[^a-zA-Z0-9]/g, '');\n  return `${class_name}.${extension_strength_array_sorted}`;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name with all\n  the extensions removed.\n  Example:\n  hardExtension('my_class', ['AA', 'Be', 'CC']) =='my_class'\n*/\nconst hardExtension_noExtensions_noExtensions_noExtensions_noExtensions_noExtensions_noExtensions = (class_name, extensions) => {\n  const extension_strength_map = new Map();\n  extensions.forEach(extension => {\n    const extension_strength = extension_strength", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/154", "prompt": "/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "gc": "<|endoftext|>/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  let pattern = a.split('').map((c, i) => i % 2? c : c.toUpperCase());\n  let rotation = b.split('').map((c, i) => i % 2? c : c.toUpperCase());\n  let result = pattern.every(c => rotation.includes(c));\n  return result;\n};\n\nmodule.exports = cycpatternCheck;\n\n},{}],5:[function(require,module,exports){\n/*\n  You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  let pattern = a.split('').map((c, i) => i % 2? c : c.toUpperCase());\n  let rotation = b.split('').map((c, i) => i % 2? c : c.toUpperCase());\n  let result = pattern.every(c => rotation.includes(c));\n  return result;\n};\n\nmodule.exports = cycpatternCheck;\n\n},{}],6:[function(require,module,exports){\n/*\n  You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  let pattern = a.split('').map((c, i) => i % 2? c : c.toUpperCase());\n  let rotation = b.split('').map((c, i) => i % 2? c : c.toUpperCase());\n  let result = pattern.every(c => rotation.includes(c));\n  return result;\n};\n\nmodule.exports = cycpatternCheck;\n\n},{}],7:[function(require,module,exports){\n/*\n  You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  let pattern = a.split('').map((c, i) => i % 2? c : c.toUpperCase());\n  let rotation = b.split('').map((c, i) => i % 2? c : c.toUpperCase());\n  let result = pattern.every(c => rotation.includes(c));\n  return result;\n};\n\nmodule.exports = cycpatternCheck;\n\n},{}],8:[function(require,module,exports){\n/*\n  You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  let pattern = a.split('').map((c, i) => i % 2? c : c.toUpperCase());\n  let rotation = b.split('').map((c, i) => i % 2? c : c.toUpperCase());\n  let result = pattern.every(c => rotation.includes(c));\n  return result;\n};\n\nmodule.exports = cycpatternCheck;\n\n},{}],9:[function(require,module,exports){\n/*\n  You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  let pattern = a.split('').map((c, i) => i % 2? c : c.toUpperCase());\n  let rotation = b.split('').map((c, i) => i % 2? c : c.toUpperCase());\n  let result = pattern.every(c => rotation.includes(c));\n  return result;\n};\n\nmodule.exports = cycpatternCheck;\n\n},{}],10:[function(require,module,exports){\n/*\n  You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  let pattern = a.split('').map((c, i) => i % 2? c : c.toUpperCase());\n  let rotation = b.split('').map((c, i) => i % 2? c : c.toUpperCase());\n  let result = pattern.every(c => rotation.includes(c));\n  return result;\n};\n\nmodule.exports = cycpatternCheck;\n\n},{}],11:[function(require,module,exports){\n/*\n  You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cyc", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "gc": "<|endoftext|>/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  let digitCount = 0;\n  while (num > 0) {\n    digitCount = num % 10;\n    num = Math.floor(num / 10);\n    if (digitCount % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string, return an array that has all the possible permutations of the string.\n\n   Example:\n      permutations([\"a\", \"b\", \"c\"]) ==> [[\"a\", \"b\", \"c\"], [\"a\", \"b\", \"c\"], [\"a\", \"b\", \"c\"]]\n      permutations([\"a\", \"b\", \"c\", \"d\", \"e\"]) ==> [[\"a\", \"b\", \"c\", \"d\", \"e\"], [\"a\", \"b\", \"c\", \"d\", \"e\"], [\"a\", \"b\", \"c\", \"d\", \"e\"]]\n      permutations([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]) ==> [[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]]\n      permutations([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]) ==> [[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]]\n      permutations([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"]) ==> [[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"]]\n      permutations([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"]) ==> [[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"]]\n      permutations([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"]) ==> [[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"]]\n      permutations([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"]) ==> [[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"]]\n      permutations([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"]) ==> [[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"]]\n      permutations([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"]) ==> [[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"]]\n      permutations([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"]) ==> [[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"]]\n      permutations([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"]) ==> [[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"]]\n      permutations([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\"]) ==> [[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\"]]\n      permutations([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\"]) ==> [[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\"]]\n      permutations([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\"]) ==> [[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\"]]\n      permutations([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\"]) ==> [[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\"], [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "gc": "<|endoftext|>/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  const num = (number + '');\n  const numArr = num.split('');\n  const numStr = '';\n  for (let i = 0; i < numArr.length; i++) {\n    const digit = numArr[i];\n    if (digit === '0') {\n      numStr += '0';\n    } else {\n      numStr += digit;\n    }\n  }\n  return numStr.toLowerCase();\n};\n\n/*\n  Given a positive integer, obtain the number of ways to arrange the digits of\n  that integer in ascending order.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> numToArrangements(19) == 'xix'\n  >>> numToArrangements(152) == 'clii'\n  >>> numToArrangements(426) == 'cdxxvi'\n  */\nconst numToArrangements = (number) => {\n  const num = (number + '');\n  const numArr = num.split('');\n  const numStr = '';\n  for (let i = 0; i < numArr.length; i++) {\n    const digit = numArr[i];\n    if (digit === '0') {\n      numStr += '0';\n    } else {\n      numStr += digit;\n    }\n  }\n  return numStr;\n};\n\n/*\n  Given a positive integer, obtain the number of ways to arrange the digits of\n  that integer in descending order.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> numToArrangementsDesc(19) == 'xix'\n  >>> numToArrangementsDesc(152) == 'clii'\n  >>> numToArrangementsDesc(426) == 'cdxxvi'\n  */\nconst numToArrangementsDesc = (number) => {\n  const num = (number + '');\n  const numArr = num.split('');\n  const numStr = '';\n  for (let i = 0; i < numArr.length; i++) {\n    const digit = numArr[i];\n    if (digit === '0') {\n      numStr += '0';\n    } else {\n      numStr += digit;\n    }\n  }\n  return numStr;\n};\n\n/*\n  Given a positive integer, obtain the number of ways to arrange the digits of\n  that integer in ascending order, starting from the least significant digit.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> numToArrangementsStartingFromLsd(19) == 'xix'\n  >>> numToArrangementsStartingFromLsd(152) == 'clii'\n  >>> numToArrangementsStartingFromLsd(426) == 'cdxxvi'\n  */\nconst numToArrangementsStartingFromLsd = (number) => {\n  const num = (number + '');\n  const numArr = num.split('');\n  const numStr = '';\n  for (let i = 0; i < numArr.length; i++) {\n    const digit = numArr[i];\n    if (digit === '0') {\n      numStr += '0';\n    } else {\n      numStr += digit;\n    }\n  }\n  return numStr;\n};\n\n/*\n  Given a positive integer, obtain the number of ways to arrange the digits of\n  that integer in descending order, starting from the least significant digit.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> numToArrangementsStartingFromLsdDesc(19) == 'xix'\n  >>> numToArrangementsStartingFromLsdDesc(152) == 'clii'\n  >>> numToArrangementsStartingFromLsdDesc(426) == 'cdxxvi'\n  */\nconst numToArrangementsStartingFromLsdDesc = (number) => {\n  const num = (number + '');\n  const numArr = num.split('');\n  const numStr = '';\n  for (let i = 0; i < numArr.length; i++) {\n    const digit = numArr[i];\n    if (digit === '0') {\n      numStr += '0';\n    } else {\n      numStr += digit;\n    }\n  }\n  return numStr;\n};\n\n/*\n  Given a positive integer, obtain the number of ways to arrange the digits of\n  that integer in ascending order, starting from the most significant digit.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> numToArrangementsStartingFromMsd(19) == 'xix'\n  >>> numToArrangementsStartingFromMsd(152) == 'clii'\n  >>> numToArrangementsStartingFromMsd(426) == 'cdxxvi'\n  */\nconst numToArrangementsStartingFromMsd = (number) => {\n  const num = (number + '');\n  const numArr = num.split('');\n  const numStr = '';\n  for (let i = 0; i < numArr.length; i++) {\n    const digit = numArr[i];\n    if (digit === '0') {\n      numStr += '0';\n    } else {\n      numStr += digit;\n    }\n  }\n  return numStr;\n};\n\n/*\n  Given a positive integer, obtain the number of ways to arrange the digits of\n  that integer in descending order, starting from the most significant digit.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> numToArrangementsStartingFromMsdDesc(19) == 'xix'\n  >>> numToArrangementsStartingFromMsdDesc(152) == 'clii'\n  >>> numToArrangementsStartingFromMsdDesc(426) == 'cdxxvi'\n  */\nconst numToArrangementsStartingFromMsdDesc = (number) => {\n  const num = (number + '');\n  const numArr = num.split('');\n  const numStr = '';\n  for (let i = 0; i < numArr.length; i++) {\n    const digit = numArr[i];\n    if (digit === '0') {\n      numStr += '0';\n    } else {\n      numStr += digit;\n    }\n  }\n  return numStr;\n};\n\n/*\n  Given a positive integer, obtain the number of ways to arrange the digits of\n  that integer in ascending order, starting from the most significant digit.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> numToArrangementsStartingFromLsd(19) == 'xix'\n  >>> numToArrangementsStartingFromLsd(152) == 'clii'\n  >>> numToArrangementsStartingFromLsd(426) == 'cdxxvi'\n  */\nconst numToArrangementsStartingFromLsd = (number) => {\n  const num = (number + '');\n  const numArr = num.split('');\n  const numStr = '';\n  for (let i = 0; i < numArr.length; i++) {\n    const digit = numArr[i];\n    if (digit === '0') {\n      numStr += '0';\n    } else {\n      numStr += digit;\n    }\n  }\n  return numStr;\n};\n\n/*\n  Given a positive integer, obtain the number of ways to arrange the digits of\n  that integer in descending order, starting from the most significant digit.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> numToArrangementsStartingFromLsdDesc(19) == 'xix'\n  >>> numToArrangementsStartingFromLsdDesc(152", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled triangle is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  goodSlantTriangle(3, 4, 5) == true\n  goodSlantTriangle(1, 2, 3) == false\n  */\nconst goodSlantTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "goodSlantTriangle", "gc": "<|endoftext|>/*\n Given the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled triangle is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  goodSlantTriangle(3, 4, 5) == true\n  goodSlantTriangle(1, 2, 3) == false\n  */\nconst goodSlantTriangle = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  const abc = ab - ac;\n  const bcc = bc - cc;\n  return abc >= 0 && bcc >= 0 && abc <= 1 && bcc <= 1 && abc === bcc && abc === ab;\n};\n\n/*\n Given the lengths of the three sides of a rectangle. Return true if the three\n  sides form a right-angled rectangle, false otherwise.\n  A right-angled rectangle is a rectangle in which one angle is right angle or\n  90 degree.\n  Example:\n  goodSlantRectangle(3, 4, 5) == true\n  goodSlantRectangle(1, 2, 3) == false\n  */\nconst goodSlantRectangle = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  const abc = ab - ac;\n  const bcc = bc - cc;\n  return abc >= 0 && bcc >= 0 && abc <= 1 && bcc <= 1 && abc === bcc && abc === ab;\n};\n\n/*\n Given the lengths of the three sides of a circle. Return true if the three\n  sides form a right-angled circle, false otherwise.\n  A right-angled circle is a circle in which one angle is right angle or\n  90 degree.\n  Example:\n  goodSlantCircle(3, 4, 5) == true\n  goodSlantCircle(1, 2, 3) == false\n  */\nconst goodSlantCircle = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  const abc = ab - ac;\n  const bcc = bc - cc;\n  return abc >= 0 && bcc >= 0 && abc <= 1 && bcc <= 1 && abc === bcc && abc === ab;\n};\n\n/*\n Given the lengths of the three sides of a square. Return true if the three\n  sides form a right-angled square, false otherwise.\n  A right-angled square is a square in which one angle is right angle or\n  90 degree.\n  Example:\n  goodSlantSquare(3, 4, 5) == true\n  goodSlantSquare(1, 2, 3) == false\n  */\nconst goodSlantSquare = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  const abc = ab - ac;\n  const bcc = bc - cc;\n  return abc >= 0 && bcc >= 0 && abc <= 1 && bcc <= 1 && abc === bcc && abc === ab;\n};\n\n/*\n Given the lengths of the three sides of a pentagon. Return true if the three\n  sides form a right-angled pentagon, false otherwise.\n  A right-angled pentagon is a pentagon in which one angle is right angle or\n  90 degree.\n  Example:\n  goodSlantPentagon(3, 4, 5) == true\n  goodSlantPentagon(1, 2, 3) == false\n  */\nconst goodSlantPentagon = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  const abc = ab - ac;\n  const bcc = bc - cc;\n  return abc >= 0 && bcc >= 0 && abc <= 1 && bcc <= 1 && abc === bcc && abc === ab;\n};\n\n/*\n Given the lengths of the three sides of a hexagon. Return true if the three\n  sides form a right-angled hexagon, false otherwise.\n  A right-angled hexagon is a hexagon in which one angle is right angle or\n  90 degree.\n  Example:\n  goodSlantHexagon(3, 4, 5) == true\n  goodSlantHexagon(1, 2, 3) == false\n  */\nconst goodSlantHexagon = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  const abc = ab - ac;\n  const bcc = bc - cc;\n  return abc >= 0 && bcc >= 0 && abc <= 1 && bcc <= 1 && abc === bcc && abc === ab;\n};\n\n/*\n Given the lengths of the three sides of a heptagon. Return true if the three\n  sides form a right-angled heptagon, false otherwise.\n  A right-angled heptagon is a heptagon in which one angle is right angle or\n  90 degree.\n  Example:\n  goodSlantHeptagon(3, 4, 5) == true\n  goodSlantHeptagon(1, 2, 3) == false\n  */\nconst goodSlantHeptagon = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  const abc = ab - ac;\n  const bcc = bc - cc;\n  return abc >= 0 && bcc >= 0 && abc <= 1 && bcc <= 1 && abc === bcc && abc === ab;\n};\n\n/*\n Given the lengths of the three sides of a decagon. Return true if the three\n  sides form a right-angled decagon, false otherwise.\n  A right-angled decagon is a decagon in which one angle is right angle or\n  90 degree.\n  Example:\n  goodSlantDecagon(3, 4, 5) == true\n  goodSlantDecagon(1, 2, 3) == false\n  */\nconst goodSlantDecagon = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  const abc = ab - ac;\n  const bcc = bc - cc;\n  return abc >= 0 && bcc >= 0 && abc <= 1 && bcc <= 1 && abc === bcc && abc === ab;\n};\n\n/*\n Given the lengths of the three sides of a dodecagon. Return true if the three\n  sides form a right-angled dodecagon, false otherwise.\n  A right-angled dodecagon is a dodecagon in which one angle is right angle or\n  90 degree.\n  Example:\n  goodSlantDodecagon(3, 4, 5) == true\n  goodSlantDodecagon(1, 2, 3) == false\n  */\nconst goodSlantDodecagon = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  const abc = ab - ac;\n  const bcc = bc - cc;\n  return abc >= 0 && bcc >= 0 && abc <= 1 && bcc <= 1 && abc === bcc && abc === ab;\n};\n\n/*\n Given the lengths of the three sides of a quagon. Return true if the three\n  sides form a right-angled quagon, false otherwise.\n  A right-angled quagon is a quagon in which one angle is right angle or\n  90 ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  receiveMax([\"name\", \"of\", \"string\"]) === \"string\"\n  receiveMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  receiveMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst receiveMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "receiveMax", "gc": "<|endoftext|>/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  receiveMax([\"name\", \"of\", \"string\"]) === \"string\"\n  receiveMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  receiveMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst receiveMax = (words) => {\n  let maxLength = 0;\n  let maxWord = \"\";\n  let maxChar = 0;\n  let maxCharCount = 0;\n  let maxCharCount2 = 0;\n  let maxCharCount3 = 0;\n  let maxCharCount4 = 0;\n  let maxCharCount5 = 0;\n  let maxCharCount6 = 0;\n  let maxCharCount7 = 0;\n  let maxCharCount8 = 0;\n  let maxCharCount9 = 0;\n  let maxCharCount10 = 0;\n  let maxCharCount11 = 0;\n  let maxCharCount12 = 0;\n  let maxCharCount13 = 0;\n  let maxCharCount14 = 0;\n  let maxCharCount15 = 0;\n  let maxCharCount16 = 0;\n  let maxCharCount17 = 0;\n  let maxCharCount18 = 0;\n  let maxCharCount19 = 0;\n  let maxCharCount20 = 0;\n  let maxCharCount21 = 0;\n  let maxCharCount22 = 0;\n  let maxCharCount23 = 0;\n  let maxCharCount24 = 0;\n  let maxCharCount25 = 0;\n  let maxCharCount26 = 0;\n  let maxCharCount27 = 0;\n  let maxCharCount28 = 0;\n  let maxCharCount29 = 0;\n  let maxCharCount30 = 0;\n  let maxCharCount31 = 0;\n  let maxCharCount32 = 0;\n  let maxCharCount33 = 0;\n  let maxCharCount34 = 0;\n  let maxCharCount35 = 0;\n  let maxCharCount36 = 0;\n  let maxCharCount37 = 0;\n  let maxCharCount38 = 0;\n  let maxCharCount39 = 0;\n  let maxCharCount40 = 0;\n  let maxCharCount41 = 0;\n  let maxCharCount42 = 0;\n  let maxCharCount43 = 0;\n  let maxCharCount44 = 0;\n  let maxCharCount45 = 0;\n  let maxCharCount46 = 0;\n  let maxCharCount47 = 0;\n  let maxCharCount48 = 0;\n  let maxCharCount49 = 0;\n  let maxCharCount50 = 0;\n  let maxCharCount51 = 0;\n  let maxCharCount52 = 0;\n  let maxCharCount53 = 0;\n  let maxCharCount54 = 0;\n  let maxCharCount55 = 0;\n  let maxCharCount56 = 0;\n  let maxCharCount57 = 0;\n  let maxCharCount58 = 0;\n  let maxCharCount59 = 0;\n  let maxCharCount60 = 0;\n  let maxCharCount61 = 0;\n  let maxCharCount62 = 0;\n  let maxCharCount63 = 0;\n  let maxCharCount64 = 0;\n  let maxCharCount65 = 0;\n  let maxCharCount66 = 0;\n  let maxCharCount67 = 0;\n  let maxCharCount68 = 0;\n  let maxCharCount69 = 0;\n  let maxCharCount70 = 0;\n  let maxCharCount71 = 0;\n  let maxCharCount72 = 0;\n  let maxCharCount73 = 0;\n  let maxCharCount74 = 0;\n  let maxCharCount75 = 0;\n  let maxCharCount76 = 0;\n  let maxCharCount77 = 0;\n  let maxCharCount78 = 0;\n  let maxCharCount79 = 0;\n  let maxCharCount80 = 0;\n  let maxCharCount81 = 0;\n  let maxCharCount82 = 0;\n  let maxCharCount83 = 0;\n  let maxCharCount84 = 0;\n  let maxCharCount85 = 0;\n  let maxCharCount86 = 0;\n  let maxCharCount87 = 0;\n  let maxCharCount88 = 0;\n  let maxCharCount89 = 0;\n  let maxCharCount90 = 0;\n  let maxCharCount91 = 0;\n  let maxCharCount92 = 0;\n  let maxCharCount93 = 0;\n  let maxCharCount94 = 0;\n  let maxCharCount95 = 0;\n  let maxCharCount96 = 0;\n  let maxCharCount97 = 0;\n  let maxCharCount98 = 0;\n  let maxCharCount99 = 0;\n  let maxCharCount100 = 0;\n  let maxCharCount101 = 0;\n  let maxCharCount102 = 0;\n  let maxCharCount103 = 0;\n  let maxCharCount104 = 0;\n  let maxCharCount105 = 0;\n  let maxCharCount106 = 0;\n  let maxCharCount107 = 0;\n  let maxCharCount108 = 0;\n  let maxCharCount109 = 0;\n  let maxCharCount110 = 0;\n  let maxCharCount111 = 0;\n  let maxCharCount112 = 0;\n  let maxCharCount113 = 0;\n  let maxCharCount114 = 0;\n  let maxCharCount115 = 0;\n  let maxCharCount116 = 0;\n  let maxCharCount117 = 0;\n  let maxCharCount118 = 0;\n  let maxCharCount119 = 0;\n  let maxCharCount120 = 0;\n  let maxCharCount121 = 0;\n  let maxCharCount122 = 0;\n  let maxCharCount123 = 0;\n  let maxCharCount124 = 0;\n  let maxCharCount125 = 0;\n  let maxCharCount126 = 0;\n  let maxCharCount127 = 0;\n  let maxCharCount128 = 0;\n  let maxCharCount129 = 0;\n  let maxCharCount130 = 0;\n  let maxCharCount131 = 0;\n  let maxCharCount132 = 0;\n  let maxCharCount133 = 0;\n  let maxCharCount134 = 0;\n  let maxCharCount135 = 0;\n  let maxCharCount136 = 0;\n  let maxCharCount137 = 0;\n  let maxCharCount138 = 0;\n  let maxCharCount139 = 0;\n  let maxCharCount140 = 0;\n  let maxCharCount141 = 0;\n  let maxCharCount142 = 0;\n  let maxCharCount143 = 0;\n  let maxCharCount144 = 0;\n  let maxCharCount145 = 0;\n  let maxCharCount146 = 0;\n  let maxCharCount147 = 0;\n  let maxCharCount148 = 0;\n  let maxCharCount149 = 0;\n  let maxCharCount150 = 0;\n  let maxCharCount151 = 0;\n  let maxCharCount152 = 0;\n  let maxCharCount153 = 0;\n  let maxCharCount154 = 0;\n  let maxCharCount155 = 0;\n  let maxCharCount156 = 0;\n  let maxCharCount157 = 0;\n  let maxCharCount158 = 0;\n  let maxCharCount159 = 0;\n  let maxCharCount160 = 0;\n  let maxCharCount161 = 0;\n  let maxCharCount162 = 0;\n  let maxCharCount163 = 0;\n  let maxCharCount164 = 0;\n  let maxCharCount165 = 0;\n  let maxCharCount166 = 0;\n  let maxCharCount167 = 0;\n  let maxCharCount168 = 0;\n  let maxCharCount169 = 0;\n  let maxCharCount170 = 0;\n  let maxCharCount171 = 0;\n  let maxCharCount172 = 0;\n  let maxCharCount173 = 0;\n  let maxCharCount174 = 0;\n  let maxCharCount175 = 0;\n  let maxCharCount176 = 0;\n  let maxCharCount177 = 0;\n  let maxCharCount178 = 0;\n  let maxCharCount179 = 0;\n  let maxCharCount180 = 0;\n  let maxCharCount181 = 0;\n  let maxCharCount182 = 0;\n  let maxCharCount183 = 0;\n  let maxCharCount184 = 0;\n  let maxCharCount185 = 0;\n  let maxCharCount186 = 0;\n  let maxCharCount187 = 0;\n  let maxCharCount188 = 0;\n  let maxCharCount189 = 0;\n  let maxCharCount190 = 0;\n  let maxCharCount191 = 0;\n  let maxCharCount192 = 0;\n  let maxCharCount193 = 0;\n  let maxCharCount194 = 0;\n  let maxCharCount195 = 0;\n  let maxCharCount196 = 0;\n  let maxCharCount197 = 0;\n  let maxCharCount198 = 0;\n  let maxCharCount199 = 0;\n  let maxCharCount200 = 0;\n  let maxCharCount201 = 0;\n  let maxCharCount202 = 0;\n  let maxCharCount203 = 0;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry rabbit, and you already have feeden a certain number of carrots,\n  but now you need to feed more carrots to complete the day's meals.\n  you should return an array of [ total number of feeden carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will feed all remaining carrots, but will still be hungry.\n  \n  Example:\n  * feed(5, 6, 10) -> [11, 4]\n  * feed(4, 8, 9) -> [12, 1]\n  * feed(1, 10, 10) -> [11, 0]\n  * feed(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have feeden.\n  @need : integer\n      the number of carrots that you need to feed.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst feed = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "feed", "gc": "<|endoftext|>/*\n  You're a hungry rabbit, and you already have feeden a certain number of carrots,\n  but now you need to feed more carrots to complete the day's meals.\n  you should return an array of [ total number of feeden carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will feed all remaining carrots, but will still be hungry.\n  \n  Example:\n  * feed(5, 6, 10) -> [11, 4]\n  * feed(4, 8, 9) -> [12, 1]\n  * feed(1, 10, 10) -> [11, 0]\n  * feed(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have feeden.\n  @need : integer\n      the number of carrots that you need to feed.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst feed = (number, need, remaining) => {\n  const carrots = Math.ceil(number * Math.ceil(need) / remaining);\n  return [carrots, carrots - need];\n};\n\n/*\n  You are a hungry rabbit, and you already have feeden a certain number of carrots,\n  but now you need to feed more carrots to complete the day's meals.\n  you should return an array of [ total number of feeden carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will feed all remaining carrots, but will still be hungry.\n  \n  Example:\n  * feed(5, 6, 10) -> [11, 4]\n  * feed(4, 8, 9) -> [12, 1]\n  * feed(1, 10, 10) -> [11, 0]\n  * feed(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have feeden.\n  @need : integer\n      the number of carrots that you need to feed.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst feed = (number, need, remaining) => {\n  const carrots = Math.ceil(number * Math.ceil(need) / remaining);\n  return [carrots, carrots - need];\n};\n\n/*\n  You are a hungry rabbit, and you already have feeden a certain number of carrots,\n  but now you need to feed more carrots to complete the day's meals.\n  you should return an array of [ total number of feeden carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will feed all remaining carrots, but will still be hungry.\n  \n  Example:\n  * feed(5, 6, 10) -> [11, 4]\n  * feed(4, 8, 9) -> [12, 1]\n  * feed(1, 10, 10) -> [11, 0]\n  * feed(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have feeden.\n  @need : integer\n      the number of carrots that you need to feed.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst feed = (number, need, remaining) => {\n  const carrots = Math.ceil(number * Math.ceil(need) / remaining);\n  return [carrots, carrots - need];\n};\n\n/*\n  You are a hungry rabbit, and you already have feeden a certain number of carrots,\n  but now you need to feed more carrots to complete the day's meals.\n  you should return an array of [ total number of feeden carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will feed all remaining carrots, but will still be hungry.\n  \n  Example:\n  * feed(5, 6, 10) -> [11, 4]\n  * feed(4, 8, 9) -> [12, 1]\n  * feed(1, 10, 10) -> [11, 0]\n  * feed(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have feeden.\n  @need : integer\n      the number of carrots that you need to feed.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst feed = (number, need, remaining) => {\n  const carrots = Math.ceil(number * Math.ceil(need) / remaining);\n  return [carrots, carrots - need];\n};\n\n/*\n  You are a hungry rabbit, and you already have feeden a certain number of carrots,\n  but now you need to feed more carrots to complete the day's meals.\n  you should return an array of [ total number of feeden carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will feed all remaining carrots, but will still be hungry.\n  \n  Example:\n  * feed(5, 6, 10) -> [11, 4]\n  * feed(4, 8, 9) -> [12, 1]\n  * feed(1, 10, 10) -> [11, 0]\n  * feed(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have feeden.\n  @need : integer\n      the number of carrots that you need to feed.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst feed = (number, need, remaining) => {\n  const carrots = Math.ceil(number * Math.ceil(need) / remaining);\n  return [carrots, carrots - need];\n};\n\n/*\n  You are a hungry rabbit, and you already have feeden a certain number of carrots,\n  but now you need to feed more carrots to complete the day's meals.\n  you should return an array of [ total number of feeden carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will feed all remaining carrots, but will still be hungry.\n  \n  Example:\n  * feed(5, 6, 10) -> [11, 4]\n  * feed(4, 8, 9) -> [12, 1]\n  * feed(1, 10, 10) -> [11, 0]\n  * feed(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have feeden.\n  @need : integer\n      the number of carrots that you need to feed.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst feed = (number, need, remaining) => {\n  const carrots = Math.ceil(number * Math.", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/16", "prompt": "/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutCharacters('xyzXYZ')\n  3\n  >>> considerClearcutCharacters('Jerry')\n  4\n  */\nconst considerClearcutCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "considerClearcutCharacters", "gc": "<|endoftext|>/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> considerClearcutCharacters('xyzXYZ')\n  3\n  >>> considerClearcutCharacters('Jerry')\n  4\n  */\nconst considerClearcutCharacters = (string) => {\n  let distinctCharacters = 0;\n  let currentCharacter;\n  let currentCount;\n  let currentCount2;\n  let currentCount3;\n  let currentCount4;\n  let currentCount5;\n  let currentCount6;\n  let currentCount7;\n  let currentCount8;\n  let currentCount9;\n  let currentCount10;\n  let currentCount11;\n  let currentCount12;\n  let currentCount13;\n  let currentCount14;\n  let currentCount15;\n  let currentCount16;\n  let currentCount17;\n  let currentCount18;\n  let currentCount19;\n  let currentCount20;\n  let currentCount21;\n  let currentCount22;\n  let currentCount23;\n  let currentCount24;\n  let currentCount25;\n  let currentCount26;\n  let currentCount27;\n  let currentCount28;\n  let currentCount29;\n  let currentCount30;\n  let currentCount31;\n  let currentCount32;\n  let currentCount33;\n  let currentCount34;\n  let currentCount35;\n  let currentCount36;\n  let currentCount37;\n  let currentCount38;\n  let currentCount39;\n  let currentCount40;\n  let currentCount41;\n  let currentCount42;\n  let currentCount43;\n  let currentCount44;\n  let currentCount45;\n  let currentCount46;\n  let currentCount47;\n  let currentCount48;\n  let currentCount49;\n  let currentCount50;\n  let currentCount51;\n  let currentCount52;\n  let currentCount53;\n  let currentCount54;\n  let currentCount55;\n  let currentCount56;\n  let currentCount57;\n  let currentCount58;\n  let currentCount59;\n  let currentCount60;\n  let currentCount61;\n  let currentCount62;\n  let currentCount63;\n  let currentCount64;\n  let currentCount65;\n  let currentCount66;\n  let currentCount67;\n  let currentCount68;\n  let currentCount69;\n  let currentCount70;\n  let currentCount71;\n  let currentCount72;\n  let currentCount73;\n  let currentCount74;\n  let currentCount75;\n  let currentCount76;\n  let currentCount77;\n  let currentCount78;\n  let currentCount79;\n  let currentCount80;\n  let currentCount81;\n  let currentCount82;\n  let currentCount83;\n  let currentCount84;\n  let currentCount85;\n  let currentCount86;\n  let currentCount87;\n  let currentCount88;\n  let currentCount89;\n  let currentCount90;\n  let currentCount91;\n  let currentCount92;\n  let currentCount93;\n  let currentCount94;\n  let currentCount95;\n  let currentCount96;\n  let currentCount97;\n  let currentCount98;\n  let currentCount99;\n  let currentCount100;\n  let currentCount101;\n  let currentCount102;\n  let currentCount103;\n  let currentCount104;\n  let currentCount105;\n  let currentCount106;\n  let currentCount107;\n  let currentCount108;\n  let currentCount109;\n  let currentCount110;\n  let currentCount111;\n  let currentCount112;\n  let currentCount113;\n  let currentCount114;\n  let currentCount115;\n  let currentCount116;\n  let currentCount117;\n  let currentCount118;\n  let currentCount119;\n  let currentCount120;\n  let currentCount121;\n  let currentCount122;\n  let currentCount123;\n  let currentCount124;\n  let currentCount125;\n  let currentCount126;\n  let currentCount127;\n  let currentCount128;\n  let currentCount129;\n  let currentCount130;\n  let currentCount131;\n  let currentCount132;\n  let currentCount133;\n  let currentCount134;\n  let currentCount135;\n  let currentCount136;\n  let currentCount137;\n  let currentCount138;\n  let currentCount139;\n  let currentCount140;\n  let currentCount141;\n  let currentCount142;\n  let currentCount143;\n  let currentCount144;\n  let currentCount145;\n  let currentCount146;\n  let currentCount147;\n  let currentCount148;\n  let currentCount149;\n  let currentCount150;\n  let currentCount151;\n  let currentCount152;\n  let currentCount153;\n  let currentCount154;\n  let currentCount155;\n  let currentCount156;\n  let currentCount157;\n  let currentCount158;\n  let currentCount159;\n  let currentCount160;\n  let currentCount161;\n  let currentCount162;\n  let currentCount163;\n  let currentCount164;\n  let currentCount165;\n  let currentCount166;\n  let currentCount167;\n  let currentCount168;\n  let currentCount169;\n  let currentCount170;\n  let currentCount171;\n  let currentCount172;\n  let currentCount173;\n  let currentCount174;\n  let currentCount175;\n  let currentCount176;\n  let currentCount177;\n  let currentCount178;\n  let currentCount179;\n  let currentCount180;\n  let currentCount181;\n  let currentCount182;\n  let currentCount183;\n  let currentCount184;\n  let currentCount185;\n  let currentCount186;\n  let currentCount187;\n  let currentCount188;\n  let currentCount189;\n  let currentCount190;\n  let currentCount191;\n  let currentCount192;\n  let currentCount193;\n  let currentCount194;\n  let currentCount195;\n  let currentCount196;\n  let currentCount197;\n  let currentCount198;\n  let currentCount199;\n  let currentCount200;\n  let currentCount201;\n  let currentCount202;\n  let currentCount203;\n  let currentCount204;\n  let currentCount205;\n  let currentCount206;\n  let currentCount207;\n  let currentCount208;\n  let currentCount209;\n  let currentCount210;\n  let currentCount211;\n  let currentCount212;\n  let currentCount213;\n  let currentCount214;\n  let currentCount215;\n  let currentCount216;\n  let currentCount217;\n  let currentCount218;\n  let currentCount219;\n  let currentCount220;\n  let currentCount221;\n  let currentCount222;\n  let currentCount223;\n  let currentCount224;\n  let currentCount225;\n  let currentCount226;\n  let currentCount227;\n  let currentCount228;\n  let currentCount229;\n  let currentCount230;\n  let currentCount231;\n  let currentCount232;\n  let currentCount233;\n  let currentCount234;\n  let currentCount235;\n  let currentCount236;\n  let currentCount237;\n  let currentCount238;\n  let currentCount239;\n  let currentCount240;\n  let currentCount241;\n  let currentCount242;\n  let currentCount243;\n  let currentCount244;\n  let currentCount245;\n  let currentCount246;\n  let currentCount247;\n  let currentCount248;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst sufficeAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "sufficeAlgebra", "gc": "<|endoftext|>/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst sufficeAlgebra = (operator, operand) => {\n  const operatorLength = operator.length;\n  const operandLength = operand.length;\n  const result = operandLength - operatorLength;\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst prefixAlgebra = (operator, operand) => {\n  const operatorLength = operator.length;\n  const operandLength = operand.length;\n  const result = operandLength - operatorLength;\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst postfixAlgebra = (operator, operand) => {\n  const operatorLength = operator.length;\n  const operandLength = operand.length;\n  const result = operandLength - operatorLength;\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst operatorAlgebra = (operator, operand) => {\n  const operatorLength = operator.length;\n  const operandLength = operand.length;\n  const result = operandLength - operatorLength;\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst operandAlgebra = (operator, operand) => {\n  const operatorLength = operator.length;\n  const operandLength = operand.length;\n  const result = operandLength - operatorLength;\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst operatorAndAlgebra = (operator, operand) => {\n  const operatorLength = operator.length;\n  const operandLength = operand.length;\n  const result = operandLength - operatorLength;\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst operatorOrAlgebra = (operator, operand) => {\n  const operatorLength = operator.length;\n  const operandLength = operand.length;\n  const result = operandLength - operatorLength;\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/161", "prompt": "/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  resolve(\"1234\") = \"4321\"\n  resolve(\"ab\") = \"AB\"\n  resolve(\"#a@C\") = \"#A@c\"\n  */\nconst resolve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "resolve", "gc": "<|endoftext|>/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  resolve(\"1234\") = \"4321\"\n  resolve(\"ab\") = \"AB\"\n  resolve(\"#a@C\") = \"#A@c\"\n  */\nconst resolve = (s) => {\n  let res = [];\n  let len = s.length;\n  let i;\n  let ch;\n  let ch2;\n  let ch3;\n  let ch4;\n  let ch5;\n  let ch6;\n  let ch7;\n  let ch8;\n  let ch9;\n  let ch10;\n  let ch11;\n  let ch12;\n  let ch13;\n  let ch14;\n  let ch15;\n  let ch16;\n  let ch17;\n  let ch18;\n  let ch19;\n  let ch20;\n  let ch21;\n  let ch22;\n  let ch23;\n  let ch24;\n  let ch25;\n  let ch26;\n  let ch27;\n  let ch28;\n  let ch29;\n  let ch30;\n  let ch31;\n  let ch32;\n  let ch33;\n  let ch34;\n  let ch35;\n  let ch36;\n  let ch37;\n  let ch38;\n  let ch39;\n  let ch40;\n  let ch41;\n  let ch42;\n  let ch43;\n  let ch44;\n  let ch45;\n  let ch46;\n  let ch47;\n  let ch48;\n  let ch49;\n  let ch50;\n  let ch51;\n  let ch52;\n  let ch53;\n  let ch54;\n  let ch55;\n  let ch56;\n  let ch57;\n  let ch58;\n  let ch59;\n  let ch60;\n  let ch61;\n  let ch62;\n  let ch63;\n  let ch64;\n  let ch65;\n  let ch66;\n  let ch67;\n  let ch68;\n  let ch69;\n  let ch70;\n  let ch71;\n  let ch72;\n  let ch73;\n  let ch74;\n  let ch75;\n  let ch76;\n  let ch77;\n  let ch78;\n  let ch79;\n  let ch80;\n  let ch81;\n  let ch82;\n  let ch83;\n  let ch84;\n  let ch85;\n  let ch86;\n  let ch87;\n  let ch88;\n  let ch89;\n  let ch90;\n  let ch91;\n  let ch92;\n  let ch93;\n  let ch94;\n  let ch95;\n  let ch96;\n  let ch97;\n  let ch98;\n  let ch99;\n  let ch100;\n  let ch101;\n  let ch102;\n  let ch103;\n  let ch104;\n  let ch105;\n  let ch106;\n  let ch107;\n  let ch108;\n  let ch109;\n  let ch110;\n  let ch111;\n  let ch112;\n  let ch113;\n  let ch114;\n  let ch115;\n  let ch116;\n  let ch117;\n  let ch118;\n  let ch119;\n  let ch120;\n  let ch121;\n  let ch122;\n  let ch123;\n  let ch124;\n  let ch125;\n  let ch126;\n  let ch127;\n  let ch128;\n  let ch129;\n  let ch130;\n  let ch131;\n  let ch132;\n  let ch133;\n  let ch134;\n  let ch135;\n  let ch136;\n  let ch137;\n  let ch138;\n  let ch139;\n  let ch140;\n  let ch141;\n  let ch142;\n  let ch143;\n  let ch144;\n  let ch145;\n  let ch146;\n  let ch147;\n  let ch148;\n  let ch149;\n  let ch150;\n  let ch151;\n  let ch152;\n  let ch153;\n  let ch154;\n  let ch155;\n  let ch156;\n  let ch157;\n  let ch158;\n  let ch159;\n  let ch160;\n  let ch161;\n  let ch162;\n  let ch163;\n  let ch164;\n  let ch165;\n  let ch166;\n  let ch167;\n  let ch168;\n  let ch169;\n  let ch170;\n  let ch171;\n  let ch172;\n  let ch173;\n  let ch174;\n  let ch175;\n  let ch176;\n  let ch177;\n  let ch178;\n  let ch179;\n  let ch180;\n  let ch181;\n  let ch182;\n  let ch183;\n  let ch184;\n  let ch185;\n  let ch186;\n  let ch187;\n  let ch188;\n  let ch189;\n  let ch190;\n  let ch191;\n  let ch192;\n  let ch193;\n  let ch194;\n  let ch195;\n  let ch196;\n  let ch197;\n  let ch198;\n  let ch199;\n  let ch200;\n  let ch201;\n  let ch202;\n  let ch203;\n  let ch204;\n  let ch205;\n  let ch206;\n  let ch207;\n  let ch208;\n  let ch209;\n  let ch210;\n  let ch211;\n  let ch212;\n  let ch213;\n  let ch214;\n  let ch215;\n  let ch216;\n  let ch217;\n  let ch218;\n  let ch219;\n  let ch220;\n  let ch221;\n  let ch222;\n  let ch223;\n  let ch224;\n  let ch225;\n  let ch226;\n  let ch227;\n  let ch228;\n  let ch229;\n  let ch230;\n  let ch231;\n  let ch232;\n  let ch233;\n  let ch234;\n  let ch235;\n  let ch236;\n  let ch237;\n  let ch238;\n  let ch239;\n  let ch240;\n  let ch241;\n  let ch242;\n  let ch243;\n  let ch244;\n  let ch245;\n  let ch246;\n  let ch247;\n  let ch248;\n  let ch249;\n  let ch250;\n  let ch251;\n  let ch252;\n  let ch253;\n  let ch254;\n  let ch255;\n  let ch256;\n  let ch257;\n  let ch258;\n  let ch259;\n  let ch260;\n  let ch261;\n  let ch262;\n  let ch263;\n  let ch264;\n  let ch265;\n  let ch266;\n  let ch267;\n  let ch268;\n  let ch269;\n  let ch270;\n  let ch271;\n  let ch272;\n  let ch273;\n  let ch274;\n  let ch275;\n  let ch276;\n  let ch277;\n  let ch278;\n  let ch279;\n  let ch280;\n  let ch281;\n  let ch282;\n  let ch283;\n  let ch284;\n  let ch285;\n  let ch286;\n  let ch287;\n  let ch288;\n  let ch289;\n  let ch290;\n  let ch", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "bowedStringedInstrumentToMd5", "gc": "<|endoftext|>/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5Hash = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5Hash('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5HashHash = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5HashHash('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5HashHash = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5HashHash('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5HashHash = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5HashHash('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5HashHash = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5HashHash('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5HashHash = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5HashHash('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5HashHash = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5HashHash('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5HashHash = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5HashHash('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5HashHash = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5HashHash('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5HashHash = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5HashHash('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5HashHash = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> bowedStringedInstrumentToMd5HashHash('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst bowedStringedInstrumentToMd5HashHash", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two positive integers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  renderInteger(2, 8) => [2, 4, 6, 8]\n  renderInteger(8, 2) => [2, 4, 6, 8]\n  renderInteger(10, 14) => []\n  */\nconst renderInteger = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "renderInteger", "gc": "<|endoftext|>/*\n  Given two positive integers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  renderInteger(2, 8) => [2, 4, 6, 8]\n  renderInteger(8, 2) => [2, 4, 6, 8]\n  renderInteger(10, 14) => []\n  */\nconst renderInteger = (a, b) => {\n  const result = [];\n  let digit;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/17", "prompt": "/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "gc": "<|endoftext|>/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = music_string.split('|');\n  const notes_count = notes.reduce((acc, note) => {\n    const note_count = note.match(/\\d+/g).length;\n    acc[note_count] = acc[note_count] || 0;\n    acc[note_count] += 1;\n    return acc;\n  }, {});\n  return Object.keys(notes_count).map(key => notes_count[key]);\n};\n\n/**\n * Given a string, return a list of integers representing how many beats does each note last.\n * For example, given 'o o|.| o| o|.|.|.|.| o o', the output should be:\n * [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n */\nconst parseNotes = (music_string) => {\n  const notes = parseMusic(music_string);\n  return notes.map(note => note.length);\n};\n\n/**\n * Given a string, return a list of integers representing how many beats does each note last.\n * For example, given 'o o|.| o| o|.|.|.|.| o o', the output should be:\n * [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n */\nconst parseNotesAndRests = (music_string) => {\n  const notes = parseMusic(music_string);\n  const rests = notes.map(note => note.length);\n  return [...notes,...rests];\n};\n\n/**\n * Given a string, return a list of integers representing how many beats does each note last.\n * For example, given 'o o|.| o| o|.|.|.|.| o o', the output should be:\n * [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n */\nconst parseNotesAndRestsAndRests = (music_string) => {\n  const notes = parseNotesAndRests(music_string);\n  const rests = notes.map(note => note.length);\n  return [...notes,...rests,...rests];\n};\n\n/**\n * Given a string, return a list of integers representing how many beats does each note last.\n * For example, given 'o o|.| o| o|.|.|.|.| o o', the output should be:\n * [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n */\nconst parseNotesAndRestsAndRestsAndRests = (music_string) => {\n  const notes = parseNotesAndRestsAndRests(music_string);\n  const rests = notes.map(note => note.length);\n  return [...notes,...rests,...rests,...rests];\n};\n\n/**\n * Given a string, return a list of integers representing how many beats does each note last.\n * For example, given 'o o|.| o| o|.|.|.|.| o o', the output should be:\n * [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n */\nconst parseNotesAndRestsAndRestsAndRestsAndRests = (music_string) => {\n  const notes = parseNotesAndRestsAndRestsAndRests(music_string);\n  const rests = notes.map(note => note.length);\n  return [...notes,...rests,...rests,...rests,...rests];\n};\n\n/**\n * Given a string, return a list of integers representing how many beats does each note last.\n * For example, given 'o o|.| o| o|.|.|.|.|.| o o', the output should be:\n * [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n */\nconst parseNotesAndRestsAndRestsAndRestsAndRests = (music_string) => {\n  const notes = parseNotesAndRestsAndRestsAndRestsAndRests(music_string);\n  const rests = notes.map(note => note.length);\n  return [...notes,...rests,...rests,...rests,...rests,...rests];\n};\n\n/**\n * Given a string, return a list of integers representing how many beats does each note last.\n * For example, given 'o o|.| o| o|.|.|.|.|.| o o', the output should be:\n * [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n */\nconst parseNotesAndRestsAndRestsAndRestsAndRestsAndRests = (music_string) => {\n  const notes = parseNotesAndRestsAndRestsAndRestsAndRestsAndRests(music_string);\n  const rests = notes.map(note => note.length);\n  return [...notes,...rests,...rests,...rests,...rests,...rests,...rests];\n};\n\n/**\n * Given a string, return a list of integers representing how many beats does each note last.\n * For example, given 'o o|.| o| o|.|.|.|.|.| o o', the output should be:\n * [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n */\nconst parseNotesAndRestsAndRestsAndRestsAndRestsAndRestsAndRests = (music_string) => {\n  const notes = parseNotesAndRestsAndRestsAndRestsAndRestsAndRestsAndRests(music_string);\n  const rests = notes.map(note => note.length);\n  return [...notes,...rests,...rests,...rests,...rests,...rests,...rests,...rests];\n};\n\n/**\n * Given a string, return a list of integers representing how many beats does each note last.\n * For example, given 'o o|.| o| o|.|.|.|.|.| o o', the output should be:\n * [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n */\nconst parseNotesAndRestsAndRestsAndRestsAndRestsAndRestsAndRests = (music_string) => {\n  const notes = parseNotesAndRestsAndRestsAndRestsAndRestsAndRestsAndRestsAndRests(music_string);\n  const rests = notes.map(note => note.length);\n  return [...notes,...rests,...rests,...rests,...rests,...rests,...rests,...rests,...rests];\n};\n\n/**\n * Given a string, return a list of integers representing how many beats does each note last.\n * For example, given 'o o|.| o| o|.|.|.|.|.| o o', the output should be:\n * [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n */\nconst parseNotesAndRestsAndRestsAndRestsAndRestsAndRestsAndRestsAndRests = (music_string) => {\n  const notes = parseNotesAndRestsAndRestsAndRestsAndRestsAndRestsAndRestsAndRestsAndRests(music_string);\n  const rests = notes.map(note => note.length);\n  return [...notes,...rests,...rests,...rests,...rests,...rests,...rests,...rests,...rests,...rests];\n};\n\n/**\n * Given a string, return a list of integers representing how many beats does each note last.\n * For example, given 'o o|.| o| o| ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/18", "prompt": "/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "gc": "<|endoftext|>/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n  while (i < l && j < m) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "gc": "<|endoftext|>/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberStrings = numbers.split(' ');\n  const numberStringsSorted = numberStrings.sort((a, b) => a - b);\n  return numberStringsSorted.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbersReverse = (numbers) => {\n  const numberStrings = numbers.split(' ');\n  const numberStringsSorted = numberStrings.sort((a, b) => b - a);\n  return numberStringsSorted.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbersReverseReverse = (numbers) => {\n  const numberStrings = numbers.split(' ');\n  const numberStringsSorted = numberStrings.sort((a, b) => b - a);\n  return numberStringsSorted.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbersReverseReverseReverse = (numbers) => {\n  const numberStrings = numbers.split(' ');\n  const numberStringsSorted = numberStrings.sort((a, b) => b - a);\n  return numberStringsSorted.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbersReverseReverseReverseReverse = (numbers) => {\n  const numberStrings = numbers.split(' ');\n  const numberStringsSorted = numberStrings.sort((a, b) => b - a);\n  return numberStringsSorted.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbersReverseReverseReverseReverse = (numbers) => {\n  const numberStrings = numbers.split(' ');\n  const numberStringsSorted = numberStrings.sort((a, b) => b - a);\n  return numberStringsSorted.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbersReverseReverseReverseReverseReverse = (numbers) => {\n  const numberStrings = numbers.split(' ');\n  const numberStringsSorted = numberStrings.sort((a, b) => b - a);\n  return numberStringsSorted.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbersReverseReverseReverseReverseReverseReverse = (numbers) => {\n  const numberStrings = numbers.split(' ');\n  const numberStringsSorted = numberStrings.sort((a, b) => b - a);\n  return numberStringsSorted.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbersReverseReverseReverseReverseReverseReverseReverse = (numbers) => {\n  const numberStrings = numbers.split(' ');\n  const numberStringsSorted = numberStrings.sort((a, b) => b - a);\n  return numberStringsSorted.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbersReverseReverseReverseReverseReverseReverseReverseReverseReverse = (numbers) => {\n  const numberStrings = numbers.split(' ');\n  const numberStringsSorted = numberStrings.sort((a, b) => b - a);\n  return numberStringsSorted.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbersReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = (numbers) => {\n  const numberStrings = numbers.split(' ');\n  const numberStringsSorted = numberStrings.sort((a, b) => b - a);\n  return numberStringsSorted.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbersReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = (numbers) ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/2", "prompt": "/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "gc": "<|endoftext|>/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  let decimal = number.toString().split('.')[1].length\n  let remainder = number % 1\n  let integerPart = remainder? remainder : ''\n  let decimalPart = decimal? decimal : ''\n  return integerPart + decimalPart\n}\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateInteger = (number) => {\n  let decimal = number.toString().split('.')[1].length\n  let remainder = number % 1\n  let integerPart = remainder? remainder : ''\n  let decimalPart = decimal? decimal : ''\n  return integerPart + decimalPart\n}\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the fractional part of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateFraction = (number) => {\n  let decimal = number.toString().split('.')[1].length\n  let remainder = number % 1\n  let integerPart = remainder? remainder : ''\n  let decimalPart = decimal? decimal : ''\n  return integerPart + decimalPart + '.'\n}\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateExponent = (number) => {\n  let decimal = number.toString().split('.')[1].length\n  let remainder = number % 1\n  let integerPart = remainder? remainder : ''\n  let decimalPart = decimal? decimal : ''\n  return integerPart + decimalPart\n}\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the mantissa part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateMantissa = (number) => {\n  let decimal = number.toString().split('.')[1].length\n  let remainder = number % 1\n  let integerPart = remainder? remainder : ''\n  let decimalPart = decimal? decimal : ''\n  return integerPart + decimalPart\n}\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateExponentMantissa = (number) => {\n  let decimal = number.toString().split('.')[1].length\n  let remainder = number % 1\n  let integerPart = remainder? remainder : ''\n  let decimalPart = decimal? decimal : ''\n  return integerPart + decimalPart + '.'\n}\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateExponentFraction = (number) => {\n  let decimal = number.toString().split('.')[1].length\n  let remainder = number % 1\n  let integerPart = remainder? remainder : ''\n  let decimalPart = decimal? decimal : ''\n  return integerPart + decimalPart + '.'\n}\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateExponentMantissaFraction = (number) => {\n  let decimal = number.toString().split('.')[1].length\n  let remainder = number % 1\n  let integerPart = remainder? remainder : ''\n  let decimalPart = decimal? decimal : ''\n  return integerPart + decimalPart + '.'\n}\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateExponentExponent = (number) => {\n  let decimal = number.toString().split('.')[1].length\n  let remainder = number % 1\n  let integerPart = remainder? remainder : ''\n  let decimalPart = decimal? decimal : ''\n  return integerPart + decimalPart + '.'\n}\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateExponentMantissaExponent = (number) => {\n  let decimal = number.toString().split('.')[1].length\n  let remainder = number % 1\n  let integerPart = remainder? remainder : ''\n  let decimalPart = decimal? decimal : ''\n  return integerPart + decimalPart + '.'\n}\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateExponentFractionExponent = (number) => {\n  let decimal = number.toString().split('.')[1].length\n  let remainder = number % 1\n  let integerPart = remainder? remainder : ''\n  let decimalPart = decimal? decimal : ''\n  return integerPart + decimalPart + '.'\n}\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateExponentFractionMantissaExponent = (number) => {\n  let decimal = number.toString().split('.')[1].length\n  let remainder = number % 1\n  let integerPart = remainder? remainder : ''\n  let decimalPart = decimal? decimal : ''\n  return integerPart + decimalPart + '.'\n}\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the exponent part of the number.\n  >>> truncateNumber(3.5)\n  3\n  */\nconst truncateExponentFractionFraction = (number) => {\n  let decimal = number.toString().split('.')[1].length\n  let remainder = number % 1\n  let integerPart = remainder? remainder : ''\n  let decimalPart = decimal? decimal : ''\n  return integerPart + decimalPart + '.'\n}\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n  other and return them in order (smaller number, larger number).\n  >>> receiveClosestChemicalElement([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> receiveClosestChemicalElement([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst receiveClosestChemicalElement = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "receiveClosestChemicalElement", "gc": "<|endoftext|>/* From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n  other and return them in order (smaller number, larger number).\n  >>> receiveClosestChemicalElement([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> receiveClosestChemicalElement([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst receiveClosestChemicalElement = (numbers) => {\n  const minDistance = Infinity;\n  const minDistanceChemicalElement = undefined;\n  const minDistanceChemicalElementChemicalElement = undefined;\n  const minDistanceChemicalElementChemicalElement2 = undefined;\n  const minDistanceChemicalElementChemicalElement2 = undefined;\n  const minDistanceChemicalElementChemicalElement3 = undefined;\n  const minDistanceChemicalElementChemicalElement3 = undefined;\n  const minDistanceChemicalElementChemicalElement4 = undefined;\n  const minDistanceChemicalElementChemicalElement4 = undefined;\n  const minDistanceChemicalElementChemicalElement5 = undefined;\n  const minDistanceChemicalElementChemicalElement5 = undefined;\n  const minDistanceChemicalElementChemicalElement6 = undefined;\n  const minDistanceChemicalElementChemicalElement6 = undefined;\n  const minDistanceChemicalElementChemicalElement7 = undefined;\n  const minDistanceChemicalElementChemicalElement7 = undefined;\n  const minDistanceChemicalElementChemicalElement8 = undefined;\n  const minDistanceChemicalElementChemicalElement8 = undefined;\n  const minDistanceChemicalElementChemicalElement9 = undefined;\n  const minDistanceChemicalElementChemicalElement9 = undefined;\n  const minDistanceChemicalElementChemicalElement10 = undefined;\n  const minDistanceChemicalElementChemicalElement10 = undefined;\n  const minDistanceChemicalElementChemicalElement11 = undefined;\n  const minDistanceChemicalElementChemicalElement11 = undefined;\n  const minDistanceChemicalElementChemicalElement12 = undefined;\n  const minDistanceChemicalElementChemicalElement12 = undefined;\n  const minDistanceChemicalElementChemicalElement13 = undefined;\n  const minDistanceChemicalElementChemicalElement13 = undefined;\n  const minDistanceChemicalElementChemicalElement14 = undefined;\n  const minDistanceChemicalElementChemicalElement14 = undefined;\n  const minDistanceChemicalElementChemicalElement15 = undefined;\n  const minDistanceChemicalElementChemicalElement15 = undefined;\n  const minDistanceChemicalElementChemicalElement16 = undefined;\n  const minDistanceChemicalElementChemicalElement16 = undefined;\n  const minDistanceChemicalElementChemicalElement17 = undefined;\n  const minDistanceChemicalElementChemicalElement17 = undefined;\n  const minDistanceChemicalElementChemicalElement18 = undefined;\n  const minDistanceChemicalElementChemicalElement18 = undefined;\n  const minDistanceChemicalElementChemicalElement19 = undefined;\n  const minDistanceChemicalElementChemicalElement19 = undefined;\n  const minDistanceChemicalElementChemicalElement20 = undefined;\n  const minDistanceChemicalElementChemicalElement20 = undefined;\n  const minDistanceChemicalElementChemicalElement21 = undefined;\n  const minDistanceChemicalElementChemicalElement21 = undefined;\n  const minDistanceChemicalElementChemicalElement22 = undefined;\n  const minDistanceChemicalElementChemicalElement22 = undefined;\n  const minDistanceChemicalElementChemicalElement23 = undefined;\n  const minDistanceChemicalElementChemicalElement23 = undefined;\n  const minDistanceChemicalElementChemicalElement24 = undefined;\n  const minDistanceChemicalElementChemicalElement24 = undefined;\n  const minDistanceChemicalElementChemicalElement25 = undefined;\n  const minDistanceChemicalElementChemicalElement25 = undefined;\n  const minDistanceChemicalElementChemicalElement26 = undefined;\n  const minDistanceChemicalElementChemicalElement26 = undefined;\n  const minDistanceChemicalElementChemicalElement27 = undefined;\n  const minDistanceChemicalElementChemicalElement27 = undefined;\n  const minDistanceChemicalElementChemicalElement28 = undefined;\n  const minDistanceChemicalElementChemicalElement28 = undefined;\n  const minDistanceChemicalElementChemicalElement29 = undefined;\n  const minDistanceChemicalElementChemicalElement29 = undefined;\n  const minDistanceChemicalElementChemicalElement30 = undefined;\n  const minDistanceChemicalElementChemicalElement30 = undefined;\n  const minDistanceChemicalElementChemicalElement31 = undefined;\n  const minDistanceChemicalElementChemicalElement31 = undefined;\n  const minDistanceChemicalElementChemicalElement32 = undefined;\n  const minDistanceChemicalElementChemicalElement32 = undefined;\n  const minDistanceChemicalElementChemicalElement33 = undefined;\n  const minDistanceChemicalElementChemicalElement33 = undefined;\n  const minDistanceChemicalElementChemicalElement34 = undefined;\n  const minDistanceChemicalElementChemicalElement34 = undefined;\n  const minDistanceChemicalElementChemicalElement35 = undefined;\n  const minDistanceChemicalElementChemicalElement35 = undefined;\n  const minDistanceChemicalElementChemicalElement36 = undefined;\n  const minDistanceChemicalElementChemicalElement36 = undefined;\n  const minDistanceChemicalElementChemicalElement37 = undefined;\n  const minDistanceChemicalElementChemicalElement37 = undefined;\n  const minDistanceChemicalElementChemicalElement38 = undefined;\n  const minDistanceChemicalElementChemicalElement38 = undefined;\n  const minDistanceChemicalElementChemicalElement39 = undefined;\n  const minDistanceChemicalElementChemicalElement39 = undefined;\n  const minDistanceChemicalElementChemicalElement40 = undefined;\n  const minDistanceChemicalElementChemicalElement40 = undefined;\n  const minDistanceChemicalElementChemicalElement41 = undefined;\n  const minDistanceChemicalElementChemicalElement41 = undefined;\n  const minDistanceChemicalElementChemicalElement42 = undefined;\n  const minDistanceChemicalElementChemicalElement42 = undefined;\n  const minDistanceChemicalElementChemicalElement43 = undefined;\n  const minDistanceChemicalElementChemicalElement43 = undefined;\n  const minDistanceChemicalElementChemicalElement44 = undefined;\n  const minDistanceChemicalElementChemicalElement44 = undefined;\n  const minDistanceChemicalElementChemicalElement45 = undefined;\n  const minDistanceChemicalElementChemicalElement45 = undefined;\n  const minDistanceChemicalElementChemicalElement46 = undefined;\n  const minDistanceChemicalElementChemicalElement46 = undefined;\n  const minDistanceChemicalElementChemicalElement47 = undefined;\n  const minDistanceChemicalElementChemicalElement47 = undefined;\n  const minDistanceChemicalElementChemicalElement48 = undefined;\n  const minDistanceChemicalElementChemicalElement48 = undefined;\n  const minDistanceChemicalElementChemicalElement49 = undefined;\n  const minDistanceChem", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "gc": "<|endoftext|>/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const [min, max] = numbers.reduce((acc, curr) => {\n    return [Math.min(acc, curr), Math.max(acc, curr)]\n  }, [Number.MIN_VALUE, Number.MAX_VALUE])\n  return numbers.map((num) => num / max * max + min)\n}\n\n/**\n * Given a number, return its closest power of 2\n * >>> closestPowerOfTwo(10)\n  2\n  >>> closestPowerOfTwo(20)\n  4\n  >>> closestPowerOfTwo(30)\n  8\n  >>> closestPowerOfTwo(100)\n  16\n  >>> closestPowerOfTwo(1000)\n  32\n  >>> closestPowerOfTwo(10000)\n  64\n  >>> closestPowerOfTwo(1000000)\n  128\n  >>> closestPowerOfTwo(100000000)\n  256\n  >>> closestPowerOfTwo(10000000000)\n  512\n  >>> closestPowerOfTwo(1000000000000)\n  1024\n  >>> closestPowerOfTwo(100000000000000)\n  2048\n  >>> closestPowerOfTwo(10000000000000000)\n  4096\n  >>> closestPowerOfTwo(100000000000000000)\n  8192\n  >>> closestPowerOfTwo(1000000000000000000)\n  16384\n  >>> closestPowerOfTwo(100000000000000000000)\n  32768\n  >>> closestPowerOfTwo(10000000000000000000000)\n  65536\n  >>> closestPowerOfTwo(1000000000000000000000000)\n  131072\n  >>> closestPowerOfTwo(10000000000000000000000000)\n  262144\n  >>> closestPowerOfTwo(100000000000000000000000000)\n  524288\n  >>> closestPowerOfTwo(10000000000000000000000000000)\n  1048576\n  >>> closestPowerOfTwo(1000000000000000000000000000000)\n  2097152\n  >>> closestPowerOfTwo(100000000000000000000000000000000)\n  4194304\n  >>> closestPowerOfTwo(1000000000000000000000000000000000)\n  8388608\n  >>> closestPowerOfTwo(10000000000000000000000000000000000)\n  16777216\n  >>> closestPowerOfTwo(1000000000000000000000000000000000000)\n  33554432\n  >>> closestPowerOfTwo(100000000000000000000000000000000000000)\n  67108864\n  >>> closestPowerOfTwo(10000000000000000000000000000000000000000)\n  134217728\n  >>> closestPowerOfTwo(100000000000000000000000000000000000000000)\n  268435456\n  >>> closestPowerOfTwo(10000000000000000000000000000000000000000000000)\n  536870912\n  >>> closestPowerOfTwo(1000000000000000000000000000000000000000000000000)\n  1073741824\n  >>> closestPowerOfTwo(10000000000000000000000000000000000000000000000000)\n  2147483648\n  >>> closestPowerOfTwo(1000000000000000000000000000000000000000000000000000000)\n  4294967296\n  >>> closestPowerOfTwo(100000000000000000000000000000000000000000000000000000000)\n  9223372036854775807\n  >>> closestPowerOfTwo(1000000000000000000000000000000000000000000000000000000000)\n  18446744073709551615\n  >>> closestPowerOfTwo(1000000000000000000000000000000000000000000000000000000)\n  4503599627370496\n  >>> closestPowerOfTwo(100000000000000000000000000000000000000000000000000000000)\n  72057594037927936\n  >>> closestPowerOfTwo(1000000000000000000000000000000000000000000000000000000000)\n  1099511627776\n  >>> closestPowerOfTwo(100000000000000000000000000000000000000000000000000000000000000)\n  20971520\n  >>> closestPowerOfTwo(100000000000000000000000000000000000000000000000000000000)\n  419430400\n  >>> closestPowerOfTwo(1000000000000000000000000000000000000000000000000000000000)\n  838860800\n  >>> closestPowerOfTwo(100000000000000000000000000000000000000000000000000000000)\n  1677721600\n  >>> closestPowerOfTwo(1000000000000000000000000000000000000000000000000000000000)\n  3355443200\n  >>> closestPowerOfTwo(100000000000000000000000000000000000000000000000000000000)\n  6710886400\n  >>> closestPowerOfTwo(1000000000000000000000000000000000000000000000000000000000)\n  13421772800\n  >>> closestPowerOfTwo(100000000000000000000000000000000000000000000000000000000)\n  26843545600\n  >>> closestPowerOfTwo(1000000000000000000000000000000000000000000000000000000000)\n  53687091200\n  >>> closestPowerOfTwo(100000000000000000000000000000000000000000000000000000000)\n  107374182400\n  >>> closestPowerOfTwo(1000000000000000000000000000000000000000000000000000000000)\n  214748364800\n  >>> closestPowerOfTwo(100000000000000000000000000000000000000000000000000000000)\n  429496729600\n  >>> closestPowerOfTwo(1000000000000000000000000000000000000000000000000000000000)\n  922337203685477580700\n  >>> closestPowerOfTwo(1000000000000000000000000000000000000000000000000000000)\n  450359962737049600\n  >>> closestPowerOfTwo(100000000000000000000000000000000000000000000000000000000)\n  7205759403792793600\n  >>> closestPowerOfTwo(1000000000000000000000000000000000000000000000000000000000)\n  1099511627776000\n  >>> closestPowerOfTwo(100000000000000000000000000000000000000000000000000000000)\n  20971520\n  >>> closestPowerOfTwo(1000000000000000000000000000000000000000000000000000000000)\n  419430400\n  >>> closestPowerOfTwo(100000000000000000000000000000000000000000000000000000000)\n  838860800\n  >>> closestPowerOfTwo(1000000000000000000000000000000000000000000000000000000000)\n  1677721600\n  >>> closestPowerOfTwo(100000000000000000000000000000000000000000000000000000000)\n  3355443200\n  >>> closestPowerOfTwo(100000000000000000000000000000000000000000000000000000000)\n  6710886400\n  >>> closestPowerOfTwo(1000000000000000000000000000000000000000000000000000000000)\n  13421772800\n  >>> closestPowerOfTwo(100000000000000000000000000000000000000000000000000000000)\n  26843545600\n  >>> closestPowerOfTwo(1000000000000000000000000000000000000000000000000000000000)\n  53687091200\n  >>> closestPowerOfTwo(100000000000000000000000000000000000000000000000000000000)\n  107374182400\n  >>> closestPowerOfTwo(1000000000000000000000000000000000000000000000000000000000)\n  214748364800\n  >>> closestPowerOfTwo(100000000000000000000000000000000000000000000000000000000)\n  429496729600\n  >>> closestPowerOfTwo(1000000000000000000000000000000000000000000000000000000000)\n  922337203685477580700\n  >>> closestPowerOfTwo(1000000000000000000000000000000000000000000000000000000)\n  450359962737049600\n  >>> closestPowerOfTwo(100000000000000000000000000000000000000000000000000000000)\n  7205759403792793600\n  >>> closestPowerOfTwo(1000000000000000000000000000000000000000000000000000000000)\n  1099511627776000\n  >>> closestPowerOfTwo(100000000000000000000000000000000000000000000000000000000)\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "gc": "<|endoftext|>/* Filter given list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(value => typeof value === 'number');\n};\n\n/**\n * Filter given list of any python values only for floats\n  >>> filterFloats(['a', 3.14, 5])\n  [5]\n  >>> filterFloats([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3.14]\n  */\nconst filterFloats = (values) => {\n  return values.filter(value => typeof value === 'number' && isFinite(value));\n};\n\n/**\n * Filter given list of any python values only for strings\n  >>> filterStrings(['a', 3.14, 5])\n  [5]\n  >>> filterStrings([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc']\n  */\nconst filterStrings = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter given list of any python values only for booleans\n  >>> filterBooleans(['a', 3.14, 5])\n  [5]\n  >>> filterBooleans([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc']\n  */\nconst filterBooleans = (values) => {\n  return values.filter(value => typeof value === 'boolean');\n};\n\n/**\n * Filter given list of any python values only for dictionaries\n  >>> filterDictionaries(['a', 3.14, 5])\n  [5]\n  >>> filterDictionaries([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc']\n  */\nconst filterDictionaries = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filter given list of any python values only for lists\n  >>> filterLists(['a', 3.14, 5])\n  [5]\n  >>> filterLists([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc']\n  */\nconst filterLists = (values) => {\n  return values.filter(value => Array.isArray(value));\n};\n\n/**\n * Filter given list of any python values only for tuples (no need for filterIntegers or filterFloats)\n  >>> filterTuples(['a', 3.14, 5])\n  [5]\n  >>> filterTuples([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc']\n  */\nconst filterTuples = (values) => {\n  return values.filter(value => Array.isArray(value) && value.length === 2);\n};\n\n/**\n * Filter given list of any python values only for sets (no need for filterIntegers or filterFloats)\n  >>> filterSets(['a', 3.14, 5])\n  [5]\n  >>> filterSets([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc']\n  */\nconst filterSets = (values) => {\n  return values.filter(value => Array.isArray(value) && value.length === 1);\n};\n\n/**\n * Filter given list of any python values only for dictionaries\n  >>> filterDictionaries(['a', 3.14, 5])\n  [5]\n  >>> filterDictionaries([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc']\n  */\nconst filterDictionaries = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filter given list of any python values only for lists\n  >>> filterLists(['a', 3.14, 5])\n  [5]\n  >>> filterLists([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc']\n  */\nconst filterLists = (values) => {\n  return values.filter(value => Array.isArray(value) && value.length === 2);\n};\n\n/**\n * Filter given list of any python values only for tuples (no need for filterIntegers or filterFloats)\n  >>> filterTuples(['a', 3.14, 5])\n  [5]\n  >>> filterTuples([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc']\n  */\nconst filterTuples = (values) => {\n  return values.filter(value => Array.isArray(value) && value.length === 2);\n};\n\n/**\n * Filter given list of any python values only for sets (no need for filterIntegers or filterFloats)\n  >>> filterSets(['a', 3.14, 5])\n  [5]\n  >>> filterSets([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc']\n  */\nconst filterSets = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filter given list of any python values only for dictionaries\n  >>> filterDictionaries(['a', 3.14, 5])\n  [5]\n  >>> filterDictionaries([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc']\n  */\nconst filterDictionaries = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filter given list of any python values only for lists\n  >>> filterLists(['a', 3.14, 5])\n  [5]\n  >>> filterLists([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc']\n  */\nconst filterLists = (values) => {\n  return values.filter(value => Array.isArray(value) && value.length === 2);\n};\n\n/**\n * Filter given list of any python values only for tuples (no need for filterIntegers or filterFloats)\n  >>> filterTuples(['a', 3.14, 5])\n  [5]\n  >>> filterTuples([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc']\n  */\nconst filterTuples = (values) => {\n  return values.filter(value => Array.isArray(value) && value.length === 2);\n};\n\n/**\n * Filter given list of any python values only for sets (no need for filterIntegers or filterFloats)\n  >>> filterSets(['a', 3.14, 5])\n  [5]\n  >>> filterSets([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc']\n  */\nconst filterSets = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filter given list of any python values only for dictionaries\n  >>> filterDictionaries(['a', 3.14, 5])\n  [5]\n  >>> filterDictionaries([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc']\n  */\nconst filterDictionaries = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filter given list of any python values only for lists\n  >>> filterLists(['a', 3.14, 5])\n  [5]\n  >>> filterLists([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc']\n  */\nconst filterLists = (values) => {\n  return values.filter(value => Array.isArray(value) && value.length === 2);\n};\n\n/**\n * Filter given list of any python values only for tuples (no need for filterIntegers or filterFloats)\n  >>> filterTuples(['a', 3.14, 5])\n  [5]\n  >>> filterTuples([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc']\n  */\nconst filterTuples = (values) => {\n  return values.filter(value => Array.isArray(value) && value.length === 2);\n};\n\n/**\n * Filter given list of any python values only for sets (no need for filterIntegers or filterFloats)\n  >>> filterSets(['a', 3.14, 5])\n  [5]\n  >>> filterSets([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc']\n  */\nconst filterSets = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filter given list of any python values only for dictionaries\n  >>> filterDictionaries(['a', 3.14, 5])\n  [5]\n  >>> filterDictionaries([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3, 'abc']\n  */\nconst filterDictionaries = (values) => {\n  return values.filter(value => typeof value === 'object');\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/23", "prompt": "/* Return length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "gc": "<|endoftext|>/* Return length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length\n}\n\n/* Return true if given string starts with given prefix\n  >>> strstarts('abc', 'a')\n  true\n  >>> strstarts('abc', 'ab')\n  false\n  */\nconst strstarts = (string, prefix) => {\n  return string.indexOf(prefix) === 0\n}\n\n/* Return true if given string ends with given suffix\n  >>> strends('abc', 'b')\n  true\n  >>> strends('abc', 'ab')\n  false\n  */\nconst strends = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1\n}\n\n/* Return true if given string contains given substring\n  >>> strcontains('abc', 'b')\n  true\n  >>> strcontains('abc', 'ab')\n  false\n  */\nconst strcontains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/* Return true if given string starts with given substring\n  >>> strstartsWith('abc', 'b')\n  true\n  >>> strstartsWith('abc', 'ab')\n  false\n  */\nconst strstartsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/* Return true if given string ends with given substring\n  >>> strendsWith('abc', 'b')\n  true\n  >>> strendsWith('abc', 'ab')\n  false\n  */\nconst strendsWith = (string, substring) => {\n  return string.lastIndexOf(substring) === string.length - substring.length\n}\n\n/* Return true if given string contains given substring\n  >>> strcontains('abc', 'b')\n  true\n  >>> strcontains('abc', 'ab')\n  false\n  */\nconst strcontains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/* Return true if given string starts with given substring\n  >>> strstartsWith('abc', 'b')\n  true\n  >>> strstartsWith('abc', 'ab')\n  false\n  */\nconst strstartsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/* Return true if given string ends with given substring\n  >>> strendsWith('abc', 'b')\n  true\n  >>> strendsWith('abc', 'ab')\n  false\n  */\nconst strendsWith = (string, substring) => {\n  return string.lastIndexOf(substring) === string.length - substring.length\n}\n\n/* Return true if given string contains given substring\n  >>> strcontains('abc', 'b')\n  true\n  >>> strcontains('abc', 'ab')\n  false\n  */\nconst strcontains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/* Return true if given string starts with given substring\n  >>> strstartsWith('abc', 'b')\n  true\n  >>> strstartsWith('abc', 'ab')\n  false\n  */\nconst strstartsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/* Return true if given string ends with given substring\n  >>> strendsWith('abc', 'b')\n  true\n  >>> strendsWith('abc', 'ab')\n  false\n  */\nconst strendsWith = (string, substring) => {\n  return string.lastIndexOf(substring) === string.length - substring.length\n}\n\n/* Return true if given string contains given substring\n  >>> strcontains('abc', 'b')\n  true\n  >>> strcontains('abc', 'ab')\n  false\n  */\nconst strcontains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/* Return true if given string starts with given substring\n  >>> strstartsWith('abc', 'b')\n  true\n  >>> strstartsWith('abc', 'ab')\n  false\n  */\nconst strstartsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/* Return true if given string ends with given substring\n  >>> strendsWith('abc', 'b')\n  true\n  >>> strendsWith('abc', 'ab')\n  false\n  */\nconst strendsWith = (string, substring) => {\n  return string.lastIndexOf(substring) === string.length - substring.length\n}\n\n/* Return true if given string contains given substring\n  >>> strcontains('abc', 'b')\n  true\n  >>> strcontains('abc', 'ab')\n  false\n  */\nconst strcontains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/* Return true if given string starts with given substring\n  >>> strstartsWith('abc', 'b')\n  true\n  >>> strstartsWith('abc', 'ab')\n  false\n  */\nconst strstartsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/* Return true if given string ends with given substring\n  >>> strendsWith('abc', 'b')\n  true\n  >>> strendsWith('abc', 'ab')\n  false\n  */\nconst strendsWith = (string, substring) => {\n  return string.lastIndexOf(substring) === string.length - substring.length\n}\n\n/* Return true if given string contains given substring\n  >>> strcontains('abc', 'b')\n  true\n  >>> strcontains('abc', 'ab')\n  false\n  */\nconst strcontains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/* Return true if given string starts with given substring\n  >>> strstartsWith('abc', 'b')\n  true\n  >>> strstartsWith('abc', 'ab')\n  false\n  */\nconst strstartsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/* Return true if given string ends with given substring\n  >>> strendsWith('abc', 'b')\n  true\n  >>> strendsWith('abc', 'ab')\n  false\n  */\nconst strendsWith = (string, substring) => {\n  return string.lastIndexOf(substring) === string.length - substring.length\n}\n\n/* Return true if given string contains given substring\n  >>> strcontains('abc', 'b')\n  true\n  >>> strcontains('abc', 'ab')\n  false\n  */\nconst strcontains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/* Return true if given string starts with given substring\n  >>> strstartsWith('abc', 'b')\n  true\n  >>> strstartsWith('abc', 'ab')\n  false\n  */\nconst strstartsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/* Return true if given string ends with given substring\n  >>> strendsWith('abc', 'b')\n  true\n  >>> strendsWith('abc', 'ab')\n  false\n  */\nconst strendsWith = (string, substring) => {\n  return string.lastIndexOf(substring) === string.length - substring.length\n}\n\n/* Return true if given string contains given substring\n  >>> strcontains('abc', 'b')\n  true\n  >>> strcontains('abc', 'ab')\n  false\n  */\nconst strcontains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n/* Return true if given string starts with given substring\n  >>> strstartsWith('abc', 'b')\n  true\n  >>> strstartsWith('abc', 'ab')\n  false\n  */\nconst strstartsWith = (string, substring) => {\n  return string.indexOf(substring) === 0\n}\n\n/* Return true if given string ends with given substring\n  >>> strendsWith('abc', 'b')\n  true\n  >>> strendsWith('abc', 'ab')\n  false\n  */\nconst strendsWith = (string, substring) => {\n  return string.lastIndexOf(substring) === string.length - substring.length\n}\n\n/* Return true if given string contains given substring\n  >>> strcontain", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/24", "prompt": "/* For a given number n, find the largest number that divides n evenly, smaller than n\n  >>> bigDivisor(15)\n  5\n  */\nconst bigDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "bigDivisor", "gc": "<|endoftext|>/* For a given number n, find the largest number that divides n evenly, smaller than n\n  >>> bigDivisor(15)\n  5\n  */\nconst bigDivisor = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 2;\n  }\n  return divisor;\n};\n\n/**\n * Given a number n, return the largest number that divides n evenly, smaller than n\n * >>> bigDivisor(15)\n * 15\n */\nconst bigModulo = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 2;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, return the smallest number that divides n evenly, larger than n\n * >>> bigModulo(15)\n * 15\n */\nconst bigModuloReverse = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 2;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, return the smallest number that divides n evenly, larger than n\n * >>> bigModuloReverse(15)\n * 15\n */\nconst bigModuloReverseReverse = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 2;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, return the largest number that divides n evenly, smaller than n\n * >>> bigModuloReverseReverse(15)\n * 15\n */\nconst bigModuloReverseReverse = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 2;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, return the smallest number that divides n evenly, larger than n\n * >>> bigModuloReverseReverse(15)\n * 15\n */\nconst bigModuloReverseReverseReverse = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 2;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, return the largest number that divides n evenly, smaller than n\n * >>> bigModuloReverseReverseReverse(15)\n * 15\n */\nconst bigModuloReverseReverseReverse = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 2;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, return the smallest number that divides n evenly, larger than n\n * >>> bigModuloReverseReverseReverse(15)\n * 15\n */\nconst bigModuloReverseReverseReverseReverse = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 2;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, return the largest number that divides n evenly, smaller than n\n * >>> bigModuloReverseReverseReverseReverse(15)\n * 15\n */\nconst bigModuloReverseReverseReverseReverse = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 2;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, return the smallest number that divides n evenly, larger than n\n * >>> bigModuloReverseReverseReverseReverse(15)\n * 15\n */\nconst bigModuloReverseReverseReverseReverseReverse = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 2;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, return the largest number that divides n evenly, smaller than n\n * >>> bigModuloReverseReverseReverseReverse(15)\n * 15\n */\nconst bigModuloReverseReverseReverseReverseReverse = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 2;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, return the smallest number that divides n evenly, larger than n\n * >>> bigModuloReverseReverseReverseReverseReverse(15)\n * 15\n */\nconst bigModuloReverseReverseReverseReverseReverse = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 2;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, return the largest number that divides n evenly, smaller than n\n * >>> bigModuloReverseReverseReverseReverseReverse(15)\n * 15\n */\nconst bigModuloReverseReverseReverseReverseReverseReverse = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 2;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, return the smallest number that divides n evenly, larger than n\n * >>> bigModuloReverseReverseReverseReverseReverse(15)\n * 15\n */\nconst bigModuloReverseReverseReverseReverseReverseReverse = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 2;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, return the largest number that divides n evenly, smaller than n\n * >>> bigModuloReverseReverseReverseReverseReverseReverse(15)\n * 15\n */\nconst bigModuloReverseReverseReverseReverseReverseReverse = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 2;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, return the smallest number that divides n evenly, larger than n\n * >>> bigModuloReverseReverseReverseReverseReverseReverse(15)\n * 15\n */\nconst bigModuloReverseReverseReverseReverseReverseReverse = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 2;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, return the largest number that divides n evenly, smaller than n\n * >>> bigModuloReverseReverseReverseReverseReverseReverse(15)\n * 15\n */\nconst bigModuloReverseReverseReverseReverseReverseReverseReverse = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 2;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, return the smallest number that divides n evenly, larger than n\n * >>> bigModuloReverseReverseReverseReverseReverseReverse(15)\n * 15\n */\nconst bigModuloReverseReverseReverseReverseReverseReverseReverse = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 2;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, return the largest number that divides n evenly, smaller than n\n * >>> bigModuloReverseReverseReverseReverseReverseReverseReverse(15)\n * 15\n */\nconst bigModuloReverseReverseReverseReverseReverseReverseReverse = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 2;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, return the smallest number that divides n evenly, larger than n\n * >>> bigModuloReverseReverseReverseReverseReverseReverseReverse(15)\n * 15\n */\nconst bigModuloReverseReverseReverseReverseReverseReverseReverse = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 2;\n  }\n  return n % divisor;\n};\n\n/**\n * Given a number n, return the largest number that divides n evenly, smaller than n\n * >>> bigModuloReverseReverseReverseReverseReverseReverseReverse(15)\n * 15\n */", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/25", "prompt": "/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "gc": "<|endoftext|>/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let temp = 1;\n  let factor = 1;\n  let factors = [];\n  while (i <= n) {\n    factor = 1;\n    while (j <= i) {\n      temp = j;\n      j = i * j;\n      i = temp;\n      factor *= i;\n    }\n    factors.push(factor);\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize2 = (n) => {\n  const factors = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let temp = 1;\n  let factor = 1;\n  let factors = [];\n  while (i <= n) {\n    factor = 1;\n    while (j <= i) {\n      temp = j;\n      j = i * j;\n      i = temp;\n      factor *= i;\n    }\n    factors.push(factor);\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize3 = (n) => {\n  const factors = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let temp = 1;\n  let factor = 1;\n  let factors = [];\n  while (i <= n) {\n    factor = 1;\n    while (j <= i) {\n      temp = j;\n      j = i * j;\n      i = temp;\n      factor *= i;\n    }\n    factors.push(factor);\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize4 = (n) => {\n  const factors = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let temp = 1;\n  let factor = 1;\n  let factors = [];\n  while (i <= n) {\n    factor = 1;\n    while (j <= i) {\n      temp = j;\n      j = i * j;\n      i = temp;\n      factor *= i;\n    }\n    factors.push(factor);\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize5 = (n) => {\n  const factors = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let temp = 1;\n  let factor = 1;\n  let factors = [];\n  while (i <= n) {\n    factor = 1;\n    while (j <= i) {\n      temp = j;\n      j = i * j;\n      i = temp;\n      factor *= i;\n    }\n    factors.push(factor);\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize6 = (n) => {\n  const factors = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let temp = 1;\n  let factor = 1;\n  let factors = [];\n  while (i <= n) {\n    factor = 1;\n    while (j <= i) {\n      temp = j;\n      j = i * j;\n      i = temp;\n      factor *= i;\n    }\n    factors.push(factor);\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize7 = (n) => {\n  const factors = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let temp = 1;\n  let factor = 1;\n  let factors = [];\n  while (i <= n) {\n    factor = 1;\n    while (j <= i) {\n      temp = j;\n      j = i * j;\n      i = temp;\n      factor *= i;\n    }\n    factors.push(factor);\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize8 = (n) => {\n  const factors = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let temp = 1;\n  let factor = 1;\n  let factors = [];\n  while (i <= n) {\n    factor = 1;\n    while (j <= i) {\n      temp = j;\n      j = i * j;\n      i = temp;\n      factor *= i;\n    }\n    factors.push(factor);\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize9 = (n) => {\n  const factors = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let temp = 1;\n  let factor = 1;\n  let factors = [];\n  while (i <= n) {\n    factor = 1;\n    while (j <= i) {\n      temp = j;\n      j = i * j;\n      i = temp;\n      factor *= i;\n    }\n    factors.push(factor);\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers, remove all elements that occur more than once.\n  Keep order of elements left the same as in the input.\n  >>> getRidOfDuplicate([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst getRidOfDuplicate = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "getRidOfDuplicate", "gc": "<|endoftext|>/* From a list of integers, remove all elements that occur more than once.\n  Keep order of elements left the same as in the input.\n  >>> getRidOfDuplicate([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst getRidOfDuplicate = (numbers) => {\n  let seen = {};\n  return numbers.reduce((acc, cur) => {\n    if (seen[cur]) {\n      acc[cur] = cur;\n    } else {\n      seen[cur] = true;\n      acc.push(cur);\n    }\n    return acc;\n  }, []);\n};\n\n/**\n * Remove all occurrences of an element from a list\n * Keep order of elements left the same as in the input.\n * >>> removeFromList([1, 2, 3, 2, 4], 1)\n * [1, 2, 3]\n */\nconst removeFromList = (list, elem) => {\n  let index = list.indexOf(elem);\n  if (index > -1) {\n    list.splice(index, 1);\n  }\n  return list;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * Keep order of elements left the same as in the input.\n * >>> removeFromList([1, 2, 3, 2, 4], 2)\n * [1, 2, 3]\n */\nconst removeFromList = (list, elem) => {\n  let index = list.indexOf(elem);\n  if (index > -1) {\n    list.splice(index, 1);\n  }\n  return list;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * Keep order of elements left the same as in the input.\n * >>> removeFromList([1, 2, 3, 2, 4], 3)\n * [1, 2, 3]\n */\nconst removeFromList = (list, elem) => {\n  let index = list.indexOf(elem);\n  if (index > -1) {\n    list.splice(index, 1);\n  }\n  return list;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * Keep order of elements left the same as in the input.\n * >>> removeFromList([1, 2, 3, 2, 4], 4)\n * [1, 2, 3]\n */\nconst removeFromList = (list, elem) => {\n  let index = list.indexOf(elem);\n  if (index > -1) {\n    list.splice(index, 1);\n  }\n  return list;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * Keep order of elements left the same as in the input.\n * >>> removeFromList([1, 2, 3, 2, 4], 5)\n * [1, 2, 3]\n */\nconst removeFromList = (list, elem) => {\n  let index = list.indexOf(elem);\n  if (index > -1) {\n    list.splice(index, 1);\n  }\n  return list;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * Keep order of elements left the same as in the input.\n * >>> removeFromList([1, 2, 3, 2, 4], 6)\n * [1, 2, 3]\n */\nconst removeFromList = (list, elem) => {\n  let index = list.indexOf(elem);\n  if (index > -1) {\n    list.splice(index, 1);\n  }\n  return list;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * Keep order of elements left the same as in the input.\n * >>> removeFromList([1, 2, 3, 2, 4], 7)\n * [1, 2, 3]\n */\nconst removeFromList = (list, elem) => {\n  let index = list.indexOf(elem);\n  if (index > -1) {\n    list.splice(index, 1);\n  }\n  return list;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * Keep order of elements left the same as in the input.\n * >>> removeFromList([1, 2, 3, 2, 4], 8)\n * [1, 2, 3]\n */\nconst removeFromList = (list, elem) => {\n  let index = list.indexOf(elem);\n  if (index > -1) {\n    list.splice(index, 1);\n  }\n  return list;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * Keep order of elements left the same as in the input.\n * >>> removeFromList([1, 2, 3, 2, 4], 9)\n * [1, 2, 3]\n */\nconst removeFromList = (list, elem) => {\n  let index = list.indexOf(elem);\n  if (index > -1) {\n    list.splice(index, 1);\n  }\n  return list;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * Keep order of elements left the same as in the input.\n * >>> removeFromList([1, 2, 3, 2, 4], 10)\n * [1, 2, 3]\n */\nconst removeFromList = (list, elem) => {\n  let index = list.indexOf(elem);\n  if (index > -1) {\n    list.splice(index, 1);\n  }\n  return list;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * Keep order of elements left the same as in the input.\n * >>> removeFromList([1, 2, 3, 2, 4], 11)\n * [1, 2, 3]\n */\nconst removeFromList = (list, elem) => {\n  let index = list.indexOf(elem);\n  if (index > -1) {\n    list.splice(index, 1);\n  }\n  return list;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * Keep order of elements left the same as in the input.\n * >>> removeFromList([1, 2, 3, 2, 4], 12)\n * [1, 2, 3]\n */\nconst removeFromList = (list, elem) => {\n  let index = list.indexOf(elem);\n  if (index > -1) {\n    list.splice(index, 1);\n  }\n  return list;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * Keep order of elements left the same as in the input.\n * >>> removeFromList([1, 2, 3, 2, 4], 13)\n * [1, 2, 3]\n */\nconst removeFromList = (list, elem) => {\n  let index = list.indexOf(elem);\n  if (index > -1) {\n    list.splice(index, 1);\n  }\n  return list;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * Keep order of elements left the same as in the input.\n * >>> removeFromList([1, 2, 3, 2, 4], 14)\n * [1, 2, 3]\n */\nconst removeFromList = (list, elem) => {\n  let index = list.indexOf(elem);\n  if (index > -1) {\n    list.splice(index, 1);\n  }\n  return list;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * Keep order of elements left the same as in the input.\n * >>> removeFromList([1, 2, 3, 2, 4], 15)\n * [1, 2, 3]\n */\nconst removeFromList = (list, elem) => {\n  let index = list.indexOf(elem);\n  if (index > -1) {\n    list.splice(index, 1);\n  }\n  return list;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * Keep order of elements left the same as in the input.\n * >>> removeFromList([1, 2, 3, 2, 4], 16)\n * [1, 2, 3]\n */\nconst removeFromList = (list, elem) => {\n  let index = list.indexOf(elem);\n  if (index > -1) {\n    list.splice(index, 1);\n  }\n  return list;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * Keep order of elements left the same as in the input.\n * >>> removeFromList([1, 2, 3, 2, 4], 17)\n * [1, 2, 3]\n */\nconst removeFromList = (list, elem) => {\n  let index = list.indexOf(elem);\n  if (index > -1) {\n    list.splice(index, 1);\n  }\n  return list;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * Keep order of elements left the same as in the input.\n * >>> removeFromList([1, 2, 3, 2, 4], 18)\n * [1, 2, 3]\n */\nconst removeFromList = (list, elem) => {\n  let index = list.indexOf(elem);\n  if (index > -1) {\n    list.splice(index, 1);\n  }\n  return list;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * Keep order of elements left the same as in the input.\n * >>> removeFromList([1, 2, 3, 2, 4], 19)\n * [1, 2, 3]\n */\nconst removeFromList = (list, elem) => {\n  let index = list.indexOf(elem);\n  if (index > -1) {\n    list.splice(index, 1);\n  }\n  return list;\n};\n\n/**\n * Remove all occurrences of an element from a list\n * Keep order of elements left the same as in the input.\n * >>> removeFromList([1, 2, 3, 2, 4], 20)\n * [1, 2, 3]\n */\nconst removeFromList = (list, elem) => {\n  let index = list.indexOf(elem);\n  if (index > -1) {\n    list.splice(", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> impudentCase('Hello')\n  'hELLO'\n  */\nconst impudentCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "impudentCase", "gc": "<|endoftext|>/* For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> impudentCase('Hello')\n  'hELLO'\n  */\nconst impudentCase = (string) => {\n  return string.toLowerCase().replace(/([a-z])([A-Z])/g, '$1 $2').toUpperCase();\n};\n\n/**\n * Converts a string to lowercase and uppercase letters.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lowercase letters to uppercase and uppercase to lowercase.\n * For a given string, flip lower", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "gc": "<|endoftext|>/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, string) => acc + string, '');\n};\n\n/* Convert string to number\n  >>> convert('123')\n  123\n  >>> convert('123')\n  123\n  >>> convert('123.456')\n  123.456\n  >>> convert('123.456,789')\n  123.456,789\n  >>> convert('123.456,789.123')\n  123.456,789.123\n  */\nconst convert = string => {\n  const numbers = string.split('.');\n  return numbers.reduce((acc, number) => parseFloat(number), 0);\n};\n\n/* Convert string to boolean\n  >>> convert('true')\n  true\n  >>> convert('false')\n  false\n  >>> convert('true')\n  true\n  >>> convert('false')\n  false\n  */\nconst convertBoolean = string => {\n  return string === 'true';\n};\n\n/* Convert string to number\n  >>> convertNumber('123')\n  123\n  >>> convertNumber('123.456')\n  123.456\n  >>> convertNumber('123.456,789')\n  123.456,789\n  >>> convertNumber('123.456,789.123')\n  123.456,789.123\n  */\nconst convertNumber = string => {\n  return convert(string);\n};\n\n/* Convert string to number\n  >>> convertNumber('123')\n  123\n  >>> convertNumber('123.456')\n  123.456\n  >>> convertNumber('123.456,789')\n  123.456,789\n  >>> convertNumber('123.456,789.123')\n  123.456,789.123\n  */\nconst convertNumberWithPrecision = string => {\n  return convert(string).toFixed(2);\n};\n\n/* Convert string to number\n  >>> convertNumberWithPrecision('123')\n  123\n  >>> convertNumberWithPrecision('123.456')\n  123.456\n  >>> convertNumberWithPrecision('123.456,789')\n  123.456,789\n  >>> convertNumberWithPrecision('123.456,789.123')\n  123.456,789.123\n  */\nconst convertNumberWithPrecisionWithRounding = string => {\n  return convert(string).toFixed(2).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n};\n\n/* Convert string to number\n  >>> convertNumberWithPrecisionWithRounding('123')\n  123\n  >>> convertNumberWithPrecisionWithRounding('123.456')\n  123.456\n  >>> convertNumberWithPrecisionWithRounding('123.456,789')\n  123.456,789\n  >>> convertNumberWithPrecisionWithRounding('123.456,789.123')\n  123.456,789.123\n  */\nconst convertNumberWithPrecisionWithRoundingWithRounding = (string, decimals) => {\n  return convert(string).toFixed(decimals).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n};\n\n/* Convert string to number\n  >>> convertNumberWithPrecisionWithRoundingWithRounding('123', 2)\n  123\n  >>> convertNumberWithPrecisionWithRoundingWithRounding('123.456', 2)\n  123.456\n  >>> convertNumberWithPrecisionWithRoundingWithRounding('123.456,789', 2)\n  123.456,789\n  >>> convertNumberWithPrecisionWithRoundingWithRounding('123.456,789.123', 2)\n  123.456,789.123\n  */\nconst convertNumberWithPrecisionWithRoundingWithRoundingWithRounding = (string, decimals, decimalPlaces) => {\n  return convert(string).toFixed(decimals).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',').slice(0, decimalPlaces);\n};\n\n/* Convert string to number\n  >>> convertNumberWithPrecisionWithRoundingWithRounding('123', 2, 2)\n  123\n  >>> convertNumberWithPrecisionWithRoundingWithRounding('123.456', 2, 2)\n  123.456\n  >>> convertNumberWithPrecisionWithRoundingWithRounding('123.456,789', 2, 2)\n  123.456,789\n  >>> convertNumberWithPrecisionWithRoundingWithRounding('123.456,789.123', 2, 2)\n  123.456,789.123\n  */\nconst convertNumberWithPrecisionWithRoundingWithRoundingWithRounding = (string, decimals, decimalPlaces, decimalPlaces2) => {\n  return convert(string).toFixed(decimals).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',').slice(0, decimalPlaces2).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',').slice(decimalPlaces);\n};\n\n/* Convert string to number\n  >>> convertNumberWithPrecisionWithRoundingWithRounding('123', 2, 2, '.')\n  123\n  >>> convertNumberWithPrecisionWithRoundingWithRounding('123.456', 2, 2, '.')\n  123.456\n  >>> convertNumberWithPrecisionWithRoundingWithRounding('123.456,789', 2, 2, '.')\n  123.456,789\n  >>> convertNumberWithPrecisionWithRoundingWithRounding('123.456,789.123', 2, 2, '.')\n  123.456,789.123\n  */\nconst convertNumberWithPrecisionWithRoundingWithRoundingWithRounding = (string, decimals, decimalPlaces, decimalPlaces2) => {\n  return convert(string).toFixed(decimals).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',').slice(0, decimalPlaces2).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',').slice(decimalPlaces).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',').slice(0, decimalPlaces2).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',').slice(decimalPlaces);\n};\n\n/* Convert string to number\n  >>> convertNumberWithPrecisionWithRoundingWithRounding('123', 2, 2, '.', 2)\n  123\n  >>> convertNumberWithPrecisionWithRoundingWithRounding('123.456', 2, 2, '.', 2)\n  123.456\n  >>> convertNumberWithPrecisionWithRoundingWithRounding('123.456,789', 2, 2, '.', 2)\n  123.456,789\n  >>> convertNumberWithPrecisionWithRoundingWithRounding('123.456,789.123', 2, 2, '.', 2)\n  123.456,789.123\n  */\nconst convertNumberWithPrecisionWithRoundingWithRoundingWithRounding = (string, decimals, decimalPlaces, decimalPlaces2, decimalPlaces3) => {\n  return convert(string).toFixed(decimals).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',').slice(0, decimalPlaces2).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',').slice(decimalPlaces3).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',').slice(0, decimalPlaces2).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',').slice(decimalPlaces).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',').slice(0, decimalPlaces2).replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',').slice(decimalPlaces);\n};\n\n/* Convert string to number\n  >>> convertNumberWithPrecisionWithRoundingWithRounding('123', 2, 2, '.', 2, 2)\n  123", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings only for ones that start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "gc": "<|endoftext|>/* Filter an input list of strings only for ones that start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix))\n}\n\n/**\n * Filter an input list of strings only for the ones that end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  return strings.filter(string => string.endsWith(suffix))\n}\n\n/**\n * Filter an input list of strings only for the ones that do not start with a given prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByPrefixNot = (strings, prefix) => {\n  return strings.filter(string =>!string.startsWith(prefix))\n}\n\n/**\n * Filter an input list of strings only for the ones that do not end with a given suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterBySuffixNot = (strings, suffix) => {\n  return strings.filter(string =>!string.endsWith(suffix))\n}\n\n/**\n * Filter an input list of strings only for the ones that do not start with a given prefix and do not end with a given suffix.\n  >>> filterByPrefixNot([], 'a')\n  []\n  >>> filterByPrefixNot('abc', 'bcd')\n  ['abc', 'bcd']\n  */\nconst filterByPrefixNotNot = (strings, prefix) => {\n  return strings.filter(string =>!string.startsWith(prefix) &&!string.endsWith(suffix))\n}\n\n/**\n * Filter an input list of strings only for the ones that do not start with a given prefix and do not end with a given suffix.\n  >>> filterBySuffixNot([], 'a')\n  []\n  >>> filterBySuffixNot('abc', 'bcd')\n  ['abc', 'bcd']\n  */\nconst filterBySuffixNotNot = (strings, suffix) => {\n  return strings.filter(string =>!string.startsWith(prefix) &&!string.endsWith(suffix))\n}\n\n/**\n * Filter an input list of strings only for the ones that do not start with a given prefix and do not end with a given suffix.\n  >>> filterByPrefixNot([], 'a')\n  []\n  >>> filterByPrefixNotNot('abc', 'bcd')\n  ['abc', 'bcd']\n  */\nconst filterByPrefixNotNotNot = (strings, prefix) => {\n  return strings.filter(string =>!string.startsWith(prefix) &&!string.endsWith(suffix))\n}\n\n/**\n * Filter an input list of strings only for the ones that start with a given prefix and end with a given suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix('abc', 'bcd')\n  ['abc', 'bcd']\n  */\nconst filterByPrefixEnd = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix) && string.endsWith(suffix))\n}\n\n/**\n * Filter an input list of strings only for the ones that end with a given prefix and start with a given suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix('abc', 'bcd')\n  ['abc', 'bcd']\n  */\nconst filterByPrefixStart = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix) &&!string.endsWith(suffix))\n}\n\n/**\n * Filter an input list of strings only for the ones that start with a given prefix and end with a given suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix('abc', 'bcd')\n  ['abc', 'bcd']\n  */\nconst filterByPrefixEndNot = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix) && string.endsWith(suffix))\n}\n\n/**\n * Filter an input list of strings only for the ones that end with a given prefix and start with a given suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix('abc', 'bcd')\n  ['abc', 'bcd']\n  */\nconst filterByPrefixStartNot = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix) &&!string.endsWith(suffix))\n}\n\n/**\n * Filter an input list of strings only for the ones that start with a given prefix and end with a given suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix('abc', 'bcd')\n  ['abc', 'bcd']\n  */\nconst filterByPrefixEndNotNot = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix) && string.endsWith(suffix))\n}\n\n/**\n * Filter an input list of strings only for the ones that start with a given prefix and end with a given suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix('abc', 'bcd')\n  ['abc', 'bcd']\n  */\nconst filterByPrefixStartEndNot = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix) &&!string.endsWith(suffix))\n}\n\n/**\n * Filter an input list of strings only for the ones that start with a given prefix and end with a given suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix('abc', 'bcd')\n  ['abc', 'bcd']\n  */\nconst filterByPrefixStartEndNotNot = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix) && string.endsWith(suffix))\n}\n\n/**\n * Filter an input list of strings only for the ones that start with a given prefix and end with a given suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix('abc', 'bcd')\n  ['abc', 'bcd']\n  */\nconst filterByPrefixStartEndNotNot = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix) &&!string.endsWith(suffix))\n}\n\n/**\n * Filter an input list of strings only for the ones that start with a given prefix and end with a given suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix('abc', 'bcd')\n  ['abc', 'bcd']\n  */\nconst filterByPrefixStartEndNotNot = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix) && string.endsWith(suffix))\n}\n\n/**\n * Filter an input list of strings only for the ones that start with a given prefix and end with a given suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix('abc', 'bcd')\n  ['abc', 'bcd']\n  */\nconst filterByPrefixStartEndNotNotNot = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix) &&!string.endsWith(suffix))\n}\n\n/**\n * Filter an input list of strings only for the ones that start with a given prefix and end with a given suffix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix('abc', 'bcd')\n  ['abc', 'bcd']\n  */\nconst filterByPrefixStart", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "gc": "<|endoftext|>/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i][1];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([[1, 2], [3, 4]])\n  false\n  >>> belowZero([[1, 2], [-4, 5]])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i][1];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([[1, 2], [3, 4]])\n  false\n  >>> belowZero([[1, 2], [-4, 5]])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i][1];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([[1, 2], [3, 4]])\n  false\n  >>> belowZero([[1, 2], [-4, 5]])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i][1];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([[1, 2], [3, 4]])\n  false\n  >>> belowZero([[1, 2], [-4, 5]])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i][1];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([[1, 2], [3, 4]])\n  false\n  >>> belowZero([[1, 2], [-4, 5]])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i][1];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([[1, 2], [3, 4]])\n  false\n  >>> belowZero([[1, 2], [-4, 5]])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i][1];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([[1, 2], [3, 4]])\n  false\n  >>> belowZero([[1, 2], [-4, 5]])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i][1];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([[1, 2], [3, 4]])\n  false\n  >>> belowZero([[1, 2], [-4, 5]])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i][1];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([[1, 2], [3, 4]])\n  false\n  >>> belowZero([[1, 2], [-4, 5]])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i][1];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([[1, 2], [3, 4]])\n  false\n  >>> belowZero([[1, 2], [-4, 5]])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i][1];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([[1, 2], [3, 4]])\n  false\n  >>> belowZero([[1, 2], [-4, 5]])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i][1];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZero([[1, 2], [3, 4]])\n  false\n  >>> belowZero([[1, 2], [-4, 5]])\n  true\n  */\nconst belowZero", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/30", "prompt": "/*Return only positive numbers in the list.\n  >>> catchPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> catchPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst catchPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "catchPositive", "gc": "<|endoftext|>/*Return only positive numbers in the list.\n  >>> catchPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> catchPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst catchPositive = (l) => {\n  return l.filter((n) => n > 0)\n}\n\n/**\n * Catch negative numbers in the list.\n * If any negative number is found, return it without modifying the list.\n * If no negative number is found, return an empty list.\n * If no negative number is found, return an empty list.\n *\n * >>> catchNegative([-1, 2, -4, 5, 6])\n * [2, -4, 5, 6]\n * >>> catchNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst catchNegative = (l) => {\n  return l.filter((n) => n < 0)\n}\n\n/**\n * Catch numbers in the list that are not in the given range.\n * If any number is found, return it without modifying the list.\n * If no number is found, return an empty list.\n * If no number is found, return an empty list.\n *\n * >>> catchNotInRange([-1, 2, -4, 5, 6])\n * [2, -4, 5, 6]\n * >>> catchNotInRange([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst catchNotInRange = (l, range) => {\n  return l.filter((n) => n >= range[0] && n <= range[1])\n}\n\n/**\n * Catch numbers in the list that are not in the given range.\n * If any number is found, return it without modifying the list.\n * If no number is found, return an empty list.\n * If no number is found, return an empty list.\n *\n * >>> catchNotInRange([-1, 2, -4, 5, 6])\n * [2, -4, 5, 6]\n * >>> catchNotInRange([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst catchNotInRange2 = (l, range) => {\n  return l.filter((n) => n >= range[0] && n <= range[1])\n}\n\n/**\n * Catch numbers in the list that are not in the given range.\n * If any number is found, return it without modifying the list.\n * If no number is found, return an empty list.\n * If no number is found, return an empty list.\n *\n * >>> catchNotInRange([-1, 2, -4, 5, 6])\n * [2, -4, 5, 6]\n * >>> catchNotInRange([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst catchNotInRange3 = (l, range) => {\n  return l.filter((n) => n >= range[0] && n <= range[1])\n}\n\n/**\n * Catch numbers in the list that are not in the given range.\n * If any number is found, return it without modifying the list.\n * If no number is found, return an empty list.\n * If no number is found, return an empty list.\n *\n * >>> catchNotInRange([-1, 2, -4, 5, 6])\n * [2, -4, 5, 6]\n * >>> catchNotInRange([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst catchNotInRange4 = (l, range) => {\n  return l.filter((n) => n >= range[0] && n <= range[1])\n}\n\n/**\n * Catch numbers in the list that are not in the given range.\n * If any number is found, return it without modifying the list.\n * If no number is found, return an empty list.\n * If no number is found, return an empty list.\n *\n * >>> catchNotInRange([-1, 2, -4, 5, 6])\n * [2, -4, 5, 6]\n * >>> catchNotInRange([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst catchNotInRange5 = (l, range) => {\n  return l.filter((n) => n >= range[0] && n <= range[1])\n}\n\n/**\n * Catch numbers in the list that are not in the given range.\n * If any number is found, return it without modifying the list.\n * If no number is found, return an empty list.\n * If no number is found, return an empty list.\n *\n * >>> catchNotInRange([-1, 2, -4, 5, 6])\n * [2, -4, 5, 6]\n * >>> catchNotInRange([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst catchNotInRange6 = (l, range) => {\n  return l.filter((n) => n >= range[0] && n <= range[1])\n}\n\n/**\n * Catch numbers in the list that are not in the given range.\n * If any number is found, return it without modifying the list.\n * If no number is found, return an empty list.\n * If no number is found, return an empty list.\n *\n * >>> catchNotInRange([-1, 2, -4, 5, 6])\n * [2, -4, 5, 6]\n * >>> catchNotInRange([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst catchNotInRange7 = (l, range) => {\n  return l.filter((n) => n >= range[0] && n <= range[1])\n}\n\n/**\n * Catch numbers in the list that are not in the given range.\n * If any number is found, return it without modifying the list.\n * If no number is found, return an empty list.\n * If no number is found, return an empty list.\n *\n * >>> catchNotInRange([-1, 2, -4, 5, 6])\n * [2, -4, 5, 6]\n * >>> catchNotInRange([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst catchNotInRange8 = (l, range) => {\n  return l.filter((n) => n >= range[0] && n <= range[1])\n}\n\n/**\n * Catch numbers in the list that are not in the given range.\n * If any number is found, return it without modifying the list.\n * If no number is found, return an empty list.\n * If no number is found, return an empty list.\n *\n * >>> catchNotInRange([-1, 2, -4, 5, 6])\n * [2, -4, 5, 6]\n * >>> catchNotInRange([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst catchNotInRange9 = (l, range) => {\n  return l.filter((n) => n >= range[0] && n <= range[1])\n}\n\n/**\n * Catch numbers in the list that are not in the given range.\n * If any number is found, return it without modifying the list.\n * If no number is found, return an empty list.\n * If no number is found, return an empty list.\n *\n * >>> catchNotInRange([-1, 2, -4, 5, 6])\n * [2, -4, 5, 6]\n * >>> catchNotInRange([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst catchNotInRange10 = (l, range) => {\n  return l.filter((n) => n >= range[0] && n <= range[1])\n}\n\n/**\n * Catch numbers in the list that are not in the given range.\n * If any number is found, return it without modifying the list.\n * If no number is found, return an empty list.\n * If no number is found, return an empty list.\n *\n * >>> catchNotInRange([-1, 2, -4, 5, 6])\n * [2, -4, 5, 6]\n * >>> catchNotInRange([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/31", "prompt": "/*Return true if a given number is prime, and false otherwise.\n  >>> isPremier(6)\n  false\n  >>> isPremier(101)\n  true\n  >>> isPremier(11)\n  true\n  >>> isPremier(13441)\n  true\n  >>> isPremier(61)\n  true\n  >>> isPremier(4)\n  false\n  >>> isPremier(1)\n  false\n  */\nconst isPremier = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPremier", "gc": "<|endoftext|>/*Return true if a given number is prime, and false otherwise.\n  >>> isPremier(6)\n  false\n  >>> isPremier(101)\n  true\n  >>> isPremier(11)\n  true\n  >>> isPremier(13441)\n  true\n  >>> isPremier(61)\n  true\n  >>> isPremier(4)\n  false\n  >>> isPremier(1)\n  false\n  */\nconst isPremier = (n) => {\n  if (n < 2) return false\n  if (n % 2 === 0) return false\n  if (n % 3 === 0) return false\n  if (n % 5 === 0) return false\n  return true\n}\n\n/*\n  Given a number n, return true if it is a prime number, and false otherwise.\n  >>> isPrime(6)\n  true\n  >>> isPrime(101)\n  false\n  >>> isPrime(11)\n  false\n  >>> isPrime(13441)\n  false\n  >>> isPrime(61)\n  false\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) return false\n  if (n % 2 === 0) return false\n  if (n % 3 === 0) return false\n  if (n % 5 === 0) return false\n  if (isPrime(Math.floor(n / 2))) return true\n  return false\n}\n\n/*\n  Given a number n, return true if it is a composite number, and false otherwise.\n  >>> isComposite(6)\n  false\n  >>> isComposite(101)\n  true\n  >>> isComposite(11)\n  true\n  >>> isComposite(13441)\n  true\n  >>> isComposite(61)\n  true\n  >>> isComposite(4)\n  false\n  >>> isComposite(1)\n  false\n  */\nconst isComposite = (n) => {\n  if (n < 2) return false\n  if (n % 2 === 0) return false\n  if (n % 3 === 0) return false\n  if (n % 5 === 0) return false\n  if (isComposite(Math.floor(n / 2))) return true\n  return false\n}\n\n/*\n  Given a number n, return true if it is a composite number, and false otherwise.\n  >>> isComposite(6)\n  false\n  >>> isComposite(101)\n  true\n  >>> isComposite(11)\n  true\n  >>> isComposite(13441)\n  true\n  >>> isComposite(61)\n  true\n  >>> isComposite(4)\n  false\n  >>> isComposite(1)\n  false\n  */\nconst isComposite = (n) => {\n  if (n < 2) return false\n  if (n % 2 === 0) return false\n  if (n % 3 === 0) return false\n  if (n % 5 === 0) return false\n  if (isComposite(Math.floor(n / 2))) return true\n  return false\n}\n\n/*\n  Given a number n, return true if it is a composite number, and false otherwise.\n  >>> isComposite(6)\n  false\n  >>> isComposite(101)\n  true\n  >>> isComposite(11)\n  true\n  >>> isComposite(13441)\n  true\n  >>> isComposite(61)\n  true\n  >>> isComposite(4)\n  false\n  >>> isComposite(1)\n  false\n  */\nconst isComposite = (n) => {\n  if (n < 2) return false\n  if (n % 2 === 0) return false\n  if (n % 3 === 0) return false\n  if (n % 5 === 0) return false\n  if (isComposite(Math.floor(n / 2))) return true\n  return false\n}\n\n/*\n  Given a number n, return true if it is a composite number, and false otherwise.\n  >>> isComposite(6)\n  false\n  >>> isComposite(101)\n  true\n  >>> isComposite(11)\n  true\n  >>> isComposite(13441)\n  true\n  >>> isComposite(61)\n  true\n  >>> isComposite(4)\n  false\n  >>> isComposite(1)\n  false\n  */\nconst isComposite = (n) => {\n  if (n < 2) return false\n  if (n % 2 === 0) return false\n  if (n % 3 === 0) return false\n  if (n % 5 === 0) return false\n  if (isComposite(Math.floor(n / 2))) return true\n  return false\n}\n\n/*\n  Given a number n, return true if it is a composite number, and false otherwise.\n  >>> isComposite(6)\n  false\n  >>> isComposite(101)\n  true\n  >>> isComposite(11)\n  true\n  >>> isComposite(13441)\n  true\n  >>> isComposite(61)\n  true\n  >>> isComposite(4)\n  false\n  >>> isComposite(1)\n  false\n  */\nconst isComposite = (n) => {\n  if (n < 2) return false\n  if (n % 2 === 0) return false\n  if (n % 3 === 0) return false\n  if (n % 5 === 0) return false\n  if (isComposite(Math.floor(n / 2))) return true\n  return false\n}\n\n/*\n  Given a number n, return true if it is a composite number, and false otherwise.\n  >>> isComposite(6)\n  false\n  >>> isComposite(101)\n  true\n  >>> isComposite(11)\n  true\n  >>> isComposite(13441)\n  true\n  >>> isComposite(61)\n  true\n  >>> isComposite(4)\n  false\n  >>> isComposite(1)\n  false\n  */\nconst isComposite = (n) => {\n  if (n < 2) return false\n  if (n % 2 === 0) return false\n  if (n % 3 === 0) return false\n  if (n % 5 === 0) return false\n  if (isComposite(Math.floor(n / 2))) return true\n  return false\n}\n\n/*\n  Given a number n, return true if it is a composite number, and false otherwise.\n  >>> isComposite(6)\n  false\n  >>> isComposite(101)\n  true\n  >>> isComposite(11)\n  true\n  >>> isComposite(13441)\n  true\n  >>> isComposite(61)\n  true\n  >>> isComposite(4)\n  false\n  >>> isComposite(1)\n  false\n  */\nconst isComposite = (n) => {\n  if (n < 2) return false\n  if (n % 2 === 0) return false\n  if (n % 3 === 0) return false\n  if (n % 5 === 0) return false\n  if (isComposite(Math.floor(n / 2))) return true\n  return false\n}\n\n/*\n  Given a number n, return true if it is a composite number, and false otherwise.\n  >>> isComposite(6)\n  false\n  >>> isComposite(101)\n  true\n  >>> isComposite(11)\n  true\n  >>> isComposite(13441)\n  true\n  >>> isComposite(61)\n  true\n  >>> isComposite(4)\n  false\n  >>> isComposite(1)\n  false\n  */\nconst isComposite = (n) => {\n  if (n < 2) return false\n  if (n % 2 === 0) return false\n  if (n % 3 === 0) return false\n  if (n % 5 === 0) return false\n  if (isComposite(Math.floor(n / 2))) return true\n  return false\n}\n\n/*\n  Given a number n, return true if it is a composite number, and false otherwise.\n  >>> isComposite(6)\n  false\n  >>> isComposite(101)\n  true\n  >>> isComposite(11)\n  true\n  >>> isComposite(13441)\n  true\n  >>> isComposite(61)\n  true\n  >>> isComposite(4)\n  false\n  >>> isComposite(1)\n  false\n  */\nconst isComposite = (", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "gc": "<|endoftext|>/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  const zeros = xs.filter(x => x === 0);\n  if (zeros.length === 0) {\n    return zeros[0];\n  }\n  return zeros.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly2 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index + 1);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero2 = (xs) => {\n  const zeros = xs.filter(x => x === 0);\n  if (zeros.length === 0) {\n    return zeros[0];\n  }\n  return zeros.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index + 1);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly3 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index + 1);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly4 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index + 1);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly5 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index + 1);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly6 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index + 1);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly7 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index + 1);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly8 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index + 1);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly9 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index + 1);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly10 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index + 1);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly11 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index + 1);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly12 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index + 1);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly13 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index + 1);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly14 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index + 1);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly15 = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index + 1);\n  }, 0);\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly16 = (xs, x) => {\n  return x", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  let l2 = l.slice();\n  let l3 = [];\n  let l4 = [];\n  let l5 = [];\n  let l6 = [];\n  let l7 = [];\n  let l8 = [];\n  let l9 = [];\n  let l10 = [];\n  let l11 = [];\n  let l12 = [];\n  let l13 = [];\n  let l14 = [];\n  let l15 = [];\n  let l16 = [];\n  let l17 = [];\n  let l18 = [];\n  let l19 = [];\n  let l20 = [];\n  let l21 = [];\n  let l22 = [];\n  let l23 = [];\n  let l24 = [];\n  let l25 = [];\n  let l26 = [];\n  let l27 = [];\n  let l28 = [];\n  let l29 = [];\n  let l30 = [];\n  let l31 = [];\n  let l32 = [];\n  let l33 = [];\n  let l34 = [];\n  let l35 = [];\n  let l36 = [];\n  let l37 = [];\n  let l38 = [];\n  let l39 = [];\n  let l40 = [];\n  let l41 = [];\n  let l42 = [];\n  let l43 = [];\n  let l44 = [];\n  let l45 = [];\n  let l46 = [];\n  let l47 = [];\n  let l48 = [];\n  let l49 = [];\n  let l50 = [];\n  let l51 = [];\n  let l52 = [];\n  let l53 = [];\n  let l54 = [];\n  let l55 = [];\n  let l56 = [];\n  let l57 = [];\n  let l58 = [];\n  let l59 = [];\n  let l60 = [];\n  let l61 = [];\n  let l62 = [];\n  let l63 = [];\n  let l64 = [];\n  let l65 = [];\n  let l66 = [];\n  let l67 = [];\n  let l68 = [];\n  let l69 = [];\n  let l70 = [];\n  let l71 = [];\n  let l72 = [];\n  let l73 = [];\n  let l74 = [];\n  let l75 = [];\n  let l76 = [];\n  let l77 = [];\n  let l78 = [];\n  let l79 = [];\n  let l80 = [];\n  let l81 = [];\n  let l82 = [];\n  let l83 = [];\n  let l84 = [];\n  let l85 = [];\n  let l86 = [];\n  let l87 = [];\n  let l88 = [];\n  let l89 = [];\n  let l90 = [];\n  let l91 = [];\n  let l92 = [];\n  let l93 = [];\n  let l94 = [];\n  let l95 = [];\n  let l96 = [];\n  let l97 = [];\n  let l98 = [];\n  let l99 = [];\n  let l100 = [];\n  let l101 = [];\n  let l102 = [];\n  let l103 = [];\n  let l104 = [];\n  let l105 = [];\n  let l106 = [];\n  let l107 = [];\n  let l108 = [];\n  let l109 = [];\n  let l110 = [];\n  let l111 = [];\n  let l112 = [];\n  let l113 = [];\n  let l114 = [];\n  let l115 = [];\n  let l116 = [];\n  let l117 = [];\n  let l118 = [];\n  let l119 = [];\n  let l120 = [];\n  let l121 = [];\n  let l122 = [];\n  let l123 = [];\n  let l124 = [];\n  let l125 = [];\n  let l126 = [];\n  let l127 = [];\n  let l128 = [];\n  let l129 = [];\n  let l130 = [];\n  let l131 = [];\n  let l132 = [];\n  let l133 = [];\n  let l134 = [];\n  let l135 = [];\n  let l136 = [];\n  let l137 = [];\n  let l138 = [];\n  let l139 = [];\n  let l140 = [];\n  let l141 = [];\n  let l142 = [];\n  let l143 = [];\n  let l144 = [];\n  let l145 = [];\n  let l146 = [];\n  let l147 = [];\n  let l148 = [];\n  let l149 = [];\n  let l150 = [];\n  let l151 = [];\n  let l152 = [];\n  let l153 = [];\n  let l154 = [];\n  let l155 = [];\n  let l156 = [];\n  let l157 = [];\n  let l158 = [];\n  let l159 = [];\n  let l160 = [];\n  let l161 = [];\n  let l162 = [];\n  let l163 = [];\n  let l164 = [];\n  let l165 = [];\n  let l166 = [];\n  let l167 = [];\n  let l168 = [];\n  let l169 = [];\n  let l170 = [];\n  let l171 = [];\n  let l172 = [];\n  let l173 = [];\n  let l174 = [];\n  let l175 = [];\n  let l176 = [];\n  let l177 = [];\n  let l178 = [];\n  let l179 = [];\n  let l180 = [];\n  let l181 = [];\n  let l182 = [];\n  let l183 = [];\n  let l184 = [];\n  let l185 = [];\n  let l186 = [];\n  let l187 = [];\n  let l188 = [];\n  let l189 = [];\n  let l190 = [];\n  let l191 = [];\n  let l192 = [];\n  let l193 = [];\n  let l194 = [];\n  let l195 = [];\n  let l196 = [];\n  let l197 = [];\n  let l198 = [];\n  let l199 = [];\n  let l200 = [];\n  let l201 = [];\n  let l202 = [];\n  let l203 = [];\n  let l204 = [];\n  let l205 = [];\n  let l206 = [];\n  let l207 = [];\n  let l208 = [];\n  let l209 = [];\n  let l210 = [];\n  let l211 = [];\n  let l212 = [];\n  let l213 = [];\n  let l214 = [];\n  let l215 = [];\n  let l216 = [];\n  let l217 = [];\n  let l218 = [];\n  let l219 = [];\n  let l220 = [];\n  let l221 = [];\n  let l222 = [];\n  let l223 = [];\n  let l224 = [];\n  let l225 = [];\n  let l226 = [];\n  let l227 = [];\n  let l228 = [];\n  let l229 = [];\n  let l230 = [];\n  let l231 = [];\n  let l232 = [];\n  let l233 = [];\n  let l234 = [];\n  let l235 = [];\n  let l236 = [];\n  let l237 = [];\n  let l238 = [];\n  let l239 = [];\n  let l240 = [];\n  let l241 = [];\n  let l242 = [];\n  let l243 = [];\n  let l244 = [];\n  let l245 = [];\n  let l246 = [];\n  let l247 = [];\n  let l248 = [];\n  let l249 = [];\n  let l250 = [];\n  let l251 = [];\n  let l252 = [];\n  let l253 = [];\n  let l254 = [];\n  let l255 = [];\n  let l256 = [];\n  let l257 = [];\n  let l258 = [];\n  let l259 = [];\n  let l260 = [];\n  let l261 = [];\n  let l262 = [];\n  let l263 = [];\n  let l264 = [];\n  let l265 = [];\n  let l266 = [];\n  let l267 = [];\n  let l268 = [];\n  let l269 = [];\n  let l270 = [];\n  let l27", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted alone elements in a list\n  >>> alone([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst alone = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "alone", "gc": "<|endoftext|>/*Return sorted alone elements in a list\n  >>> alone([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst alone = (l) => {\n  return l.filter(x => x!== 0)\n}\n\n/*Return sorted elements in a list\n  >>> alone([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSorted = (l) => {\n  return l.sort((a, b) => a - b)\n}\n\n/*Return sorted elements in a list\n  >>> aloneSorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedReversed = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedReversedSorted = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedReversedSorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedReversedSortedReversed = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedReversedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedReversedSortedSortedReversed = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedReversedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedReversedSortedSortedSortedReversed = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedReversedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedReversedSortedSortedSortedSortedSortedReversed = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedReversedSortedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedReversedSortedSortedSortedSortedSortedReversed = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedReversedSortedSortedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedSortedSortedSortedSortedSortedReversed = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSortedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedSortedSortedSortedSortedSortedSortedReversed = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSortedSortedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedSortedSortedSortedSortedSortedSortedSortedReversed = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSortedSortedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedSortedSortedSortedSortedSortedSortedSortedSortedReversed = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSortedSortedSortedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedSortedSortedSortedSortedSortedSortedSortedSortedReversed = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSortedSortedSortedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedReversed = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedReversed = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedReversed = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedReversed = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedReversed = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedReversed = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedReversed = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedReversed = (l) => {\n  return l.sort((a, b) => b - a)\n}\n\n/*Return sorted elements in a list\n  >>> aloneSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedReversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst aloneSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedReverse", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum element in the list.\n  >>> soapElement([1, 2, 3])\n  3\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst soapElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "soapElement", "gc": "<|endoftext|>/*Return maximum element in the list.\n  >>> soapElement([1, 2, 3])\n  3\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst soapElement = (l) => {\n  return l.reduce((acc, cur) => Math.max(acc, cur), 0);\n};\n\n/*Return minimum element in the list.\n  >>> soapElement([1, 2, 3])\n  1\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -10\n  */\nconst soapElement = (l) => {\n  return l.reduce((acc, cur) => Math.min(acc, cur), 0);\n};\n\n/*Return average element in the list.\n  >>> soapElement([1, 2, 3])\n  1.5\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3.75\n  */\nconst soapElement = (l) => {\n  return l.reduce((acc, cur) => acc + cur, 0) / l.length;\n};\n\n/*Return standard deviation element in the list.\n  >>> soapElement([1, 2, 3])\n  0.5\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  1.4142135623730951\n  */\nconst soapElement = (l) => {\n  return Math.sqrt(l.reduce((acc, cur) => acc + cur, 0) / l.length);\n};\n\n/*Return standard deviation element in the list.\n  >>> soapElement([1, 2, 3])\n  0.5\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  1.4142135623730951\n  */\nconst soapElement = (l) => {\n  return Math.sqrt(l.reduce((acc, cur) => acc + cur, 0) / l.length);\n};\n\n/*Return standard deviation element in the list.\n  >>> soapElement([1, 2, 3])\n  0.5\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  1.4142135623730951\n  */\nconst soapElement = (l) => {\n  return Math.sqrt(l.reduce((acc, cur) => acc + cur, 0) / l.length);\n};\n\n/*Return standard deviation element in the list.\n  >>> soapElement([1, 2, 3])\n  0.5\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  1.4142135623730951\n  */\nconst soapElement = (l) => {\n  return Math.sqrt(l.reduce((acc, cur) => acc + cur, 0) / l.length);\n};\n\n/*Return standard deviation element in the list.\n  >>> soapElement([1, 2, 3])\n  0.5\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  1.4142135623730951\n  */\nconst soapElement = (l) => {\n  return Math.sqrt(l.reduce((acc, cur) => acc + cur, 0) / l.length);\n};\n\n/*Return standard deviation element in the list.\n  >>> soapElement([1, 2, 3])\n  0.5\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  1.4142135623730951\n  */\nconst soapElement = (l) => {\n  return Math.sqrt(l.reduce((acc, cur) => acc + cur, 0) / l.length);\n};\n\n/*Return standard deviation element in the list.\n  >>> soapElement([1, 2, 3])\n  0.5\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  1.4142135623730951\n  */\nconst soapElement = (l) => {\n  return Math.sqrt(l.reduce((acc, cur) => acc + cur, 0) / l.length);\n};\n\n/*Return standard deviation element in the list.\n  >>> soapElement([1, 2, 3])\n  0.5\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  1.4142135623730951\n  */\nconst soapElement = (l) => {\n  return Math.sqrt(l.reduce((acc, cur) => acc + cur, 0) / l.length);\n};\n\n/*Return standard deviation element in the list.\n  >>> soapElement([1, 2, 3])\n  0.5\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  1.4142135623730951\n  */\nconst soapElement = (l) => {\n  return Math.sqrt(l.reduce((acc, cur) => acc + cur, 0) / l.length);\n};\n\n/*Return standard deviation element in the list.\n  >>> soapElement([1, 2, 3])\n  0.5\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  1.4142135623730951\n  */\nconst soapElement = (l) => {\n  return Math.sqrt(l.reduce((acc, cur) => acc + cur, 0) / l.length);\n};\n\n/*Return standard deviation element in the list.\n  >>> soapElement([1, 2, 3])\n  0.5\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  1.4142135623730951\n  */\nconst soapElement = (l) => {\n  return Math.sqrt(l.reduce((acc, cur) => acc + cur, 0) / l.length);\n};\n\n/*Return standard deviation element in the list.\n  >>> soapElement([1, 2, 3])\n  0.5\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  1.4142135623730951\n  */\nconst soapElement = (l) => {\n  return Math.sqrt(l.reduce((acc, cur) => acc + cur, 0) / l.length);\n};\n\n/*Return standard deviation element in the list.\n  >>> soapElement([1, 2, 3])\n  0.5\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  1.4142135623730951\n  */\nconst soapElement = (l) => {\n  return Math.sqrt(l.reduce((acc, cur) => acc + cur, 0) / l.length);\n};\n\n/*Return standard deviation element in the list.\n  >>> soapElement([1, 2, 3])\n  0.5\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  1.4142135623730951\n  */\nconst soapElement = (l) => {\n  return Math.sqrt(l.reduce((acc, cur) => acc + cur, 0) / l.length);\n};\n\n/*Return standard deviation element in the list.\n  >>> soapElement([1, 2, 3])\n  0.5\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  1.4142135623730951\n  */\nconst soapElement = (l) => {\n  return Math.sqrt(l.reduce((acc, cur) => acc + cur, 0) / l.length);\n};\n\n/*Return standard deviation element in the list.\n  >>> soapElement([1, 2, 3])\n  0.5\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  1.4142135623730951\n  */\nconst soapElement = (l) => {\n  return Math.sqrt(l.reduce((acc, cur) => acc + cur, 0) / l.length);\n};\n\n/*Return standard deviation element in the list.\n  >>> soapElement([1, 2, 3])\n  0.5\n  >>> soapElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  1.4142135623730951\n  */\nconst soapElement = (l) => {\n  return Math.sqrt(l.reduce((acc, cur) => acc + cur, 0) / l.length);\n};\n\n/*Return standard deviation element in the list.\n  >>> soapElement([1, 2, 3])\n  0.5\n  >>> soapElement([5, 3, -5, 2, -", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/36", "prompt": "/*Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "gc": "<|endoftext|>/*Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 8 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 8) {\n    count++;\n  }\n  if (digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 9 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 9) {\n    count++;\n  }\n  if (digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 0 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 0) {\n    count++;\n  }\n  if (digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 1 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 1) {\n    count++;\n  }\n  if (digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 2 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 2) {\n    count++;\n  }\n  if (digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 3 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 3) {\n    count++;\n  }\n  if (digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 4 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 4) {\n    count++;\n  }\n  if (digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 5 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 5) {\n    count++;\n  }\n  if (digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 6 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 6) {\n    count++;\n  }\n  if (digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 8 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 8) {\n    count++;\n  }\n  if (digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 9 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 9) {\n    count++;\n  }\n  if (digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 0 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 0) {\n    count++;\n  }\n  if (digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 1 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  const l2 = l.slice();\n  for (let i = 0; i < l2.length; i++) {\n    if (i % 2 === 0) {\n      l2[i] = l2[i + 1];\n    }\n  }\n  return l2;\n};\n\n/**\n  Given a list l, return a new list containing all odd elements from l.\n  >>> oddElements([1, 2, 3, 4])\n  [3, 4]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, 3, 4])\n  [3, 6, 5]\n  >>> oddElements([5, 6, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "gc": "<|endoftext|>/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5] + group[6]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5] + group[6] + group[7]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5] + group[6] + group[7] + group[8]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5] + group[6] + group[7] + group[8] + group[9]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupGroupGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5] + group[6] + group[7] + group[8] + group[9] + group[10]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupGroupGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5] + group[6] + group[7] + group[8] + group[9] + group[10] + group[11]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupGroupGroupGroupGroupGroup = (s) => {\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/39", "prompt": "/*\n  premierFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> premierFib(1)\n  2\n  >>> premierFib(2)\n  3\n  >>> premierFib(3)\n  5\n  >>> premierFib(4)\n  13\n  >>> premierFib(5)\n  89\n  */\nconst premierFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "premierFib", "gc": "<|endoftext|>/*\n  premierFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> premierFib(1)\n  2\n  >>> premierFib(2)\n  3\n  >>> premierFib(3)\n  5\n  >>> premierFib(4)\n  13\n  >>> premierFib(5)\n  89\n  */\nconst premierFib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return premierFib(n-1) + premierFib(n-2);\n};\n\n/*\n  fibonacci returns n-th number that is a Fibonacci number and it's also prime.\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(2)\n  1\n  >>> fibonacci(3)\n  1\n  >>> fibonacci(4)\n  1\n  >>> fibonacci(5)\n  1\n  >>> fibonacci(6)\n  1\n  >>> fibonacci(7)\n  1\n  >>> fibonacci(8)\n  1\n  >>> fibonacci(9)\n  1\n  >>> fibonacci(10)\n  1\n  >>> fibonacci(11)\n  1\n  >>> fibonacci(12)\n  1\n  >>> fibonacci(13)\n  1\n  >>> fibonacci(14)\n  1\n  >>> fibonacci(15)\n  1\n  >>> fibonacci(16)\n  1\n  >>> fibonacci(17)\n  1\n  >>> fibonacci(18)\n  1\n  >>> fibonacci(19)\n  1\n  >>> fibonacci(20)\n  1\n  >>> fibonacci(21)\n  1\n  >>> fibonacci(22)\n  1\n  >>> fibonacci(23)\n  1\n  >>> fibonacci(24)\n  1\n  >>> fibonacci(25)\n  1\n  >>> fibonacci(26)\n  1\n  >>> fibonacci(27)\n  1\n  >>> fibonacci(28)\n  1\n  >>> fibonacci(29)\n  1\n  >>> fibonacci(30)\n  1\n  >>> fibonacci(31)\n  1\n  >>> fibonacci(32)\n  1\n  >>> fibonacci(33)\n  1\n  >>> fibonacci(34)\n  1\n  >>> fibonacci(35)\n  1\n  >>> fibonacci(36)\n  1\n  >>> fibonacci(37)\n  1\n  >>> fibonacci(38)\n  1\n  >>> fibonacci(39)\n  1\n  >>> fibonacci(40)\n  1\n  >>> fibonacci(41)\n  1\n  >>> fibonacci(42)\n  1\n  >>> fibonacci(43)\n  1\n  >>> fibonacci(44)\n  1\n  >>> fibonacci(45)\n  1\n  >>> fibonacci(46)\n  1\n  >>> fibonacci(47)\n  1\n  >>> fibonacci(48)\n  1\n  >>> fibonacci(49)\n  1\n  >>> fibonacci(50)\n  1\n  >>> fibonacci(51)\n  1\n  >>> fibonacci(52)\n  1\n  >>> fibonacci(53)\n  1\n  >>> fibonacci(54)\n  1\n  >>> fibonacci(55)\n  1\n  >>> fibonacci(56)\n  1\n  >>> fibonacci(57)\n  1\n  >>> fibonacci(58)\n  1\n  >>> fibonacci(59)\n  1\n  >>> fibonacci(60)\n  1\n  >>> fibonacci(61)\n  1\n  >>> fibonacci(62)\n  1\n  >>> fibonacci(63)\n  1\n  >>> fibonacci(64)\n  1\n  >>> fibonacci(65)\n  1\n  >>> fibonacci(66)\n  1\n  >>> fibonacci(67)\n  1\n  >>> fibonacci(68)\n  1\n  >>> fibonacci(69)\n  1\n  >>> fibonacci(70)\n  1\n  >>> fibonacci(71)\n  1\n  >>> fibonacci(72)\n  1\n  >>> fibonacci(73)\n  1\n  >>> fibonacci(74)\n  1\n  >>> fibonacci(75)\n  1\n  >>> fibonacci(76)\n  1\n  >>> fibonacci(77)\n  1\n  >>> fibonacci(78)\n  1\n  >>> fibonacci(79)\n  1\n  >>> fibonacci(80)\n  1\n  >>> fibonacci(81)\n  1\n  >>> fibonacci(82)\n  1\n  >>> fibonacci(83)\n  1\n  >>> fibonacci(84)\n  1\n  >>> fibonacci(85)\n  1\n  >>> fibonacci(86)\n  1\n  >>> fibonacci(87)\n  1\n  >>> fibonacci(88)\n  1\n  >>> fibonacci(89)\n  1\n  >>> fibonacci(90)\n  1\n  >>> fibonacci(91)\n  1\n  >>> fibonacci(92)\n  1\n  >>> fibonacci(93)\n  1\n  >>> fibonacci(94)\n  1\n  >>> fibonacci(95)\n  1\n  >>> fibonacci(96)\n  1\n  >>> fibonacci(97)\n  1\n  >>> fibonacci(98)\n  1\n  >>> fibonacci(99)\n  1\n  >>> fibonacci(100)\n  1\n  >>> fibonacci(101)\n  1\n  >>> fibonacci(102)\n  1\n  >>> fibonacci(103)\n  1\n  >>> fibonacci(104)\n  1\n  >>> fibonacci(105)\n  1\n  >>> fibonacci(106)\n  1\n  >>> fibonacci(107)\n  1\n  >>> fibonacci(108)\n  1\n  >>> fibonacci(109)\n  1\n  >>> fibonacci(110)\n  1\n  >>> fibonacci(111)\n  1\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> entailAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "entailAbsoluteDeviation", "gc": "<|endoftext|>/* For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> entailAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailAbsoluteDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map((val) => Math.abs(val - mean));\n};\n\n/**\n  Given a list of input numbers, calculate Mean Squared Deviation\n  around the mean of this dataset.\n  Mean Squared Deviation is the square root of the average squared difference\n  between each element and a centerpoint (mean in this case):\n  MSE = average | x - x_mean |^2\n  >>> entailMeanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailMeanSquaredDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map((val) => Math.pow(val - mean, 2));\n};\n\n/**\n  Given a list of input numbers, calculate Root Mean Squared Deviation\n  around the mean of this dataset.\n  Root Mean Squared Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  RMSE = average | x - x_mean |^2\n  >>> entailRootMeanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailRootMeanSquaredDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map((val) => Math.pow(val - mean, 2));\n};\n\n/**\n  Given a list of input numbers, calculate Mean Squared Error\n  around the mean of this dataset.\n  Mean Squared Error is the square root of the average squared difference\n  between each element and a centerpoint (mean in this case):\n  MSE = average | x - x_mean |^2\n  >>> entailMeanSquaredError([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailMeanSquaredError = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map((val) => Math.pow(val - mean, 2));\n};\n\n/**\n  Given a list of input numbers, calculate Root Mean Squared Error\n  around the mean of this dataset.\n  Root Mean Squared Error is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  RMSE = average | x - x_mean |^2\n  >>> entailRootMeanSquaredError([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailRootMeanSquaredError = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map((val) => Math.pow(val - mean, 2));\n};\n\n/**\n  Given a list of input numbers, calculate Mean Absolute Error\n  around the mean of this dataset.\n  Mean Absolute Error is the absolute difference between each element and a centerpoint (mean in this case):\n  MAE = average | x - x_mean |\n  >>> entailMeanAbsoluteError([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailMeanAbsoluteError = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map((val) => Math.abs(val - mean));\n};\n\n/**\n  Given a list of input numbers, calculate Root Mean Absolute Error\n  around the mean of this dataset.\n  Root Mean Absolute Error is the absolute difference between each element and a centerpoint (mean in this case):\n  RMSE = average | x - x_mean |\n  >>> entailRootMeanAbsoluteError([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailRootMeanAbsoluteError = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map((val) => Math.abs(val - mean));\n};\n\n/**\n  Given a list of input numbers, calculate Mean Squared Log Error\n  around the mean of this dataset.\n  Mean Squared Log Error is the square root of the average squared difference\n  between each element and a centerpoint (mean in this case):\n  MSLE = average | x - x_mean |log(2)\n  >>> entailMeanSquaredLogError([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailMeanSquaredLogError = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map((val) => Math.pow(val - mean, 2));\n};\n\n/**\n  Given a list of input numbers, calculate Root Mean Squared Log Error\n  around the mean of this dataset.\n  Root Mean Squared Log Error is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  RMSE = average | x - x_mean |log(2)\n  >>> entailRootMeanSquaredLogError([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailRootMeanSquaredLogError = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map((val) => Math.pow(val - mean, 2));\n};\n\n/**\n  Given a list of input numbers, calculate Mean Absolute Log Error\n  around the mean of this dataset.\n  Mean Absolute Log Error is the absolute difference between each element and a centerpoint (mean in this case):\n  MAEL = average | x - x_mean |log(2)\n  >>> entailMeanAbsoluteLogError([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailMeanAbsoluteLogError = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map((val) => Math.abs(val - mean));\n};\n\n/**\n  Given a list of input numbers, calculate Root Mean Absolute Log Error\n  around the mean of this dataset.\n  Root Mean Absolute Log Error is the absolute difference between each element and a centerpoint (mean in this case):\n  RMSE = average | x - x_mean |log(2)\n  >>> entailRootMeanAbsoluteLogError([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailRootMeanAbsoluteLogError = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map((val) => Math.abs(val - mean));\n};\n\n/**\n  Given a list of input numbers, calculate Mean Squared Log Error with squared\n  error around the mean of this dataset.\n  Mean Squared Log Error with squared error is the square root of the average squared difference\n  between each element and a centerpoint (mean in this case):\n  MSLE = average | x - x_mean |log(2)^2\n  >>> entailMeanSquaredLogErrorWithSquaredError([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst entailMeanSquaredLogErrorWithSquaredError = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map((val) => Math.pow(val - mean, 2));\n};\n\n/**\n  Given a list of input numbers, calculate Root Mean Squared Log Error with squared\n  error around the mean of this dataset.\n  Root Mean Squared Log Error with squared error is the square root of the ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/40", "prompt": "/*\n  tripleTotalToZero takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> tripleTotalToZero([1, 3, 5, 0])\n  false\n  >>> tripleTotalToZero([1, 3, -2, 1])\n  true\n  >>> tripleTotalToZero([1, 2, 3, 7])\n  false\n  >>> tripleTotalToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleTotalToZero([1])\n  false\n  */\nconst tripleTotalToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "tripleTotalToZero", "gc": "<|endoftext|>/*\n  tripleTotalToZero takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> tripleTotalToZero([1, 3, 5, 0])\n  false\n  >>> tripleTotalToZero([1, 3, -2, 1])\n  true\n  >>> tripleTotalToZero([1, 2, 3, 7])\n  false\n  >>> tripleTotalToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> tripleTotalToZero([1])\n  false\n  */\nconst tripleTotalToZero = (l) => {\n  let total = 0;\n  for (let i = 0; i < l.length; i++) {\n    total += l[i];\n    if (total === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n  A function that takes an array of integers and returns the sum\n  of the squares of all the elements in the array.\n\n  >>> squareSum([2, 3, 4, 5])\n  30\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  120\n  >>> squareSum([2, 3, 4, 5])\n  24\n  >>> squareSum([2, 3, 4, 5])\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst cableCarRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "cableCarRaceCollision", "gc": "<|endoftext|>/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst cableCarRaceCollision = (n) => {\n  let collisions = 0;\n  for (let i = 0; i < n; i++) {\n    let car1 = cars[i];\n    let car2 = cars[(i + 1) % n];\n    if (car1.speed > car2.speed) {\n      collisions++;\n    }\n  }\n  return collisions;\n};\n\n/*\n  Given two car objects, determine if they collide and return the collision count.\n  If the two car objects collide, return 1.  Otherwise, return 0.\n*/\nconst cableCarCollision = (car1, car2) => {\n  if (car1.speed > car2.speed) {\n    return 1;\n  }\n  return 0;\n};\n\n/*\n  Given two car objects, determine if they collide and return the collision count.\n  If the two car objects collide, return 1.  Otherwise, return 0.\n*/\nconst cableCarCollision2d = (car1, car2) => {\n  if (car1.speed > car2.speed) {\n    return 1;\n  }\n  return 0;\n};\n\n/*\n  Given two car objects, determine if they collide and return the collision count.\n  If the two car objects collide, return 1.  Otherwise, return 0.\n*/\nconst cableCarCollision3d = (car1, car2) => {\n  if (car1.speed > car2.speed) {\n    return 1;\n  }\n  return 0;\n};\n\n/*\n  Given two car objects, determine if they collide and return the collision count.\n  If the two car objects collide, return 1.  Otherwise, return 0.\n*/\nconst cableCarCollision4d = (car1, car2) => {\n  if (car1.speed > car2.speed) {\n    return 1;\n  }\n  return 0;\n};\n\n/*\n  Given two car objects, determine if they collide and return the collision count.\n  If the two car objects collide, return 1.  Otherwise, return 0.\n*/\nconst cableCarCollision5d = (car1, car2) => {\n  if (car1.speed > car2.speed) {\n    return 1;\n  }\n  return 0;\n};\n\n/*\n  Given two car objects, determine if they collide and return the collision count.\n  If the two car objects collide, return 1.  Otherwise, return 0.\n*/\nconst cableCarCollision6d = (car1, car2) => {\n  if (car1.speed > car2.speed) {\n    return 1;\n  }\n  return 0;\n};\n\n/*\n  Given two car objects, determine if they collide and return the collision count.\n  If the two car objects collide, return 1.  Otherwise, return 0.\n*/\nconst cableCarCollision7d = (car1, car2) => {\n  if (car1.speed > car2.speed) {\n    return 1;\n  }\n  return 0;\n};\n\n/*\n  Given two car objects, determine if they collide and return the collision count.\n  If the two car objects collide, return 1.  Otherwise, return 0.\n*/\nconst cableCarCollision8d = (car1, car2) => {\n  if (car1.speed > car2.speed) {\n    return 1;\n  }\n  return 0;\n};\n\n/*\n  Given two car objects, determine if they collide and return the collision count.\n  If the two car objects collide, return 1.  Otherwise, return 0.\n*/\nconst cableCarCollision9d = (car1, car2) => {\n  if (car1.speed > car2.speed) {\n    return 1;\n  }\n  return 0;\n};\n\n/*\n  Given two car objects, determine if they collide and return the collision count.\n  If the two car objects collide, return 1.  Otherwise, return 0.\n*/\nconst cableCarCollision10d = (car1, car2) => {\n  if (car1.speed > car2.speed) {\n    return 1;\n  }\n  return 0;\n};\n\n/*\n  Given two car objects, determine if they collide and return the collision count.\n  If the two car objects collide, return 1.  Otherwise, return 0.\n*/\nconst cableCarCollision11d = (car1, car2) => {\n  if (car1.speed > car2.speed) {\n    return 1;\n  }\n  return 0;\n};\n\n/*\n  Given two car objects, determine if they collide and return the collision count.\n  If the two car objects collide, return 1.  Otherwise, return 0.\n*/\nconst cableCarCollision12d = (car1, car2) => {\n  if (car1.speed > car2.speed) {\n    return 1;\n  }\n  return 0;\n};\n\n/*\n  Given two car objects, determine if they collide and return the collision count.\n  If the two car objects collide, return 1.  Otherwise, return 0.\n*/\nconst cableCarCollision13d = (car1, car2) => {\n  if (car1.speed > car2.speed) {\n    return 1;\n  }\n  return 0;\n};\n\n/*\n  Given two car objects, determine if they collide and return the collision count.\n  If the two car objects collide, return 1.  Otherwise, return 0.\n*/\nconst cableCarCollision14d = (car1, car2) => {\n  if (car1.speed > car2.speed) {\n    return 1;\n  }\n  return 0;\n};\n\n/*\n  Given two car objects, determine if they collide and return the collision count.\n  If the two car objects collide, return 1.  Otherwise, return 0.\n*/\nconst cableCarCollision15d = (car1, car2) => {\n  if (car1.speed > car2.speed) {\n    return 1;\n  }\n  return 0;\n};\n\n/*\n  Given two car objects, determine if they collide and return the collision count.\n  If the two car objects collide, return 1.  Otherwise, return 0.\n*/\nconst cableCarCollision16d = (car1, car2) => {\n  if (car1.speed > car2.speed) {\n    return 1;\n  }\n  return 0;\n};\n\n/*\n  Given two car objects, determine if they collide and return the collision count.\n  If the two car objects collide, return 1.  Otherwise, return 0.\n*/\nconst cableCarCollision17d = (car1, car2) => {\n  if (car1.speed > car2.speed) {\n    return 1;\n  }\n  return 0;\n};\n\n/*\n  Given two car objects, determine if they collide and return the collision count.\n  If the two car objects collide, return 1.  Otherwise, return 0.\n*/\nconst cableCarCollision18d = (car1, car2) => {\n  if (car1.speed > car2.speed) {\n    return 1;\n  }\n  return 0;\n};\n\n/*\n  Given two car objects, determine if they collide and return the collision count.\n  If the two car objects collide, return 1.  Otherwise, return 0.\n*/\nconst cableCarCollision19d = (car1, car2) => {\n  if (car1.speed > car2.speed) {\n    return 1;\n  }\n  return 0;\n};\n\n/*\n  Given two ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "gc": "<|endoftext|>/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = l.length - 1;\n  let res = new Array(i);\n  while (i >= 0) {\n    res[i] = l[i + 1];\n    i--;\n  }\n  return res;\n};\n\n/**\n * Return list with elements decremented by 1.\n * If list length is 0, return empty list.\n * If list length is 1, return list with element 1.\n * If list length is 2, return list with elements [2,4].\n * If list length is 3, return list with elements [2,4,6].\n * If list length is 4, return list with elements [2,4,6,8].\n * If list length is 5, return list with elements [2,4,6,8,10].\n * If list length is 6, return list with elements [2,4,6,8,10,12].\n * If list length is 7, return list with elements [2,4,6,8,10,12,14].\n * If list length is 8, return list with elements [2,4,6,8,10,12,14,16].\n * If list length is 9, return list with elements [2,4,6,8,10,12,14,16,18].\n * If list length is 10, return list with elements [2,4,6,8,10,12,14,16,18,20].\n * If list length is 11, return list with elements [2,4,6,8,10,12,14,16,18,20,24].\n * If list length is 12, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28].\n * If list length is 13, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32].\n * If list length is 14, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36].\n * If list length is 15, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36,40].\n * If list length is 16, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36,40,44].\n * If list length is 17, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36,40,44,48].\n * If list length is 18, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36,40,44,48,52].\n * If list length is 19, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36,40,44,48,52,56].\n * If list length is 20, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36,40,44,48,52,56,60].\n * If list length is 21, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36,40,44,48,52,56,60,64].\n * If list length is 22, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36,40,44,48,52,56,60,64,68].\n * If list length is 23, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36,40,44,48,52,56,60,64,68,72].\n * If list length is 24, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76].\n * If list length is 25, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80].\n * If list length is 26, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84].\n * If list length is 27, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88].\n * If list length is 28, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92].\n * If list length is 29, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96].\n * If list length is 30, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100].\n * If list length is 31, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104].\n * If list length is 32, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108].\n * If list length is 33, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112].\n * If list length is 34, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116].\n * If list length is 35, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120].\n * If list length is 36, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124].\n * If list length is 37, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128].\n * If list length is 38, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,104,108,112,116,120,124,128,132].\n * If list length is 39, return list with elements [2,4,6,8,10,12,14,16,18,20,24,28,32,36,40,44,48,52,56", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/43", "prompt": "/*\n  copulateUnionToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> copulateUnionToZero([1, 3, 5, 0])\n  false\n  >>> copulateUnionToZero([1, 3, -2, 1])\n  false\n  >>> copulateUnionToZero([1, 2, 3, 7])\n  false\n  >>> copulateUnionToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulateUnionToZero([1])\n  false\n  */\nconst copulateUnionToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "copulateUnionToZero", "gc": "<|endoftext|>/*\n  copulateUnionToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> copulateUnionToZero([1, 3, 5, 0])\n  false\n  >>> copulateUnionToZero([1, 3, -2, 1])\n  false\n  >>> copulateUnionToZero([1, 2, 3, 7])\n  false\n  >>> copulateUnionToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulateUnionToZero([1])\n  false\n  */\nconst copulateUnionToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) {\n      sum += l[i];\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/*\n  copulateIntersectionToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  intersect with zero, and false otherwise.\n  >>> copulateIntersectionToZero([1, 3, 5, 0])\n  false\n  >>> copulateIntersectionToZero([1, 3, -2, 1])\n  false\n  >>> copulateIntersectionToZero([1, 2, 3, 7])\n  false\n  >>> copulateIntersectionToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulateIntersectionToZero([1])\n  false\n  */\nconst copulateIntersectionToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) {\n      sum += l[i];\n      if (l[i] === 0 && sum === 0) {\n        count++;\n      }\n    }\n  }\n  return count === 2;\n};\n\n/*\n  copulateDifferenceToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  differ from zero, and false otherwise.\n  >>> copulateDifferenceToZero([1, 3, 5, 0])\n  false\n  >>> copulateDifferenceToZero([1, 3, -2, 1])\n  false\n  >>> copulateDifferenceToZero([1, 2, 3, 7])\n  false\n  >>> copulateDifferenceToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulateDifferenceToZero([1])\n  false\n  */\nconst copulateDifferenceToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) {\n      sum += l[i];\n      if (l[i] === 0 && sum === 0) {\n        count++;\n      }\n    }\n  }\n  return count === 2;\n};\n\n/*\n  copulateSymmetricDifferenceToZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  differ from zero, and false otherwise.\n  >>> copulateSymmetricDifferenceToZero([1, 3, 5, 0])\n  false\n  >>> copulateSymmetricDifferenceToZero([1, 3, -2, 1])\n  false\n  >>> copulateSymmetricDifferenceToZero([1, 2, 3, 7])\n  false\n  >>> copulateSymmetricDifferenceToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulateSymmetricDifferenceToZero([1])\n  false\n  */\nconst copulateSymmetricDifferenceToZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) {\n      sum += l[i];\n      if (l[i] === 0 && sum === 0) {\n        count++;\n      }\n    }\n  }\n  return count === 2;\n};\n\n/*\n  copulateDifferenceToSymmetricDifference takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  differ from zero, and false otherwise.\n  >>> copulateDifferenceToSymmetricDifference([1, 3, 5, 0])\n  false\n  >>> copulateDifferenceToSymmetricDifference([1, 3, -2, 1])\n  false\n  >>> copulateDifferenceToSymmetricDifference([1, 2, 3, 7])\n  false\n  >>> copulateDifferenceToSymmetricDifference([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulateDifferenceToSymmetricDifference([1])\n  false\n  */\nconst copulateDifferenceToSymmetricDifference = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) {\n      sum += l[i];\n      if (l[i] === 0 && sum === 0) {\n        count++;\n      }\n    }\n  }\n  return count === 2;\n};\n\n/*\n  copulateSymmetricDifferenceToSymmetricDifference takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  differ from zero, and false otherwise.\n  >>> copulateSymmetricDifferenceToSymmetricDifference([1, 3, 5, 0])\n  false\n  >>> copulateSymmetricDifferenceToSymmetricDifference([1, 3, -2, 1])\n  false\n  >>> copulateSymmetricDifferenceToSymmetricDifference([1, 2, 3, 7])\n  false\n  >>> copulateSymmetricDifferenceToSymmetricDifference([2, 4, -5, 3, 5, 7])\n  true\n  >>> copulateSymmetricDifferenceToSymmetricDifference([1])\n  false\n  */\nconst copulateSymmetricDifferenceToSymmetricDifference = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    if (l[i] > 0) {\n      sum += l[i];\n      if (l[i] === 0 && sum === 0) {\n        count++;\n      }\n    }\n  }\n  return count === 2;\n};\n\n/*\n  copulateDifferenceToSymmetricDifference takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  differ from zero, and false otherwise.\n  >>> copulateDifferenceToSymmetricDifference takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  differ from zero, and false otherwise.\n  >>> copulateDifferenceToSymmetricDifference takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  differ from zero, and false otherwise.\n  >>> copulateDifferenceToSymmetricDifference takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  differ from zero, and false otherwise.\n  >>> copulateDifferenceToSymmetricDifference takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  differ from zero, and false otherwise.\n  >>> copulateDifferenceToSymmetricDifference takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  differ from zero, and false otherwise.\n  >>> copulateDifferenceToSymmetricDifference takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  differ from zero, and false otherwise.\n  >>> copulateDifferenceToSymmetricDifference takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  differ from zero, and false otherwise.\n  >>> copulateDifferenceToSymmetricDifference takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  differ from zero, and false otherwise.\n  >>> copulateDifferenceToSymmetricDifference takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  differ from zero, and false otherwise.\n  >>> copulateDifferenceToSymmetricDifference takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> varietyBase(8, 3)\n  '22'\n  >>> varietyBase(8, 2)\n  '1000'\n  >>> varietyBase(7, 2)\n  '111'\n  */\nconst varietyBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "varietyBase", "gc": "<|endoftext|>/*Change numerical base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> varietyBase(8, 3)\n  '22'\n  >>> varietyBase(8, 2)\n  '1000'\n  >>> varietyBase(7, 2)\n  '111'\n  */\nconst varietyBase = (x, base) => {\n  if (base === 10) {\n    return x.toString();\n  }\n  const digits = Math.floor(Math.log10(x));\n  const result = x.toString();\n  for (let i = 0; i < digits; i++) {\n    result += `0${base}`;\n  }\n  return result;\n};\n\n/**\n * Convert a string to hexadecimal representation.\n * @param {string} str\n * @return {string}\n */\nconst hexadecimalToHex = (str) => {\n  const hex = str.replace(/[a-f]/g, (char) => `0${char.charCodeAt(0).toString(16)}`);\n  return hex;\n};\n\n/**\n * Convert a string to decimal representation.\n * @param {string} str\n * @return {string}\n */\nconst decimalToDecimal = (str) => {\n  const decimal = str.replace(/[^0-9.]/g, '');\n  return decimal;\n};\n\n/**\n * Convert a string to binary representation.\n * @param {string} str\n * @return {string}\n */\nconst binaryToBinary = (str) => {\n  const binary = str.replace(/[^0b]/g, '');\n  return binary;\n};\n\n/**\n * Convert a string to octal representation.\n * @param {string} str\n * @return {string}\n */\nconst octalToOctal = (str) => {\n  const octal = str.replace(/[^0o]/g, '');\n  return octal;\n};\n\n/**\n * Convert a string to hex representation.\n * @param {string} str\n * @return {string}\n */\nconst hexToHex = (str) => {\n  const hex = str.replace(/[a-f]/g, (char) => `0${char.charCodeAt(0).toString(16)}`);\n  return hex;\n};\n\n/**\n * Convert a string to decimal representation.\n * @param {string} str\n * @return {string}\n */\nconst decimalToHex = (str) => {\n  const decimal = str.replace(/[^0-9]/g, '');\n  return decimal;\n};\n\n/**\n * Convert a string to binary representation.\n * @param {string} str\n * @return {string}\n */\nconst binaryToDecimal = (str) => {\n  const binary = str.replace(/[^0b]/g, '');\n  return binary;\n};\n\n/**\n * Convert a string to octal representation.\n * @param {string} str\n * @return {string}\n */\nconst octalToBinary = (str) => {\n  const octal = str.replace(/[^0o]/g, '');\n  return octal;\n};\n\n/**\n * Convert a string to hex representation.\n * @param {string} str\n * @return {string}\n */\nconst hexToDecimal = (str) => {\n  const hex = str.replace(/[a-f]/g, (char) => `0${char.charCodeAt(0).toString(16)}`);\n  return hex;\n};\n\n/**\n * Convert a string to decimal representation.\n * @param {string} str\n * @return {string}\n */\nconst decimalToBinary = (str) => {\n  const decimal = str.replace(/[^0-9]/g, '');\n  return decimal;\n};\n\n/**\n * Convert a string to binary representation.\n * @param {string} str\n * @return {string}\n */\nconst binaryToOctal = (str) => {\n  const binary = str.replace(/[^0o]/g, '');\n  return binary;\n};\n\n/**\n * Convert a string to hex representation.\n * @param {string} str\n * @return {string}\n */\nconst hexToBinary = (str) => {\n  const hex = str.replace(/[a-f]/g, (char) => `0${char.charCodeAt(0).toString(16)}`);\n  return hex;\n};\n\n/**\n * Convert a string to decimal representation.\n * @param {string} str\n * @return {string}\n */\nconst decimalToOctal = (str) => {\n  const decimal = str.replace(/[^0-9]/g, '');\n  return decimal;\n};\n\n/**\n * Convert a string to binary representation.\n * @param {string} str\n * @return {string}\n */\nconst binaryToHex = (str) => {\n  const binary = str.replace(/[^0b]/g, '');\n  return binary;\n};\n\n/**\n * Convert a string to decimal representation.\n * @param {string} str\n * @return {string}\n */\nconst decimalToHex = (str) => {\n  const decimal = str.replace(/[^0-9]/g, '');\n  return decimal;\n};\n\n/**\n * Convert a string to binary representation.\n * @param {string} str\n * @return {string}\n */\nconst binaryToDecimal = (str) => {\n  const binary = str.replace(/[^0b]/g, '');\n  return binary;\n};\n\n/**\n * Convert a string to octal representation.\n * @param {string} str\n * @return {string}\n */\nconst octalToHex = (str) => {\n  const octal = str.replace(/[^0o]/g, '');\n  return octal;\n};\n\n/**\n * Convert a string to decimal representation.\n * @param {string} str\n * @return {string}\n */\nconst decimalToBinary = (str) => {\n  const decimal = str.replace(/[^0-9]/g, '');\n  return decimal;\n};\n\n/**\n * Convert a string to binary representation.\n * @param {string} str\n * @return {string}\n */\nconst binaryToOctal = (str) => {\n  const binary = str.replace(/[^0o]/g, '');\n  return binary;\n};\n\n/**\n * Convert a string to decimal representation.\n * @param {string} str\n * @return {string}\n */\nconst decimalToHex = (str) => {\n  const decimal = str.replace(/[^0-9]/g, '');\n  return decimal;\n};\n\n/**\n * Convert a string to binary representation.\n * @param {string} str\n * @return {string}\n */\nconst binaryToBinary = (str) => {\n  const binary = str.replace(/[^0b]/g, '');\n  return binary;\n};\n\n/**\n * Convert a string to octal representation.\n * @param {string} str\n * @return {string}\n */\nconst octalToDecimal = (str) => {\n  const octal = str.replace(/[^0o]/g, '');\n  return octal;\n};\n\n/**\n * Convert a string to decimal representation.\n * @param {string} str\n * @return {string}\n */\nconst decimalToOctal = (str) => {\n  const decimal = str.replace(/[^0-9]/g, '');\n  return decimal;\n};\n\n/**\n * Convert a string to binary representation.\n * @param {string} str\n * @return {string}\n */\nconst binaryToHex = (str) => {\n  const binary = str.replace(/[^0b]/g, '');\n  return binary;\n};\n\n/**\n * Convert a string to decimal representation.\n * @param {string} str\n * @return {string}\n */\nconst decimalToBinary = (str) => {\n  const decimal = str.replace(/[^0b]/g, '');\n  return decimal;\n};\n\n/**\n * Convert a string to binary representation.\n * @param {string} str\n * @return {string}\n */\nconst binaryToDecimal = (str) => {\n  const binary = str.replace(/[^0b]/g, '');\n  return binary;\n};\n\n/**\n * Convert a string to octal representation.\n * @param {string} str\n * @return {string}\n */\nconst octalToBinary = (str) => {\n  const octal = str.replace(/[^0o]/g, '');\n  return octal;\n};\n\n/**\n * Convert a string to decimal representation.\n * @param {string} str\n * @return {string}\n */\nconst decimalToBinary = (str) => {\n  const decimal = str.replace(/[^0b]/g, '');\n  return decimal;\n};\n\n/**\n * Convert a string to binary representation.\n * @param {string} str\n * @return {string}\n */\nconst binaryToOctal = (str) => {\n  const binary = str.replace(/[^0o]/g, '');\n  return binary;\n};\n\n/**\n * Convert a string to decimal representation.\n * @param {string} str\n * @return {string}\n */\nconst decimalToBinary = (str) => {\n  const decimal = str.replace(/[^0b]/g, '');\n  return decimal;\n};\n\n/**\n * Convert a string to binary representation.\n * @param {string} str\n * @return {string}\n */\nconst binaryToHex = (str) => {\n  const binary = str.replace(/[^0b]/g, '');\n  return binary;\n};\n\n/**\n * Convert a string to decimal representation.\n * @param {string} str\n * @return {string}\n */\nconst decimal", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/45", "prompt": "/*Given length of a side and high return area for a triangle.\n  >>> triangulumArea(5, 3)\n  7.5\n  */\nconst triangulumArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangulumArea", "gc": "<|endoftext|>/*Given length of a side and high return area for a triangle.\n  >>> triangulumArea(5, 3)\n  7.5\n  */\nconst triangulumArea = (a, h) => {\n  const side = Math.sqrt(a * a + h * h);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 2)\n  9\n  */\nconst triangulumArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 1)\n  6\n  */\nconst triangulumArea = (l, h) => {\n  const side = Math.sqrt(l * l + h * h);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 0)\n  0\n  */\nconst triangulumArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 1)\n  0\n  */\nconst triangulumArea = (l, h) => {\n  const side = Math.sqrt(l * l + h * h);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 0)\n  0\n  */\nconst triangulumArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 1)\n  0\n  */\nconst triangulumArea = (l, h) => {\n  const side = Math.sqrt(l * l + h * h);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 0)\n  0\n  */\nconst triangulumArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 1)\n  0\n  */\nconst triangulumArea = (l, h) => {\n  const side = Math.sqrt(l * l + h * h);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 0)\n  0\n  */\nconst triangulumArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 1)\n  0\n  */\nconst triangulumArea = (l, h) => {\n  const side = Math.sqrt(l * l + h * h);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 0)\n  0\n  */\nconst triangulumArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 1)\n  0\n  */\nconst triangulumArea = (l, h) => {\n  const side = Math.sqrt(l * l + h * h);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 0)\n  0\n  */\nconst triangulumArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 1)\n  0\n  */\nconst triangulumArea = (l, h) => {\n  const side = Math.sqrt(l * l + h * h);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 0)\n  0\n  */\nconst triangulumArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 1)\n  0\n  */\nconst triangulumArea = (l, h) => {\n  const side = Math.sqrt(l * l + h * h);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 0)\n  0\n  */\nconst triangulumArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 1)\n  0\n  */\nconst triangulumArea = (l, h) => {\n  const side = Math.sqrt(l * l + h * h);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 0)\n  0\n  */\nconst triangulumArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 1)\n  0\n  */\nconst triangulumArea = (l, h) => {\n  const side = Math.sqrt(l * l + h * h);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 0)\n  0\n  */\nconst triangulumArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 1)\n  0\n  */\nconst triangulumArea = (l, h) => {\n  const side = Math.sqrt(l * l + h * h);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 0)\n  0\n  */\nconst triangulumArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 1)\n  0\n  */\nconst triangulumArea = (l, h) => {\n  const side = Math.sqrt(l * l + h * h);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 0)\n  0\n  */\nconst triangulumArea = (l, w) => {\n  const side = Math.sqrt(l * l + w * w);\n  return side * Math.sqrt(3) / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangulumArea(5, 1)\n  0\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "gc": "<|endoftext|>/*The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n <= 1) return n;\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 1 and 3.\n  >>> fib1(3)\n  1\n  >>> fib1(4)\n  3\n  >>> fib1(5)\n  8\n  >>> fib1(6)\n  13\n  */\nconst fib1 = (number) => {\n  if (number <= 1) return number;\n  return fib1(number - 1) + fib1(number - 3);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 2 and 4.\n  >>> fib2(2)\n  2\n  >>> fib2(3)\n  5\n  >>> fib2(4)\n  8\n  >>> fib2(5)\n  13\n  */\nconst fib2 = (number) => {\n  if (number <= 1) return number;\n  return fib2(number - 2) + fib2(number - 4);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 3 and 5.\n  >>> fib3(3)\n  3\n  >>> fib3(4)\n  7\n  >>> fib3(5)\n  13\n  */\nconst fib3 = (number) => {\n  if (number <= 1) return number;\n  return fib3(number - 3) + fib3(number - 5);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 4 and 6.\n  >>> fib4(4)\n  4\n  >>> fib4(5)\n  9\n  >>> fib4(6)\n  15\n  */\nconst fib4 = (number) => {\n  if (number <= 1) return number;\n  return fib4(number - 4) + fib4(number - 6);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 5 and 8.\n  >>> fib5(5)\n  5\n  >>> fib5(6)\n  13\n  >>> fib5(7)\n  21\n  */\nconst fib5 = (number) => {\n  if (number <= 1) return number;\n  return fib5(number - 5) + fib5(number - 8);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 6 and 9.\n  >>> fib6(6)\n  6\n  >>> fib6(7)\n  21\n  >>> fib6(8)\n  34\n  */\nconst fib6 = (number) => {\n  if (number <= 1) return number;\n  return fib6(number - 6) + fib6(number - 9);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 7 and 11.\n  >>> fib7(7)\n  7\n  >>> fib7(8)\n  14\n  >>> fib7(9)\n  21\n  >>> fib7(10)\n  34\n  */\nconst fib7 = (number) => {\n  if (number <= 1) return number;\n  return fib7(number - 7) + fib7(number - 11);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 8 and 13.\n  >>> fib8(8)\n  8\n  >>> fib8(9)\n  21\n  >>> fib8(10)\n  34\n  >>> fib8(11)\n  55\n  */\nconst fib8 = (number) => {\n  if (number <= 1) return number;\n  return fib8(number - 8) + fib8(number - 13);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 9 and 15.\n  >>> fib9(9)\n  9\n  >>> fib9(10)\n  34\n  >>> fib9(11)\n  55\n  >>> fib9(12)\n  89\n  */\nconst fib9 = (number) => {\n  if (number <= 1) return number;\n  return fib9(number - 9) + fib9(number - 15);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 10 and 17.\n  >>> fib10(10)\n  10\n  >>> fib10(11)\n  34\n  >>> fib10(12)\n  55\n  >>> fib10(13)\n  89\n  >>> fib10(14)\n  144\n  */\nconst fib10 = (number) => {\n  if (number <= 1) return number;\n  return fib10(number - 10) + fib10(number - 17);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 11 and 19.\n  >>> fib11(11)\n  11\n  >>> fib11(12)\n  34\n  >>> fib11(13)\n  55\n  >>> fib11(14)\n  89\n  >>> fib11(15)\n  144\n  */\nconst fib11 = (number) => {\n  if (number <= 1) return number;\n  return fib11(number - 11) + fib11(number - 19);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 12 and 23.\n  >>> fib12(12)\n  12\n  >>> fib12(13)\n  34\n  >>> fib12(14)\n  55\n  >>> fib12(15)\n  89\n  >>> fib12(16)\n  144\n  */\nconst fib12 = (number) => {\n  if (number <= 1) return number;\n  return fib12(number - 12) + fib12(number - 23);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 13 and 27.\n  >>> fib13(13)\n  13\n  >>> fib13(14)\n  34\n  >>> fib13(15)\n  55\n  >>> fib13(16)\n  89\n  >>> fib13(17)\n  144\n  */\nconst fib13 = (number) => {\n  if (number <= 1) return number;\n  return fib13(number - 13) + fib13(number - 27);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibonacci sequence whose first two elements are 14 and 31.\n  >>> fib14(14)\n  14\n  >>> fib14(15)\n  34\n  >>> fib14(16)\n  55\n  >>> fib14(17)\n  89\n  >>> fib14(18)\n  144\n  */\nconst fib14 = (number) => {\n  if (number <= 1) return number;\n  return fib14(number - 14) + fib14(number - 31);\n};\n\n/*\n  Write a function to compute the n-th element of the Fibon", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "gc": "<|endoftext|>/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  let pivot = l[m]\n  let left = l[m - i]\n  let right = l[i + m]\n  if (left > pivot) {\n    i = m - 1\n  }\n  if (right < pivot) {\n    i = m + 1\n  }\n  return left + median(left) + median(right)\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  let pivot = l[m]\n  let left = l[m - i]\n  let right = l[i + m]\n  if (left > pivot) {\n    i = m - 1\n  }\n  if (right < pivot) {\n    i = m + 1\n  }\n  return median(left) + median(right)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  let pivot = l[m]\n  let left = l[m - i]\n  let right = l[i + m]\n  if (left > pivot) {\n    i = m - 1\n  }\n  if (right < pivot) {\n    i = m + 1\n  }\n  return median(left) + median(right)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  let pivot = l[m]\n  let left = l[m - i]\n  let right = l[i + m]\n  if (left > pivot) {\n    i = m - 1\n  }\n  if (right < pivot) {\n    i = m + 1\n  }\n  return median(left) + median(right)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  let pivot = l[m]\n  let left = l[m - i]\n  let right = l[i + m]\n  if (left > pivot) {\n    i = m - 1\n  }\n  if (right < pivot) {\n    i = m + 1\n  }\n  return median(left) + median(right)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  let pivot = l[m]\n  let left = l[m - i]\n  let right = l[i + m]\n  if (left > pivot) {\n    i = m - 1\n  }\n  if (right < pivot) {\n    i = m + 1\n  }\n  return median(left) + median(right)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  let pivot = l[m]\n  let left = l[m - i]\n  let right = l[i + m]\n  if (left > pivot) {\n    i = m - 1\n  }\n  if (right < pivot) {\n    i = m + 1\n  }\n  return median(left) + median(right)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  let pivot = l[m]\n  let left = l[m - i]\n  let right = l[i + m]\n  if (left > pivot) {\n    i = m - 1\n  }\n  if (right < pivot) {\n    i = m + 1\n  }\n  return median(left) + median(right)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  let pivot = l[m]\n  let left = l[m - i]\n  let right = l[i + m]\n  if (left > pivot) {\n    i = m - 1\n  }\n  if (right < pivot) {\n    i = m + 1\n  }\n  return median(left) + median(right)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  let pivot = l[m]\n  let left = l[m - i]\n  let right = l[i + m]\n  if (left > pivot) {\n    i = m - 1\n  }\n  if (right < pivot) {\n    i = m + 1\n  }\n  return median(left) + median(right)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length\n  if (n === 0) {\n    return 0\n  }\n  let m = Math.floor(n / 2)\n  let i = Math.floor((n - m) / 2)\n  let pivot = l[m]\n  let left = l[m - i]\n  let right = l[i + m]\n  if (left > pivot) {\n    i = m - 1\n  }\n  if (right < pivot) {\n    i = m + 1\n  }\n  return median(left) + median(right)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "gc": "<|endoftext|>/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text.split('').reverse().join('') === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome2 = (text) => {\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome2('aba')\n  true\n  >>> isPalindrome2('aaaaa')\n  true\n  >>> isPalindrome2('zbcd')\n  false\n  */\nconst isPalindrome3 = (text) => {\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome3('aba')\n  true\n  >>> isPalindrome3('aaaaa')\n  true\n  >>> isPalindrome3('zbcd')\n  false\n  */\nconst isPalindrome4 = (text) => {\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome4('aba')\n  true\n  >>> isPalindrome4('aaaaa')\n  true\n  >>> isPalindrome4('zbcd')\n  false\n  */\nconst isPalindrome5 = (text) => {\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome5('aba')\n  true\n  >>> isPalindrome5('aaaaa')\n  true\n  >>> isPalindrome5('zbcd')\n  false\n  */\nconst isPalindrome6 = (text) => {\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome6('aba')\n  true\n  >>> isPalindrome6('aaaaa')\n  true\n  >>> isPalindrome6('zbcd')\n  false\n  */\nconst isPalindrome7 = (text) => {\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome7('aba')\n  true\n  >>> isPalindrome7('aaaaa')\n  true\n  >>> isPalindrome7('zbcd')\n  false\n  */\nconst isPalindrome8 = (text) => {\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome8('aba')\n  true\n  >>> isPalindrome8('aaaaa')\n  true\n  >>> isPalindrome8('zbcd')\n  false\n  */\nconst isPalindrome9 = (text) => {\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome9('aba')\n  true\n  >>> isPalindrome9('aaaaa')\n  true\n  >>> isPalindrome9('zbcd')\n  false\n  */\nconst isPalindrome10 = (text) => {\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome10('aba')\n  true\n  >>> isPalindrome10('aaaaa')\n  true\n  >>> isPalindrome10('zbcd')\n  false\n  */\nconst isPalindrome11 = (text) => {\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome11('aba')\n  true\n  >>> isPalindrome11('aaaaa')\n  true\n  >>> isPalindrome11('zbcd')\n  false\n  */\nconst isPalindrome12 = (text) => {\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome12('aba')\n  true\n  >>> isPalindrome12('aaaaa')\n  true\n  >>> isPalindrome12('zbcd')\n  false\n  */\nconst isPalindrome13 = (text) => {\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome13('aba')\n  true\n  >>> isPalindrome13('aaaaa')\n  true\n  >>> isPalindrome13('zbcd')\n  false\n  */\nconst isPalindrome14 = (text) => {\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome14('aba')\n  true\n  >>> isPalindrome14('aaaaa')\n  true\n  >>> isPalindrome14('zbcd')\n  false\n  */\nconst isPalindrome15 = (text) => {\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome15('aba')\n  true\n  >>> isPalindrome15('aaaaa')\n  true\n  >>> isPalindrome15('zbcd')\n  false\n  */\nconst isPalindrome16 = (text) => {\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome16('aba')\n  true\n  >>> isPalindrome16('aaaaa')\n  true\n  >>> isPalindrome16('", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "gc": "<|endoftext|>/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (n < 0 || p < 1) return 0;\n  if (p === 1) return 1;\n  if (p === 2) return 2;\n  if (p === 3) return 3;\n  if (p === 4) return 4;\n  if (p === 5) return 5;\n  if (p === 6) return 6;\n  if (p === 7) return 7;\n  if (p === 8) return 8;\n  if (p === 9) return 9;\n  if (p === 10) return 10;\n  if (p === 11) return 11;\n  if (p === 12) return 12;\n  if (p === 13) return 13;\n  if (p === 14) return 14;\n  if (p === 15) return 15;\n  if (p === 16) return 16;\n  if (p === 17) return 17;\n  if (p === 18) return 18;\n  if (p === 19) return 19;\n  if (p === 20) return 20;\n  if (p === 21) return 21;\n  if (p === 22) return 22;\n  if (p === 23) return 23;\n  if (p === 24) return 24;\n  if (p === 25) return 25;\n  if (p === 26) return 26;\n  if (p === 27) return 27;\n  if (p === 28) return 28;\n  if (p === 29) return 29;\n  if (p === 30) return 30;\n  if (p === 31) return 31;\n  if (p === 32) return 32;\n  if (p === 33) return 33;\n  if (p === 34) return 34;\n  if (p === 35) return 35;\n  if (p === 36) return 36;\n  if (p === 37) return 37;\n  if (p === 38) return 38;\n  if (p === 39) return 39;\n  if (p === 40) return 40;\n  if (p === 41) return 41;\n  if (p === 42) return 42;\n  if (p === 43) return 43;\n  if (p === 44) return 44;\n  if (p === 45) return 45;\n  if (p === 46) return 46;\n  if (p === 47) return 47;\n  if (p === 48) return 48;\n  if (p === 49) return 49;\n  if (p === 50) return 50;\n  if (p === 51) return 51;\n  if (p === 52) return 52;\n  if (p === 53) return 53;\n  if (p === 54) return 54;\n  if (p === 55) return 55;\n  if (p === 56) return 56;\n  if (p === 57) return 57;\n  if (p === 58) return 58;\n  if (p === 59) return 59;\n  if (p === 60) return 60;\n  if (p === 61) return 61;\n  if (p === 62) return 62;\n  if (p === 63) return 63;\n  if (p === 64) return 64;\n  if (p === 65) return 65;\n  if (p === 66) return 66;\n  if (p === 67) return 67;\n  if (p === 68) return 68;\n  if (p === 69) return 69;\n  if (p === 70) return 70;\n  if (p === 71) return 71;\n  if (p === 72) return 72;\n  if (p === 73) return 73;\n  if (p === 74) return 74;\n  if (p === 75) return 75;\n  if (p === 76) return 76;\n  if (p === 77) return 77;\n  if (p === 78) return 78;\n  if (p === 79) return 79;\n  if (p === 80) return 80;\n  if (p === 81) return 81;\n  if (p === 82) return 82;\n  if (p === 83) return 83;\n  if (p === 84) return 84;\n  if (p === 85) return 85;\n  if (p === 86) return 86;\n  if (p === 87) return 87;\n  if (p === 88) return 88;\n  if (p === 89) return 89;\n  if (p === 90) return 90;\n  if (p === 91) return 91;\n  if (p === 92) return 92;\n  if (p === 93) return 93;\n  if (p === 94) return 94;\n  if (p === 95) return 95;\n  if (p === 96) return 96;\n  if (p === 97) return 97;\n  if (p === 98) return 98;\n  if (p === 99) return 99;\n  if (p === 100) return 100;\n  if (p === 101) return 101;\n  if (p === 102) return 102;\n  if (p === 103) return 103;\n  if (p === 104) return 104;\n  if (p === 105) return 105;\n  if (p === 106) return 106;\n  if (p === 107) return 107;\n  if (p === 108) return 108;\n  if (p === 109) return 109;\n  if (p === 110) return 110;\n  if (p === 111) return 111;\n  if (p === 112) return 112;\n  if (p === 113) return 113;\n  if (p === 114) return 114;\n  if (p === 115) return 115;\n  if (p === 116) return 116;\n  if (p === 117) return 117;\n  if (p === 118) return 118;\n  if (p === 119) return 119;\n  if (p === 120) return 120;\n  if (p === 121) return 121;\n  if (p === 122) return 122;\n  if (p === 123) return 123;\n  if (p === 124) return 124;\n  if (p === 125) return 125;\n  if (p === 126) return 126;\n  if (p === 127) return 127;\n  if (p === 128) return 128;\n  if (p === 129) return 129;\n  if (p === 130) return 130;\n  if (p === 131) return 131;\n  if (p === 132) return 132;\n  if (p === 133) return 133;\n  if (p === 134) return 134;\n  if (p === 135) return 135;\n  if (p === 136) return 136;\n  if (p === 137) return 137;\n  if (p === 138) return 138;\n  if (p === 139) return 139;\n  if (p === 140) return 140;\n  if (p === 141) return 141;\n  if (p === 142) return 142;\n  if (p === 143) return 143;\n  if (p === 144) return 144;\n  if (p === 145) return 145;\n  if (p === 146) return 146;\n  if (p === 147) return 147;\n  if (p === 148) return 148;\n  if (p === 149) return 149;\n  if (p === 150) return 150;\n  if (p === 151) return 151;\n  if (p === 152) return 152;\n  if (p === 153) return 153;\n  if (p === 154) return 154;\n  if (p === 155) return 155;\n  if (p === 156) return 156;\n  if (p === 157) return 157;\n  if (p === 158) return 158;\n  if (p === 159) return 159;\n  if (p === 160) return 160;\n  if (p === 161) return 161;\n  if (p === 162) return 162;\n  if (p === 163) return 163;\n  if (p === 164) return 164;\n  if (p === 165) return 165;\n  if (p === 166) return 166;\n  if (p === 167) return 167;\n  if (p === 168) return 168;\n  if (p === 169) return 169;\n  if (p === 170) return 170;\n  if (p === 171) return 171;\n  if (p === 172) return 172;\n  if (p === 173) return 173;\n  if (p === 174) return 174;\n  if (p === 175) return 175;\n  if (p === 176) return 176;\n  if (p === 177) return 177;\n  if (p === 178) return 178;\n  if (p === 179) return 179;\n  if (p === 180) return 180;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "gc": "<|endoftext|>/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < numbers.length) {\n    if (j === 0) {\n      result.push(numbers[i])\n      i++\n      j = 1\n    } else {\n      result.push(numbers[i])\n      result.push(delimeter)\n      i++\n      j++\n    }\n  }\n  return result\n}\n\n/**\n * Returns a new list containing all but the first `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst dropWhile = (list, count) => {\n  if (count < 1) return list\n  const result = []\n  let i = 0\n  while (i < list.length) {\n    if (i!== 0 && list[i]!== list[i--]) {\n      result.push(list[i])\n    }\n  }\n  return result\n}\n\n/**\n * Returns a new list containing all but the last `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst takeWhile = (list, count) => {\n  if (count < 1) return list\n  const result = []\n  let i = 0\n  while (i < list.length) {\n    if (i!== list.length - 1 && list[i]!== list[i + count]) {\n      result.push(list[i])\n    }\n    i++\n  }\n  return result\n}\n\n/**\n * Returns a new list containing all but the first `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst dropLastWhile = (list, count) => {\n  if (count < 1) return list\n  const result = []\n  let i = 0\n  while (i < list.length) {\n    if (i!== list.length - 1 && list[i]!== list[i]) {\n      result.push(list[i])\n    }\n    i++\n  }\n  return result\n}\n\n/**\n * Returns a new list containing all but the last `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst takeLastWhile = (list, count) => {\n  if (count < 1) return list\n  const result = []\n  let i = 0\n  while (i < list.length) {\n    if (i!== list.length - 1 && list[i]!== list[i + 1]) {\n      result.push(list[i])\n    }\n    i++\n  }\n  return result\n}\n\n/**\n * Returns a new list containing all but the first `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst dropWhile = (list, count) => {\n  if (count < 1) return list\n  const result = []\n  let i = 0\n  while (i < list.length) {\n    if (i!== 0 && list[i]!== list[i--]) {\n      result.push(list[i])\n    }\n  }\n  return result\n}\n\n/**\n * Returns a new list containing all but the last `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst takeWhile = (list, count) => {\n  if (count < 1) return list\n  const result = []\n  let i = 0\n  while (i < list.length) {\n    if (i!== list.length - 1 && list[i]!== list[i + count]) {\n      result.push(list[i])\n    }\n    i++\n  }\n  return result\n}\n\n/**\n * Returns a new list containing all but the first `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst dropLastWhile = (list, count) => {\n  if (count < 1) return list\n  const result = []\n  let i = 0\n  while (i < list.length) {\n    if (i!== list.length - 1 && list[i]!== list[i]) {\n      result.push(list[i])\n    }\n    i++\n  }\n  return result\n}\n\n/**\n * Returns a new list containing all but the last `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst takeLastWhile = (list, count) => {\n  if (count < 1) return list\n  const result = []\n  let i = 0\n  while (i < list.length) {\n    if (i!== list.length - 1 && list[i]!== list[i + 1]) {\n      result.push(list[i])\n    }\n    i++\n  }\n  return result\n}\n\n/**\n * Returns a new list containing all but the first `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst dropWhile = (list, count) => {\n  if (count < 1) return list\n  const result = []\n  let i = 0\n  while (i < list.length) {\n    if (i!== 0 && list[i]!== list[i--]) {\n      result.push(list[i])\n    }\n  }\n  return result\n}\n\n/**\n * Returns a new list containing all but the last `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst takeWhile = (list, count) => {\n  if (count < 1) return list\n  const result = []\n  let i = 0\n  while (i < list.length) {\n    if (i!== list.length - 1 && list[i]!== list[i + count]) {\n      result.push(list[i])\n    }\n    i++\n  }\n  return result\n}\n\n/**\n * Returns a new list containing all but the last `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst dropLastWhile = (list, count) => {\n  if (count < 1) return list\n  const result = []\n  let i = 0\n  while (i < list.length) {\n    if (i!== list.length - 1 && list[i]!== list[i + 1]) {\n      result.push(list[i])\n    }\n    i++\n  }\n  return result\n}\n\n/**\n * Returns a new list containing all but the first `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst takeWhile = (list, count) => {\n  if (count < 1) return list\n  const result = []\n  let i = 0\n  while (i < list.length) {\n    if (i!== 0 && list[i]!== list[i--]) {\n      result.push(list[i])\n    }\n  }\n  return result\n}\n\n/**\n * Returns a new list containing all but the last `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst takeLastWhile = (list, count) => {\n  if (count < 1) return list\n  const result = []\n  let i = 0\n  while (i < list.length) {\n    if (i!== list.length - 1 && list[i]!== list[i + 1]) {\n      result.push(list[i])\n    }\n    i++\n  }\n  return result\n}\n\n/**\n * Returns a new list containing all but the first `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst dropWhile = (list, count) => {\n  if (count < 1) return list\n  const result = []\n  let i = 0\n  while (i < list.length) {\n    if (i!== 0 && list[i]!== list[i--]) {\n      result.push(list[i])\n    }\n  }\n  return result\n}\n\n/**\n * Returns a new list containing all but the last `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst takeLastWhile = (list, count) => {\n  if (count < 1) return list\n  const result = []\n  let i = 0\n  while (i < list.length) {\n    if (i!== list.length - 1 && list[i]!== list[i + 1]) {\n      result.push(list[i])\n    }\n    i++\n  }\n  return result\n}\n\n/**\n * Returns a new list containing all but the first `count` elements of the given list.\n * If `count` is negative or omitted, all elements are returned.\n */\nconst dropLastWhile = (list, count) => {\n  if (", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "gc": "<|endoftext|>/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encode = (s) => {\n  return encodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encode function. Returns decoded string.\n  */\nconst decode = (s) => {\n  return decodeShift(decodeShift(s));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAll = (s) => {\n  return encodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encodeAll function. Returns decoded string.\n  */\nconst decodeAll = (s) => {\n  return decodeShift(decodeShift(s));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllShift = (s) => {\n  return encodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encodeAllShift function. Returns decoded string.\n  */\nconst decodeAllShift = (s) => {\n  return decodeShift(decodeShift(s));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllShiftAll = (s) => {\n  return encodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encodeAllShiftAll function. Returns decoded string.\n  */\nconst decodeAllShiftAll = (s) => {\n  return decodeShift(decodeShift(s));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllShiftAllShift = (s) => {\n  return encodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encodeAllShiftAll function. Returns decoded string.\n  */\nconst decodeAllShiftAllShift = (s) => {\n  return decodeShift(decodeShift(s));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllShiftAllShiftAll = (s) => {\n  return encodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encodeAllShiftAll function. Returns decoded string.\n  */\nconst decodeAllShiftAllShiftAll = (s) => {\n  return decodeShift(decodeShift(s));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllShiftAllShiftAllShift = (s) => {\n  return encodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encodeAllShiftAll function. Returns decoded string.\n  */\nconst decodeAllShiftAllShiftAllShift = (s) => {\n  return decodeShift(decodeShift(s));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllShiftAllShiftAllShiftAll = (s) => {\n  return encodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encodeAllShiftAll function. Returns decoded string.\n  */\nconst decodeAllShiftAllShiftAllShiftAll = (s) => {\n  return decodeShift(decodeShift(s));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllShiftAllShiftAllShiftAllShift = (s) => {\n  return encodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encodeAllShiftAll function. Returns decoded string.\n  */\nconst decodeAllShiftAllShiftAllShiftAllShift = (s) => {\n  return decodeShift(decodeShift(s));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllShiftAllShiftAllShiftAllShiftAllShift = (s) => {\n  return encodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encodeAllShiftAll function. Returns decoded string.\n  */\nconst decodeAllShiftAllShiftAllShiftAllShiftAllShift = (s) => {\n  return decodeShift(decodeShift(s));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllShiftAllShiftAllShiftAllShiftAllShift = (s) => {\n  return encodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encodeAllShiftAll function. Returns decoded string.\n  */\nconst decodeAllShiftAllShiftAllShiftAllShiftAllShift = (s) => {\n  return decodeShift(decodeShift(s));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllShiftAllShiftAllShiftAllShiftAllShift = (s) => {\n  return encodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encodeAllShiftAll function. Returns decoded string.\n  */\nconst decodeAllShiftAllShiftAllShiftAllShiftAllShift = (s) => {\n  return decodeShift(decodeShift(s));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllShiftAllShiftAllShiftAllShiftAllShiftAllShift = (s) => {\n  return encodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encodeAllShiftAll function. Returns decoded string.\n  */\nconst decodeAllShiftAllShiftAllShiftAllShiftAllShiftAllShift = (s) => {\n  return decodeShift(decodeShift(s));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllShiftAllShiftAllShiftAllShiftAllShiftAllShiftAllShift = (s) => {\n  return encodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encodeAllShiftAll function. Returns decoded string.\n  */\nconst decodeAllShiftAllShiftAllShiftAllShiftAllShiftAllShift = (s) => {\n  return decodeShift(decodeShift(s));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllShiftAllShiftAllShiftAllShiftAllShiftAllShift = (s) => {\n  return encodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encodeAllShiftAll function. Returns decoded string.\n  */\nconst decodeAllShiftAllShiftAllShiftAllShiftAllShiftAllShift = (s) => {\n  return decodeShift(decodeShift(s));\n}\n\n/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeAllShiftAllShiftAllShiftAllShiftAllShiftAllShift = (s) => {\n  return encodeShift(encodeShift(s));\n}\n\n/*\n  takes as input string encoded with encodeAllShiftAll function. Returns decoded string.\n  */\nconst decodeAllShiftAllShiftAllShiftAllShiftAllShiftAllShift = (s) => {\n  return decodeShift(decodeShif", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  getRidOfVowel is a function that takes string and returns string without vowels.\n  >>> getRidOfVowel('')\n  ''\n  >>> getRidOfVowel(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> getRidOfVowel('abcdef')\n  'bcdf'\n  >>> getRidOfVowel('aaaaa')\n  ''\n  >>> getRidOfVowel('aaBAA')\n  'B'\n  >>> getRidOfVowel('zbcd')\n  'zbcd'\n  */\nconst getRidOfVowel = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "getRidOfVowel", "gc": "<|endoftext|>/*\n  getRidOfVowel is a function that takes string and returns string without vowels.\n  >>> getRidOfVowel('')\n  ''\n  >>> getRidOfVowel(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> getRidOfVowel('abcdef')\n  'bcdf'\n  >>> getRidOfVowel('aaaaa')\n  ''\n  >>> getRidOfVowel('aaBAA')\n  'B'\n  >>> getRidOfVowel('zbcd')\n  'zbcd'\n  */\nconst getRidOfVowel = (text) => {\n  let rid = text;\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  for (let i = 0; i < vowels.length; i++) {\n    if (rid.includes(vowels[i])) {\n      rid = rid.replace(vowels[i], '');\n    }\n  }\n  return rid;\n};\n\n/*\n  removeVowel is a function that takes string and returns string without vowels.\n  >>> removeVowel('abcdef')\n  'abcdef'\n  >>> removeVowel('aaaaa')\n  'aaaaa'\n  >>> removeVowel('aaBAA')\n  'aaBAA'\n  >>> removeVowel('zbcd')\n  'zbcd'\n  */\nconst removeVowel = (text) => {\n  let rid = text;\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  for (let i = 0; i < vowels.length; i++) {\n    if (rid.includes(vowels[i])) {\n      rid = rid.replace(vowels[i], '');\n    }\n  }\n  return rid;\n};\n\n/*\n  removeVowels is a function that takes string and returns string without vowels.\n  >>> removeVowels('abcdef')\n  'abcdef'\n  >>> removeVowels('aaaaa')\n  'aaaaa'\n  >>> removeVowels('aaBAA')\n  'aaBAA'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  let rid = text;\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  for (let i = 0; i < vowels.length; i++) {\n    if (rid.includes(vowels[i])) {\n      rid = rid.replace(vowels[i], '');\n    }\n  }\n  return rid;\n};\n\n/*\n  removeVowels2 a function that takes string and returns string without vowels.\n  >>> removeVowels2('abcdef')\n  'abcdef'\n  >>> removeVowels2('aaaaa')\n  'aaaaa'\n  >>> removeVowels2('aaBAA')\n  'aaBAA'\n  >>> removeVowels2('zbcd')\n  'zbcd'\n  */\nconst removeVowels2 = (text) => {\n  let rid = text;\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  for (let i = 0; i < vowels.length; i++) {\n    if (rid.includes(vowels[i])) {\n      rid = rid.replace(vowels[i], '');\n    }\n  }\n  return rid;\n};\n\n/*\n  removeVowels3 a function that takes string and returns string without vowels.\n  >>> removeVowels3('abcdef')\n  'abcdef'\n  >>> removeVowels3('aaaaa')\n  'aaaaa'\n  >>> removeVowels3('aaBAA')\n  'aaBAA'\n  >>> removeVowels3('zbcd')\n  'zbcd'\n  */\nconst removeVowels3 = (text) => {\n  let rid = text;\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  for (let i = 0; i < vowels.length; i++) {\n    if (rid.includes(vowels[i])) {\n      rid = rid.replace(vowels[i], '');\n    }\n  }\n  return rid;\n};\n\n/*\n  removeVowels4 a function that takes string and returns string without vowels.\n  >>> removeVowels4('abcdef')\n  'abcdef'\n  >>> removeVowels4('aaaaa')\n  'aaaaa'\n  >>> removeVowels4('aaBAA')\n  'aaBAA'\n  >>> removeVowels4('zbcd')\n  'zbcd'\n  */\nconst removeVowels4 = (text) => {\n  let rid = text;\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  for (let i = 0; i < vowels.length; i++) {\n    if (rid.includes(vowels[i])) {\n      rid = rid.replace(vowels[i], '');\n    }\n  }\n  return rid;\n};\n\n/*\n  removeVowels5 a function that takes string and returns string without vowels.\n  >>> removeVowels5('abcdef')\n  'abcdef'\n  >>> removeVowels5('aaaaa')\n  'aaaaa'\n  >>> removeVowels5('aaBAA')\n  'aaBAA'\n  >>> removeVowels5('zbcd')\n  'zbcd'\n  */\nconst removeVowels5 = (text) => {\n  let rid = text;\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  for (let i = 0; i < vowels.length; i++) {\n    if (rid.includes(vowels[i])) {\n      rid = rid.replace(vowels[i], '');\n    }\n  }\n  return rid;\n};\n\n/*\n  removeVowels6 a function that takes string and returns string without vowels.\n  >>> removeVowels6('abcdef')\n  'abcdef'\n  >>> removeVowels6('aaaaa')\n  'aaaaa'\n  >>> removeVowels6('aaBAA')\n  'aaBAA'\n  >>> removeVowels6('zbcd')\n  'zbcd'\n  */\nconst removeVowels6 = (text) => {\n  let rid = text;\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  for (let i = 0; i < vowels.length; i++) {\n    if (rid.includes(vowels[i])) {\n      rid = rid.replace(vowels[i], '');\n    }\n  }\n  return rid;\n};\n\n/*\n  removeVowels7 a function that takes string and returns string without vowels.\n  >>> removeVowels7('abcdef')\n  'abcdef'\n  >>> removeVowels7('aaaaa')\n  'aaaaa'\n  >>> removeVowels7('aaBAA')\n  'aaBAA'\n  >>> removeVowels7('zbcd')\n  'zbcd'\n  */\nconst removeVowels7 = (text) => {\n  let rid = text;\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  for (let i = 0; i < vowels.length; i++) {\n    if (rid.includes(vowels[i])) {\n      rid = rid.replace(vowels[i], '');\n    }\n  }\n  return rid;\n};\n\n/*\n  removeVowels8 a function that takes string and returns string without vowels.\n  >>> removeVowels8('abcdef')\n  'abcdef'\n  >>> removeVowels8('aaaaa')\n  'aaaaa'\n  >>> removeVowels8('aaBAA')\n  'aaBAA'\n  >>> removeVowels8('zbcd')\n  'zbcd'\n  */\nconst removeVowels8 = (text) => {\n  let rid = text;\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all numbers in the list l are below threshold t.\n  >>> belowDoorway([1, 2, 4, 10], 100)\n  true\n  >>> belowDoorway([1, 20, 4, 10], 5)\n  false\n  */\nconst belowDoorway = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowDoorway", "gc": "<|endoftext|>/*Return true if all numbers in the list l are below threshold t.\n  >>> belowDoorway([1, 2, 4, 10], 100)\n  true\n  >>> belowDoorway([1, 20, 4, 10], 5)\n  false\n  */\nconst belowDoorway = (l, t) => {\n  let i = l.length - 1;\n  let j = t.length - 1;\n  let count = 0;\n  while (i >= 0 && j >= 0) {\n    if (l[i] > t) {\n      count++;\n      i--;\n    } else if (l[j] > t) {\n      count++;\n      j--;\n    } else {\n      i--;\n      j--;\n    }\n  }\n  return count >= 2;\n};\n\nmodule.exports = {\n  belowDoorway,\n};\n\n},{}],15:[function(require,module,exports){\n/*\n  A simple JavaScript implementation of the Huffman coding algorithm.\n  By John Resig (http://ejohn.org/)\n  Modified by David Bauer (http://dbauer.com/)\n  Modified by Joseph O'Connor (http://oconnor.org)\n  Modified by Martin O'Connor (http://maconnor.org)\n  Modified by Brett Zamir (http://brett-zamir.me)\n  Modified by David Karlsen (http://dkarlsen.com)\n  Modified by Eric Niebler - http://ejniebler.com/\n  Modified by Michael J. Schindler (http://javascript.sc)\n  Modified by Philip Peterson (http://peterson.eu-berlin.de)\n  Modified by Robert Penner (http://www.robertpenner.com/)\n  Modified by Martin Johnson (http://www.artinjohnson.com)\n  Modified by Sebastian Heimmelmann (http://eheiml.org/)\n  Modified by Brian Tafoya\n  Modified by Thomas Fuchs (http://thomas.fguh.com)\n  Modified by Martin Williams\n  Modified by Nathan Sepulveda\n  Modified by Jonathan Feinberger\n  Modified by Eric Niebler\n  Modified by James McCarthy\n  Modified by Michael Aufreiter\n  Modified by Jonathan Ongson\n  Modified by Paul Johnston\n  Modified by Paul Kukawski\n  Modified by Martin Bauer\n  Modified by Jonathan Ongson\n  Modified by Martin Bauer\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson\n  Modified by Jonathan Ongson", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> lend(2, 3)\n  5\n  >>> lend(5, 7)\n  12\n  */\nconst lend = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "lend", "gc": "<|endoftext|>/*Add two numbers x and y\n  >>> lend(2, 3)\n  5\n  >>> lend(5, 7)\n  12\n  */\nconst lend = (x, y) => {\n  if (x === 0 && y === 0) {\n    return 0\n  }\n  if (x === 0 && y === Infinity) {\n    return Infinity\n  }\n  if (x === Infinity && y === 0) {\n    return 0\n  }\n  if (x === Infinity && y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 1\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === y) {\n    return 0\n  }\n  if (x === Infinity) {\n    return Infinity\n  }\n  if (y === Infinity) {\n    return Infinity\n  }\n  if (x === ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two words have the same characters.\n  >>> likeChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> likeChars('abcd', 'dddddddabc')\n  true\n  >>> likeChars('dddddddabc', 'abcd')\n  true\n  >>> likeChars('eabcd', 'dddddddabc')\n  false\n  >>> likeChars('abcd', 'dddddddabce')\n  false\n  >>> likeChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst likeChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "likeChars", "gc": "<|endoftext|>/*\n  Check if two words have the same characters.\n  >>> likeChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> likeChars('abcd', 'dddddddabc')\n  true\n  >>> likeChars('dddddddabc', 'abcd')\n  true\n  >>> likeChars('eabcd', 'dddddddabc')\n  false\n  >>> likeChars('abcd', 'dddddddabce')\n  false\n  >>> likeChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst likeChars = (s0, s1) => {\n  const len = s1.length\n  const s0 = s0.toLowerCase()\n  const s1 = s1.toLowerCase()\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "gc": "<|endoftext|>/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  let a = 1, b = 1;\n  for (let i = 0; i < n; i++) {\n    const tmp = a + b;\n    a = b;\n    b = tmp;\n  }\n  return b;\n};\n\n/*\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21\n  >>> fib(8)\n  21", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresponding closing bracket.\n\n  >>> rightBracketing(\"<\")\n  false\n  >>> rightBracketing(\"<>\")\n  false\n  >>> rightBracketing(\"<<><>>\")\n  false\n  >>> rightBracketing(\"><<>\")\n  false\n  */\nconst rightBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "rightBracketing", "gc": "<|endoftext|>/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresponding closing bracket.\n\n  >>> rightBracketing(\"<\")\n  false\n  >>> rightBracketing(\"<>\")\n  false\n  >>> rightBracketing(\"<<><>>\")\n  false\n  >>> rightBracketing(\"><<>\")\n  false\n  */\nconst rightBracketing = (brackets) => {\n  const openingBrackets = brackets.split(\">\");\n  const closingBrackets = brackets.split(\">\");\n  const openingBracketsLength = openingBrackets.length;\n  const closingBracketsLength = closingBrackets.length;\n  if (openingBracketsLength === closingBracketsLength) {\n    return openingBracketsLength === 0;\n  }\n  return openingBracketsLength > closingBracketsLength;\n};\n\n/**\n  Returns true if a character is a punctuation character.\n\n  >>> isPunctuation(\".\")\n  true\n  >>> isPunctuation(\",\")\n  true\n  >>> isPunctuation(\";\")\n  true\n  >>> isPunctuation(\"(\")\n  true\n  >>> isPunctuation(\")\")\n  true\n  >>> isPunctuation(\"[\")\n  true\n  >>> isPunctuation(\"]\")\n  true\n  >>> isPunctuation(\"{\")\n  true\n  >>> isPunctuation(\"}\")\n  true\n  >>> isPunctuation(\":\")\n  true\n  >>> isPunctuation(\";\")\n  true\n  >>> isPunctuation(\"<\")\n  true\n  >>> isPunctuation(\"[\")\n  true\n  >>> isPunctuation(\"]\")\n  true\n  >>> isPunctuation(\"{\")\n  true\n  >>> isPunctuation(\"}\")\n  true\n  >>> isPunctuation(\"(\")\n  true\n  >>> isPunctuation(\")\")\n  true\n  >>> isPunctuation(\"[\")\n  true\n  >>> isPunctuation(\"]\")\n  true\n  >>> isPunctuation(\"{\")\n  true\n  >>> isPunctuation(\"}\")\n  true\n  >>> isPunctuation(\":\")\n  true\n  >>> isPunctuation(\";\")\n  true\n  >>> isPunctuation(\"<\")\n  true\n  >>> isPunctuation(\"[\")\n  true\n  >>> isPunctuation(\"]\")\n  true\n  >>> isPunctuation(\"{\")\n  true\n  >>> isPunctuation(\"}\")\n  true\n  >>> isPunctuation(\"(\")\n  true\n  >>> isPunctuation(\")\")\n  true\n  >>> isPunctuation(\"[\")\n  true\n  >>> isPunctuation(\"]\")\n  true\n  >>> isPunctuation(\"{\")\n  true\n  >>> isPunctuation(\"}\")\n  true\n  >>> isPunctuation(\":\")\n  true\n  >>> isPunctuation(\";\")\n  true\n  >>> isPunctuation(\"<\")\n  true\n  >>> isPunctuation(\"[\")\n  true\n  >>> isPunctuation(\"]\")\n  true\n  >>> isPunctuation(\"{\")\n  true\n  >>> isPunctuation(\"}\")\n  true\n  >>> isPunctuation(\"(\")\n  true\n  >>> isPunctuation(\")\")\n  true\n  >>> isPunctuation(\"[\")\n  true\n  >>> isPunctuation(\"]\")\n  true\n  >>> isPunctuation(\"{\")\n  true\n  >>> isPunctuation(\"}\")\n  true\n  >>> isPunctuation(\":\")\n  true\n  >>> isPunctuation(\";\")\n  true\n  >>> isPunctuation(\"<\")\n  true\n  >>> isPunctuation(\"[\")\n  true\n  >>> isPunctuation(\"]\")\n  true\n  >>> isPunctuation(\"{\")\n  true\n  >>> isPunctuation(\"}\")\n  true\n  >>> isPunctuation(\":\")\n  true\n  >>> isPunctuation(\";\")\n  true\n  >>> isPunctuation(\"<\")\n  true\n  >>> isPunctuation(\"[\")\n  true\n  >>> isPunctuation(\"]\")\n  true\n  >>> isPunctuation(\"{\")\n  true\n  >>> isPunctuation(\"}\")\n  true\n  >>> isPunctuation(\"(\")\n  true\n  >>> isPunctuation(\")\")\n  true\n  >>> isPunctuation(\"[\")\n  true\n  >>> isPunctuation(\"]\")\n  true\n  >>> isPunctuation(\"{\")\n  true\n  >>> isPunctuation(\"}\")\n  true\n  >>> isPunctuation(\":\")\n  true\n  >>> isPunctuation(\";\")\n  true\n  >>> isPunctuation(\"<\")\n  true\n  >>> isPunctuation(\"[\")\n  true\n  >>> isPunctuation(\"]\")\n  true\n  >>> isPunctuation(\"{\")\n  true\n  >>> isPunctuation(\"}\")\n  true\n  >>> isPunctuation(\":\")\n  true\n  >>> isPunctuation(\";\")\n  true\n  >>> isPunctuation(\"<\")\n  true\n  >>> isPunctuation(\"[\")\n  true\n  >>> isPunctuation(\"]\")\n  true\n  >>> isPunctuation(\"{\")\n  true\n  >>> isPunctuation(\"}\")\n  true\n  >>> isPunctuation(\":\")\n  true\n  >>> isPunctuation(\";\")\n  true\n  >>> isPunctuation(\"<\")\n  true\n  >>> isPunctuation(\"[\")\n  true\n  >>> isPunctuation(\"]\")\n  true\n  >>> isPunctuation(\"{\")\n  true\n  >>> isPunctuation(\"}\")\n  true\n  >>> isPunctuation(\":\")\n  true\n  >>> isPunctuation(\";\")\n  true\n  >>> isPunctuation(\"<\")\n  true\n  >>> isPunctuation(\"[\")\n  true\n  >>> isPunctuation(\"]\")\n  true\n  >>> isPunctuation(\"{\")\n  true\n  >>> isPunctuation(\"}\")\n  true\n  >>> isPunctuation(\":\")\n  true\n  >>> isPunctuation(\";\")\n  true\n  >>> isPunctuation(\"<\")\n  true\n  >>> isPunctuation(\"[\")\n  true\n  >>> isPunctuation(\"]\")\n  true\n  >>> isPunctuation(\"{\")\n  true\n  >>> isPunctuation(\"}\")\n  true\n  >>> isPunctuation(\":\")\n  true\n  >>> isPunctuation(\";\")\n  true\n  >>> isPunctuation(\"<\")\n  true\n  >>> isPunctuation(\"[\")\n  true\n  >>> isPunctuation(\"]\")\n  true\n  >>> isPunctuation(\"{\")\n  true\n  >>> isPunctuation(\"}\")\n  true\n  >>> isPunctuation(\":\")\n  true\n  >>> isPunctuation(\";\")\n  true\n  >>> isPunctuation(\"<\")\n  true\n  >>> isPunctuation(\"[\")\n  true\n  >>> isPunctuation(\"]\")\n  true\n  >>> isPunctuation(\"{\")\n  true\n  >>> isPunctuation(\"}\")\n  true\n  >>> isPunctuation(\":\")\n  true\n  >>> isPunctuation(\";\")\n  true\n  >>> isPunctuation(\"<\")\n  true\n  >>> isPunctuation(\"[\")\n  true\n  >>> isPunctuation(\"]\")\n  true\n  >>> isPunctuation(\"{\")\n  true\n  >>> isPunctuation(\"}\")\n  true\n  >>> isPunctuation(\":\")\n  true\n  >>> isPunctuation(\";\")\n  true\n  >>> isPunctuation(\"<\")\n  true\n  >>> isPunctuation", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/57", "prompt": "/*Return true is list elements are flatally increasing or decreasing.\n  >>> flat([1, 2, 4, 20])\n  true\n  >>> flat([1, 20, 4, 10])\n  false\n  >>> flat([4, 1, 0, -10])\n  true\n  */\nconst flat = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "flat", "gc": "<|endoftext|>/*Return true is list elements are flatally increasing or decreasing.\n  >>> flat([1, 2, 4, 20])\n  true\n  >>> flat([1, 20, 4, 10])\n  false\n  >>> flat([4, 1, 0, -10])\n  true\n  */\nconst flat = (l) => {\n  return l.length === 0? false : l.every(\n    (_, i) =>!isNaN(Number(i)) && isFinite(Number(i))\n  )\n}\n\n/*Return true is list elements are unique.\n  >>> unique([1, 2, 4, 20])\n  true\n  >>> unique([1, 20, 4, 10])\n  false\n  >>> unique([4, 1, 0, -10])\n  true\n  */\nconst unique = (l) => {\n  return l.length === 0? false : l.every(\n    (_, i) => l.indexOf(i) === i\n  )\n}\n\n/*Return true is list elements are unique.\n  >>> unique([1, 2, 4, 20])\n  true\n  >>> unique([1, 20, 4, 10])\n  false\n  >>> unique([4, 1, 0, -10])\n  true\n  */\nconst uniqueArray = (l) => {\n  return l.length === 0? false : l.every(\n    (_, i) => l.indexOf(i) === i\n  )\n}\n\n/*Return true is list elements are unique.\n  >>> unique([1, 2, 4, 20])\n  true\n  >>> unique([1, 20, 4, 10])\n  false\n  >>> unique([4, 1, 0, -10])\n  true\n  */\nconst uniqueObject = (l) => {\n  return l.length === 0? false : l.every(\n    (_, i) => l.indexOf(i) === i\n  )\n}\n\n/*Return true is list elements are unique.\n  >>> unique([1, 2, 4, 20])\n  true\n  >>> unique([1, 20, 4, 10])\n  false\n  >>> unique([4, 1, 0, -10])\n  true\n  */\nconst uniqueString = (l) => {\n  return l.length === 0? false : l.every(\n    (_, i) => l.indexOf(i) === i\n  )\n}\n\n/*Return true is list elements are unique.\n  >>> unique([1, 2, 4, 20])\n  true\n  >>> unique([1, 20, 4, 10])\n  false\n  >>> unique([4, 1, 0, -10])\n  true\n  */\nconst uniqueBoolean = (l) => {\n  return l.length === 0? false : l.every(\n    (_, i) => l.indexOf(i) === i\n  )\n}\n\n/*Return true is list elements are unique.\n  >>> unique([1, 2, 4, 20])\n  true\n  >>> unique([1, 20, 4, 10])\n  false\n  >>> unique([4, 1, 0, -10])\n  true\n  */\nconst uniqueArrayString = (l) => {\n  return l.length === 0? false : l.every(\n    (_, i) => l.indexOf(i) === i\n  )\n}\n\n/*Return true is list elements are unique.\n  >>> unique([1, 2, 4, 20])\n  true\n  >>> unique([1, 20, 4, 10])\n  false\n  >>> unique([4, 1, 0, -10])\n  true\n  */\nconst uniqueArrayBoolean = (l) => {\n  return l.length === 0? false : l.every(\n    (_, i) => l.indexOf(i) === i\n  )\n}\n\n/*Return true is list elements are unique.\n  >>> unique([1, 2, 4, 20])\n  true\n  >>> unique([1, 20, 4, 10])\n  false\n  >>> unique([4, 1, 0, -10])\n  true\n  */\nconst uniqueObjectString = (l) => {\n  return l.length === 0? false : l.every(\n    (_, i) => l.indexOf(i) === i\n  )\n}\n\n/*Return true is list elements are unique.\n  >>> unique([1, 2, 4, 20])\n  true\n  >>> unique([1, 20, 4, 10])\n  false\n  >>> unique([4, 1, 0, -10])\n  true\n  */\nconst uniqueObjectBoolean = (l) => {\n  return l.length === 0? false : l.every(\n    (_, i) => l.indexOf(i) === i\n  )\n}\n\n/*Return true is list elements are unique.\n  >>> unique([1, 2, 4, 20])\n  true\n  >>> unique([1, 20, 4, 10])\n  false\n  >>> unique([4, 1, 0, -10])\n  true\n  */\nconst uniqueStringArray = (l) => {\n  return l.length === 0? false : l.every(\n    (_, i) => l.indexOf(i) === i\n  )\n}\n\n/*Return true is list elements are unique.\n  >>> unique([1, 2, 4, 20])\n  true\n  >>> unique([1, 20, 4, 10])\n  false\n  >>> unique([4, 1, 0, -10])\n  true\n  */\nconst uniqueStringObject = (l) => {\n  return l.length === 0? false : l.every(\n    (_, i) => l.indexOf(i) === i\n  )\n}\n\n/*Return true is list elements are unique.\n  >>> unique([1, 2, 4, 20])\n  true\n  >>> unique([1, 20, 4, 10])\n  false\n  >>> unique([4, 1, 0, -10])\n  true\n  */\nconst uniqueStringStringArray = (l) => {\n  return l.length === 0? false : l.every(\n    (_, i) => l.indexOf(i) === i\n  )\n}\n\n/*Return true is list elements are unique.\n  >>> unique([1, 2, 4, 20])\n  true\n  >>> unique([1, 20, 4, 10])\n  false\n  >>> unique([4, 1, 0, -10])\n  true\n  */\nconst uniqueStringBooleanArray = (l) => {\n  return l.length === 0? false : l.every(\n    (_, i) => l.indexOf(i) === i\n  )\n}\n\n/*Return true is list elements are unique.\n  >>> unique([1, 2, 4, 20])\n  true\n  >>> unique([1, 20, 4, 10])\n  false\n  >>> unique([4, 1, 0, -10])\n  true\n  */\nconst uniqueStringArrayBoolean = (l) => {\n  return l.length === 0? false : l.every(\n    (_, i) => l.indexOf(i) === i\n  )\n}\n\n/*Return true is list elements are unique.\n  >>> unique([1, 2, 4, 20])\n  true\n  >>> unique([1, 20, 4, 10])\n  false\n  >>> unique([4, 1, 0, -10])\n  true\n  */\nconst uniqueBooleanArray = (l) => {\n  return l.length === 0? false : l.every(\n    (_, i) => l.indexOf(i) === i\n  )\n}\n\n/*Return true is list elements are unique.\n  >>> unique([1, 2, 4, 20])\n  true\n  >>> unique([1, 20, 4, 10])\n  false\n  >>> unique([4, 1, 0, -10])\n  true\n  */\nconst uniqueBooleanObject = (l) => {\n  return l.length === 0? false : l.every(\n    (_, i) => l.indexOf(i) === i\n  )\n}\n\n/*Return true is list elements are unique.\n  >>> unique([1, 2, 4, 20])\n  true\n  >>> unique([1, 20, 4, 10])\n  false\n  >>> unique([4, 1, 0, -10])\n  true\n  */\nconst uniqueBooleanString = (l) => {\n  return l.length === 0? false : l.every(\n    (_, i) => l.indexOf(i) === i\n  )\n}\n\n/*Return true is list elements are unique.\n  >>> unique([1, 2, 4, 20])\n  true\n  >>> unique([1, 20, 4, 10])\n  false\n  >>> unique([4, 1, 0, -10])\n  true\n  */\nconst uniqueBooleanStringArray = (l) => {\n  return l.length === 0? false : l.every(\n    (_, i) => l.indexOf(i) === i\n  )\n}\n\n/*Return true is list elements are unique.\n  >>> unique([1, 2, 4, 20])\n  true\n  >>> unique([1, 20, 4, 10])\n  false\n  >>> unique([4, 1, 0, -10])\n  true\n  */", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted unique coarse elements for two lists.\n  >>> coarse([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> coarse([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst coarse = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "coarse", "gc": "<|endoftext|>/*Return sorted unique coarse elements for two lists.\n  >>> coarse([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> coarse([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst coarse = (l1, l2) => {\n  const set1 = new Set();\n  const set2 = new Set();\n  for (let i = 0; i < l1.length; i++) {\n    set1.add(l1[i]);\n  }\n  for (let i = 0; i < l2.length; i++) {\n    set2.add(l2[i]);\n  }\n  const result = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (set1.has(l1[i])) {\n      result.push(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (set2.has(l2[i])) {\n      result.push(l2[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique fine elements for two lists.\n  >>> fine([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> fine([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst fine = (l1, l2) => {\n  const set1 = new Set();\n  const set2 = new Set();\n  for (let i = 0; i < l1.length; i++) {\n    set1.add(l1[i]);\n  }\n  for (let i = 0; i < l2.length; i++) {\n    set2.add(l2[i]);\n  }\n  const result = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (set1.has(l1[i])) {\n      result.push(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (set2.has(l2[i])) {\n      result.push(l2[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique elements for two lists.\n  >>> elements([1, 2, 3, 4], [5, 6, 7, 8])\n  [1, 2, 3, 4, 5, 6, 7, 8]\n\n  */\nconst elements = (l1, l2) => {\n  const set1 = new Set();\n  const set2 = new Set();\n  for (let i = 0; i < l1.length; i++) {\n    set1.add(l1[i]);\n  }\n  for (let i = 0; i < l2.length; i++) {\n    set2.add(l2[i]);\n  }\n  const result = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (set1.has(l1[i])) {\n      result.push(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (set2.has(l2[i])) {\n      result.push(l2[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique elements for two lists.\n  >>> elements([1, 2, 3, 4], [5, 6, 7, 8])\n  [1, 2, 3, 4, 5, 6, 7, 8]\n\n  */\nconst unique = (l1, l2) => {\n  const set1 = new Set();\n  const set2 = new Set();\n  for (let i = 0; i < l1.length; i++) {\n    set1.add(l1[i]);\n  }\n  for (let i = 0; i < l2.length; i++) {\n    set2.add(l2[i]);\n  }\n  const result = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (set1.has(l1[i])) {\n      result.push(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (set2.has(l2[i])) {\n      result.push(l2[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique elements for two lists.\n  >>> elements([1, 2, 3, 4], [5, 6, 7, 8])\n  [1, 2, 3, 4, 5, 6, 7, 8]\n\n  */\nconst uniqueElements = (l1, l2) => {\n  const set1 = new Set();\n  const set2 = new Set();\n  for (let i = 0; i < l1.length; i++) {\n    set1.add(l1[i]);\n  }\n  for (let i = 0; i < l2.length; i++) {\n    set2.add(l2[i]);\n  }\n  const result = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (set1.has(l1[i])) {\n      result.push(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (set2.has(l2[i])) {\n      result.push(l2[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique elements for two lists.\n  >>> elements([1, 2, 3, 4], [5, 6, 7, 8])\n  [1, 2, 3, 4, 5, 6, 7, 8]\n\n  */\nconst uniqueElementsFine = (l1, l2) => {\n  const set1 = new Set();\n  const set2 = new Set();\n  for (let i = 0; i < l1.length; i++) {\n    set1.add(l1[i]);\n  }\n  for (let i = 0; i < l2.length; i++) {\n    set2.add(l2[i]);\n  }\n  const result = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (set1.has(l1[i])) {\n      result.push(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (set2.has(l2[i])) {\n      result.push(l2[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique elements for two lists.\n  >>> elements([1, 2, 3, 4], [5, 6, 7, 8])\n  [1, 2, 3, 4, 5, 6, 7, 8]\n\n  */\nconst uniqueElementsCoarse = (l1, l2) => {\n  const set1 = new Set();\n  const set2 = new Set();\n  for (let i = 0; i < l1.length; i++) {\n    set1.add(l1[i]);\n  }\n  for (let i = 0; i < l2.length; i++) {\n    set2.add(l2[i]);\n  }\n  const result = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (set1.has(l1[i])) {\n      result.push(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (set2.has(l2[i])) {\n      result.push(l2[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique elements for two lists.\n  >>> elements([1, 2, 3, 4], [5, 6, 7, 8])\n  [1, 2, 3, 4, 5, 6, 7, 8]\n\n  */\nconst uniqueElementsFineCoarse = (l1, l2) => {\n  const set1 = new Set();\n  const set2 = new Set();\n  for (let i = 0; i < l1.length; i++) {\n    set1.add(l1[i]);\n  }\n  for (let i = 0; i < l2.length; i++) {\n    set2.add(l2[i]);\n  }\n  const result = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (set1.has(l1[i])) {\n      result.push(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (set2.has(l2[i])) {\n      result.push(l2[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique elements for two lists.\n  >>> elements([1, 2, 3, 4], [5, 6, 7, 8])\n  [1, 2, 3, 4, 5, 6, 7, 8]\n\n  */\nconst uniqueElementsFineCoarseElements = (l1, l2) => {\n  const set1 = new Set();\n  const set2 = new Set();\n  for (let i = 0; i < l1.length; i++) {\n    set1.add(l1[i]);\n  }\n  for (let i = 0; i < l2.length; i++) {\n    set2.add(l2[i]);\n  }\n  const result = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (set1.has(l1[i])) {\n      result.push(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (set2.has(l2[i])) {\n      result.push(l2[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique elements for two lists.\n  >>> elements([1, 2, 3, 4], [5, 6, 7, 8])\n  [1, 2, 3, 4, 5, 6, 7, 8]\n\n  */\nconst uniqueElementsFineCoarseElementsFine = (l1, l2) => {\n  const set1 = new Set();\n  const set2 = new Set();\n  for (let i = 0; i < l1.length; i++) {\n    set1.add(l1[i]);\n  }\n  for (let i = 0; i < l2.length; i++) {\n    set2.add(l2[i]);\n  }\n  const result = [];\n  for (let i = 0; i < l1.length; i++) {\n    if (set1.has(l1[i])) {\n      result.push(l1[i]);\n    }\n  }\n  for (let i = 0; i < l2.length; i++) {\n    if (set2.has(l2[i])) {\n      result.push(l2[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique elements for two list", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> bigChoiceFactor(13195)\n  29\n  >>> bigChoiceFactor(2048)\n  2\n  */\nconst bigChoiceFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "bigChoiceFactor", "gc": "<|endoftext|>/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> bigChoiceFactor(13195)\n  29\n  >>> bigChoiceFactor(2048)\n  2\n  */\nconst bigChoiceFactor = (n) => {\n  let i = 2;\n  let j = 2;\n  let k = 2;\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % i === 0) {\n      primeFactor = i;\n      i++;\n    } else if (n % j === 0) {\n      primeFactor = j;\n      j++;\n    } else if (n % k === 0) {\n      primeFactor = k;\n      k++;\n    } else {\n      primeFactor++;\n    }\n  }\n  return primeFactor;\n};\n\n/*\n  Given a positive integer n, return true if and only if the sum of its digit\n  factors is equal to n.\n  >>> isPowerOf10(1234)\n  true\n  >>> isPowerOf10(12345)\n  false\n  >>> isPowerOf10(12346)\n  false\n  >>> isPowerOf10(12347)\n  false\n  >>> isPowerOf10(12348)\n  false\n  >>> isPowerOf10(12349)\n  false\n  >>> isPowerOf10(12350)\n  false\n  >>> isPowerOf10(12351)\n  false\n  >>> isPowerOf10(12352)\n  false\n  >>> isPowerOf10(12353)\n  false\n  >>> isPowerOf10(12354)\n  false\n  >>> isPowerOf10(12355)\n  false\n  >>> isPowerOf10(12356)\n  false\n  >>> isPowerOf10(12357)\n  false\n  >>> isPowerOf10(12358)\n  false\n  >>> isPowerOf10(12359)\n  false\n  >>> isPowerOf10(12360)\n  false\n  >>> isPowerOf10(12361)\n  false\n  >>> isPowerOf10(12362)\n  false\n  >>> isPowerOf10(12363)\n  false\n  >>> isPowerOf10(12364)\n  false\n  >>> isPowerOf10(12365)\n  false\n  >>> isPowerOf10(12366)\n  false\n  >>> isPowerOf10(12367)\n  false\n  >>> isPowerOf10(12368)\n  false\n  >>> isPowerOf10(12369)\n  false\n  >>> isPowerOf10(12370)\n  false\n  >>> isPowerOf10(12371)\n  false\n  >>> isPowerOf10(12372)\n  false\n  >>> isPowerOf10(12373)\n  false\n  >>> isPowerOf10(12374)\n  false\n  >>> isPowerOf10(12375)\n  false\n  >>> isPowerOf10(12376)\n  false\n  >>> isPowerOf10(12377)\n  false\n  >>> isPowerOf10(12378)\n  false\n  >>> isPowerOf10(12379)\n  false\n  >>> isPowerOf10(12380)\n  false\n  >>> isPowerOf10(12381)\n  false\n  >>> isPowerOf10(12382)\n  false\n  >>> isPowerOf10(12383)\n  false\n  >>> isPowerOf10(12384)\n  false\n  >>> isPowerOf10(12385)\n  false\n  >>> isPowerOf10(12386)\n  false\n  >>> isPowerOf10(12387)\n  false\n  >>> isPowerOf10(12388)\n  false\n  >>> isPowerOf10(12389)\n  false\n  >>> isPowerOf10(12390)\n  false\n  >>> isPowerOf10(12391)\n  false\n  >>> isPowerOf10(12392)\n  false\n  >>> isPowerOf10(12393)\n  false\n  >>> isPowerOf10(12394)\n  false\n  >>> isPowerOf10(12395)\n  false\n  >>> isPowerOf10(12396)\n  false\n  >>> isPowerOf10(12397)\n  false\n  >>> isPowerOf10(12398)\n  false\n  >>> isPowerOf10(12399)\n  false\n  >>> isPowerOf10(12400)\n  false\n  >>> isPowerOf10(12401)\n  false\n  >>> isPowerOf10(12402)\n  false\n  >>> isPowerOf10(12403)\n  false\n  >>> isPowerOf10(12400)\n  false\n  >>> isPowerOf10(12401)\n  false\n  >>> isPowerOf10(12402)\n  false\n  >>> isPowerOf10(12403)\n  false\n  >>> isPowerOf10(12400)\n  false\n  >>> isPowerOf10(12401)\n  false\n  >>> isPowerOf10(12402)\n  false\n  >>> isPowerOf10(12403)\n  false\n  >>> isPowerOf10(12400)\n  false\n  >>> isPowerOf10(12401)\n  false\n  >>> isPowerOf10(12402)\n  false\n  >>> isPowerOf10(12403)\n  false\n  >>> isPowerOf10(12400)\n  false\n  >>> isPowerOf10(12401)\n  false\n  >>> isPowerOf10(12402)\n  false\n  >>> isPowerOf10(12403)\n  false\n  >>> isPowerOf10(12400)\n  false\n  >>> isPowerOf10(12401)\n  false\n  >>> isPowerOf10(12402)\n  false\n  >>> isPowerOf10(12403)\n  false\n  >>> isPowerOf10(12400)\n  false\n  >>> isPowerOf10(12401)\n  false\n  >>> isPowerOf10(12402)\n  false\n  >>> isPowerOf10(12403)\n  false\n  >>> isPowerOf10(12400)\n  false\n  >>> isPowerOf10(12401)\n  false\n  >>> isPowerOf10(12402)\n  false\n  >>> isPowerOf10(12403)\n  false\n  >>> isPowerOf10(12400)\n  false\n  >>> isPowerOf10(12401)\n  false\n  >>> isPowerOf10(12402)\n  false\n  >>> isPowerOf10(12403)\n  false\n  >>> isPowerOf10(12400)\n  false\n  >>> isPowerOf10(12401)\n  false\n  >>> isPowerOf10(12402)\n  false\n  >>> isPowerOf10(12403)\n  false\n  >>> isPowerOf10(12400)\n  false\n  >>> isPowerOf10(12401)\n  false\n  >>> isPowerOf10(12402)\n  false\n  >>> isPowerOf10(12403)\n  false\n  >>> isPowerOf10(12400)\n  false\n  >>> isPowerOf10(12401)\n  false\n  >>> isPowerOf10(12402)", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/6", "prompt": "/* Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n  For each of the group, output the deepest level of nesting of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "gc": "<|endoftext|>/* Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n  For each of the group, output the deepest level of nesting of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_stack = [];\n  const paren_level = 0;\n  const paren_stack_size = 0;\n  const paren_stack_remaining = [];\n  let paren_level_remaining = 0;\n  let paren_stack_remaining_size = 0;\n  let paren_stack_remaining_remaining = 0;\n\n  // Parse the paren string and store its nesting level and stack size\n  const paren_stack_remaining_remaining = paren_string.split(\" \").length;\n  for (let i = 0; i < paren_string.length; i++) {\n    const char = paren_string[i];\n    if (char === \"(\") {\n      paren_stack.push(paren_level);\n      paren_stack_size++;\n    } else if (char === \")\") {\n      if (paren_stack_remaining_remaining > 0) {\n        paren_stack_remaining_remaining--;\n        paren_stack_remaining_size += paren_stack_remaining_remaining;\n      }\n      if (paren_stack_remaining_remaining === 0) {\n        paren_stack_remaining_size += paren_stack_remaining_remaining;\n        paren_stack_remaining_remaining = 0;\n        paren_stack_remaining_size += paren_stack_remaining_remaining;\n      }\n      if (paren_stack_remaining_size === paren_stack_size) {\n        paren_stack_remaining_size += paren_stack_remaining_remaining;\n        paren_stack_remaining_remaining = 0;\n        paren_stack_remaining_size += paren_stack_remaining_remaining;\n      }\n      paren_level_remaining++;\n    } else if (char === \"(\") {\n      paren_stack_remaining_remaining++;\n      paren_stack_remaining_size += paren_stack_remaining_remaining;\n    } else if (char === \")\") {\n      paren_stack_remaining_remaining--;\n      paren_stack_remaining_size += paren_stack_remaining_remaining;\n    }\n  }\n\n  // Return the nesting level and stack size\n  return [paren_level, paren_stack_size];\n};\n\n// Parse a number represented as a string and store its nesting level and stack size\nconst parseNumber = (number_string) => {\n  const number_stack = [];\n  const number_level = 0;\n  const number_stack_size = 0;\n  const number_stack_remaining = 0;\n  let number_stack_remaining_size = 0;\n  let number_stack_remaining_remaining = 0;\n\n  // Parse the number string and store its nesting level and stack size\n  const number_stack_remaining_remaining = number_string.split(\" \").length;\n  for (let i = 0; i < number_string.length; i++) {\n    const char = number_string[i];\n    if (char === \"0\") {\n      number_stack.push(number_level);\n      number_stack_size++;\n    } else if (char === \"x\") {\n      number_stack_remaining_remaining++;\n      number_stack_remaining_size += number_stack_remaining_remaining;\n    } else if (char === \"X\") {\n      number_stack_remaining_remaining--;\n      number_stack_remaining_size += number_stack_remaining_remaining;\n    }\n  }\n\n  // Return the nesting level and stack size\n  return [number_level, number_stack_size];\n};\n\n// Parse a boolean represented as a string and store its nesting level and stack size\nconst parseBoolean = (boolean_string) => {\n  const boolean_stack = [];\n  const boolean_level = 0;\n  const boolean_stack_size = 0;\n  const boolean_stack_remaining = 0;\n  let boolean_stack_remaining_size = 0;\n  let boolean_stack_remaining_remaining = 0;\n\n  // Parse the boolean string and store its nesting level and stack size\n  const boolean_stack_remaining_remaining = boolean_string.split(\" \").length;\n  for (let i = 0; i < boolean_string.length; i++) {\n    const char = boolean_string[i];\n    if (char === \"t\") {\n      boolean_stack.push(boolean_level);\n      boolean_stack_size++;\n    } else if (char === \"f\") {\n      boolean_stack_remaining_remaining++;\n      boolean_stack_remaining_size += boolean_stack_remaining_remaining;\n    } else if (char === \"F\") {\n      boolean_stack_remaining_remaining--;\n      boolean_stack_remaining_size += boolean_stack_remaining_remaining;\n    }\n  }\n\n  // Return the nesting level and stack size\n  return [boolean_level, boolean_stack_size];\n};\n\n// Parse a date represented as a string and store its nesting level and stack size\nconst parseDate = (date_string) => {\n  const date_stack = [];\n  const date_level = 0;\n  const date_stack_size = 0;\n  const date_stack_remaining = 0;\n  let date_stack_remaining_size = 0;\n  let date_stack_remaining_remaining = 0;\n\n  // Parse the date string and store its nesting level and stack size\n  const date_stack_remaining_remaining = date_string.split(\" \").length;\n  for (let i = 0; i < date_string.length; i++) {\n    const char = date_string[i];\n    if (char === \"-\") {\n      date_stack.push(date_level);\n      date_stack_size++;\n    } else if (char === \"+\") {\n      date_stack_remaining_remaining++;\n      date_stack_remaining_size += date_stack_remaining_remaining;\n    } else if (char === \"-\") {\n      date_stack_remaining_remaining--;\n      date_stack_remaining_size += date_stack_remaining_remaining;\n    }\n  }\n\n  // Return the nesting level and stack size\n  return [date_level, date_stack_size];\n};\n\n// Parse a time represented as a string and store its nesting level and stack size\nconst parseTime = (time_string) => {\n  const time_stack = [];\n  const time_level = 0;\n  const time_stack_size = 0;\n  const time_stack_remaining = 0;\n  let time_stack_remaining_size = 0;\n  let time_stack_remaining_remaining = 0;\n\n  // Parse the time string and store its nesting level and stack size\n  const time_stack_remaining_remaining = time_string.split(\" \").length;\n  for (let i = 0; i < time_string.length; i++) {\n    const char = time_string[i];\n    if (char === \"-\") {\n      time_stack.push(time_level);\n      time_stack_size++;\n    } else if (char === \"+\") {\n      time_stack_remaining_remaining++;\n      time_stack_remaining_size += time_stack_remaining_remaining;\n    } else if (char === \"-\") {\n      time_stack_remaining_remaining--;\n      time_stack_remaining_size += time_stack_remaining_remaining;\n    }\n  }\n\n  // Return the nesting level and stack size\n  return [time_level, time_stack_size];\n};\n\n// Parse a date represented as a string and store its nesting level and stack size\nconst parseDateTime = (date_string) => {\n  const date_stack = [];\n  const date_level = 0;\n  const date_stack_size = 0;\n  const date_stack_remaining = 0;\n  let date_stack_remaining_size = 0;\n  let date_stack_remaining_remaining = 0;\n\n  // Parse the date string and store its nesting level and stack size\n  const date_stack_remaining_remaining = date_string.split(\" \").length;\n  for (let i = 0; i < date_string.length; i++) {\n    const char = date_string[i];\n    if (char === \"-\") {\n      date_stack.push(date_level);\n      date_stack_size++;\n    } else if (char === \"+\") {\n      date_stack_remaining_remaining++;\n      date_stack_remaining_size += date_stack_remain", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/60", "prompt": "/*summarizeToN is a function that sums numbers from 1 to n.\n  >>> summarizeToN(30)\n  465\n  >>> summarizeToN(100)\n  5050\n  >>> summarizeToN(5)\n  15\n  >>> summarizeToN(10)\n  55\n  >>> summarizeToN(1)\n  1\n  */\nconst summarizeToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "summarizeToN", "gc": "<|endoftext|>/*summarizeToN is a function that sums numbers from 1 to n.\n  >>> summarizeToN(30)\n  465\n  >>> summarizeToN(100)\n  5050\n  >>> summarizeToN(5)\n  15\n  >>> summarizeToN(10)\n  55\n  >>> summarizeToN(1)\n  1\n  */\nconst summarizeToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that takes an array and returns a new array that contains\n * every nth element from the original array. Useful for generating\n * permutations.\n *\n * >>> everyNth([1,2,3,4,5,6,7,8,9], 2)\n * [2,4,6,8,10]\n */\nconst everyNth = (array, n) => {\n  const result = [];\n  for (let i = 0; i < array.length; i++) {\n    if (i % n === 0 && i!== 0) {\n      result.push(array[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * A function that takes an array and returns a new array that contains\n * every nth element from the original array. Useful for generating\n * combinations.\n *\n * >>> everyNth([1,2,3,4,5,6,7,8,9], 3)\n * [1,2,4,6,8,10,12]\n */\nconst everyNth2 = (array, n) => {\n  const result = [];\n  for (let i = 0; i < array.length; i++) {\n    if (i % n === 0) {\n      result.push(array[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * A function that takes an array and returns a new array that contains\n * every nth element from the original array. Useful for generating\n * combinations.\n *\n * >>> everyNth([1,2,3,4,5,6,7,8,9], 4)\n * [1,2,4,6,8,10,12,14]\n */\nconst everyNth3 = (array, n) => {\n  const result = [];\n  for (let i = 0; i < array.length; i++) {\n    if (i % n === 0 && i!== 0) {\n      result.push(array[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * A function that takes an array and returns a new array that contains\n * every nth element from the original array. Useful for generating\n * combinations.\n *\n * >>> everyNth([1,2,3,4,5,6,7,8,9], 5)\n * [1,2,4,6,8,10,12,14,16]\n */\nconst everyNth4 = (array, n) => {\n  const result = [];\n  for (let i = 0; i < array.length; i++) {\n    if (i % n === 0) {\n      result.push(array[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * A function that takes an array and returns a new array that contains\n * every nth element from the original array. Useful for generating\n * combinations.\n *\n * >>> everyNth([1,2,3,4,5,6,7,8,9], 6)\n * [1,2,4,6,8,10,12,14,16,18]\n */\nconst everyNth5 = (array, n) => {\n  const result = [];\n  for (let i = 0; i < array.length; i++) {\n    if (i % n === 0) {\n      result.push(array[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * A function that takes an array and returns a new array that contains\n * every nth element from the original array. Useful for generating\n * combinations.\n *\n * >>> everyNth([1,2,3,4,5,6,7,8,9], 7)\n * [1,2,4,6,8,10,12,14,16,18,20]\n */\nconst everyNth6 = (array, n) => {\n  const result = [];\n  for (let i = 0; i < array.length; i++) {\n    if (i % n === 0) {\n      result.push(array[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * A function that takes an array and returns a new array that contains\n * every nth element from the original array. Useful for generating\n * combinations.\n *\n * >>> everyNth([1,2,3,4,5,6,7,8,9], 8)\n * [1,2,4,6,8,10,12,14,16,18,20,22]\n */\nconst everyNth7 = (array, n) => {\n  const result = [];\n  for (let i = 0; i < array.length; i++) {\n    if (i % n === 0) {\n      result.push(array[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * A function that takes an array and returns a new array that contains\n * every nth element from the original array. Useful for generating\n * combinations.\n *\n * >>> everyNth([1,2,3,4,5,6,7,8,9], 9)\n * [1,2,4,6,8,10,12,14,16,18,20,22,24]\n */\nconst everyNth8 = (array, n) => {\n  const result = [];\n  for (let i = 0; i < array.length; i++) {\n    if (i % n === 0) {\n      result.push(array[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * A function that takes an array and returns a new array that contains\n * every nth element from the original array. Useful for generating\n * combinations.\n *\n * >>> everyNth([1,2,3,4,5,6,7,8,9], 10)\n * [1,2,4,6,8,10,12,14,16,18,20,22,24,26]\n */\nconst everyNth9 = (array, n) => {\n  const result = [];\n  for (let i = 0; i < array.length; i++) {\n    if (i % n === 0) {\n      result.push(array[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * A function that takes an array and returns a new array that contains\n * every nth element from the original array. Useful for generating\n * combinations.\n *\n * >>> everyNth([1,2,3,4,5,6,7,8,9], 11)\n * [1,2,4,6,8,10,12,14,16,18,20,22,24,26,28]\n */\nconst everyNth10 = (array, n) => {\n  const result = [];\n  for (let i = 0; i < array.length; i++) {\n    if (i % n === 0) {\n      result.push(array[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * A function that takes an array and returns a new array that contains\n * every nth element from the original array. Useful for generating\n * combinations.\n *\n * >>> everyNth([1,2,3,4,5,6,7,8,9], 12)\n * [1,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30]\n */\nconst everyNth11 = (array, n) => {\n  const result = [];\n  for (let i = 0; i < array.length; i++) {\n    if (i % n === 0) {\n      result.push(array[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * A function that takes an array and returns a new array that contains\n * every nth element from the original array. Useful for generating\n * combinations.\n *\n * >>> everyNth([1,2,3,4,5,6,7,8,9], 13)\n * [1,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32]\n */\nconst everyNth12 = (array, n) => {\n  const result = [];\n  for (let i = 0; i < array.length; i++) {\n    if (i % n === 0) {\n      result.push(array[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * A function that takes an array and returns a new array that contains\n * every nth element from the original array. Useful for generating\n * combinations.\n *\n * >>> everyNth([1,2,3,4,5,6,7,8,9], 14)\n * [1,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,36]\n */\nconst everyNth13 = (array, n) => {\n  const result = [];\n  for (let i = 0; i < array.length; i++) {\n    if (i % n === 0) {\n      result.push(array[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * A function that takes an array and returns a new array that contains\n * every nth element from the original array. Useful for generating\n * combinations.\n *\n * >>> everyNth([1,2,", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> rightBracketing(\"(\")\n  false\n  >>> rightBracketing(\"()\")\n  true\n  >>> rightBracketing(\"(()())\")\n  true\n  >>> rightBracketing(\")(()\")\n  false\n  */\nconst rightBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "rightBracketing", "gc": "<|endoftext|>/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> rightBracketing(\"(\")\n  false\n  >>> rightBracketing(\"()\")\n  true\n  >>> rightBracketing(\"(()())\")\n  true\n  >>> rightBracketing(\")(()\")\n  false\n  */\nconst rightBracketing = (brackets) => {\n  const openingBrackets = brackets.split(\"(\").map(str => str.trim());\n  const closingBrackets = brackets.split(\")\").map(str => str.trim());\n  return openingBrackets.every(openingBracket => closingBrackets.every(closingBracket => openingBracket === closingBracket));\n};\n\n/**\n * Returns true if the given string is a valid CSS selector\n * that matches a given CSS selector.\n *\n * A CSS selector is either a string or an array of strings.\n *\n * A CSS selector is valid if it is a valid CSS selector\n * that matches a given CSS selector. For example:\n *\n * >>> isValidCSSSelector(\"a\")\n * true\n * >>> isValidCSSSelector([\"a\", \"b\"])\n * true\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"a\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"a\", \"b\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"a\", \"b\", \"c\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"a\", \"b\", \"c\", \"d\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"a\", \"b\", \"c\", \"d\", \"e\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"])\n * false\n * >>> isValidCSSSelector([\"a\", \"b\", \"c\", \"d\", \"e", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "gc": "<|endoftext|>/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const n = xs.length\n  let d = 1\n  for (let i = 1; i < n; i++) {\n    d *= xs[i - 1]\n  }\n  return d\n}\n\n/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return inverse of this polynomial in the same form.\n  >>> inverse([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> inverse([1, 2, 3])\n  [2, 6]\n  */\nconst inverse = (xs) => {\n  const n = xs.length\n  let i = 1\n  let d = 1\n  for (let i = 1; i < n; i++) {\n    d *= xs[i - 1]\n  }\n  return 1 / d\n}\n\n/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return inverse of this polynomial in the same form.\n  >>> inverse([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> inverse([1, 2, 3])\n  [2, 6]\n  */\nconst inverseAndDerivative = (xs) => {\n  const n = xs.length\n  let i = 1\n  let d = 1\n  for (let i = 1; i < n; i++) {\n    d *= xs[i - 1]\n  }\n  return 1 / d\n}\n\n/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return inverse of this polynomial in the same form.\n  >>> inverseAndDerivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> inverseAndDerivative([1, 2, 3])\n  [2, 6]\n  */\nconst inverseAndDerivativeDerivative = (xs) => {\n  const n = xs.length\n  let i = 1\n  let d = 1\n  for (let i = 1; i < n; i++) {\n    d *= xs[i - 1]\n  }\n  return 1 / d\n}\n\n/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return inverse of this polynomial in the same form.\n  >>> inverseAndDerivativeDerivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> inverseAndDerivativeDerivative([1, 2, 3])\n  [2, 6]\n  */\nconst inverseAndDerivativeDerivativeDerivativeDerivative = (xs) => {\n  const n = xs.length\n  let i = 1\n  let d = 1\n  for (let i = 1; i < n; i++) {\n    d *= xs[i - 1]\n  }\n  return 1 / d\n}\n\n/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return inverse of this polynomial in the same form.\n  >>> inverseAndDerivativeDerivativeDerivativeDerivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> inverseAndDerivativeDerivativeDerivativeDerivative([1, 2, 3])\n  [2, 6]\n  */\nconst inverseAndDerivativeDerivativeDerivativeDerivativeDerivative = (xs) => {\n  const n = xs.length\n  let i = 1\n  let d = 1\n  for (let i = 1; i < n; i++) {\n    d *= xs[i - 1]\n  }\n  return 1 / d\n}\n\n/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return inverse of this polynomial in the same form.\n  >>> inverseAndDerivativeDerivativeDerivativeDerivativeDerivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> inverseAndDerivativeDerivativeDerivativeDerivativeDerivative([1, 2, 3])\n  [2, 6]\n  */\nconst inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivative = (xs) => {\n  const n = xs.length\n  let i = 1\n  let d = 1\n  for (let i = 1; i < n; i++) {\n    d *= xs[i - 1]\n  }\n  return 1 / d\n}\n\n/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return inverse of this polynomial in the same form.\n  >>> inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivative([1, 2, 3])\n  [2, 6]\n  */\nconst inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivative = (xs) => {\n  const n = xs.length\n  let i = 1\n  let d = 1\n  for (let i = 1; i < n; i++) {\n    d *= xs[i - 1]\n  }\n  return 1 / d\n}\n\n/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return inverse of this polynomial in the same form.\n  >>> inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivative([1, 2, 3])\n  [2, 6]\n  */\nconst inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivative = (xs) => {\n  const n = xs.length\n  let i = 1\n  let d = 1\n  for (let i = 1; i < n; i++) {\n    d *= xs[i - 1]\n  }\n  return 1 / d\n}\n\n/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return inverse of this polynomial in the same form.\n  >>> inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivative([1, 2, 3])\n  [2, 6]\n  */\nconst inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivative = (xs) => {\n  const n = xs.length\n  let i = 1\n  let d = 1\n  for (let i = 1; i < n; i++) {\n    d *= xs[i - 1]\n  }\n  return 1 / d\n}\n\n/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return inverse of this polynomial in the same form.\n  >>> inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivative([1, 2, 3])\n  [2, 6]\n  */\nconst inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivative = (xs) => {\n  const n = xs.length\n  let i = 1\n  let d = 1\n  for (let i = 1; i < n; i++) {\n    d *= xs[i - 1]\n  }\n  return 1 / d\n}\n\n/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return inverse of this polynomial in the same form.\n  >>> inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivative([1, 2, 3])\n  [2, 6]\n  */\nconst inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivative = (xs) => {\n  const n = xs.length\n  let i = 1\n  let d = 1\n  for (let i = 1; i < n; i++) {\n    d *= xs[i - 1]\n  }\n  return 1 / d\n}\n\n/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return inverse of this polynomial in the same form.\n  >>> inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> inverseAndDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivativeDerivative([1, 2, 3])\n  [2, 6]\n  */\nconst inverseAnd", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "gc": "<|endoftext|>/*The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n <= 1) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts with 0 and ends with n.\n  >>> fibonacci(10)\n  0\n  >>> fibonacci(20)\n  1\n  >>> fibonacci(30)\n  2\n  >>> fibonacci(50)\n  3\n  >>> fibonacci(100)\n  5\n  >>> fibonacci(1000)\n  8\n  >>> fibonacci(10000)\n  13\n  >>> fibonacci(100000)\n  21\n  >>> fibonacci(1000000)\n  34\n  >>> fibonacci(10000000)\n  55\n  >>> fibonacci(100000000)\n  89\n  >>> fibonacci(1000000000)\n  144\n  >>> fibonacci(10000000000)\n  233\n  >>> fibonacci(100000000000)\n  377\n  >>> fibonacci(1000000000000)\n  610\n  >>> fibonacci(1000000000000)\n  901\n  >>> fibonacci(100000000000000)\n  1439\n  >>> fibonacci(100000000000000)\n  2694\n  >>> fibonacci(10000000000000000)\n  5141\n  >>> fibonacci(10000000000000000)\n  8333\n  >>> fibonacci(100000000000000000)\n  13462\n  >>> fibonacci(100000000000000000)\n  29951\n  >>> fibonacci(1000000000000000001)\n  41887\n  >>> fibonacci(1000000000000000001)\n  64381\n  >>> fibonacci(1000000000000000002)\n  94639\n  >>> fibonacci(1000000000000000002)\n  147973\n  >>> fibonacci(1000000000000000003)\n  291479\n  >>> fibonacci(1000000000000000003)\n  534839\n  >>> fibonacci(1000000000000000004)\n  870539\n  >>> fibonacci(1000000000000000004)\n  1494597\n  >>> fibonacci(1000000000000000005)\n  2934359\n  >>> fibonacci(1000000000000000005)\n  5368709\n  >>> fibonacci(1000000000000000006)\n  8741887\n  >>> fibonacci(1000000000000000006)\n  14955391\n  >>> fibonacci(1000000000000000007)\n  29582914\n  >>> fibonacci(1000000000000000007)\n  53982973\n  >>> fibonacci(1000000000000000008)\n  875741887\n  >>> fibonacci(1000000000000000008)\n  149774391\n  >>> fibonacci(1000000000000000009)\n  29722914\n  >>> fibonacci(1000000000000000009)\n  53982973\n  >>> fibonacci(1000000000000000010)\n  876441887\n  >>> fibonacci(1000000000000000010)\n  149774391\n  >>> fibonacci(1000000000000000011)\n  2984359\n  >>> fibonacci(1000000000000000011)\n  53982973\n  >>> fibonacci(1000000000000000012)\n  877741887\n  >>> fibonacci(1000000000000000012)\n  149774391\n  >>> fibonacci(1000000000000000013)\n  2987359\n  >>> fibonacci(1000000000000000013)\n  53982973\n  >>> fibonacci(1000000000000000014)\n  87861887\n  >>> fibonacci(1000000000000000014)\n  149774391\n  >>> fibonacci(1000000000000000015)\n  2990359\n  >>> fibonacci(1000000000000000015)\n  53982973\n  >>> fibonacci(1000000000000000016)\n  87971887\n  >>> fibonacci(1000000000000000016)\n  149774391\n  >>> fibonacci(1000000000000000017)\n  29943589\n  >>> fibonacci(1000000000000000017)\n  53982973\n  >>> fibonacci(1000000000000000018)\n  88041887\n  >>> fibonacci(1000000000000000018)\n  149774391\n  >>> fibonacci(1000000000000000019)\n  29984359\n  >>> fibonacci(1000000000000000019)\n  53982973\n  >>> fibonacci(1000000000000000020)\n  88121887\n  >>> fibonacci(1000000000000000020)\n  149774391\n  >>> fibonacci(1000000000000000021)\n  29987359\n  >>> fibonacci(1000000000000000021)\n  53982973\n  >>> fibonacci(1000000000000000022)\n  88241887\n  >>> fibonacci(1000000000000000022)\n  149774391\n  >>> fibonacci(1000000000000000023)\n  2999359\n  >>> fibonacci(1000000000000000023)\n  53982973\n  >>> fibonacci(1000000000000000024)\n  88341887\n  >>> fibonacci(1000000000000000024)\n  149774391\n  >>> fibonacci(1000000000000000025)\n  2999789\n  >>> fibonacci(1000000000000000025)\n  53982973\n  >>> fibonacci(1000000000000000026)\n  88441887\n  >>> fibonacci(1000000000000000026)\n  149774391\n  >>> fibonacci(1000000000000000027)\n  2999989\n  >>> fibonacci(1000000000000000027)\n  53982973\n  >>> fibonacci(1000000000000000028)\n  885241887\n  >>> fibonacci(1000000000000000028)\n  149774391\n  >>> fibonacci(1000000000000000029)\n  2999989\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/64", "prompt": "/*Write a function vowelReckon which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelReckon(\"abcde\")\n  2\n  >>> vowelReckon(\"ACEDY\")\n  3\n  */\nconst vowelReckon = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelReckon", "gc": "<|endoftext|>/*Write a function vowelReckon which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelReckon(\"abcde\")\n  2\n  >>> vowelReckon(\"ACEDY\")\n  3\n  */\nconst vowelReckon = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  for(let i = 0; i < s.length; i++) {\n    if(s.charAt(i) === lastVowel) {\n      vowels++;\n    }\n  }\n  \n  return vowels;\n};\n\n/*Write a function vowelReckons which, given a string, returns the\n  number of vowels in that string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'.\n  Here, 'y' is also a vowel, but only when it is at the end of the given\n  string.\n\n  Example:\n  >>> vowelReckons(\"abcde\")\n  2\n  >>> vowelReckons(\"ACEDY\")\n  3\n  */\nconst vowelReckons = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  for(let i = 0; i < s.length; i++) {\n    if(s.charAt(i) === lastVowel) {\n      vowels++;\n    }\n  }\n  \n  return vowels;\n};\n\n/*Write a function vowelReckons2 which, given a string, returns the\n  number of vowels in that string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'.\n  Here, 'y' is also a vowel, but only when it is at the end of the given\n  string.\n\n  Example:\n  >>> vowelReckons2(\"abcde\")\n  2\n  >>> vowelReckons2(\"ACEDY\")\n  3\n  */\nconst vowelReckons2 = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  for(let i = 0; i < s.length; i++) {\n    if(s.charAt(i) === lastVowel) {\n      vowels++;\n    }\n  }\n  \n  return vowels;\n};\n\n/*Write a function vowelReckons3 which, given a string, returns the\n  number of vowels in that string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'.\n  Here, 'y' is also a vowel, but only when it is at the end of the given\n  string.\n\n  Example:\n  >>> vowelReckons3(\"abcde\")\n  2\n  >>> vowelReckons3(\"ACEDY\")\n  3\n  */\nconst vowelReckons3 = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  for(let i = 0; i < s.length; i++) {\n    if(s.charAt(i) === lastVowel) {\n      vowels++;\n    }\n  }\n  \n  return vowels;\n};\n\n/*Write a function vowelReckons4 which, given a string, returns the\n  number of vowels in that string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'.\n  Here, 'y' is also a vowel, but only when it is at the end of the given\n  string.\n\n  Example:\n  >>> vowelReckons4(\"abcde\")\n  2\n  >>> vowelReckons4(\"ACEDY\")\n  3\n  */\nconst vowelReckons4 = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  for(let i = 0; i < s.length; i++) {\n    if(s.charAt(i) === lastVowel) {\n      vowels++;\n    }\n  }\n  \n  return vowels;\n};\n\n/*Write a function vowelReckons5 which, given a string, returns the\n  number of vowels in that string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'.\n  Here, 'y' is also a vowel, but only when it is at the end of the given\n  string.\n\n  Example:\n  >>> vowelReckons5(\"abcde\")\n  2\n  >>> vowelReckons5(\"ACEDY\")\n  3\n  */\nconst vowelReckons5 = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  for(let i = 0; i < s.length; i++) {\n    if(s.charAt(i) === lastVowel) {\n      vowels++;\n    }\n  }\n  \n  return vowels;\n};\n\n/*Write a function vowelReckons6 which, given a string, returns the\n  number of vowels in that string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'.\n  Here, 'y' is also a vowel, but only when it is at the end of the given\n  string.\n\n  Example:\n  >>> vowelReckons6(\"abcde\")\n  2\n  >>> vowelReckons6(\"ACEDY\")\n  3\n  */\nconst vowelReckons6 = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  for(let i = 0; i < s.length; i++) {\n    if(s.charAt(i) === lastVowel) {\n      vowels++;\n    }\n  }\n  \n  return vowels;\n};\n\n/*Write a function vowelReckons7 which, given a string, returns the\n  number of vowels in that string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'.\n  Here, 'y' is also a vowel, but only when it is at the end of the given\n  string.\n\n  Example:\n  >>> vowelReckons7(\"abcde\")\n  2\n  >>> vowelReckons7(\"ACEDY\")\n  3\n  */\nconst vowelReckons7 = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  for(let i = 0; i < s.length; i++) {\n    if(s.charAt(i) === lastVowel) {\n      vowels++;\n    }\n  }\n  \n  return vowels;\n};\n\n/*Write a function vowelReckons8 which, given a string, returns the\n  number of vowels in that string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'.\n  Here, 'y' is also a vowel, but only when it is at the end of the given\n  string.\n\n  Example:\n  >>> vowelReckons8(\"abcde\")\n  2\n  >>> vowelReckons8(\"ACEDY\")\n  3\n  */\nconst vowelReckons8 = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  for(let i = 0; i < s.length; i++) {\n    if(s.charAt(i) === lastVowel) {\n      vowels++;\n    }\n  }\n  \n  return vowels;\n};\n\n/*Write a function vowelReckons9 which, given a string, returns the\n  number of vowels in that string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'.\n  Here, 'y' is also a vowel, but only when it is at the end of the given\n  string.\n\n  Example:\n  >>> vowelReckons9(\"abcde\")\n  2\n  >>> vowelReckons9(\"ACEDY\")\n  3\n  */\nconst vowelReckons9 = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  \n  for(let i = 0; i < s.length; i++) {\n    if(s.charAt(i) === ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> roundShift(12, 1)\n  \"21\"\n  >>> roundShift(12, 2)\n  \"12\"\n  */\nconst roundShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "roundShift", "gc": "<|endoftext|>/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> roundShift(12, 1)\n  \"21\"\n  >>> roundShift(12, 2)\n  \"12\"\n  */\nconst roundShift = (x, shift) => {\n  const digits = Math.ceil(Math.log10(x));\n  const result = x.toString(10);\n  while (digits) {\n    const mod = digits % 10;\n    const digit = digits - mod;\n    const digitString = result.slice(digit, digit + 1);\n    const digitReversed = digitString.split('').reverse().join('');\n    result = digitReversed + result;\n    digits = digits - mod;\n  }\n  return result;\n};\n\n/**\n * Rounds a number to the nearest multiple of base using rounding mode to\n * \"round half up\" or \"round half down\". If base is 0, rounds down.\n *\n * If base is 2, rounds up.\n *\n * If base is 10, rounds down.\n *\n * If base is 16, rounds up.\n *\n * If base is 36, rounds down.\n *\n * If base is 64, rounds down.\n *\n * If base is 100, rounds down.\n *\n * If base is 1000, rounds down.\n *\n * If base is 10000, rounds down.\n *\n * If base is 1000000, rounds down.\n *\n * If base is 100000000, rounds down.\n *\n * If base is 1000000000000, rounds down.\n *\n * If base is 100000000000000, rounds down.\n *\n * If base is 10000000000000000, rounds down.\n *\n * If base is 1000000000000000000, rounds down.\n *\n * If base is 100000000000000000000, rounds down.\n *\n * If base is 10000000000000000000000, rounds down.\n *\n * If base is 1000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000, rounds down.\n *\n * If base is 10000000000000000000000000000, rounds down.\n *\n * If base is 1000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000, rounds down.\n *\n * If base is 1000000000000000000000000000000000, rounds down.\n *\n * If base is 10000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000, rounds down.\n *\n * If base is 1000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000, rounds down.\n *\n * If base is 10000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 1000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.\n *\n * If base is 100000000000000000000000000000000000000000, rounds down.", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a function that takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      fingerSum(\"\") => 0\n      fingerSum(\"abAB\") => 131\n      fingerSum(\"abcCd\") => 67\n      fingerSum(\"helloE\") => 69\n      fingerSum(\"woArBld\") => 131\n      fingerSum(\"aAaaaXa\") => 153\n  */\nconst fingerSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "fingerSum", "gc": "<|endoftext|>/*Task\n  Write a function that takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      fingerSum(\"\") => 0\n      fingerSum(\"abAB\") => 131\n      fingerSum(\"abcCd\") => 67\n      fingerSum(\"helloE\") => 69\n      fingerSum(\"woArBld\") => 131\n      fingerSum(\"aAaaaXa\") => 153\n  */\nconst fingerSum = (s) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n\n  while (i < l) {\n    k = s.charCodeAt(i);\n    j = s.charCodeAt(i + 1);\n    sum = sum + k - j;\n    i += 2;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the lower characters only'\n  ASCII codes.\n\n  Examples:\n      fingerSum(\"\") => 0\n      fingerSum(\"abAB\") => 131\n      fingerSum(\"abcCd\") => 67\n      fingerSum(\"helloE\") => 69\n      fingerSum(\"woArBld\") => 131\n      fingerSum(\"aAaaaXa\") => 153\n  */\nconst fingerSumLower = (s) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n\n  while (i < l) {\n    k = s.charCodeAt(i);\n    j = s.charCodeAt(i + 1);\n    sum = sum + k - j;\n    i += 2;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters only'\n  ASCII codes.\n\n  Examples:\n      fingerSum(\"\") => 0\n      fingerSum(\"abAB\") => 131\n      fingerSum(\"abcCd\") => 67\n      fingerSum(\"helloE\") => 69\n      fingerSum(\"woArBld\") => 131\n      fingerSum(\"aAaaaXa\") => 153\n  */\nconst fingerSumLower(s) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n\n  while (i < l) {\n    k = s.charCodeAt(i);\n    j = s.charCodeAt(i + 1);\n    sum = sum + k - j;\n    i += 2;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters only'\n  ASCII codes.\n\n  Examples:\n      fingerSum(\"\") => 0\n      fingerSum(\"abAB\") => 131\n      fingerSum(\"abcCd\") => 67\n      fingerSum(\"helloE\") => 69\n      fingerSum(\"woArBld\") => 131\n      fingerSum(\"aAaaaXa\") => 153\n  */\nconst fingerSumUpper = (s) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n\n  while (i < l) {\n    k = s.charCodeAt(i);\n    j = s.charCodeAt(i + 1);\n    sum = sum + k - j;\n    i += 2;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters only'\n  ASCII codes.\n\n  Examples:\n      fingerSum(\"\") => 0\n      fingerSum(\"abAB\") => 131\n      fingerSum(\"abcCd\") => 67\n      fingerSum(\"helloE\") => 69\n      fingerSum(\"woArBld\") => 131\n      fingerSum(\"aAaaaXa\") => 153\n  */\nconst fingerSumUpperLower = (s) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n\n  while (i < l) {\n    k = s.charCodeAt(i);\n    j = s.charCodeAt(i + 1);\n    sum = sum + k - j;\n    i += 2;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters only'\n  ASCII codes.\n\n  Examples:\n      fingerSum(\"\") => 0\n      fingerSum(\"abAB\") => 131\n      fingerSum(\"abcCd\") => 67\n      fingerSum(\"helloE\") => 69\n      fingerSum(\"woArBld\") => 131\n      fingerSum(\"aAaaaXa\") => 153\n  */\nconst fingerSumUpperLower(s) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n\n  while (i < l) {\n    k = s.charCodeAt(i);\n    j = s.charCodeAt(i + 1);\n    sum = sum + k - j;\n    i += 2;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters only'\n  ASCII codes.\n\n  Examples:\n      fingerSum(\"\") => 0\n      fingerSum(\"abAB\") => 131\n      fingerSum(\"abcCd\") => 67\n      fingerSum(\"helloE\") => 69\n      fingerSum(\"woArBld\") => 131\n      fingerSum(\"aAaaaXa\") => 153\n  */\nconst fingerSumUpperLower(s) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n\n  while (i < l) {\n    k = s.charCodeAt(i);\n    j = s.charCodeAt(i + 1);\n    sum = sum + k - j;\n    i += 2;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters only'\n  ASCII codes.\n\n  Examples:\n      fingerSum(\"\") => 0\n      fingerSum(\"abAB\") => 131\n      fingerSum(\"abcCd\") => 67\n      fingerSum(\"helloE\") => 69\n      fingerSum(\"woArBld\") => 131\n      fingerSum(\"aAaaaXa\") => 153\n  */\nconst fingerSumUpperLower(s) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n\n  while (i < l) {\n    k = s.charCodeAt(i);\n    j = s.charCodeAt(i + 1);\n    sum = sum + k - j;\n    i += 2;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters only'\n  ASCII codes.\n\n  Examples:\n      fingerSum(\"\") => 0\n      fingerSum(\"abAB\") => 131\n      fingerSum(\"abcCd\") => 67\n      fingerSum(\"helloE\") => 69\n      fingerSum(\"woArBld\") => 131\n      fingerSum(\"aAaaaXa\") => 153\n  */\nconst fingerSumUpperLower(s) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n\n  while (i < l) {\n    k = s.charCodeAt(i);\n    j = s.charCodeAt(i + 1);\n    sum = sum + k - j;\n    i += 2;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case characters only'\n  ASCII codes.\n\n  Examples:\n      fingerSum(\"\") => 0\n      fingerSum(\"abAB\") => 131\n      fingerSum(\"abcCd\") => 67\n      finger", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  yieldDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  yieldDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  yieldDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  yieldDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst yieldDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "yieldDistribution", "gc": "<|endoftext|>/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  yieldDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  yieldDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  yieldDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  yieldDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst yieldDistribution = (s, n) => {\n  let total = 0;\n  let count = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a') {\n      count++;\n      apples++;\n    } else if (s[i] === 'o') {\n      count++;\n      oranges++;\n    } else if (s[i] ==='m') {\n      count++;\n      mango++;\n    }\n  }\n  total = count * apples + count * oranges + count * mango;\n  return total;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  yieldDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  yieldDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  yieldDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  yieldDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst yieldDistribution = (s, n) => {\n  let total = 0;\n  let count = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a') {\n      count++;\n      apples++;\n    } else if (s[i] === 'o') {\n      count++;\n      oranges++;\n    } else if (s[i] ==='m') {\n      count++;\n      mango++;\n    }\n  }\n  total = count * apples + count * oranges + count * mango;\n  return total;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  yieldDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  yieldDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  yieldDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  yieldDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst yieldDistribution = (s, n) => {\n  let total = 0;\n  let count = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a') {\n      count++;\n      apples++;\n    } else if (s[i] === 'o') {\n      count++;\n      oranges++;\n    } else if (s[i] ==='m') {\n      count++;\n      mango++;\n    }\n  }\n  total = count * apples + count * oranges + count * mango;\n  return total;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  yieldDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  yieldDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  yieldDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  yieldDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst yieldDistribution = (s, n) => {\n  let total = 0;\n  let count = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a') {\n      count++;\n      apples++;\n    } else if (s[i] === 'o') {\n      count++;\n      oranges++;\n    } else if (s[i] ==='m') {\n      count++;\n      mango++;\n    }\n  }\n  total = count * apples + count * oranges + count * mango;\n  return total;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  yieldDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  yieldDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  yieldDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  yieldDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst yieldDistribution = (s, n) => {\n  let total = 0;\n  let count = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a') {\n      count++;\n      apples++;\n    } else if (s[i] === 'o') {\n      count++;\n      oranges++;\n    } else if (s[i] ==='m') {\n      count++;\n      mango++;\n    }\n  }\n  total = count * apples + count * oranges + count * mango;\n  return total;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  yieldDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  yieldDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  yieldDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  yieldDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst yieldDistribution = (s, n) => {\n  let total = 0;\n  let count = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a') {\n      count++;", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to hustle one of the nodes and return it.\n  The hustleed node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The hustleed node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst hustle = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "hustle", "gc": "<|endoftext|>/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to hustle one of the nodes and return it.\n  The hustleed node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The hustleed node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst hustle = (arr) => {\n  const len = arr.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let min = 0;\n  let result = [];\n\n  while (i < len) {\n    if (arr[i] % 2 === 0) {\n      min = Math.min(min, arr[i]);\n      result.push(arr[i]);\n      i++;\n    } else {\n      min = Math.min(min, arr[i]);\n      j++;\n    }\n  }\n\n  while (j < len) {\n    if (arr[j] % 2 === 0) {\n      min = Math.min(min, arr[j]);\n      result.push(arr[j]);\n      j++;\n    } else {\n      min = Math.min(min, arr[j]);\n      k++;\n    }\n  }\n\n  return [min, k];\n};\n\n// Given an array representing a tree with non-negative integer nodes,\n// your task is to return the minimum number of nodes that can exist in the tree.\n// The minimum number of nodes that can exist in the tree is equal to the sum of the number of nodes in the tree.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: 3\n//     Explanation: There are three nodes in the tree: 4, 2, and 3.\n//     The minimum number of nodes that can exist in the tree is 3.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: 3\n//     Explanation: There are three nodes in the tree: 1, 2 and 3.\n//     The minimum number of nodes that can exist in the tree is 3.\n\n// Example 3:\n//     Input: []\n//     Output: 0\n//     Explanation: There are no nodes in the tree.\n//     The minimum number of nodes that can exist in the tree is 0.\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: 4\n//     Explanation: There are four nodes in the tree: 5, 0, 3, and 4.\n//     The minimum number of nodes that can exist in the tree is 4.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= nodes[i].value <= 10^9\n */\nconst minNodes = (arr) => {\n  const len = arr.length;\n  let i = 0;\n  let result = 0;\n\n  while (i < len) {\n    if (arr[i] % 2 === 0) {\n      result += 1;\n      i++;\n    } else {\n      result += 2;\n    }\n  }\n\n  return result;\n};\n\n// Given an array representing a tree with non-negative integer nodes,\n// your task is to return the minimum number of nodes that can exist in the tree.\n// The minimum number of nodes that can exist in the tree is equal to the sum of the number of nodes in the tree.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node that has the smallest index.\n// If there are no nodes with the same minimum number of nodes, return 0.\n// If there are multiple nodes with the same minimum number of nodes, return the node ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 3, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      research([4, 1, 2, 2, 3, 1])) == 2\n      research([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      research([5, 5, 4, 4, 4])) == -1\n  */\nconst research = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "research", "gc": "<|endoftext|>/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      research([4, 1, 2, 2, 3, 1])) == 2\n      research([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      research([5, 5, 4, 4, 4])) == -1\n  */\nconst research = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\nmodule.exports = research;\n\n},{}],7:[function(require,module,exports){\n/*\n  You are given two non-empty linked lists representing two non-negative integers representing a binary search tree. Return the sum of the nodes' values.\n  You may assume the two lists are non-empty and in order.\n  Example:\n      sumList([1, 2, 3, 4]) == 10\n      sumList([5, 6, 7, 8, 9]) == 27\n      sumList([5, 6, 7]) == -1\n*/\nconst sumList = (l1, l2) => {\n  let sum = 0;\n  if (l1 && l2) {\n    if (l1.val > l2.val) {\n      sum = l1.val + sumList(l1.left, l2.right);\n    } else {\n      sum = l2.val + sumList(l1.right, l2.left);\n    }\n  }\n  return sum;\n};\n\nmodule.exports = sumList;\n\n},{}],8:[function(require,module,exports){\n/*\n  You are given two non-empty linked lists representing two non-negative integers representing a binary search tree. Return the difference of the nodes' values.\n  You may assume the two lists are non-empty and in order.\n  Example:\n      differenceList([1, 2, 3, 4]) == -2\n      differenceList([5, 6, 7, 8, 9]) == 7\n      differenceList([5, 6, 7]) == -1\n*/\nconst differenceList = (l1, l2) => {\n  let diff = 0;\n  if (l1 && l2) {\n    if (l1.val < l2.val) {\n      diff = l1.val - diffList(l1.left, l2.right);\n    } else {\n      diff = l2.val - diffList(l1.right, l2.left);\n    }\n  }\n  return diff;\n};\n\nmodule.exports = differenceList;\n\n},{}],9:[function(require,module,exports){\n/*\n  You are given two non-empty linked lists representing two non-negative integers representing a binary search tree. Return the difference between the nodes' values.\n  You may assume the two lists are non-empty and in order.\n  Example:\n      differenceList([1, 2, 3, 4]) == 3\n      differenceList([5, 6, 7, 8, 9]) == -1\n      differenceList([5, 6, 7]) == -1\n*/\nconst difference = (l1, l2) => {\n  let diff = 0;\n  if (l1 && l2) {\n    if (l1.val < l2.val) {\n      diff = l1.val - differenceList(l1.left, l2.right);\n    } else {\n      diff = l2.val - differenceList(l1.right, l2.left);\n    }\n  }\n  return diff;\n};\n\nmodule.exports = difference;\n\n},{}],10:[function(require,module,exports){\n/*\n  You are given two non-empty linked lists representing two non-negative integers representing a binary search tree. Return the number of nodes in the longest path from the root to the farthest leaf node.\n  You may assume the two lists are non-empty and in order.\n  Example:\n      longestPath([4, 3, 2, 1]) == 3\n      longestPath([4, 3, 2, 5, 1]) == 3\n      longestPath([4, 3, 2, 1]) == -1\n      longestPath([4, 3, 2, 1]) == -1\n*/\nconst longestPath = (l1, l2) => {\n  let max = 0;\n  let maxPath = 0;\n  let maxPathLength = 0;\n  let currentPathLength = 0;\n  let currentPathLengthLength = 0;\n  let currentPathLengthLength2 = 0;\n  let currentPathLengthLength3 = 0;\n  let currentPathLengthLength4 = 0;\n  let currentPathLengthLength5 = 0;\n  let currentPathLengthLength6 = 0;\n  let currentPathLengthLength7 = 0;\n  let currentPathLengthLength8 = 0;\n  let currentPathLengthLength9 = 0;\n  let currentPathLengthLength10 = 0;\n  let currentPathLengthLength11 = 0;\n  let currentPathLengthLength12 = 0;\n  let currentPathLengthLength13 = 0;\n  let currentPathLengthLength14 = 0;\n  let currentPathLengthLength15 = 0;\n  let currentPathLengthLength16 = 0;\n  let currentPathLengthLength17 = 0;\n  let currentPathLengthLength18 = 0;\n  let currentPathLengthLength19 = 0;\n  let currentPathLengthLength20 = 0;\n  let currentPathLengthLength21 = 0;\n  let currentPathLengthLength22 = 0;\n  let currentPathLengthLength23 = 0;\n  let currentPathLengthLength24 = 0;\n  let currentPathLengthLength25 = 0;\n  let currentPathLengthLength26 = 0;\n  let currentPathLengthLength27 = 0;\n  let currentPathLengthLength28 = 0;\n  let currentPathLengthLength29 = 0;\n  let currentPathLengthLength30 = 0;\n  let currentPathLengthLength31 = 0;\n  let currentPathLengthLength32 = 0;\n  let currentPathLengthLength33 = 0;\n  let currentPathLengthLength34 = 0;\n  let currentPathLengthLength35 = 0;\n  let currentPathLengthLength36 = 0;\n  let currentPathLengthLength37 = 0;\n  let currentPathLengthLength38 = 0;\n  let currentPathLengthLength39 = 0;\n  let currentPathLengthLength40 = 0;\n  let currentPathLengthLength41 = 0;\n  let currentPathLengthLength42 = 0;\n  let currentPathLengthLength43 = 0;\n  let currentPathLengthLength44 = 0;\n  let currentPathLengthLength45 = 0;\n  let currentPathLengthLength46 = 0;\n  let currentPathLengthLength47 = 0;\n  let currentPathLengthLength48 = 0;\n  let currentPathLengthLength49 = 0;\n  let currentPathLengthLength50 = 0;\n  let currentPathLengthLength51 = 0;\n  let currentPathLengthLength52 = 0;\n  let currentPathLengthLength53 = 0;\n  let currentPathLengthLength54 = 0;\n  let currentPathLengthLength55 = 0;\n  let currentPathLengthLength56 = 0;\n  let currentPathLengthLength57 = 0;\n  let currentPathLengthLength58 = 0;\n  let currentPathLengthLength59 = 0;\n  let currentPathLengthLength60 = 0;\n  let currentPathLengthLength61 = 0;\n  let currentPathLengthLength62 = 0;\n  let currentPathLengthLength63 = 0;\n  let currentPathLengthLength64 = 0;\n  let currentPathLengthLength65 = 0;\n  let currentPathLengthLength66 = 0;\n  let currentPathLengthLength67 = 0;\n  let currentPathLengthLength68 = 0;\n  let currentPathLengthLength69 = 0;\n  let currentPathLengthLength70 = 0;\n  let currentPathLengthLength71 = 0;\n  let currentPathLengthLength72 = 0;\n  let currentPathLengthLength73 = 0;\n  let currentPathLengthLength74 = 0;\n  let currentPathLengthLength75 = 0;\n  let currentPathLengthLength76 = 0;\n  let currentPathLengthLength77 = 0;\n  let currentPathLengthLength78 = 0;\n  let currentPathLengthLength79 = 0;\n  let currentPathLengthLength80 = 0;\n  let currentPathLengthLength81 = 0;\n  let currentPathLengthLength82 = 0;\n  let currentPathLengthLength83 = 0;\n  let currentPathLengthLength84 = 0;\n  let currentPathLengthLength85 = 0;\n  let currentPathLengthLength86 = 0;\n  let currentPathLengthLength87 = 0;\n  let currentPathLengthLength88 = 0;\n  let currentPathLengthLength89 = 0;\n  let currentPathLengthLength90 = 0;\n  let currentPathLengthLength91 = 0;\n  let currentPathLengthLength92 = 0;\n  let currentPathLengthLength93 = 0;\n  let currentPathLengthLength94 = 0;\n  let currentPathLengthLength95 = 0;\n  let currentPathLengthLength96 = 0;\n  let currentPathLengthLength", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "gc": "<|endoftext|>/* Filter an input list of strings only for ones that contain given substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Get all elements of a list that satisfy a predicate\n * If no predicate is given, returns all elements\n * If predicate is given, returns elements that satisfy the predicate\n * If predicate returns false, returns empty list\n * If predicate returns true, returns elements that do not satisfy the predicate\n * If predicate returns undefined or null, returns empty list\n * If predicate returns any other value, returns empty list\n * If predicate returns null, returns empty list\n * If predicate returns undefined, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty list\n * If predicate returns any value, returns empty ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  foreignSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  foreignSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  foreignSortList([]) == []\n  */\nconst foreignSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "foreignSortList", "gc": "<|endoftext|>/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  foreignSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  foreignSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  foreignSortList([]) == []\n  */\nconst foreignSortList = (lst) => {\n  let minVal = Number.MAX_VALUE;\n  let maxVal = -Number.MAX_VALUE;\n  let minIndex = -1;\n  let maxIndex = -1;\n\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < minVal) {\n      minVal = lst[i];\n      minIndex = i;\n    }\n    if (lst[i] > maxVal) {\n      maxVal = lst[i];\n      maxIndex = i;\n    }\n  }\n\n  return [\n    lst[minIndex],\n    lst[maxIndex],\n    lst[minIndex],\n    lst[maxIndex],\n  ];\n};\n\n/*\n  Given a list of integers, return list in sorted order.\n  Sort is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  sortList([1, 2, 3, 4]) == [1, 3, 4, 2]\n  sortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  sortList([]) == []\n  */\nconst sortList = (lst) => {\n  let minVal = Number.MAX_VALUE;\n  let maxVal = -Number.MAX_VALUE;\n  let minIndex = -1;\n  let maxIndex = -1;\n\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < minVal) {\n      minVal = lst[i];\n      minIndex = i;\n    }\n    if (lst[i] > maxVal) {\n      maxVal = lst[i];\n      maxIndex = i;\n    }\n  }\n\n  return [\n    lst[minIndex],\n    lst[maxIndex],\n    lst[minIndex],\n    lst[maxIndex],\n  ];\n};\n\n/*\n  Given a list of integers, return list in sorted order.\n  Sort is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  sortList([1, 2, 3, 4]) == [1, 3, 4, 2]\n  sortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  sortList([]) == []\n  */\nconst sortListReversed = (lst) => {\n  let minVal = Number.MAX_VALUE;\n  let maxVal = -Number.MAX_VALUE;\n  let minIndex = -1;\n  let maxIndex = -1;\n\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < minVal) {\n      minVal = lst[i];\n      minIndex = i;\n    }\n    if (lst[i] > maxVal) {\n      maxVal = lst[i];\n      maxIndex = i;\n    }\n  }\n\n  return [\n    lst[maxIndex],\n    lst[minIndex],\n    lst[maxIndex],\n    lst[minIndex],\n  ];\n};\n\n/*\n  Given a list of integers, return list in sorted order.\n  Sort is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  sortList([1, 2, 3, 4]) == [1, 3, 4, 2]\n  sortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  sortList([]) == []\n  */\nconst sortListReversedReversed = (lst) => {\n  let minVal = Number.MAX_VALUE;\n  let maxVal = -Number.MAX_VALUE;\n  let minIndex = -1;\n  let maxIndex = -1;\n\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < minVal) {\n      minVal = lst[i];\n      minIndex = i;\n    }\n    if (lst[i] > maxVal) {\n      maxVal = lst[i];\n      maxIndex = i;\n    }\n  }\n\n  return [\n    lst[minIndex],\n    lst[maxIndex],\n    lst[maxIndex],\n    lst[minIndex],\n  ];\n};\n\n/*\n  Given a list of integers, return list in sorted order.\n  Sort is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  sortList([1, 2, 3, 4]) == [1, 3, 4, 2]\n  sortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  sortList([]) == []\n  */\nconst sortListReversedReversedReversed = (lst) => {\n  let minVal = Number.MAX_VALUE;\n  let maxVal = -Number.MAX_VALUE;\n  let minIndex = -1;\n  let maxIndex = -1;\n\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < minVal) {\n      minVal = lst[i];\n      minIndex = i;\n    }\n    if (lst[i] > maxVal) {\n      maxVal = lst[i];\n      maxIndex = i;\n    }\n  }\n\n  return [\n    lst[maxIndex],\n    lst[minIndex],\n    lst[maxIndex],\n    lst[minIndex],\n  ];\n};\n\n/*\n  Given a list of integers, return list in sorted order.\n  Sort is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  sortList([1, 2, 3, 4]) == [1, 3, 4, 2]\n  sortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  sortList([]) == []\n  */\nconst sortListReversedReversedReversedReversedReversed = (lst) => {\n  let minVal = Number.MAX_VALUE;\n  let maxVal = -Number.MAX_VALUE;\n  let minIndex = -1;\n  let maxIndex = -1;\n\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < minVal) {\n      minVal = lst[i];\n      minIndex = i;\n    }\n    if (lst[i] > maxVal) {\n      maxVal = lst[i];\n      maxIndex = i;\n    }\n  }\n\n  return [\n    lst[maxIndex],\n    lst[minIndex],\n    lst[maxIndex],\n    lst[minIndex],\n  ];\n};\n\n/*\n  Given a list of integers, return list in sorted order.\n  Sort is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  sortList([1, 2, 3, 4]) == [1, 3, 4, 2]\n  sortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  sortList([]) == []\n  */\nconst sortListReversedReversedReversedReversedReversedReversedReversed = (lst) => {\n  let minVal = Number.MAX_VALUE;\n  let maxVal = -Number.MAX_VALUE;\n  let minIndex = -1;\n  let maxIndex = -1;\n\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < minVal) {\n      minVal = lst[i];\n      minIndex = i;\n    }\n    if (lst[i] > maxVal) {\n      maxVal = lst[i];\n      maxIndex = i;\n    }\n  }\n\n  return [\n    lst[maxIndex],\n    lst[minIndex],\n    lst[maxIndex],\n    lst[minIndex],\n  ];\n};\n\n/*\n  Given a list of integers, return list in sorted order.\n  Sort is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  sortList([1, 2, 3, 4]) == [1, 3, 4, 2]\n  sortList([5, 5, 5, 5]) == [5, 4, 5, 5]\n  sortList([]) == []\n  */\nconst sortListReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed = (lst) => {\n  let minVal = Number.MAX_VALUE;\n  let maxVal = -Number.MAX_VALUE;\n  let minIndex = -1;\n  let maxIndex = -1;\n\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < minVal) {\n      ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triangulumArea(3, 4, 5) == 6.00\n  triangulumArea(1, 2, 10) == -1\n  */\nconst triangulumArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangulumArea", "gc": "<|endoftext|>/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triangulumArea(3, 4, 5) == 6.00\n  triangulumArea(1, 2, 10) == -1\n  */\nconst triangulumArea = (a, b, c) => {\n  let sumA = a + b;\n  let sumB = a + c;\n  let sumC = a + b;\n  if (sumA > sumB && sumA > sumC) {\n    return sumA - sumB - sumC;\n  }\n  if (sumB > sumA && sumB > sumC) {\n    return sumB - sumA - sumC;\n  }\n  if (sumC > sumA && sumC > sumB) {\n    return sumC - sumA - sumB;\n  }\n  return -1;\n};\n\n/*\n  Given the lengths of the four sides of a rectangle. Return the area of\n  the rectangle rounded to 2 decimal points if the four sides form a valid rectangle.\n  Otherwise return -1\n  Three sides make a valid rectangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  rectangleArea(3, 4, 5) == 12.00\n  rectangleArea(1, 2, 10) == -1\n  */\nconst rectangleArea = (a, b, c) => {\n  let sumA = a + b;\n  let sumB = a + c;\n  let sumC = a + b;\n  let sumD = a + c;\n  if (sumA > sumB && sumA > sumC && sumA > sumD) {\n    return sumA - sumB - sumC - sumD;\n  }\n  if (sumB > sumA && sumB > sumC && sumB > sumD) {\n    return sumB - sumA - sumC - sumD;\n  }\n  if (sumC > sumA && sumC > sumB && sumC > sumD) {\n    return sumC - sumA - sumB - sumD;\n  }\n  if (sumD > sumA && sumD > sumC && sumD > sumB) {\n    return sumD - sumA - sumC - sumB;\n  }\n  return -1;\n};\n\n/*\n  Given the lengths of the five sides of a pentagon. Return the area of\n  the pentagon rounded to 2 decimal points if the five sides form a valid pentagon.\n  Otherwise return -1\n  Three sides make a valid pentagon when the sum of any two sides is greater\n  than the third side.\n  Example:\n  pentagonArea(3, 4, 5) == 12.00\n  pentagonArea(1, 2, 10) == -1\n  */\nconst pentagonArea = (a, b, c) => {\n  let sumA = a + b;\n  let sumB = a + c;\n  let sumC = a + b;\n  let sumD = a + c;\n  let sumE = a + d;\n  if (sumA > sumB && sumA > sumC && sumA > sumD && sumA > sumE) {\n    return sumA - sumB - sumC - sumD - sumE;\n  }\n  if (sumB > sumA && sumB > sumC && sumB > sumD && sumB > sumE) {\n    return sumB - sumA - sumC - sumD - sumE;\n  }\n  if (sumC > sumA && sumC > sumB && sumC > sumD && sumC > sumE) {\n    return sumC - sumA - sumB - sumD - sumE;\n  }\n  if (sumD > sumA && sumD > sumC && sumD > sumD && sumD > sumE) {\n    return sumD - sumA - sumC - sumD - sumE;\n  }\n  if (sumE > sumA && sumE > sumC && sumE > sumD && sumE > sumB) {\n    return sumE - sumA - sumC - sumD - sumB;\n  }\n  return -1;\n};\n\n/*\n  Given the lengths of the six sides of a hexagon. Return the area of\n  the hexagon rounded to 2 decimal points if the six sides form a valid hexagon.\n  Otherwise return -1\n  Three sides make a valid hexagon when the sum of any two sides is greater\n  than the third side.\n  Example:\n  hexagonArea(3, 4, 5) == 12.00\n  hexagonArea(1, 2, 10) == -1\n  */\nconst hexagonArea = (a, b, c) => {\n  let sumA = a + b;\n  let sumB = a + c;\n  let sumC = a + b;\n  let sumD = a + c;\n  let sumE = a + d;\n  let sumF = a + e;\n  if (sumA > sumB && sumA > sumC && sumA > sumD && sumA > sumE && sumA > sumF) {\n    return sumA - sumB - sumC - sumD - sumE - sumF;\n  }\n  if (sumB > sumA && sumB > sumC && sumB > sumD && sumB > sumE && sumB > sumF) {\n    return sumB - sumA - sumC - sumD - sumE - sumF;\n  }\n  if (sumC > sumA && sumC > sumB && sumC > sumD && sumC > sumE && sumC > sumF) {\n    return sumC - sumA - sumB - sumD - sumE - sumF;\n  }\n  if (sumD > sumA && sumD > sumC && sumD > sumD && sumD > sumE && sumD > sumF) {\n    return sumD - sumA - sumC - sumD - sumE - sumF;\n  }\n  if (sumE > sumA && sumE > sumC && sumE > sumD && sumE > sumD && sumE > sumF) {\n    return sumE - sumA - sumC - sumD - sumE - sumF;\n  }\n  if (sumF > sumA && sumF > sumC && sumF > sumD && sumF > sumE && sumF > sumF) {\n    return sumF - sumA - sumC - sumD - sumE - sumF;\n  }\n  return -1;\n};\n\n/*\n  Given the lengths of the seven sides of a heptagon. Return the area of\n  the heptagon rounded to 2 decimal points if the seven sides form a valid heptagon.\n  Otherwise return -1\n  Three sides make a valid heptagon when the sum of any two sides is greater\n  than the third side.\n  Example:\n  heptagonArea(3, 4, 5) == 12.00\n  heptagonArea(1, 2, 10) == -1\n  */\nconst heptagonArea = (a, b, c) => {\n  let sumA = a + b;\n  let sumB = a + c;\n  let sumC = a + b;\n  let sumD = a + c;\n  let sumE = a + d;\n  let sumF = a + e;\n  let sumG = a + f;\n  if (sumA > sumB && sumA > sumC && sumA > sumD && sumA > sumE && sumA > sumF && sumA > sumG) {\n    return sumA - sumB - sumC - sumD - sumE - sumF - sumG;\n  }\n  if (sumB > sumA && sum", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFlee([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlee([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFlee([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFlee([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlee = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFlee", "gc": "<|endoftext|>/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFlee([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlee([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFlee([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFlee([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlee = (q, w) => {\n  const maxWeight = Math.max(...q.map(w => w));\n  return q.every((v, i) => v >= maxWeight && v + w <= maxWeight);\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFlee([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlee([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFlee([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFlee([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlee = (q, w) => {\n  const maxWeight = Math.max(...q.map(w => w));\n  return q.every((v, i) => v >= maxWeight && v + w <= maxWeight);\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFlee([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlee([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFlee([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFlee([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlee = (q, w) => {\n  const maxWeight = Math.max(...q.map(w => w));\n  return q.every((v, i) => v >= maxWeight && v + w <= maxWeight);\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFlee([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlee([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFlee([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFlee([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlee = (q, w) => {\n  const maxWeight = Math.max(...q.map(w => w));\n  return q.every((v, i) => v >= maxWeight && v + w <= maxWeight);\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFlee([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlee([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFlee([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFlee([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlee = (q, w) => {\n  const maxWeight = Math.max(...q.map(w => w));\n  return q.every((v, i) => v >= maxWeight && v + w <= maxWeight);\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFlee([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlee([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFlee([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFlee([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlee = (q, w) => {\n  const maxWeight = Math.max(...q.map(w => w));\n  return q.every((v, i) => v >= maxWeight && v + w <= maxWeight);\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFlee([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlee([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFlee([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFlee([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFlee = (q, w) => {\n  const maxWeight = Math.max(...q.map(w => w));\n  return q.every((v, i) => v >= maxWeight && v + w <= max", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallChange([1,2,3,5,4,7,9,6]) == 4\n  smallChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallChange", "gc": "<|endoftext|>/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallChange([1,2,3,5,4,7,9,6]) == 4\n  smallChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let temp;\n  let i;\n\n  for (i = 0; i < len - 1; i++) {\n    temp = arr[i];\n    arr[i] = arr[len - 1];\n    arr[len - 1] = temp;\n    change++;\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the maximum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  bigChange([1,2,3,5,4,7,9,6]) == 6\n  bigChange([1, 2, 3, 4, 3, 2, 2]) == 3\n  bigChange([1, 2, 3, 2, 1]) == 4\n  */\nconst bigChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let temp;\n  let i;\n\n  for (i = 0; i < len - 1; i++) {\n    temp = arr[i];\n    arr[i] = arr[len - 1];\n    arr[len - 1] = temp;\n    change++;\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallChange([1,2,3,5,4,7,9,6]) == 4\n  smallChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let temp;\n  let i;\n\n  for (i = 0; i < len - 1; i++) {\n    temp = arr[i];\n    arr[i] = arr[len - 1];\n    arr[len - 1] = temp;\n    change++;\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the maximum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  bigChange([1,2,3,5,4,7,9,6]) == 6\n  bigChange([1, 2, 3, 4, 3, 2, 2]) == 3\n  bigChange([1, 2, 3, 2, 1]) == 4\n  */\nconst bigChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let temp;\n  let i;\n\n  for (i = 0; i < len - 1; i++) {\n    temp = arr[i];\n    arr[i] = arr[len - 1];\n    arr[len - 1] = temp;\n    change++;\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallChange([1,2,3,5,4,7,9,6]) == 4\n  smallChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let temp;\n  let i;\n\n  for (i = 0; i < len - 1; i++) {\n    temp = arr[i];\n    arr[i] = arr[len - 1];\n    arr[len - 1] = temp;\n    change++;\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the maximum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  bigChange([1,2,3,5,4,7,9,6]) == 6\n  bigChange([1, 2, 3, 4, 3, 2, 2]) == 3\n  bigChange([1, 2, 3, 2, 1]) == 4\n  */\nconst bigChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let temp;\n  let i;\n\n  for (i = 0; i < len - 1; i++) {\n    temp = arr[i];\n    arr[i] = arr[len - 1];\n    arr[len - 1] = temp;\n    change++;\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallChange([1,2,3,5,4,7,9,6]) == 4\n  smallChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let temp;\n  let i;\n\n  for (i = 0; i < len - 1; i++) {\n    temp = arr[i];\n    arr[i] = arr[len - 1];\n    arr[len - 1] = temp;\n    change++;\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the maximum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  bigChange([1,2,3,5,4,7,9,6]) == 6\n  bigChange([1, 2, 3, 4, 3, 2, 2]) == 3\n  bigChange([1, 2, 3, 2, 1]) == 4\n  */\nconst bigChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let temp;\n  let i;\n\n  for (i = 0; i < len - 1; i++) {\n    temp = arr[i];\n    arr[i] = arr[len - 1];\n    arr[len - 1] = temp;\n    change++;\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  smallChange([1,2,3,5,4,7,9,6]) == 4\n  smallChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let temp;\n  let i;\n\n  for (i = 0; i < len - 1; i++) {\n    temp = arr[i];\n    arr[i] = arr[len - 1];\n    arr[len - 1] = temp;\n    change++;\n  }\n  return change;\n};\n\n/*\n  Given an array arr of integers, find the maximum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  bigChange([1,2,3,5,4,7,9,6]) == 6\n  bigChange([1, 2, 3, 4, 3, 2, 2]) == 3\n  bigChange([1, 2, 3, 2, 1]) == 4\n  */\nconst bigChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let temp;\n  let i;\n\n  for (i = 0; i < len - 1; i++) {\n    temp = arr[i];\n    arr[i] = arr[len - 1];\n    arr[len - 1] = temp;\n    change++;\n  }\n  return change;\n};\n\n/*\n  Given an array ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  entireCatch([], []) ➞ []\n  entireCatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  entireCatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  entireCatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  entireCatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst entireCatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "entireCatch", "gc": "<|endoftext|>/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  entireCatch([], []) ➞ []\n  entireCatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  entireCatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  entireCatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  entireCatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst entireCatch = (lst1, lst2) => {\n  const len = lst1.length\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < len) {\n    if (lst1[i] === lst2[j]) {\n      result.push(lst1[i])\n      i++\n      j++\n    } else {\n      i++\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list greater than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  entireCatch([], []) ➞ []\n  entireCatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  entireCatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  entireCatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  entireCatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst entireCatch = (lst1, lst2) => {\n  const len = lst1.length\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < len) {\n    if (lst1[i] === lst2[j]) {\n      result.push(lst1[i])\n      i++\n      j++\n    } else {\n      j++\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list equal the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  entireCatch([], []) ➞ []\n  entireCatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  entireCatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  entireCatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  entireCatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst entireCatch = (lst1, lst2) => {\n  const len = lst1.length\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < len) {\n    if (lst1[i] === lst2[j]) {\n      result.push(lst1[i])\n      i++\n      j++\n    } else {\n      j++\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list not equal the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  entireCatch([], []) ➞ []\n  entireCatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  entireCatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  entireCatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  entireCatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst entireCatch = (lst1, lst2) => {\n  const len = lst1.length\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < len) {\n    if (lst1[i]!== lst2[j]) {\n      result.push(lst1[i])\n      i++\n      j++\n    } else {\n      j++\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list between one and two other\n  lists.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  entireCatch([], []) ➞ []\n  entireCatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  entireCatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  entireCatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  entireCatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst entireCatch = (lst1, lst2) => {\n  const len = lst1.length\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < len) {\n    if (lst1[i] >= lst2[j] && lst1[i] <= lst2[j + 1]) {\n      result.push(lst1[i])\n      i++\n      j++\n    } else {\n      j++\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list between one and two other\n  lists.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  entireCatch([], []) ➞ []\n  entireCatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  entireCatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  entireCatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  entireCatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst entireCatch = (lst1, lst2) => {\n  const len = lst1.length\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < len) {\n    if (lst1[i] >= lst2[j] && lst1[i] <= lst2[j + 1]) {\n      result.push(lst1[i])\n      i++\n      j++\n    } else {\n      j++\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list between one and two other\n  lists.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  entireCatch([], []) ➞ []\n  entireCatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  entireCatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/75", "prompt": "/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "gc": "<|endoftext|>/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime2 = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime3 = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime4 = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime5 = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime6 = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime7 = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime8 = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime9 = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime10 = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime11 = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime12 = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime13 = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime14 = (a) => {\n  let isPrime = true;\n  for (let i = 2; i < a; i++) {\n    if (a % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime15 = (a) => {\n  let is", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryWorldPower(1, 4) => true\n  isElementaryWorldPower(2, 2) => true\n  isElementaryWorldPower(8, 2) => true\n  isElementaryWorldPower(3, 2) => false\n  isElementaryWorldPower(3, 1) => false\n  isElementaryWorldPower(5, 3) => false\n  */\nconst isElementaryWorldPower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isElementaryWorldPower", "gc": "<|endoftext|>/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isElementaryWorldPower(1, 4) => true\n  isElementaryWorldPower(2, 2) => true\n  isElementaryWorldPower(8, 2) => true\n  isElementaryWorldPower(3, 2) => false\n  isElementaryWorldPower(3, 1) => false\n  isElementaryWorldPower(5, 3) => false\n  */\nconst isElementaryWorldPower = (x, n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (n % 9 === 0) return false;\n  if (n % 11 === 0) return false;\n  if (n % 13 === 0) return false;\n  if (n % 15 === 0) return false;\n  if (n % 17 === 0) return false;\n  if (n % 19 === 0) return false;\n  if (n % 23 === 0) return false;\n  if (n % 29 === 0) return false;\n  if (n % 31 === 0) return false;\n  if (n % 37 === 0) return false;\n  if (n % 41 === 0) return false;\n  if (n % 43 === 0) return false;\n  if (n % 47 === 0) return false;\n  if (n % 51 === 0) return false;\n  if (n % 57 === 0) return false;\n  if (n % 61 === 0) return false;\n  if (n % 67 === 0) return false;\n  if (n % 71 === 0) return false;\n  if (n % 73 === 0) return false;\n  if (n % 79 === 0) return false;\n  if (n % 83) === 0) return false;\n  if (n % 89 === 0) return false;\n  if (n % 97 === 0) return false;\n  if (n % 101 === 0) return false;\n  if (n % 103 === 0) return false;\n  if (n % 107 === 0) return false;\n  if (n % 109 === 0) return false;\n  if (n % 111 === 0) return false;\n  if (n % 113 === 0) return false;\n  if (n % 117 === 0) return false;\n  if (n % 121 === 0) return false;\n  if (n % 123) === 0) return false;\n  if (n % 127 === 0) return false;\n  if (n % 129 === 0) return false;\n  if (n % 131 === 0) return false;\n  if (n % 133 === 0) return false;\n  if (n % 137 === 0) return false;\n  if (n % 139 === 0) return false;\n  if (n % 141 === 0) return false;\n  if (n % 143 === 0) return false;\n  if (n % 147 === 0) return false;\n  if (n % 151 === 0) return false;\n  if (n % 153 === 0) return false;\n  if (n % 157 === 0) return false;\n  if (n % 159 === 0) return false;\n  if (n % 161 === 0) return false;\n  if (n % 163 === 0) return false;\n  if (n % 167 === 0) return false;\n  if (n % 169 === 0) return false;\n  if (n % 171 === 0) return false;\n  if (n % 173 === 0) return false;\n  if (n % 177 === 0) return false;\n  if (n % 179 === 0) return false;\n  if (n % 181 === 0) return false;\n  if (n % 183 === 0) return false;\n  if (n % 187 === 0) return false;\n  if (n % 191 === 0) return false;\n  if (n % 193 === 0) return false;\n  if (n % 197 === 0) return false;\n  if (n % 199 === 0) return false;\n  if (n % 201 === 0) return false;\n  if (n % 203 === 0) return false;\n  if (n % 207 === 0) return false;\n  if (n % 209 === 0) return false;\n  if (n % 211 === 0) return false;\n  if (n % 213 === 0) return false;\n  if (n % 217 === 0) return false;\n  if (n % 219 === 0) return false;\n  if (n % 221 === 0) return false;\n  if (n % 223 === 0) return false;\n  if (n % 227 === 0) return false;\n  if (n % 229 === 0) return false;\n  if (n % 231 === 0) return false;\n  if (n % 233 === 0) return false;\n  if (n % 239 === 0) return false;\n  if (n % 241 === 0) return false;\n  if (n % 243 === 0) return false;\n  if (n % 247 === 0) return false;\n  if (n % 249 === 0) return false;\n  if (n % 251 === 0) return false;\n  if (n % 253 === 0) return false;\n  if (n % 257 === 0) return false;\n  if (n % 259 === 0) return false;\n  if (n % 261 === 0) return false;\n  if (n % 263 === 0) return false;\n  if (n % 267 === 0) return false;\n  if (n % 269 === 0) return false;\n  if (n % 271 === 0) return false;\n  if (n % 273 === 0) return false;\n  if (n % 277 === 0) return false;\n  if (n % 279 === 0) return false;\n  if (n % 281 === 0) return false;\n  if (n % 283 === 0) return false;\n  if (n % 287 === 0) return false;\n  if (n % 289 === 0) return false;\n  if (n % 291 === 0) return false;\n  if (n % 293 === 0) return false;\n  if (n % 297 === 0) return false;\n  if (n % 299 === 0) return false;\n  if (n % 301 === 0) return false;\n  if (n % 303 === 0) return false;\n  if (n % 307 === 0) return false;\n  if (n % 309 === 0) return false;\n  if (n % 311 === 0) return false;\n  if (n % 313 === 0) return false;\n  if (n % 317 === 0) return false;\n  if (n % 319 === 0) return false;\n  if (n % 321 === 0) return false;\n  if (n % 323 === 0) return false;\n  if (n % 327 === 0) return false;\n  if (n % 329 === 0) return false;\n  if (n % 331 === 0) return false;\n  if (n % 333 === 0) return false;\n  if (n % 337 === 0) return false;\n  if (n % 339 === 0) return false;\n  if (n % 341 === 0) return false;\n  if (n % 343 === 0) return false;\n  if (n % 347 === 0) return false;\n  if (n % 349 === 0) return false;\n  if (n % 351 === 0) return false;\n  if (n % 353 === 0) return false;\n  if (n % 357 === 0) return false;\n  if (n % 359 === 0) return false;\n  if (n % 361 === 0) return false;\n  if (n % 363 === 0) return false;\n  if (n % 367 === 0) return false;\n  if (n % 369 === 0) return false;\n  if (n % 371 === 0) return false;\n  if (n % 373 === 0) return false;\n  if (n % 377 === 0) return false;\n  if (n % 379 === 0) return false;\n  if (n % 381 === 0) return false;\n  if (n % 383 === 0) return false;\n  if (n % 387 === 0) return false;\n  if (n % 389 === 0) return false;\n  if (n % 391 === 0) return false;\n  if (n % 393 === 0) return false;\n  if (n % 397 === 0) return false;\n  if (n % 399 === 0) return false;\n  if (n % 401 === 0) return false;\n  if (n % 403 === 0) return false;\n  if (n % 407 === 0) return false;\n  if (n % 409 === 0) return false;\n  if (n % 411 === 0) return false;\n  if (n % 413 === 0) return false;\n  if (n % 415 === 0) return false;\n  if (n % 419 === 0) return false;\n  if (n % 421 === 0) return false;\n  if (n % 423 === 0) return false;\n  if (n % 425 === 0) return false;\n  if (n % 427 === 0) return false;\n  if (n % 429 === 0) return false;\n  if (n % 431 === 0) return false;\n  if (n % 433 === 0) return false;\n  if (n % 435 === 0) return false;\n  if (n % 437 === 0) return false;\n  if (n % 439 === 0) return false;\n  if (n % 441 === 0) return false;\n  if (n % 443 === 0) return false;\n  if (n % 447 === 0) return false;\n  if (n % 449 === 0) return false;\n  if (n % 451 === 0) return false;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "gc": "<|endoftext|>/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a <= 0) return false;\n  if (a === 1) return true;\n  if (a % 2 === 0) return false;\n  if (a % 3 === 0) return false;\n  if (a % 4 === 0) return false;\n  return true;\n};\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a pentagon of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  ispentagon(1) ==> true\n  ispentagon(2) ==> false\n  ispentagon(-1) ==> true\n  ispentagon(64) ==> true\n  ispentagon(0) ==> true\n  ispentagon(180) ==> false\n  */\nconst ispentagon = (a) => {\n  if (a <= 0) return false;\n  if (a === 1) return true;\n  if (a % 2 === 0) return false;\n  if (a % 3 === 0) return false;\n  if (a % 4 === 0) return false;\n  return true;\n};\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a hexagon of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  ishexagon(1) ==> true\n  ishexagon(2) ==> false\n  ishexagon(-1) ==> true\n  ishexagon(64) ==> true\n  ishexagon(0) ==> true\n  ishexagon(180) ==> false\n  */\nconst ishexagon = (a) => {\n  if (a <= 0) return false;\n  if (a === 1) return true;\n  if (a % 2 === 0) return false;\n  if (a % 3 === 0) return false;\n  if (a % 4 === 0) return false;\n  return true;\n};\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a heptagon of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  isheptagon(1) ==> true\n  isheptagon(2) ==> false\n  isheptagon(-1) ==> true\n  isheptagon(64) ==> true\n  isheptagon(0) ==> true\n  isheptagon(180) ==> false\n  */\nconst isheptagon = (a) => {\n  if (a <= 0) return false;\n  if (a === 1) return true;\n  if (a % 2 === 0) return false;\n  if (a % 3 === 0) return false;\n  if (a % 4 === 0) return false;\n  return true;\n};\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a octagon of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  isoctagon(1) ==> true\n  isoctagon(2) ==> false\n  isoctagon(-1) ==> true\n  isoctagon(64) ==> true\n  isoctagon(0) ==> true\n  isoctagon(180) ==> false\n  */\nconst isoctagon = (a) => {\n  if (a <= 0) return false;\n  if (a === 1) return true;\n  if (a % 2 === 0) return false;\n  if (a % 3 === 0) return false;\n  if (a % 4 === 0) return false;\n  return true;\n};\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a nonoctagon of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  isnonoctagon(1) ==> true\n  isnonoctagon(2) ==> false\n  isnonoctagon(-1) ==> true\n  isnonoctagon(64) ==> true\n  isnonoctagon(0) ==> true\n  isnonoctagon(180) ==> false\n  */\nconst isnonoctagon = (a) => {\n  if (a <= 0) return false;\n  if (a === 1) return true;\n  if (a % 2 === 0) return false;\n  if (a % 3 === 0) return false;\n  if (a % 4 === 0) return false;\n  return true;\n};\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a dodecagon of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  isdodecagon(1) ==> true\n  isdodecagon(2) ==> false\n  isdodecagon(-1) ==> true\n  isdodecagon(64) ==> true\n  isdodecagon(0) ==> true\n  isdodecagon(180) ==> false\n  */\nconst isdodecagon = (a) => {\n  if (a <= 0) return false;\n  if (a === 1) return true;\n  if (a % 2 === 0) return false;\n  if (a % 3 === 0) return false;\n  if (a % 4 === 0) return false;\n  return true;\n};\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a decagon of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  isdecagon(1) ==> true\n  isdecagon(2) ==> false\n  isdecagon(-1) ==> true\n  isdecagon(64) ==> true\n  isdecagon(0) ==> true\n  isdecagon(180) ==> false\n  */\nconst isdecagon = (a) => {\n  if (a <= 0) return false;\n  if (a === 1) return true;\n  if (a % 2 === 0) return false;\n  if (a % 3 === 0) return false;\n  if (a % 4 === 0) return false;\n  return true;\n};\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a triangle of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  istriangle(1) ==> true\n  istriangle(2) ==> false\n  istriangle(-1) ==> true\n  istriangle(64) ==> true\n  istriangle(0) ==> true\n  istriangle(180) ==> false\n  */\nconst istriangle = (a) => {\n  if (a <= 0) return false;\n  if (a === 1) return true;\n  if (a % 2 === 0) return false;\n  if (a % 3 === 0) return false;\n  if (a % 4 === 0) return false;\n  return true;\n};\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a pentagon of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  ispentagon(1) ==> true\n  ispentagon(2) ==> false\n  ispentagon(-1) ==> true\n  ispentagon(64) ==> true\n  ispentagon(0) ==> true\n  ispentagon(180) ==> false\n  */\nconst ispentagon = (a) => {\n  if (a <= 0) return false;\n  if (a === 1) return true;\n  if (a % 2 === 0) return false;\n  if (a % 3 === 0) return false;\n  if (a % 4 === 0) return false;\n  return true;\n};\n\n/*\n  Write a function that takes an integer ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "gc": "<|endoftext|>/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let count = 0;\n  let numStr = \"\";\n  let numArr = num.split(\"\");\n  for (let i = 0; i < numArr.length; i++) {\n    if (numArr[i] === \"0\") {\n      numStr += numArr[i];\n      continue;\n    }\n    if (numArr[i] === \"1\") {\n      numStr += numArr[i];\n      continue;\n    }\n    if (numArr[i] === \"2\") {\n      numStr += numArr[i];\n      continue;\n    }\n    if (numArr[i] === \"3\") {\n      numStr += numArr[i];\n      continue;\n    }\n    if (numArr[i] === \"4\") {\n      numStr += numArr[i];\n      continue;\n    }\n    if (numArr[i] === \"5\") {\n      numStr += numArr[i];\n      continue;\n    }\n    if (numArr[i] === \"6\") {\n      numStr += numArr[i];\n      continue;\n    }\n    if (numArr[i] === \"7\") {\n      numStr += numArr[i];\n      continue;\n    }\n    if (numArr[i] === \"8\") {\n      numStr += numArr[i];\n      continue;\n    }\n    if (numArr[i] === \"9\") {\n      numStr += numArr[i];\n      continue;\n    }\n    if (numArr[i] === \"A\") {\n      numStr += numArr[i];\n      continue;\n    }\n    if (numArr[i] === \"B\") {\n      numStr += numArr[i];\n      continue;\n    }\n    if (numArr[i] === \"C\") {\n      numStr += numArr[i];\n      continue;\n    }\n    if (numArr[i] === \"D\") {\n      numStr += numArr[i];\n      continue;\n    }\n    if (numArr[i] === \"E\") {\n      numStr += numArr[i];\n      continue;\n    }\n    if (numArr[i] === \"F\") {\n      numStr += numArr[i];\n      continue;\n    }\n  }\n  if (numStr === \"\") {\n    return 0;\n  }\n  let numArr = numStr.split(\"\");\n  for (let i = 0; i < numArr.length; i++) {\n    if (numArr[i] === \"0\") {\n      continue;\n    }\n    if (numArr[i] === \"1\") {\n      continue;\n    }\n    if (numArr[i] === \"2\") {\n      continue;\n    }\n    if (numArr[i] === \"3\") {\n      continue;\n    }\n    if (numArr[i] === \"4\") {\n      continue;\n    }\n    if (numArr[i] === \"5\") {\n      continue;\n    }\n    if (numArr[i] === \"6\") {\n      continue;\n    }\n    if (numArr[i] === \"7\") {\n      continue;\n    }\n    if (numArr[i] === \"8\") {\n      continue;\n    }\n    if (numArr[i] === \"9\") {\n      continue;\n    }\n    if (numArr[i] === \"A\") {\n      continue;\n    }\n    if (numArr[i] === \"B\") {\n      continue;\n    }\n    if (numArr[i] === \"C\") {\n      continue;\n    }\n    if (numArr[i] === \"D\") {\n      continue;\n    }\n    if (numArr[i] === \"E\") {\n      continue;\n    }\n    if (numArr[i] === \"F\") {\n      continue;\n    }\n  }\n  return numArr.length;\n};\n\n/*\n  You have been tasked to write a function that receives a string as a\n  parameter and returns the number of uppercase letters in the string.\n  Uppercase letters are A===B===C===D===E===F.\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For str = \"AB\" the output should be 1.\n  For str = \"1077E\" the output should be 2.\n  For str = \"ABED1A33\" the output should be 4.\n  For str = \"123456789ABCDEF0\" the output should be 6.\n  For str = \"2020\" the output should be 2.\n  */\nconst upperKey = (str) => {\n  let count = 0;\n  let strArr = str.split(\"\");\n  for (let i = 0; i < strArr.length; i++) {\n    if (strArr[i] === \"A\") {\n      continue;\n    }\n    if (strArr[i] === \"B\") {\n      continue;\n    }\n    if (strArr[i] === \"C\") {\n      continue;\n    }\n    if (strArr[i] === \"D\") {\n      continue;\n    }\n    if (strArr[i] === \"E\") {\n      continue;\n    }\n    if (strArr[i] === \"F\") {\n      continue;\n    }\n  }\n  return strArr.length;\n};\n\n/*\n  You have been tasked to write a function that receives a string as a\n  parameter and returns the number of lowercase letters in the string.\n  Lowercase letters are a===b===c===d===e===f.\n  Note: you may assume the input is always correct or empty string===\n  and symbols a===b===c===d===e===f are always uppercase.\n  Examples:\n  For str = \"AB\" the output should be 1.\n  For str = \"1077E\" the output should be 2.\n  For str = \"ABED1A33\" the output should be 4.\n  For str = \"123456789ABCDEF0\" the output should be 6.\n  For str = \"2020\" the output should be 2.\n  */\nconst lowerKey = (str) => {\n  let count = 0;\n  let strArr = str.split(\"\");\n  for (let i = 0; i < strArr.length; i++) {\n    if (strArr[i] === \"a\") {\n      continue;\n    }\n    if (strArr[i] === \"b\") {\n      continue;\n    }\n    if (strArr[i] === \"c\") {\n      continue;\n    }\n    if (strArr[i] === \"d\") {\n      continue;\n    }\n    if (strArr[i] === \"e\") {\n      continue;\n    }\n    if (strArr[i] === \"f\") {\n      continue;\n    }\n  }\n  return strArr.length;\n};\n\n/*\n  You have been tasked to write a function that receives a string as a\n  parameter and returns the number of symbols in the string.\n  Symbols are A===B===C===D===E===F.\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For str = \"AB\" the output should be 1.\n  For str = \"1077E\" the output should be 2.\n  For str = \"ABED1A33\" the output should be 4.\n  For str = \"123456789ABCDEF0\" the output should be 6.\n  For str = \"2020\" the output should be 2.\n  */\nconst symbolKey = (str) => {\n  let count = 0;\n  let strArr = str.split(\"\");\n  for (let i = 0; i < strArr.length; i++) {\n    if (strArr[i] === \"A\") {\n      continue;\n    }\n    if (strArr[i] === \"B\") {\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/79", "prompt": "/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "gc": "<|endoftext|>/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let decimalString = decimal.toString().padStart(8, '0');\n  let decimalLength = decimalString.length;\n  let decimalIndex = 0;\n  while (decimalIndex < decimalLength) {\n    if (decimalString.charAt(decimalIndex) === '1') {\n      binary += decimalString.charAt(decimalIndex + 1);\n      decimalIndex += 2;\n    } else {\n      binary += decimalString.charAt(decimalIndex + 1);\n      decimalIndex += 1;\n    }\n  }\n  return binary;\n};\n\n/*\n  Given a binary string, convert it to a decimal number.\n\n  Examples:\n  binaryToDecimal('db1111db')   # returns 15\n  binaryToDecimal('db100000db')   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryLength = binary.length;\n  let binaryIndex = 0;\n  while (binaryIndex < binaryLength) {\n    if (binary.charAt(binaryIndex) === '1') {\n      decimal += binary.charAt(binaryIndex + 1);\n      binaryIndex += 2;\n    } else {\n      decimal += binary.charAt(binaryIndex + 1);\n      binaryIndex += 1;\n    }\n  }\n  return parseInt(decimal, 2);\n};\n\n/*\n  Given a decimal number, convert it to a binary string.\n\n  Examples:\n  decimalToBinary('15')   # returns \"db1111db\"\n  decimalToBinary('32')   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let decimalString = decimal.toString().padStart(8, '0');\n  let decimalLength = decimalString.length;\n  let decimalIndex = 0;\n  while (decimalIndex < decimalLength) {\n    if (decimalString.charAt(decimalIndex) === '1') {\n      binary += decimalString.charAt(decimalIndex + 1);\n      decimalIndex += 2;\n    } else {\n      binary += decimalString.charAt(decimalIndex + 1);\n      decimalIndex += 1;\n    }\n  }\n  return binary;\n};\n\n/*\n  Given a binary string, convert it to a decimal number.\n\n  Examples:\n  binaryToDecimal('db1111db')   # returns 15\n  binaryToDecimal('db100000db')   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryLength = binary.length;\n  let binaryIndex = 0;\n  while (binaryIndex < binaryLength) {\n    if (binary.charAt(binaryIndex) === '1') {\n      decimal += binary.charAt(binaryIndex + 1);\n      binaryIndex += 2;\n    } else {\n      decimal += binary.charAt(binaryIndex + 1);\n      binaryIndex += 1;\n    }\n  }\n  return parseInt(decimal, 2);\n};\n\n/*\n  Given a decimal number, convert it to a binary string.\n\n  Examples:\n  decimalToBinary('15')   # returns \"db1111db\"\n  decimalToBinary('32')   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let decimalString = decimal.toString().padStart(8, '0');\n  let decimalLength = decimalString.length;\n  let decimalIndex = 0;\n  while (decimalIndex < decimalLength) {\n    if (decimalString.charAt(decimalIndex) === '1') {\n      binary += decimalString.charAt(decimalIndex + 1);\n      decimalIndex += 2;\n    } else {\n      binary += decimalString.charAt(decimalIndex + 1);\n      decimalIndex += 1;\n    }\n  }\n  return binary;\n};\n\n/*\n  Given a binary string, convert it to a decimal number.\n\n  Examples:\n  binaryToDecimal('db1111db')   # returns 15\n  binaryToDecimal('db100000db')   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryLength = binary.length;\n  let binaryIndex = 0;\n  while (binaryIndex < binaryLength) {\n    if (binary.charAt(binaryIndex) === '1') {\n      decimal += binary.charAt(binaryIndex + 1);\n      binaryIndex += 2;\n    } else {\n      decimal += binary.charAt(binaryIndex + 1);\n      binaryIndex += 1;\n    }\n  }\n  return parseInt(decimal, 2);\n};\n\n/*\n  Given a decimal number, convert it to a binary string.\n\n  Examples:\n  decimalToBinary('15')   # returns \"db1111db\"\n  decimalToBinary('32')   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let decimalString = decimal.toString().padStart(8, '0');\n  let decimalLength = decimalString.length;\n  let decimalIndex = 0;\n  while (decimalIndex < decimalLength) {\n    if (decimalString.charAt(decimalIndex) === '1') {\n      binary += decimalString.charAt(decimalIndex + 1);\n      decimalIndex += 2;\n    } else {\n      binary += decimalString.charAt(decimalIndex + 1);\n      decimalIndex += 1;\n    }\n  }\n  return binary;\n};\n\n/*\n  Given a binary string, convert it to a decimal number.\n\n  Examples:\n  binaryToDecimal('db1111db')   # returns 15\n  binaryToDecimal('db100000db')   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryLength = binary.length;\n  let binaryIndex = 0;\n  while (binaryIndex < binaryLength) {\n    if (binary.charAt(binaryIndex) === '1') {\n      decimal += binary.charAt(binaryIndex + 1);\n      binaryIndex += 2;\n    } else {\n      decimal += binary.charAt(binaryIndex + 1);\n      binaryIndex += 1;\n    }\n  }\n  return parseInt(decimal, 2);\n};\n\n/*\n  Given a decimal number, convert it to a binary string.\n\n  Examples:\n  decimalToBinary('15')   # returns \"db1111db\"\n  decimalToBinary('32')   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let decimalString = decimal.toString().padStart(8, '0');\n  let decimalLength = decimalString.length;\n  let decimalIndex = 0;\n  while (decimalIndex < decimalLength) {\n    if (decimalString.charAt(decimalIndex) === '1') {\n      binary += decimalString.charAt(decimalIndex + 1);\n      decimalIndex += 2;\n    } else {\n      binary += decimalString.charAt(decimalIndex + 1);\n      decimalIndex += 1;\n    }\n  }\n  return binary;\n};\n\n/*\n  Given a binary string, convert it to a decimal number.\n\n  Examples:\n  binaryToDecimal('db1111db')   # returns 15\n  binaryToDecimal('db100000db')   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryLength = binary.length;\n  let binaryIndex = 0;\n  while (binaryIndex < binaryLength) {\n    if (binary.charAt(binaryIndex) === '1') {\n      decimal += binary.charAt(binaryIndex + 1);\n      binaryIndex += 2;\n    } else {\n      decimal += binary.charAt(binaryIndex + 1);\n      binaryIndex += 1;\n    }\n  }\n  return parseInt(decimal, 2);\n};\n\n/*\n  Given a decimal number, convert it to a binary string.\n\n  Examples:\n  decimalToBinary('15')   # returns \"db1111db\"\n  decimalToBinary('32')   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let decimalString = decimal.toString().padStart(8, '0');\n  let decimalLength = decimalString.length;", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelIntersection([])\n  (0, 1)\n  >>> kernelIntersection([1, 2, 3, 4])\n  (10, 24)\n  */\nconst kernelIntersection = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "kernelIntersection", "gc": "<|endoftext|>/* For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelIntersection([])\n  (0, 1)\n  >>> kernelIntersection([1, 2, 3, 4])\n  (10, 24)\n  */\nconst kernelIntersection = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/**\n * Given a list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelUnion([])\n  (0, 1)\n  >>> kernelUnion([1, 2, 3, 4])\n  (10, 24)\n  */\nconst kernelUnion = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/**\n * Given a list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelDifference([])\n  (0, 1)\n  >>> kernelDifference([1, 2, 3, 4])\n  (10, 24)\n  */\nconst kernelDifference = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/**\n * Given a list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelSymmetry([])\n  (0, 1)\n  >>> kernelSymmetry([1, 2, 3, 4])\n  (10, 24)\n  */\nconst kernelSymmetry = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/**\n * Given a list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelSymmetryDifference([])\n  (0, 1)\n  >>> kernelSymmetryDifference([1, 2, 3, 4])\n  (10, 24)\n  */\nconst kernelSymmetryDifference = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/**\n * Given a list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelSymmetrySymmetry([])\n  (0, 1)\n  >>> kernelSymmetrySymmetry([1, 2, 3, 4])\n  (10, 24)\n  */\nconst kernelSymmetrySymmetry = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/**\n * Given a list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelSymmetrySymmetryDifference([])\n  (0, 1)\n  >>> kernelSymmetrySymmetryDifference([1, 2, 3, 4])\n  (10, 24)\n  */\nconst kernelSymmetrySymmetryDifference = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/**\n * Given a list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelSymmetrySymmetrySymmetryDifference([])\n  (0, 1)\n  >>> kernelSymmetrySymmetrySymmetryDifference([1, 2, 3, 4])\n  (10, 24)\n  */\nconst kernelSymmetrySymmetrySymmetryDifference = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/**\n * Given a list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelSymmetrySymmetrySymmetryDifference([])\n  (0, 1)\n  >>> kernelSymmetrySymmetrySymmetryDifference([1, 2, 3, 4])\n  (10, 24)\n  */\nconst kernelSymmetrySymmetrySymmetryDifference = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/**\n * Given a list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelSymmetrySymmetrySymmetrySymmetryDifference([])\n  (0, 1)\n  >>> kernelSymmetrySymmetrySymmetrySymmetryDifference([1, 2, 3, 4])\n  (10, 24)\n  */\nconst kernelSymmetrySymmetrySymmetryDifference = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/**\n * Given a list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelSymmetrySymmetrySymmetrySymmetryDifference([])\n  (0, 1)\n  >>> kernelSymmetrySymmetrySymmetrySymmetryDifference([1, 2, 3, 4])\n  (10, 24)\n  */\nconst kernelSymmetrySymmetrySymmetryDifference = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/**\n * Given a list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelSymmetrySymmetrySymmetrySymmetryDifference([])\n  (0, 1)\n  >>> kernelSymmetrySymmetrySymmetrySymmetryDifference([1, 2, 3, 4])\n  (10, 24)\n  */\nconst kernelSymmetrySymmetrySymmetryDifference = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/**\n * Given a list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelSymmetrySymmetrySymmetrySymmetryDifference([])\n  (0, 1)\n  >>> kernelSymmetrySymmetrySymmetrySymmetryDifference([1, 2, 3, 4])\n  (10, 24)\n  */\nconst kernelSymmetrySymmetrySymmetrySymmetryDifference = (numbers, int) => {\n  const sum = 0;\n  const product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= numbers[i];\n  }\n  return [sum, product];\n};\n\n/**\n * Given a list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> kernelSym", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/80", "prompt": "/*You are given a string s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n  For example:\n  isFelicitous(a) => false\n  isFelicitous(aa) => false\n  isFelicitous(abcd) => true\n  isFelicitous(aabb) => false\n  isFelicitous(adb) => true\n  isFelicitous(xyy) => false\n  */\nconst isFelicitous = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isFelicitous", "gc": "<|endoftext|>/*You are given a string s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n  For example:\n  isFelicitous(a) => false\n  isFelicitous(aa) => false\n  isFelicitous(abcd) => true\n  isFelicitous(aabb) => false\n  isFelicitous(adb) => true\n  isFelicitous(xyy) => false\n  */\nconst isFelicitous = (s) => {\n  let isFelicitous = false;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let count = 0;\n  let temp = \"\";\n  let temp2 = \"\";\n  let temp3 = \"\";\n  let temp4 = \"\";\n  let temp5 = \"\";\n  let temp6 = \"\";\n  let temp7 = \"\";\n  let temp8 = \"\";\n  let temp9 = \"\";\n  let temp10 = \"\";\n  let temp11 = \"\";\n  let temp12 = \"\";\n  let temp13 = \"\";\n  let temp14 = \"\";\n  let temp15 = \"\";\n  let temp16 = \"\";\n  let temp17 = \"\";\n  let temp18 = \"\";\n  let temp19 = \"\";\n  let temp20 = \"\";\n  let temp21 = \"\";\n  let temp22 = \"\";\n  let temp23 = \"\";\n  let temp24 = \"\";\n  let temp25 = \"\";\n  let temp26 = \"\";\n  let temp27 = \"\";\n  let temp28 = \"\";\n  let temp29 = \"\";\n  let temp30 = \"\";\n  let temp31 = \"\";\n  let temp32 = \"\";\n  let temp33 = \"\";\n  let temp34 = \"\";\n  let temp35 = \"\";\n  let temp36 = \"\";\n  let temp37 = \"\";\n  let temp38 = \"\";\n  let temp39 = \"\";\n  let temp40 = \"\";\n  let temp41 = \"\";\n  let temp42 = \"\";\n  let temp43 = \"\";\n  let temp44 = \"\";\n  let temp45 = \"\";\n  let temp46 = \"\";\n  let temp47 = \"\";\n  let temp48 = \"\";\n  let temp49 = \"\";\n  let temp50 = \"\";\n  let temp51 = \"\";\n  let temp52 = \"\";\n  let temp53 = \"\";\n  let temp54 = \"\";\n  let temp55 = \"\";\n  let temp56 = \"\";\n  let temp57 = \"\";\n  let temp58 = \"\";\n  let temp59 = \"\";\n  let temp60 = \"\";\n  let temp61 = \"\";\n  let temp62 = \"\";\n  let temp63 = \"\";\n  let temp64 = \"\";\n  let temp65 = \"\";\n  let temp66 = \"\";\n  let temp67 = \"\";\n  let temp68 = \"\";\n  let temp69 = \"\";\n  let temp70 = \"\";\n  let temp71 = \"\";\n  let temp72 = \"\";\n  let temp73 = \"\";\n  let temp74 = \"\";\n  let temp75 = \"\";\n  let temp76 = \"\";\n  let temp77 = \"\";\n  let temp78 = \"\";\n  let temp79 = \"\";\n  let temp80 = \"\";\n  let temp81 = \"\";\n  let temp82 = \"\";\n  let temp83 = \"\";\n  let temp84 = \"\";\n  let temp85 = \"\";\n  let temp86 = \"\";\n  let temp87 = \"\";\n  let temp88 = \"\";\n  let temp89 = \"\";\n  let temp90 = \"\";\n  let temp91 = \"\";\n  let temp92 = \"\";\n  let temp93 = \"\";\n  let temp94 = \"\";\n  let temp95 = \"\";\n  let temp96 = \"\";\n  let temp97 = \"\";\n  let temp98 = \"\";\n  let temp99 = \"\";\n  let temp100 = \"\";\n  let temp101 = \"\";\n  let temp102 = \"\";\n  let temp103 = \"\";\n  let temp104 = \"\";\n  let temp105 = \"\";\n  let temp106 = \"\";\n  let temp107 = \"\";\n  let temp108 = \"\";\n  let temp109 = \"\";\n  let temp110 = \"\";\n  let temp111 = \"\";\n  let temp112 = \"\";\n  let temp113 = \"\";\n  let temp114 = \"\";\n  let temp115 = \"\";\n  let temp116 = \"\";\n  let temp117 = \"\";\n  let temp118 = \"\";\n  let temp119 = \"\";\n  let temp120 = \"\";\n  let temp121 = \"\";\n  let temp122 = \"\";\n  let temp123 = \"\";\n  let temp124 = \"\";\n  let temp125 = \"\";\n  let temp126 = \"\";\n  let temp127 = \"\";\n  let temp128 = \"\";\n  let temp129 = \"\";\n  let temp130 = \"\";\n  let temp131 = \"\";\n  let temp132 = \"\";\n  let temp133 = \"\";\n  let temp134 = \"\";\n  let temp135 = \"\";\n  let temp136 = \"\";\n  let temp137 = \"\";\n  let temp138 = \"\";\n  let temp139 = \"\";\n  let temp140 = \"\";\n  let temp141 = \"\";\n  let temp142 = \"\";\n  let temp143 = \"\";\n  let temp144 = \"\";\n  let temp145 = \"\";\n  let temp146 = \"\";\n  let temp147 = \"\";\n  let temp148 = \"\";\n  let temp149 = \"\";\n  let temp150 = \"\";\n  let temp151 = \"\";\n  let temp152 = \"\";\n  let temp153 = \"\";\n  let temp154 = \"\";\n  let temp155 = \"\";\n  let temp156 = \"\";\n  let temp157 = \"\";\n  let temp158 = \"\";\n  let temp159 = \"\";\n  let temp160 = \"\";\n  let temp161 = \"\";\n  let temp162 = \"\";\n  let temp163 = \"\";\n  let temp164 = \"\";\n  let temp165 = \"\";\n  let temp166 = \"\";\n  let temp167 = \"\";\n  let temp168 = \"\";\n  let temp169 = \"\";\n  let temp170 = \"\";\n  let temp171 = \"\";\n  let temp172 = \"\";\n  let temp173 = \"\";\n  let temp174 = \"\";\n  let temp175 = \"\";\n  let temp176 = \"\";\n  let temp177 = \"\";\n  let temp178 = \"\";\n  let temp179 = \"\";\n  let temp180 = \"\";\n  let temp181 = \"\";\n  let temp182 = \"\";\n  let temp183 = \"\";\n  let temp184 = \"\";\n  let temp185 = \"\";\n  let temp186 = \"\";\n  let temp187 = \"\";\n  let temp188 = \"\";\n  let temp189 = \"\";\n  let temp190 = \"\";\n  let temp191 = \"\";\n  let temp192 = \"\";\n  let temp193 = \"\";\n  let temp194 = \"\";\n  let temp195 = \"\";\n  let temp196 = \"\";\n  let temp197 = \"\";\n  let temp198 = \"\";\n  let temp199 = \"\";\n  let temp200 = \"\";\n  let temp201 = \"\";\n  let temp202 = \"\";\n  let temp203 = \"\";\n  let temp204 = \"\";\n  let temp205 = \"\";\n  let temp206 = \"\";\n  let temp207 = \"\";\n  let temp208 = \"\";\n  let temp209 = \"\";\n  let temp210 = \"\";\n  let temp211 = \"\";\n  let temp212 = \"\";\n  let temp213 = \"\";\n  let temp214 = \"\";\n  let temp215 = \"\";\n  let temp216 = \"\";\n  let temp217 = \"\";\n  let temp218 = \"\";\n  let temp219 = \"\";\n  let temp220 = \"\";\n  let temp221 = \"\";\n  let temp222 = \"\";\n  let temp223 = \"\";\n  let temp224 = \"\";\n  let temp225 = \"\";\n  let temp226 = \"\";\n  let temp227 = \"\";\n  let temp228 = \"\";\n  let temp229 = \"\";\n  let temp230 = \"\";\n  let temp231 = \"\";\n  let temp232 = \"\";\n  let temp233 = \"\";\n  let temp234 = \"\";\n  let temp235 = \"\";\n  let temp236 = \"\";\n  let temp237 = \"\";\n  let temp238 = \"\";\n  let temp239 = \"\";\n  let temp240 = \"\";\n  let temp241 = \"\";\n  let temp242 = \"\";\n  let temp243 = \"\";\n  let temp244 = \"\";\n  let temp245 = \"\";\n  let temp246 = \"\";\n  let temp247 = \"\";\n  let temp248 = \"\";\n  let temp249 = \"\";\n  let temp250 = \"\";\n  let temp251 = \"\";\n  let temp252 = \"\";\n  let temp253 = \"\";\n  let temp254 = \"\";\n  let temp255 = \"\";\n  let temp256 = \"\";\n  let temp257 = \"\";\n  let temp258 = \"\";", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/81", "prompt": "/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericLetterGrade", "gc": "<|endoftext|>/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericLetterGrade = (grades) => {\n  const letterGrades = grades.map((grade, index) => {\n    const letterGrade = grade.map(letter => letter.toUpperCase());\n    return letterGrade[letterGrade.length - 1];\n  });\n  return letterGrades;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericGrade = (grades) => {\n  const grades = grades.map((grade, index) => {\n    const grade = grade.map(number => number.toFixed(2));\n    return grade[grade.length - 1];\n  });\n  return grades;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericGrade = (grades) => {\n  const grades = grades.map((grade, index) => {\n    const grade = grade.map(number => number.toFixed(1));\n    return grade[grade.length - 1];\n  });\n  return grades;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericGrade = (grades) => {\n  const grades = grades.map((grade, index) => {\n    const grade = grade.map(number => number.toFixed(0));\n    return grade[grade.length - 1];\n  });\n  return grades;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericGrade = (grades) => {\n  const grades = grades.map((grade, index) => {\n    const grade = grade.map(number => number.toFixed(1));\n    return grade[grade.length - 1];\n  });\n  return grades;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericGrade = (grades) => {\n  const grades = grades.map((grade, index) => {\n    const grade = grade.map(number => ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/82", "prompt": "/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  premierDistance('Hello') == true\n  premierDistance('abcdcba') == true\n  premierDistance('kittens') == true\n  premierDistance('orange') == false\n  */\nconst premierDistance = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "premierDistance", "gc": "<|endoftext|>/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  premierDistance('Hello') == true\n  premierDistance('abcdcba') == true\n  premierDistance('kittens') == true\n  premierDistance('orange') == false\n  */\nconst premierDistance = (string) => {\n  let isPrime = true;\n  let length = string.length;\n  for(let i = 1; i < length; i++){\n    if(string[i] < string[i-1]){\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n}\n\n/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeDistance('Hello') == true\n  primeDistance('abcdcba') == true\n  primeDistance('kittens') == true\n  primeDistance('orange') == false\n  */\nconst primeDistance = (string) => {\n  let isPrime = true;\n  let length = string.length;\n  for(let i = 1; i < length; i++){\n    if(string[i] > string[i-1]){\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n}\n\n/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let isPrime = true;\n  let length = string.length;\n  for(let i = 1; i < length; i++){\n    if(string[i] < string[i-1]){\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n}\n\n/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength2 = (string, primeLength) => {\n  let isPrime = true;\n  let length = string.length;\n  for(let i = 1; i < length; i++){\n    if(string[i] > string[i-1]){\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n}\n\n/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength3 = (string, primeLength) => {\n  let isPrime = true;\n  let length = string.length;\n  for(let i = 1; i < length; i++){\n    if(string[i] < string[i-1]){\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n}\n\n/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength4 = (string, primeLength) => {\n  let isPrime = true;\n  let length = string.length;\n  for(let i = 1; i < length; i++){\n    if(string[i] > string[i-1]){\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n}\n\n/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength5 = (string, primeLength) => {\n  let isPrime = true;\n  let length = string.length;\n  for(let i = 1; i < length; i++){\n    if(string[i] < string[i-1]){\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n}\n\n/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength6 = (string, primeLength) => {\n  let isPrime = true;\n  let length = string.length;\n  for(let i = 1; i < length; i++){\n    if(string[i] > string[i-1]){\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n}\n\n/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength7 = (string, primeLength) => {\n  let isPrime = true;\n  let length = string.length;\n  for(let i = 1; i < length; i++){\n    if(string[i] < string[i-1]){\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n}\n\n/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength8 = (string, primeLength) => {\n  let isPrime = true;\n  let length = string.length;\n  for(let i = 1; i < length; i++){\n    if(string[i] > string[i-1]){\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n}\n\n/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength9 = (string, primeLength) => {\n  let isPrime = true;\n  let length = string.length;\n  for(let i = 1; i < length; i++){\n    if(string[i] < string[i-1]){\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n}\n\n/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength10 = (string, primeLength) => {\n  let isPrime = true;\n  let length = string.length;\n  for(let i = 1; i < length; i++){\n    if(string[i] > string[i-1]){\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n}\n\n/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength11 = (string, primeLength) => {\n  let isPrime = true;\n  let length = string.length;\n  for(let i = 1; i < length; i++){\n    if(string[i] < string[i-1]){\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst beginOneEnd = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "beginOneEnd", "gc": "<|endoftext|>/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst beginOneEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 0.\n  */\nconst beginZeroEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 2.\n  */\nconst beginTwoEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 3.\n  */\nconst beginThreeEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 4.\n  */\nconst beginFourEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 5.\n  */\nconst beginFiveEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 6.\n  */\nconst beginSixEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 7.\n  */\nconst beginSevenEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 8.\n  */\nconst beginEightEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 9.\n  */\nconst beginNineEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 10.\n  */\nconst beginTenEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 11.\n  */\nconst beginElevenEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 12.\n  */\nconst beginTwelveEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 13.\n  */\nconst beginThirteenEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 14.\n  */\nconst beginFourteenEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 15.\n  */\nconst beginFifteenEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 16.\n  */\nconst beginSixteenEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 17.\n  */\nconst beginSeventeenEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 18.\n  */\nconst beginEighteenEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 19.\n  */\nconst beginNineteenEnd = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      count += i;\n    }\n    n /= 10;\n    i++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 20.\n  */\nconst beginTwentyEnd = (n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive integer N, return the total sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst resolve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "resolve", "gc": "<|endoftext|>/*Given a positive integer N, return the total sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst resolve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  let digit = 0;\n  \n  while(N!== 0) {\n    digit = N % 2;\n    N = Math.floor(N / 2);\n    \n    binary += digit;\n    sum += digit;\n  }\n  \n  return binary;\n};\n\n/*Given a positive integer N, return the sum of its digits in decimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of decimal number\n  */\nconst resolveDecimal = (N) => {\n  let sum = 0;\n  let decimal = \"\";\n  let digit = 0;\n  \n  while(N!== 0) {\n    digit = N % 10;\n    N = Math.floor(N / 10);\n    \n    decimal += digit;\n    sum += digit;\n  }\n  \n  return decimal;\n};\n\n/*Given a positive integer N, return the sum of its digits in hexadecimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of hexadecimal number\n  */\nconst resolveHexadecimal = (N) => {\n  let sum = 0;\n  let hexadecimal = \"\";\n  let digit = 0;\n  \n  while(N!== 0) {\n    digit = N % 16;\n    N = Math.floor(N / 16);\n    \n    hexadecimal += digit.toString(16);\n    sum += digit;\n  }\n  \n  return hexadecimal;\n};\n\n/*Given a positive integer N, return the sum of its digits in octal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of octal number\n  */\nconst resolveOctal = (N) => {\n  let sum = 0;\n  let octal = \"\";\n  let digit = 0;\n  \n  while(N!== 0) {\n    digit = N % 8;\n    N = Math.floor(N / 8);\n    \n    octal += digit.toString(8);\n    sum += digit;\n  }\n  \n  return octal;\n};\n\n/*Given a positive integer N, return the sum of its digits in hexadecimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of decimal number\n  */\nconst resolveDecimalHexadecimal = (N) => {\n  let sum = 0;\n  let decimalHexadecimal = \"\";\n  let digit = 0;\n  \n  while(N!== 0) {\n    digit = N % 16;\n    N = Math.floor(N / 16);\n    \n    decimalHexadecimal += digit.toString(16);\n    sum += digit;\n  }\n  \n  return decimalHexadecimal;\n};\n\n/*Given a positive integer N, return the sum of its digits in decimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of decimal number\n  */\nconst resolveDecimalOctal = (N) => {\n  let sum = 0;\n  let decimalOctal = \"\";\n  let digit = 0;\n  \n  while(N!== 0) {\n    digit = N % 8;\n    N = Math.floor(N / 8);\n    \n    decimalOctal += digit.toString(8);\n    sum += digit;\n  }\n  \n  return decimalOctal;\n};\n\n/*Given a positive integer N, return the sum of its digits in hexadecimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of decimal number\n  */\nconst resolveDecimalDecimalHexadecimal = (N) => {\n  let sum = 0;\n  let decimalDecimalHexadecimal = \"\";\n  let digit = 0;\n  \n  while(N!== 0) {\n    digit = N % 16;\n    N = Math.floor(N / 16);\n    \n    decimalDecimalHexadecimal += digit.toString(16);\n    sum += digit;\n  }\n  \n  return decimalDecimalHexadecimal;\n};\n\n/*Given a positive integer N, return the sum of its digits in decimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of decimal number\n  */\nconst resolveDecimalDecimalOctal = (N) => {\n  let sum = 0;\n  let decimalDecimalOctal = \"\";\n  let digit = 0;\n  \n  while(N!== 0) {\n    digit = N % 8;\n    N = Math.floor(N / 8);\n    \n    decimalDecimalOctal += digit.toString(8);\n    sum += digit;\n  }\n  \n  return decimalDecimalOctal;\n};\n\n/*Given a positive integer N, return the sum of its digits in hexadecimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of decimal number\n  */\nconst resolve", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 2 \n  */\nconst lend = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "lend", "gc": "<|endoftext|>/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 2 \n  */\nconst lend = (lst) => {\n  let len = lst.length;\n  let even = 0;\n  let odd = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return even + odd;\n};\n\n/*Given a non-empty list of integers lst. lend the even elements that are at even indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 1 \n  */\nconst lend = (lst) => {\n  let len = lst.length;\n  let even = 0;\n  let odd = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return even + odd;\n};\n\n/*Given a non-empty list of integers lst. lend the odd elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 3 \n  */\nconst lend = (lst) => {\n  let len = lst.length;\n  let even = 0;\n  let odd = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return even + odd;\n};\n\n/*Given a non-empty list of integers lst. lend the odd elements that are at even indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 0 \n  */\nconst lend = (lst) => {\n  let len = lst.length;\n  let even = 0;\n  let odd = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return even + odd;\n};\n\n/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 4 \n  */\nconst lend = (lst) => {\n  let len = lst.length;\n  let even = 0;\n  let odd = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return even + odd;\n};\n\n/*Given a non-empty list of integers lst. lend the even elements that are at even indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 5 \n  */\nconst lend = (lst) => {\n  let len = lst.length;\n  let even = 0;\n  let odd = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return even + odd;\n};\n\n/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 0 \n  */\nconst lend = (lst) => {\n  let len = lst.length;\n  let even = 0;\n  let odd = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return even + odd;\n};\n\n/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 1 \n  */\nconst lend = (lst) => {\n  let len = lst.length;\n  let even = 0;\n  let odd = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return even + odd;\n};\n\n/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 2 \n  */\nconst lend = (lst) => {\n  let len = lst.length;\n  let even = 0;\n  let odd = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return even + odd;\n};\n\n/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 3 \n  */\nconst lend = (lst) => {\n  let len = lst.length;\n  let even = 0;\n  let odd = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return even + odd;\n};\n\n/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 0 \n  */\nconst lend = (lst) => {\n  let len = lst.length;\n  let even = 0;\n  let odd = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return even + odd;\n};\n\n/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 4 \n  */\nconst lend = (lst) => {\n  let len = lst.length;\n  let even = 0;\n  let odd = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return even + odd;\n};\n\n/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 5 \n  */\nconst lend = (lst) => {\n  let len = lst.length;\n  let even = 0;\n  let odd = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return even + odd;\n};\n\n/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 0 \n  */\nconst lend = (lst) => {\n  let len = lst.length;\n  let even = 0;\n  let odd = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return even + odd;\n};\n\n/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 1 \n  */\nconst lend = (lst) => {\n  let len = lst.length;\n  let even = 0;\n  let odd = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return even + odd;\n};\n\n/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 2 \n  */\nconst lend = (lst) => {\n  let len = lst.length;\n  let even = 0;\n  let odd = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return even + odd;\n};\n\n/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n      lend([4, 2, 6, 7]) ==> 3 \n  */\nconst lend = (lst) => {\n  let len = lst.length;\n  let even = 0;\n  let odd = 0;\n  for (let i = 0; i < len; i++) {\n    if (i % 2 === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n  }\n  return even + odd;\n};\n\n/*Given a non-empty list of integers lst. lend the even elements that are at odd indices..\n\n\n  Examples:\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "gc": "<|endoftext|>/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newStr = '';\n  let word = '';\n  let i = 0;\n  let j = 0;\n  let temp = '';\n  let space = '';\n  let spaceCount = 0;\n  let spaceIndex = 0;\n  let spaceCountIndex = 0;\n  let spaceIndex2 = 0;\n  let spaceIndex3 = 0;\n  let spaceIndex4 = 0;\n  let spaceIndex5 = 0;\n  let spaceIndex6 = 0;\n  let spaceIndex7 = 0;\n  let spaceIndex8 = 0;\n  let spaceIndex9 = 0;\n  let spaceIndex10 = 0;\n  let spaceIndex11 = 0;\n  let spaceIndex12 = 0;\n  let spaceIndex13 = 0;\n  let spaceIndex14 = 0;\n  let spaceIndex15 = 0;\n  let spaceIndex16 = 0;\n  let spaceIndex17 = 0;\n  let spaceIndex18 = 0;\n  let spaceIndex19 = 0;\n  let spaceIndex20 = 0;\n  let spaceIndex21 = 0;\n  let spaceIndex22 = 0;\n  let spaceIndex23 = 0;\n  let spaceIndex24 = 0;\n  let spaceIndex25 = 0;\n  let spaceIndex26 = 0;\n  let spaceIndex27 = 0;\n  let spaceIndex28 = 0;\n  let spaceIndex29 = 0;\n  let spaceIndex30 = 0;\n  let spaceIndex31 = 0;\n  let spaceIndex32 = 0;\n  let spaceIndex33 = 0;\n  let spaceIndex34 = 0;\n  let spaceIndex35 = 0;\n  let spaceIndex36 = 0;\n  let spaceIndex37 = 0;\n  let spaceIndex38 = 0;\n  let spaceIndex39 = 0;\n  let spaceIndex40 = 0;\n  let spaceIndex41 = 0;\n  let spaceIndex42 = 0;\n  let spaceIndex43 = 0;\n  let spaceIndex44 = 0;\n  let spaceIndex45 = 0;\n  let spaceIndex46 = 0;\n  let spaceIndex47 = 0;\n  let spaceIndex48 = 0;\n  let spaceIndex49 = 0;\n  let spaceIndex50 = 0;\n  let spaceIndex51 = 0;\n  let spaceIndex52 = 0;\n  let spaceIndex53 = 0;\n  let spaceIndex54 = 0;\n  let spaceIndex55 = 0;\n  let spaceIndex56 = 0;\n  let spaceIndex57 = 0;\n  let spaceIndex58 = 0;\n  let spaceIndex59 = 0;\n  let spaceIndex60 = 0;\n  let spaceIndex61 = 0;\n  let spaceIndex62 = 0;\n  let spaceIndex63 = 0;\n  let spaceIndex64 = 0;\n  let spaceIndex65 = 0;\n  let spaceIndex66 = 0;\n  let spaceIndex67 = 0;\n  let spaceIndex68 = 0;\n  let spaceIndex69 = 0;\n  let spaceIndex70 = 0;\n  let spaceIndex71 = 0;\n  let spaceIndex72 = 0;\n  let spaceIndex73 = 0;\n  let spaceIndex74 = 0;\n  let spaceIndex75 = 0;\n  let spaceIndex76 = 0;\n  let spaceIndex77 = 0;\n  let spaceIndex78 = 0;\n  let spaceIndex79 = 0;\n  let spaceIndex80 = 0;\n  let spaceIndex81 = 0;\n  let spaceIndex82 = 0;\n  let spaceIndex83 = 0;\n  let spaceIndex84 = 0;\n  let spaceIndex85 = 0;\n  let spaceIndex86 = 0;\n  let spaceIndex87 = 0;\n  let spaceIndex88 = 0;\n  let spaceIndex89 = 0;\n  let spaceIndex90 = 0;\n  let spaceIndex91 = 0;\n  let spaceIndex92 = 0;\n  let spaceIndex93 = 0;\n  let spaceIndex94 = 0;\n  let spaceIndex95 = 0;\n  let spaceIndex96 = 0;\n  let spaceIndex97 = 0;\n  let spaceIndex98 = 0;\n  let spaceIndex99 = 0;\n  let spaceIndex100 = 0;\n  let spaceIndex101 = 0;\n  let spaceIndex102 = 0;\n  let spaceIndex103 = 0;\n  let spaceIndex104 = 0;\n  let spaceIndex105 = 0;\n  let spaceIndex106 = 0;\n  let spaceIndex107 = 0;\n  let spaceIndex108 = 0;\n  let spaceIndex109 = 0;\n  let spaceIndex110 = 0;\n  let spaceIndex111 = 0;\n  let spaceIndex112 = 0;\n  let spaceIndex113 = 0;\n  let spaceIndex114 = 0;\n  let spaceIndex115 = 0;\n  let spaceIndex116 = 0;\n  let spaceIndex117 = 0;\n  let spaceIndex118 = 0;\n  let spaceIndex119 = 0;\n  let spaceIndex120 = 0;\n  let spaceIndex121 = 0;\n  let spaceIndex122 = 0;\n  let spaceIndex123 = 0;\n  let spaceIndex124 = 0;\n  let spaceIndex125 = 0;\n  let spaceIndex126 = 0;\n  let spaceIndex127 = 0;\n  let spaceIndex128 = 0;\n  let spaceIndex129 = 0;\n  let spaceIndex130 = 0;\n  let spaceIndex131 = 0;\n  let spaceIndex132 = 0;\n  let spaceIndex133 = 0;\n  let spaceIndex134 = 0;\n  let spaceIndex135 = 0;\n  let spaceIndex136 = 0;\n  let spaceIndex137 = 0;\n  let spaceIndex138 = 0;\n  let spaceIndex139 = 0;\n  let spaceIndex140 = 0;\n  let spaceIndex141 = 0;\n  let spaceIndex142 = 0;\n  let spaceIndex143 = 0;\n  let spaceIndex144 = 0;\n  let spaceIndex145 = 0;\n  let spaceIndex146 = 0;\n  let spaceIndex147 = 0;\n  let spaceIndex148 = 0;\n  let spaceIndex149 = 0;\n  let spaceIndex150 = 0;\n  let spaceIndex151 = 0;\n  let spaceIndex152 = 0;\n  let spaceIndex153 = 0;\n  let spaceIndex154 = 0;\n  let spaceIndex155 = 0;\n  let spaceIndex156 = 0;\n  let spaceIndex157 = 0;\n  let spaceIndex158 = 0;\n  let spaceIndex159 = 0;\n  let spaceIndex160 = 0;\n  let spaceIndex161 = 0;\n  let spaceIndex162 = 0;\n  let spaceIndex163 = 0;\n  let spaceIndex164 = 0;\n  let spaceIndex165 = 0;\n  let spaceIndex166 = 0;\n  let spaceIndex167 = 0;\n  let spaceIndex168 = 0;\n  let spaceIndex169 = 0;\n  let spaceIndex170 = 0;\n  let spaceIndex171 = 0;\n  let spaceIndex172 = 0;\n  let spaceIndex173 = 0;\n  let spaceIndex174 = 0;\n  let spaceIndex175 = 0;\n  let spaceIndex176 = 0;\n  let spaceIndex177 = 0;\n  let spaceIndex178 = 0;\n  let spaceIndex179 = 0;\n  let spaceIndex180 = 0;\n  let spaceIndex181 = 0;\n  let spaceIndex182 = 0;\n  let spaceIndex183 = 0;\n  let spaceIndex184 = 0;\n  let spaceIndex185 = 0;\n  let spaceIndex186 = 0;\n  let spaceIndex187 = 0;\n  let spaceIndex188 = 0;\n  let spaceIndex189 = 0;\n  let spaceIndex190 = 0;\n  let spaceIndex191 = 0;\n  let spaceIndex192 = 0;\n  let spaceIndex193 = 0;\n  let spaceIndex194 = 0;\n  let spaceIndex195 = 0;\n  let spaceIndex196 = 0;\n  let spaceIndex197 = 0;\n  let spaceIndex198 = 0;\n  let spaceIndex199 = 0;\n  let spaceIndex200 = 0;\n  let spaceIndex201 = 0;\n  let spaceIndex202 = 0;\n  let spaceIndex203 = 0;\n  let spaceIndex204 = 0;\n  let spaceIndex205 = 0;\n  let spaceIndex206 = 0;\n  let spaceIndex207 = 0;\n  let spaceIndex208 = 0;\n  let spaceIndex209 = 0;\n  let spaceIndex210 = 0;\n  let spaceIndex211 = 0;\n  let spaceIndex212 = 0;\n  let spaceIndex213 = 0;\n  let spaceIndex214 = 0;\n  let spaceIndex215 = 0;\n  let spaceIndex216 = 0;\n  let spaceIndex217 = 0;\n  let spaceIndex218 = 0;\n  let spaceIndex219 = 0;\n  let spaceIndex220 = 0;\n  let spaceIndex221 = 0;\n  let spaceIndex222 = 0;\n  let spaceIndex223 = 0;\n  let spaceIndex224 = 0;\n  let spaceIndex225 = 0;\n  let spaceIndex226 = 0;\n  let spaceIndex227 = 0;\n  let spaceIndex228 = 0;\n  let spaceIndex229 = 0;\n  let spaceIndex230 = 0;\n  let spaceIndex231 = 0;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  catchRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  catchRow([], 1) == []\n  catchRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst catchRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "catchRow", "gc": "<|endoftext|>/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  catchRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  catchRow([], 1) == []\n  catchRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst catchRow = (lst, x) => {\n  let row = []\n  let rowIndex = 0\n  let colIndex = 0\n  let rowLen = lst.length\n  let colLen = lst[0].length\n  let result = []\n  let resultIndex = 0\n  let resultLen = lst.length\n  let resultIndexLen = lst[0].length\n  let resultIndexIndex = 0\n  let resultIndexIndexLen = lst[0].length\n  let resultIndexIndexIndex = 0\n  let resultIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndexLen = lst[0].length\n  let resultIndexIndexIndexIndexIndexIndexIndex = 0\n  let resultIndexIndexIndexIndexIndexIndex", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n  or sort it in descending order if the sum( first index value, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "gc": "<|endoftext|>/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n  or sort it in descending order if the sum( first index value, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sortedArray = array.sort((a, b) => a - b);\n  return sortedArray;\n};\n\n/**\n * Given an array of non-negative integers, return the length of the given array.\n\n  Example:\n  * length([1, 2, 3, 4]) => 4\n  * length([1, 2, 3, 4, 5]) => 5\n  * length([1, 2, 3, 4, 5]) => 5\n  * length([1, 2, 3, 4, 5]) => 5\n  */\nconst length = (array) => {\n  return array.length;\n};\n\n/**\n * Given an array of non-negative integers, return the sum of the given array.\n\n  Example:\n  * sum([1, 2, 3, 4]) => 10\n  * sum([1, 2, 3, 4, 5]) => 15\n  * sum([1, 2, 3, 4, 5]) => 15\n  * sum([1, 2, 3, 4, 5]) => 15\n  */\nconst sum = (array) => {\n  return array.reduce((a, b) => a + b, 0);\n};\n\n/**\n * Given an array of non-negative integers, return the average of the given array.\n\n  Example:\n  * average([1, 2, 3, 4]) => 2.5\n  * average([1, 2, 3, 4, 5]) => 2.5\n  * average([1, 2, 3, 4, 5]) => 2.5\n  * average([1, 2, 3, 4, 5]) => 2.5\n  */\nconst average = (array) => {\n  return array.reduce((a, b) => a + b) / array.length;\n};\n\n/**\n * Given an array of non-negative integers, return the median of the given array.\n\n  Example:\n  * median([1, 2, 3, 4]) => 3\n  * median([1, 2, 3, 4, 5]) => 3\n  * median([1, 2, 3, 4, 5]) => 3\n  * median([1, 2, 3, 4, 5]) => 3\n  */\nconst median = (array) => {\n  const sortedArray = sortArray(array);\n  const middle = Math.floor(sortedArray.length / 2);\n  const left = sortedArray.slice(0, middle);\n  const right = sortedArray.slice(middle, sortedArray.length);\n  return median(left) + median(right);\n};\n\n/**\n * Given an array of non-negative integers, return the mode of the given array.\n\n  Example:\n  * mode([1, 2, 3, 4]) => 2\n  * mode([1, 2, 3, 4, 5]) => 2\n  * mode([1, 2, 3, 4, 5]) => 2\n  * mode([1, 2, 3, 4, 5]) => 2\n  */\nconst mode = (array) => {\n  const sortedArray = sortArray(array);\n  const sortedArrayLength = sortedArray.length;\n  const sortedArrayValues = sortedArray.map(value => value);\n  const sortedArrayValueCount = sortedArrayValues.length;\n  const sortedArrayValueCounts = sortedArrayValues.reduce((acc, value) => {\n    acc[value] = acc[value]? acc[value] + 1 : 1;\n    return acc;\n  }, {});\n  const sortedArrayValueCountKeys = Object.keys(sortedArrayValueCounts);\n  const sortedArrayValueCountValues = sortedArrayValueCounts.map(value => value);\n  const sortedArrayValueCountValueCount = sortedArrayValueCountValues.reduce((acc, value) => {\n    acc[value] = acc[value]? acc[value] + 1 : 1;\n    return acc;\n  }, {});\n  const sortedArrayValueCountValueCounts = sortedArrayValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountKeys = Object.keys(sortedArrayValueCountValueCounts);\n  const sortedArrayValueCountValueCountValues = sortedArrayValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountKeys = Object.keys(sortedArrayValueCountValueCountValueCounts);\n  const sortedArrayValueCountValueCountValueCountValues = sortedArrayValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCountValueCounts = sortedArrayValueCountValueCountValueCountValueCounts.map(value => value);\n  const sortedArrayValueCountValueCountValueCount", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/89", "prompt": "/*Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "gc": "<|endoftext|>/*Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotated = '';\n  let i;\n  for (i = 0; i < s.length; i++) {\n    rotated += alphabet[alphabet.indexOf(s[i])];\n  }\n  return rotated;\n};\n\n/*Create a function decrypt that takes a string as an argument and\n  returns a string decrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  decrypt('lm') returns 'hi'\n  decrypt('ewhjklnop') returns 'asdfghjkl'\n  decrypt('kj') returns 'gf'\n  decrypt('ix') returns 'et'\n  */\nconst decrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotated = '';\n  let i;\n  for (i = 0; i < s.length; i++) {\n    rotated += alphabet[alphabet.indexOf(s[i])];\n  }\n  return rotated;\n};\n\n/*Create a function rotate that takes a string as an argument and\n  returns a string rotated the specified number of places.\n  For example:\n  rotate('hi', 2) returns 'lmn'\n  rotate('asdfghjkl', 2) returns 'ewhjklnop'\n  rotate('gf', 2) returns 'kjlmn'\n  rotate('et', 2) returns 'ix'\n  */\nconst rotate = (s, n) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotated = '';\n  let i;\n  for (i = 0; i < s.length; i++) {\n    rotated += alphabet[alphabet.indexOf(s[i])];\n  }\n  return rotated.substring(0, n);\n};\n\n/*Create a function trim that takes a string as an argument and\n  returns a string trimmed from the beginning and end of the string.\n  For example:\n  trim('   hi   ') returns 'hi'\n  trim('   asdfghjkl   ') returns 'asdfghjkl'\n  trim('   gf   ') returns 'gf'\n  trim('   et   ') returns 'et'\n  */\nconst trim = s => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let trimmed = '';\n  let i;\n  for (i = 0; i < s.length; i++) {\n    trimmed += alphabet[alphabet.indexOf(s[i])];\n  }\n  return trimmed.substring(0, trimmed.length - 1);\n};\n\n/*Create a function trim that takes a string as an argument and\n  returns a string trimmed from the beginning and end of the string.\n  For example:\n  trim('   hi   ') returns 'hi'\n  trim('   asdfghjkl   ') returns 'asdfghjkl'\n  trim('   gf   ') returns 'gf'\n  trim('   et   ') returns 'et'\n  */\nconst trimRight = s => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let trimmed = '';\n  let i;\n  for (i = 0; i < s.length; i++) {\n    trimmed += alphabet[alphabet.indexOf(s[i])];\n  }\n  return trimmed.substring(0, trimmed.length - 1);\n};\n\n/*Create a function trim that takes a string as an argument and\n  returns a string trimmed from the beginning and end of the string.\n  For example:\n  trim('   hi   ') returns 'hi'\n  trim('   asdfghjkl   ') returns 'asdfghjkl'\n  trim('   gf   ') returns 'gf'\n  trim('   et   ') returns 'et'\n  */\nconst trimLeft = s => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let trimmed = '';\n  let i;\n  for (i = 0; i < s.length; i++) {\n    trimmed += alphabet[alphabet.indexOf(s[i])];\n  }\n  return trimmed.substring(0, trimmed.length - 1);\n};\n\n/*Create a function trim that takes a string as an argument and\n  returns a string trimmed from the beginning and end of the string.\n  For example:\n  trim('   hi   ') returns 'hi'\n  trim('   asdfghjkl   ') returns 'asdfghjkl'\n  trim('   gf   ') returns 'gf'\n  trim('   et   ') returns 'et'\n  */\nconst trim = s => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let trimmed = '';\n  let i;\n  for (i = 0; i < s.length; i++) {\n    trimmed += alphabet[alphabet.indexOf(s[i])];\n  }\n  return trimmed.substring(0, trimmed.length - 1);\n};\n\n/*Create a function trim that takes a string as an argument and\n  returns a string trimmed from the beginning and end of the string.\n  For example:\n  trim('   hi   ') returns 'hi'\n  trim('   asdfghjkl   ') returns 'asdfghjkl'\n  trim('   gf   ') returns 'gf'\n  trim('   et   ') returns 'et'\n  */\nconst trimRight = s => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let trimmed = '';\n  let i;\n  for (i = 0; i < s.length; i++) {\n    trimmed += alphabet[alphabet.indexOf(s[i])];\n  }\n  return trimmed.substring(0, trimmed.length - 1);\n};\n\n/*Create a function trim that takes a string as an argument and\n  returns a string trimmed from the beginning and end of the string.\n  For example:\n  trim('   hi   ') returns 'hi'\n  trim('   asdfghjkl   ') returns 'asdfghjkl'\n  trim('   gf   ') returns 'gf'\n  trim('   et   ') returns 'et'\n  */\nconst trimLeft = s => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let trimmed = '';\n  let i;\n  for (i = 0; i < s.length; i++) {\n    trimmed += alphabet[alphabet.indexOf(s[i])];\n  }\n  return trimmed.substring(0, trimmed.length - 1);\n};\n\n/*Create a function trim that takes a string as an argument and\n  returns a string trimmed from the beginning and end of the string.\n  For example:\n  trim('   hi   ') returns 'hi'\n  trim('   asdfghjkl   ') returns 'asdfghjkl'\n  trim('   gf   ') returns 'gf'\n  trim('   et   ') returns 'et'\n  */\nconst trim = s => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let trimmed = '';\n  let i;\n  for (i = 0; i < s.length; i++) {\n    trimmed += alphabet[alphabet.indexOf(s[i])];\n  }\n  return trimmed.substring(0, trimmed.length - 1);\n};\n\n/*Create a function trim that takes a string as an argument and\n  returns a string trimmed from the beginning and end of the string.\n  For example:\n  trim('   hi   ') returns 'hi'\n  trim('   asdfghjkl   ') returns 'asdfghjkl'\n  trim('   gf   ') returns 'gf'", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/9", "prompt": "/* From a given list of integers, generate a list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rolledMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rolledMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rolledMax", "gc": "<|endoftext|>/* From a given list of integers, generate a list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rolledMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rolledMax = (numbers) => {\n  const maxes = numbers.reduce((acc, curr, index) => {\n    if (curr > acc) {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  return maxes.reduce((acc, curr) => Math.max(acc, curr), 0);\n};\n\n/* Given a list of integers, generate a list of rolling minimum element found until given moment\n  in the sequence.\n  >>> rolledMin([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 1, 2, 3]\n  */\nconst rolledMin = (numbers) => {\n  const mins = numbers.reduce((acc, curr, index) => {\n    if (curr < acc) {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  return mins.reduce((acc, curr) => Math.min(acc, curr), 0);\n};\n\n/* Given a list of integers, generate a list of rolling sum of elements found until given moment\n  in the sequence.\n  >>> rolledSum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 4, 5]\n  */\nconst rolledSum = (numbers) => {\n  const sums = numbers.reduce((acc, curr, index) => {\n    if (curr + acc > acc) {\n      acc.push(curr + acc);\n    }\n    return acc;\n  }, []);\n  return sums.reduce((acc, curr) => acc + curr, 0);\n};\n\n/* Given a list of integers, generate a list of rolling product elements found until given moment\n  in the sequence.\n  >>> rolledProd([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 4, 6]\n  */\nconst rolledProd = (numbers) => {\n  const prods = numbers.reduce((acc, curr, index) => {\n    if (curr * acc > acc) {\n      acc.push(curr * acc);\n    }\n    return acc;\n  }, []);\n  return prods.reduce((acc, curr) => acc * curr, 1);\n};\n\n/* Given a list of integers, generate a list of rolling product of elements found until given moment\n  in the sequence.\n  >>> rolledProdSum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 4, 6]\n  */\nconst rolledProdSum = (numbers) => {\n  const prods = numbers.reduce((acc, curr, index) => {\n    if (curr * curr > acc) {\n      acc.push(curr * curr);\n    }\n    return acc;\n  }, []);\n  return prods.reduce((acc, curr) => acc * curr, 1);\n};\n\n/* Given a list of integers, generate a list of rolling sum of squares elements found until given moment\n  in the sequence.\n  >>> rolledSumSquares([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 4, 6]\n  */\nconst rolledSumSquares = (numbers) => {\n  const sums = numbers.reduce((acc, curr, index) => {\n    if (curr + curr + acc > acc) {\n      acc.push(curr + curr + acc);\n    }\n    return acc;\n  }, []);\n  return sums.reduce((acc, curr) => acc + curr * curr, 0);\n};\n\n/* Given a list of integers, generate a list of rolling product of squares elements found until given moment\n  in the sequence.\n  >>> rolledProdSumSquares([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 4, 6]\n  */\nconst rolledProdSumSquares = (numbers) => {\n  const prods = numbers.reduce((acc, curr, index) => {\n    if (curr * curr + curr * curr > acc) {\n      acc.push(curr * curr + curr * curr);\n    }\n    return acc;\n  }, []);\n  return prods.reduce((acc, curr) => acc * curr, 1);\n};\n\n/* Given a list of integers, generate a list of rolling maximum and minimum elements found until given moment\n  in the sequence.\n  >>> rolledMaxMin([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 1, 2, 3]\n  */\nconst rolledMaxMin = (numbers) => {\n  const maxes = numbers.reduce((acc, curr, index) => {\n    if (curr > acc) {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  const mins = numbers.reduce((acc, curr, index) => {\n    if (curr < acc) {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  return maxes.reduce((acc, curr) => Math.min(acc, curr), mins);\n};\n\n/* Given a list of integers, generate a list of rolling maximum and minimum elements found until given moment\n  in the sequence.\n  >>> rolledMaxMinSum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 1, 2, 3]\n  */\nconst rolledMaxMinSum = (numbers) => {\n  const maxes = numbers.reduce((acc, curr, index) => {\n    if (curr > acc) {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  const mins = numbers.reduce((acc, curr, index) => {\n    if (curr < acc) {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  return maxes.reduce((acc, curr) => Math.min(acc, curr), mins);\n};\n\n/* Given a list of integers, generate a list of rolling maximum and minimum elements found until given moment\n  in the sequence.\n  >>> rolledMaxMinSumSquares([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 1, 2, 3]\n  */\nconst rolledMaxMinSumSquares = (numbers) => {\n  const maxes = numbers.reduce((acc, curr, index) => {\n    if (curr > acc) {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  const mins = numbers.reduce((acc, curr, index) => {\n    if (curr < acc) {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  return maxes.reduce((acc, curr) => Math.min(acc, curr), mins);\n};\n\n/* Given a list of integers, generate a list of rolling maximum and minimum elements found until given moment\n  in the sequence.\n  >>> rolledMaxMinSumSquaresSum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 1, 2, 3]\n  */\nconst rolledMaxMinSumSquaresSum = (numbers) => {\n  const maxes = numbers.reduce((acc, curr, index) => {\n    if (curr > acc) {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  const mins = numbers.reduce((acc, curr, index) => {\n    if (curr < acc) {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  return maxes.reduce((acc, curr) => Math.min(acc, curr), mins);\n};\n\n/* Given a list of integers, generate a list of rolling maximum and minimum elements found until given moment\n  in the sequence.\n  >>> rolledMaxMinSumSquaresSumSquares([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 1, 2, 3]\n  */\nconst rolledMaxMinSumSquaresSumSquares = (numbers) => {\n  const maxes = numbers.reduce((acc, curr, index) => {\n    if (curr > acc) {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  const mins = numbers.reduce((acc, curr, index) => {\n    if (curr < acc) {\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n  return maxes.reduce((acc, curr) => Math.min(acc, curr), mins);\n};\n\n/* Given a list of integers, generate a list of rolling maximum and minimum elements found until given moment\n  in the sequence.\n  >>> rolledMaxMinSumSquaresSumSquaresSum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 1, 2, 3]\n  */\nconst rolledMaxMinSumSquaresSumSquaresSum = (numbers) => {\n  const maxes = numbers.reduce((acc, curr, index) => {\n    if (curr > acc) {\n      acc.push(curr);\n    }\n    return ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "gc": "<|endoftext|>/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 2\n  nextSmallest([5, 1, 4, 3, 2]) == 2\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  let min = null;\n  let max = lst[0];\n  let i = 1;\n  while (min === null || min > max) {\n    if (min === null || min > max) {\n      min = lst[i];\n      max = lst[i];\n    }\n    i++;\n  }\n  return min;\n};\n\nmodule.exports = nextSmallest;\n\n},{}],3:[function(require,module,exports){\n/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 3\n  nextSmallest([5, 1, 4, 3, 2]) == 3\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  let min = null;\n  let max = lst[0];\n  let i = 1;\n  while (min === null || min > max) {\n    if (min === null || min > max) {\n      min = lst[i];\n      max = lst[i];\n    }\n    i++;\n  }\n  return min;\n};\n\nmodule.exports = nextSmallest;\n\n},{}],4:[function(require,module,exports){\n/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 4\n  nextSmallest([5, 1, 4, 3, 2]) == 4\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  let min = null;\n  let max = lst[0];\n  let i = 1;\n  while (min === null || min > max) {\n    if (min === null || min > max) {\n      min = lst[i];\n      max = lst[i];\n    }\n    i++;\n  }\n  return min;\n};\n\nmodule.exports = nextSmallest;\n\n},{}],5:[function(require,module,exports){\n/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 5\n  nextSmallest([5, 1, 4, 3, 2]) == 5\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  let min = null;\n  let max = lst[0];\n  let i = 1;\n  while (min === null || min > max) {\n    if (min === null || min > max) {\n      min = lst[i];\n      max = lst[i];\n    }\n    i++;\n  }\n  return min;\n};\n\nmodule.exports = nextSmallest;\n\n},{}],6:[function(require,module,exports){\n/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 6\n  nextSmallest([5, 1, 4, 3, 2]) == 6\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  let min = null;\n  let max = lst[0];\n  let i = 1;\n  while (min === null || min > max) {\n    if (min === null || min > max) {\n      min = lst[i];\n      max = lst[i];\n    }\n    i++;\n  }\n  return min;\n};\n\nmodule.exports = nextSmallest;\n\n},{}],7:[function(require,module,exports){\n/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 7\n  nextSmallest([5, 1, 4, 3, 2]) == 7\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  let min = null;\n  let max = lst[0];\n  let i = 1;\n  while (min === null || min > max) {\n    if (min === null || min > max) {\n      min = lst[i];\n      max = lst[i];\n    }\n    i++;\n  }\n  return min;\n};\n\nmodule.exports = nextSmallest;\n\n},{}],8:[function(require,module,exports){\n/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 8\n  nextSmallest([5, 1, 4, 3, 2]) == 8\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  let min = null;\n  let max = lst[0];\n  let i = 1;\n  while (min === null || min > max) {\n    if (min === null || min > max) {\n      min = lst[i];\n      max = lst[i];\n    }\n    i++;\n  }\n  return min;\n};\n\nmodule.exports = nextSmallest;\n\n},{}],9:[function(require,module,exports){\n/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 9\n  nextSmallest([5, 1, 4, 3, 2]) == 9\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  let min = null;\n  let max = lst[0];\n  let i = 1;\n  while (min === null || min > max) {\n    if (min === null || min > max) {\n      min = lst[i];\n      max = lst[i];\n    }\n    i++;\n  }\n  return min;\n};\n\nmodule.exports = nextSmallest;\n\n},{}],10:[function(require,module,exports){\n/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 10\n  nextSmallest([5, 1, 4, 3, 2]) == 10\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  let min = null;\n  let max = lst[0];\n  let i = 1;\n  while (min === null || min > max) {\n    if (min === null || min > max) {\n      min = lst[i];\n      max = lst[i];\n    }\n    i++;\n  }\n  return min;\n};\n\nmodule.exports = nextSmallest;\n\n},{}],11:[function(require,module,exports){\n/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 11\n  nextSmallest([5, 1, 4, 3, 2]) == 11\n  ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBlase(\"Hello world\")\n  0\n  >>> isBlase(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBlase = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBlase", "gc": "<|endoftext|>/*\n  You'll be given a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBlase(\"Hello world\")\n  0\n  >>> isBlase(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBlase = (S) => {\n  let boredoms = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'I') boredoms += 1;\n  });\n  return boredoms;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of consonants. A consonant is a word that starts with the letter \"c\".\n  Words are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isConsonant(\"Hello world\")\n  0\n  >>> isConsonant(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isConsonant = (S) => {\n  let consonants = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'c') consonants += 1;\n  });\n  return consonants;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of vowels. A vowel is a word that starts with the letter \"a\".\n  Words are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isVowel(\"Hello world\")\n  0\n  >>> isVowel(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isVowel = (S) => {\n  let vowels = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'a') vowels += 1;\n  });\n  return vowels;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of consonants and vowels. A consonant is a word that starts with the letter \"c\".\n  Words are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isConsonantVowel(\"Hello world\")\n  0\n  >>> isConsonantVowel(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isConsonantVowel = (S) => {\n  let consonantVowels = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'c') consonantVowels += 1;\n  });\n  return consonantVowels;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of consonants and vowels. A vowel is a word that starts with the letter \"a\".\n  Words are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isVowelVowel(\"Hello world\")\n  0\n  >>> isVowelVowel(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isVowelVowel = (S) => {\n  let vowelVowels = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'a') vowelVowels += 1;\n  });\n  return vowelVowels;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of consonants and vowels. A consonant is a word that starts with the letter \"c\".\n  Words are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isConsonantVowelVowel(\"Hello world\")\n  0\n  >>> isConsonantVowelVowel(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isConsonantVowelVowel = (S) => {\n  let consonantVowelVowels = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'c') consonantVowelVowels += 1;\n  });\n  return consonantVowelVowels;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of consonants and vowels. A vowel is a word that starts with the letter \"a\".\n  Words are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isVowelVowelVowel(\"Hello world\")\n  0\n  >>> isVowelVowelVowel(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isVowelVowelVowel = (S) => {\n  let vowelVowelVowels = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'a') vowelVowelVowels += 1;\n  });\n  return vowelVowelVowels;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of consonants and vowels. A vowel is a word that starts with the letter \"a\".\n  Words are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isConsonantVowelVowelVowel(\"Hello world\")\n  0\n  >>> isConsonantVowelVowelVowel(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isConsonantVowelVowelVowel = (S) => {\n  let consonantVowelVowels = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'a') consonantVowelVowels += 1;\n  });\n  return consonantVowelVowels;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of consonants and vowels. A vowel is a word that starts with the letter \"a\".\n  Words are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isVowelVowelVowelVowel(\"Hello world\")\n  0\n  >>> isVowelVowelVowelVowel(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isVowelVowelVowelVowel = (S) => {\n  let vowelVowelVowelVowels = 0;\n  let words = S.split('.');\n  words.forEach((word) => {\n    if (word === 'a') vowelVowelVowelVowels += 1;\n  });\n  return vowelVowelVowelVowels;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/92", "prompt": "/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "gc": "<|endoftext|>/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  const isInt = (x) => Number.isInteger(x) && x === x && Number.isInteger(y);\n  return isInt(x) && isInt(y) && isInt(z);\n};\n\n/* Create a function that takes 3 numbers and returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ true\n  */\nconst anyIntOrZero = (x, y, z) => {\n  const isInt = (x) => Number.isInteger(x) && x === x && Number.isInteger(y);\n  return isInt(x) || isInt(y) || isInt(z);\n};\n\n/* Create a function that takes 3 numbers and returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyIntOrZeroOrZero = (x, y, z) => {\n  const isInt = (x) => Number.isInteger(x) && x === x && Number.isInteger(y);\n  return isInt(x) || isInt(y) || isInt(z);\n};\n\n/* Create a function that takes 3 numbers and returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ true\n  */\nconst anyIntOrZeroOrZeroOrZero = (x, y, z) => {\n  const isInt = (x) => Number.isInteger(x) && x === x && Number.isInteger(y);\n  return isInt(x) || isInt(y) || isInt(z);\n};\n\n/* Create a function that takes 3 numbers and returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ true\n  */\nconst anyIntOrZeroOrZeroOrZeroOrZero = (x, y, z) => {\n  const isInt = (x) => Number.isInteger(x) && x === x && Number.isInteger(y);\n  return isInt(x) || isInt(y) || isInt(z);\n};\n\n/* Create a function that takes 3 numbers and returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ true\n  */\nconst anyIntOrZeroOrZeroOrZeroOrZeroOrZero = (x, y, z) => {\n  const isInt = (x) => Number.isInteger(x) && x === x && Number.isInteger(y);\n  return isInt(x) || isInt(y) || isInt(z);\n};\n\n/* Create a function that takes 3 numbers and returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ true\n  */\nconst anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = (x, y, z) => {\n  const isInt = (x) => Number.isInteger(x) && x === x && Number.isInteger(y);\n  return isInt(x) || isInt(y) || isInt(z);\n};\n\n/* Create a function that takes 3 numbers and returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ true\n  */\nconst anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = (x, y, z) => {\n  const isInt = (x) => Number.isInteger(x) && x === x && Number.isInteger(y);\n  return isInt(x) || isInt(y) || isInt(z);\n};\n\n/* Create a function that takes 3 numbers and returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ true\n  */\nconst anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = (x, y, z) => {\n  const isInt = (x) => Number.isInteger(x) && x === x && Number.isInteger(y);\n  return isInt(x) || isInt(y) || isInt(z);\n};\n\n/* Create a function that takes 3 numbers and returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ true\n  */\nconst anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = (x, y, z) => {\n  const isInt = (x) => Number.isInteger(x) && x === x && Number.isInteger(y);\n  return isInt(x) || isInt(y) || isInt(z);\n};\n\n/* Create a function that takes 3 numbers and returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ true\n  */\nconst anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = (x, y, z) => {\n  const isInt = (x) => Number.isInteger(x) && x === x && Number.isInteger(y);\n  return isInt(x) || isInt(y) || isInt(z);\n};\n\n/* Create a function that takes 3 numbers and returns true if any of the numbers is equal to the sum", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "gc": "<|endoftext|>/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let encoded = '';\n  let vowels = 'aeiouAEIOU';\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let vowelsIndex = 0;\n  let alphabetIndex = 0;\n  let vowelsIndex2 = 0;\n  let alphabetIndex2 = 0;\n  let vowelsIndex3 = 0;\n  let alphabetIndex3 = 0;\n  let vowelsIndex4 = 0;\n  let alphabetIndex4 = 0;\n  let vowelsIndex5 = 0;\n  let alphabetIndex5 = 0;\n  let vowelsIndex6 = 0;\n  let alphabetIndex6 = 0;\n  let vowelsIndex7 = 0;\n  let alphabetIndex7 = 0;\n  let vowelsIndex8 = 0;\n  let alphabetIndex8 = 0;\n  let vowelsIndex9 = 0;\n  let alphabetIndex9 = 0;\n  let vowelsIndex10 = 0;\n  let alphabetIndex10 = 0;\n  let vowelsIndex11 = 0;\n  let alphabetIndex11 = 0;\n  let vowelsIndex12 = 0;\n  let alphabetIndex12 = 0;\n  let vowelsIndex13 = 0;\n  let alphabetIndex13 = 0;\n  let vowelsIndex14 = 0;\n  let alphabetIndex14 = 0;\n  let vowelsIndex15 = 0;\n  let alphabetIndex15 = 0;\n  let vowelsIndex16 = 0;\n  let alphabetIndex16 = 0;\n  let vowelsIndex17 = 0;\n  let alphabetIndex17 = 0;\n  let vowelsIndex18 = 0;\n  let alphabetIndex18 = 0;\n  let vowelsIndex19 = 0;\n  let alphabetIndex19 = 0;\n  let vowelsIndex20 = 0;\n  let alphabetIndex20 = 0;\n  let vowelsIndex21 = 0;\n  let alphabetIndex21 = 0;\n  let vowelsIndex22 = 0;\n  let alphabetIndex22 = 0;\n  let vowelsIndex23 = 0;\n  let alphabetIndex23 = 0;\n  let vowelsIndex24 = 0;\n  let alphabetIndex24 = 0;\n  let vowelsIndex25 = 0;\n  let alphabetIndex25 = 0;\n  let vowelsIndex26 = 0;\n  let alphabetIndex26 = 0;\n  let vowelsIndex27 = 0;\n  let alphabetIndex27 = 0;\n  let vowelsIndex28 = 0;\n  let alphabetIndex28 = 0;\n  let vowelsIndex29 = 0;\n  let alphabetIndex29 = 0;\n  let vowelsIndex30 = 0;\n  let alphabetIndex30 = 0;\n  let vowelsIndex31 = 0;\n  let alphabetIndex31 = 0;\n  let vowelsIndex32 = 0;\n  let alphabetIndex32 = 0;\n  let vowelsIndex33 = 0;\n  let alphabetIndex33 = 0;\n  let vowelsIndex34 = 0;\n  let alphabetIndex34 = 0;\n  let vowelsIndex35 = 0;\n  let alphabetIndex35 = 0;\n  let vowelsIndex36 = 0;\n  let alphabetIndex36 = 0;\n  let vowelsIndex37 = 0;\n  let alphabetIndex37 = 0;\n  let vowelsIndex38 = 0;\n  let alphabetIndex38 = 0;\n  let vowelsIndex39 = 0;\n  let alphabetIndex39 = 0;\n  let vowelsIndex40 = 0;\n  let alphabetIndex40 = 0;\n  let vowelsIndex41 = 0;\n  let alphabetIndex41 = 0;\n  let vowelsIndex42 = 0;\n  let alphabetIndex42 = 0;\n  let vowelsIndex43 = 0;\n  let alphabetIndex43 = 0;\n  let vowelsIndex44 = 0;\n  let alphabetIndex44 = 0;\n  let vowelsIndex45 = 0;\n  let alphabetIndex45 = 0;\n  let vowelsIndex46 = 0;\n  let alphabetIndex46 = 0;\n  let vowelsIndex47 = 0;\n  let alphabetIndex47 = 0;\n  let vowelsIndex48 = 0;\n  let alphabetIndex48 = 0;\n  let vowelsIndex49 = 0;\n  let alphabetIndex49 = 0;\n  let vowelsIndex50 = 0;\n  let alphabetIndex50 = 0;\n  let vowelsIndex51 = 0;\n  let alphabetIndex51 = 0;\n  let vowelsIndex52 = 0;\n  let alphabetIndex52 = 0;\n  let vowelsIndex53 = 0;\n  let alphabetIndex53 = 0;\n  let vowelsIndex54 = 0;\n  let alphabetIndex54 = 0;\n  let vowelsIndex55 = 0;\n  let alphabetIndex55 = 0;\n  let vowelsIndex56 = 0;\n  let alphabetIndex56 = 0;\n  let vowelsIndex57 = 0;\n  let alphabetIndex57 = 0;\n  let vowelsIndex58 = 0;\n  let alphabetIndex58 = 0;\n  let vowelsIndex59 = 0;\n  let alphabetIndex59 = 0;\n  let vowelsIndex60 = 0;\n  let alphabetIndex60 = 0;\n  let vowelsIndex61 = 0;\n  let alphabetIndex61 = 0;\n  let vowelsIndex62 = 0;\n  let alphabetIndex62 = 0;\n  let vowelsIndex63 = 0;\n  let alphabetIndex63 = 0;\n  let vowelsIndex64 = 0;\n  let alphabetIndex64 = 0;\n  let vowelsIndex65 = 0;\n  let alphabetIndex65 = 0;\n  let vowelsIndex66 = 0;\n  let alphabetIndex66 = 0;\n  let vowelsIndex67 = 0;\n  let alphabetIndex67 = 0;\n  let vowelsIndex68 = 0;\n  let alphabetIndex68 = 0;\n  let vowelsIndex69 = 0;\n  let alphabetIndex69 = 0;\n  let vowelsIndex70 = 0;\n  let alphabetIndex70 = 0;\n  let vowelsIndex71 = 0;\n  let alphabetIndex71 = 0;\n  let vowelsIndex72 = 0;\n  let alphabetIndex72 = 0;\n  let vowelsIndex73 = 0;\n  let alphabetIndex73 = 0;\n  let vowelsIndex74 = 0;\n  let alphabetIndex74 = 0;\n  let vowelsIndex75 = 0;\n  let alphabetIndex75 = 0;\n  let vowelsIndex76 = 0;\n  let alphabetIndex76 = 0;\n  let vowelsIndex77 = 0;\n  let alphabetIndex77 = 0;\n  let vowelsIndex78 = 0;\n  let alphabetIndex78 = 0;\n  let vowelsIndex79 = 0;\n  let alphabetIndex79 = 0;\n  let vowelsIndex80 = 0;\n  let alphabetIndex80 = 0;\n  let vowelsIndex81 = 0;\n  let alphabetIndex81 = 0;\n  let vowelsIndex82 = 0;\n  let alphabetIndex82 = 0;\n  let vowelsIndex83 = 0;\n  let alphabetIndex83 = 0;\n  let vowelsIndex84 = 0;\n  let alphabetIndex84 = 0;\n  let vowelsIndex85 = 0;\n  let alphabetIndex85 = 0;\n  let vowelsIndex86 = 0;\n  let alphabetIndex86 = 0;\n  let vowelsIndex87 = 0;\n  let alphabetIndex87 = 0;\n  let vowelsIndex88 = 0;\n  let alphabetIndex88 = 0;\n  let vowelsIndex89 = 0;\n  let alphabetIndex89 = 0;\n  let vowelsIndex90 = 0;\n  let alphabetIndex90 = 0;\n  let vowelsIndex91 = 0;\n  let alphabetIndex91 = 0;\n  let vowelsIndex92 = 0;\n  let alphabetIndex92 = 0;\n  let vowelsIndex93 = 0;\n  let alphabetIndex93 = 0;\n  let vowelsIndex94 = 0;\n  let alphabetIndex94 = 0;\n  let vowelsIndex95 = 0;\n  let alphabetIndex95 = 0;\n  let vowelsIndex96 = 0;\n  let alphabetIndex96 = 0;\n  let vowelsIndex97 = 0;\n  let alphabetIndex97 = 0;\n  let vowelsIndex98 = 0;\n  let alphabetIndex98 = 0;\n  let vowelsIndex99 = 0;\n  let alphabetIndex99 = 0;\n  let vowelsIndex100 = 0;\n  let alphabetIndex100 = 0;\n  let vowelsIndex101 = 0;\n  let alphabetIndex101 = 0;\n  let vowelsIndex102 = 0;\n  let alphabetIndex102 = 0;\n  let vowelsIndex103 = 0;\n  let alphabetIndex103 = 0;\n  let vowelsIndex104 = 0;\n  let alphabetIndex104 = 0;\n  let vowelsIndex105 = 0;\n  let alphabetIndex105 = 0;\n  let vowelsIndex106 = 0;\n  let alphabetIndex106 = 0;\n  let vowelsIndex107 = 0;\n  let alphabetIndex107 = 0;\n  let vowelsIndex108 = 0;\n  let alphabetIndex108 = 0;\n  let vowelsIndex109 = 0;\n  let alphabetIndex109 = 0;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/94", "prompt": "/*You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "gc": "<|endoftext|>/*You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let sum = 0;\n  let max = 0;\n  let maxPrime = 0;\n  let maxDigit = 0;\n  let maxDigitPrime = 0;\n  let maxDigitPrimeSum = 0;\n  let maxDigitPrimeSum2 = 0;\n  let maxDigitPrimeSum3 = 0;\n  let maxDigitPrimeSum4 = 0;\n  let maxDigitPrimeSum5 = 0;\n  let maxDigitPrimeSum6 = 0;\n  let maxDigitPrimeSum7 = 0;\n  let maxDigitPrimeSum8 = 0;\n  let maxDigitPrimeSum9 = 0;\n  let maxDigitPrimeSum10 = 0;\n  let maxDigitPrimeSum11 = 0;\n  let maxDigitPrimeSum12 = 0;\n  let maxDigitPrimeSum13 = 0;\n  let maxDigitPrimeSum14 = 0;\n  let maxDigitPrimeSum15 = 0;\n  let maxDigitPrimeSum16 = 0;\n  let maxDigitPrimeSum17 = 0;\n  let maxDigitPrimeSum18 = 0;\n  let maxDigitPrimeSum19 = 0;\n  let maxDigitPrimeSum20 = 0;\n  let maxDigitPrimeSum21 = 0;\n  let maxDigitPrimeSum22 = 0;\n  let maxDigitPrimeSum23 = 0;\n  let maxDigitPrimeSum24 = 0;\n  let maxDigitPrimeSum25 = 0;\n  let maxDigitPrimeSum26 = 0;\n  let maxDigitPrimeSum27 = 0;\n  let maxDigitPrimeSum28 = 0;\n  let maxDigitPrimeSum29 = 0;\n  let maxDigitPrimeSum30 = 0;\n  let maxDigitPrimeSum31 = 0;\n  let maxDigitPrimeSum32 = 0;\n  let maxDigitPrimeSum33 = 0;\n  let maxDigitPrimeSum34 = 0;\n  let maxDigitPrimeSum35 = 0;\n  let maxDigitPrimeSum36 = 0;\n  let maxDigitPrimeSum37 = 0;\n  let maxDigitPrimeSum38 = 0;\n  let maxDigitPrimeSum39 = 0;\n  let maxDigitPrimeSum40 = 0;\n  let maxDigitPrimeSum41 = 0;\n  let maxDigitPrimeSum42 = 0;\n  let maxDigitPrimeSum43 = 0;\n  let maxDigitPrimeSum44 = 0;\n  let maxDigitPrimeSum45 = 0;\n  let maxDigitPrimeSum46 = 0;\n  let maxDigitPrimeSum47 = 0;\n  let maxDigitPrimeSum48 = 0;\n  let maxDigitPrimeSum49 = 0;\n  let maxDigitPrimeSum50 = 0;\n  let maxDigitPrimeSum51 = 0;\n  let maxDigitPrimeSum52 = 0;\n  let maxDigitPrimeSum53 = 0;\n  let maxDigitPrimeSum54 = 0;\n  let maxDigitPrimeSum55 = 0;\n  let maxDigitPrimeSum56 = 0;\n  let maxDigitPrimeSum57 = 0;\n  let maxDigitPrimeSum58 = 0;\n  let maxDigitPrimeSum59 = 0;\n  let maxDigitPrimeSum60 = 0;\n  let maxDigitPrimeSum61 = 0;\n  let maxDigitPrimeSum62 = 0;\n  let maxDigitPrimeSum63 = 0;\n  let maxDigitPrimeSum64 = 0;\n  let maxDigitPrimeSum65 = 0;\n  let maxDigitPrimeSum66 = 0;\n  let maxDigitPrimeSum67 = 0;\n  let maxDigitPrimeSum68 = 0;\n  let maxDigitPrimeSum69 = 0;\n  let maxDigitPrimeSum70 = 0;\n  let maxDigitPrimeSum71 = 0;\n  let maxDigitPrimeSum72 = 0;\n  let maxDigitPrimeSum73 = 0;\n  let maxDigitPrimeSum74 = 0;\n  let maxDigitPrimeSum75 = 0;\n  let maxDigitPrimeSum76 = 0;\n  let maxDigitPrimeSum77 = 0;\n  let maxDigitPrimeSum78 = 0;\n  let maxDigitPrimeSum79 = 0;\n  let maxDigitPrimeSum80 = 0;\n  let maxDigitPrimeSum81 = 0;\n  let maxDigitPrimeSum82 = 0;\n  let maxDigitPrimeSum83 = 0;\n  let maxDigitPrimeSum84 = 0;\n  let maxDigitPrimeSum85 = 0;\n  let maxDigitPrimeSum86 = 0;\n  let maxDigitPrimeSum87 = 0;\n  let maxDigitPrimeSum88 = 0;\n  let maxDigitPrimeSum89 = 0;\n  let maxDigitPrimeSum90 = 0;\n  let maxDigitPrimeSum91 = 0;\n  let maxDigitPrimeSum92 = 0;\n  let maxDigitPrimeSum93 = 0;\n  let maxDigitPrimeSum94 = 0;\n  let maxDigitPrimeSum95 = 0;\n  let maxDigitPrimeSum96 = 0;\n  let maxDigitPrimeSum97 = 0;\n  let maxDigitPrimeSum98 = 0;\n  let maxDigitPrimeSum99 = 0;\n  let maxDigitPrimeSum100 = 0;\n  let maxDigitPrimeSum101 = 0;\n  let maxDigitPrimeSum102 = 0;\n  let maxDigitPrimeSum103 = 0;\n  let maxDigitPrimeSum104 = 0;\n  let maxDigitPrimeSum105 = 0;\n  let maxDigitPrimeSum106 = 0;\n  let maxDigitPrimeSum107 = 0;\n  let maxDigitPrimeSum108 = 0;\n  let maxDigitPrimeSum109 = 0;\n  let maxDigitPrimeSum110 = 0;\n  let maxDigitPrimeSum111 = 0;\n  let maxDigitPrimeSum112 = 0;\n  let maxDigitPrimeSum113 = 0;\n  let maxDigitPrimeSum114 = 0;\n  let maxDigitPrimeSum115 = 0;\n  let maxDigitPrimeSum116 = 0;\n  let maxDigitPrimeSum117 = 0;\n  let maxDigitPrimeSum118 = 0;\n  let maxDigitPrimeSum119 = 0;\n  let maxDigitPrimeSum120 = 0;\n  let maxDigitPrimeSum121 = 0;\n  let maxDigitPrimeSum122 = 0;\n  let maxDigitPrimeSum123 = 0;\n  let maxDigitPrimeSum124 = 0;\n  let maxDigitPrimeSum125 = 0;\n  let maxDigitPrimeSum126 = 0;\n  let maxDigitPrimeSum127 = 0;\n  let maxDigitPrimeSum128 = 0;\n  let maxDigitPrimeSum129 = 0;\n  let maxDigitPrimeSum130 = 0;\n  let maxDigitPrimeSum131 = 0;\n  let maxDigitPrimeSum132 = 0;\n  let maxDigitPrimeSum133 = 0;\n  let maxDigitPrimeSum134 = 0;\n  let maxDigitPrimeSum135 = 0;\n  let maxDigitPrimeSum136 = 0;\n  let maxDigitPrimeSum137 = 0;\n  let maxDigitPrimeSum138 = 0;\n  let maxDigitPrimeSum139 = 0;\n  let maxDigitPrimeSum140 = 0;\n  let maxDigitPrimeSum141 = 0;\n  let maxDigitPrimeSum142 = 0;\n  let maxDigitPrimeSum143 = 0;\n  let maxDigitPrimeSum144 = 0;\n  let maxDigitPrimeSum145 = 0;\n  let maxDigitPrimeSum146 = 0;\n  let maxDigitPrimeSum147 = 0;\n  let maxDigitPrimeSum148 = 0;\n  let maxDigitPrimeSum149 = 0;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  determineDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  determineDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  determineDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  determineDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  determineDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst determineDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "determineDictCase", "gc": "<|endoftext|>/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  determineDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  determineDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  determineDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  determineDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  determineDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst determineDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i];\n    let value = dict[key];\n    if (typeof value ==='string' && value.toLowerCase().trim() === key.toLowerCase().trim()) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Given a string, return true if all characters are lowercase or all \n  characters are uppercase, else return false.\n  The function should return false is the given string is empty.\n  Examples:\n  determineStringCase(\"a\") should return true.\n  determineStringCase(\"A\") should return false.\n  determineStringCase(\"aB\") should return false.\n  determineStringCase(\"aBc\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n  determineStringCase(\"aBcD\") should return false.\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function that takes an non-negative integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  considerUpTo(5) => [2,3]\n  considerUpTo(11) => [2,3,5,7]\n  considerUpTo(0) => []\n  considerUpTo(20) => [2,3,5,7,11,13,17,19]\n  considerUpTo(1) => []\n  considerUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst considerUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "considerUpTo", "gc": "<|endoftext|>/*Implement a function that takes an non-negative integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  considerUpTo(5) => [2,3]\n  considerUpTo(11) => [2,3,5,7]\n  considerUpTo(0) => []\n  considerUpTo(20) => [2,3,5,7,11,13,17,19]\n  considerUpTo(1) => []\n  considerUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst considerUpTo = (n) => {\n  let primes = [];\n  let primesCount = 0;\n  let primesCountMax = n;\n  let primesCountMin = n - 1;\n  let primesCountMinMax = primesCountMin;\n  let primesCountMaxMin = primesCountMax + 1;\n  let primesCountMaxMinMax = primesCountMaxMin + 1;\n  let primesCountMinMaxMin = primesCountMinMaxMax + 1;\n  let primesCountMinMaxMinMax = primesCountMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMin = primesCountMinMaxMinMaxMax + 1;\n  let primesCountMinMaxMinMaxMinMax = primesCountMinMaxMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMin = primesCountMinMaxMinMaxMinMaxMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMax = primesCountMinMaxMinMaxMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMin = primesCountMinMaxMinMaxMinMaxMinMaxMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMin = primesCountMinMaxMinMaxMinMaxMinMaxMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMin = primesCountMinMaxMinMaxMinMaxMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMin = primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMin = primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax + 1;\n  let primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = primesCountMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax + 1;\n  let primesCountMinMax", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function that takes two integers and returns \n  the product of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  breed(148, 412) should return 16.\n  breed(19, 28) should return 72.\n  breed(2020, 1851) should return 0.\n  breed(14,-15) should return 20.\n  */\nconst breed = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "breed", "gc": "<|endoftext|>/*Complete the function that takes two integers and returns \n  the product of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  breed(148, 412) should return 16.\n  breed(19, 28) should return 72.\n  breed(2020, 1851) should return 0.\n  breed(14,-15) should return 20.\n  */\nconst breed = (a, b) => {\n  let sum = 0;\n  let digits = 0;\n  let remainder = 0;\n  let remainder2 = 0;\n  let remainder3 = 0;\n  let remainder4 = 0;\n  let remainder5 = 0;\n  let remainder6 = 0;\n  let remainder7 = 0;\n  let remainder8 = 0;\n  let remainder9 = 0;\n  let remainder10 = 0;\n  let remainder11 = 0;\n  let remainder12 = 0;\n  let remainder13 = 0;\n  let remainder14 = 0;\n  let remainder15 = 0;\n  let remainder16 = 0;\n  let remainder17 = 0;\n  let remainder18 = 0;\n  let remainder19 = 0;\n  let remainder20 = 0;\n  let remainder21 = 0;\n  let remainder22 = 0;\n  let remainder23 = 0;\n  let remainder24 = 0;\n  let remainder25 = 0;\n  let remainder26 = 0;\n  let remainder27 = 0;\n  let remainder28 = 0;\n  let remainder29 = 0;\n  let remainder30 = 0;\n  let remainder31 = 0;\n  let remainder32 = 0;\n  let remainder33 = 0;\n  let remainder34 = 0;\n  let remainder35 = 0;\n  let remainder36 = 0;\n  let remainder37 = 0;\n  let remainder38 = 0;\n  let remainder39 = 0;\n  let remainder40 = 0;\n  let remainder41 = 0;\n  let remainder42 = 0;\n  let remainder43 = 0;\n  let remainder44 = 0;\n  let remainder45 = 0;\n  let remainder46 = 0;\n  let remainder47 = 0;\n  let remainder48 = 0;\n  let remainder49 = 0;\n  let remainder50 = 0;\n  let remainder51 = 0;\n  let remainder52 = 0;\n  let remainder53 = 0;\n  let remainder54 = 0;\n  let remainder55 = 0;\n  let remainder56 = 0;\n  let remainder57 = 0;\n  let remainder58 = 0;\n  let remainder59 = 0;\n  let remainder60 = 0;\n  let remainder61 = 0;\n  let remainder62 = 0;\n  let remainder63 = 0;\n  let remainder64 = 0;\n  let remainder65 = 0;\n  let remainder66 = 0;\n  let remainder67 = 0;\n  let remainder68 = 0;\n  let remainder69 = 0;\n  let remainder70 = 0;\n  let remainder71 = 0;\n  let remainder72 = 0;\n  let remainder73 = 0;\n  let remainder74 = 0;\n  let remainder75 = 0;\n  let remainder76 = 0;\n  let remainder77 = 0;\n  let remainder78 = 0;\n  let remainder79 = 0;\n  let remainder80 = 0;\n  let remainder81 = 0;\n  let remainder82 = 0;\n  let remainder83 = 0;\n  let remainder84 = 0;\n  let remainder85 = 0;\n  let remainder86 = 0;\n  let remainder87 = 0;\n  let remainder88 = 0;\n  let remainder89 = 0;\n  let remainder90 = 0;\n  let remainder91 = 0;\n  let remainder92 = 0;\n  let remainder93 = 0;\n  let remainder94 = 0;\n  let remainder95 = 0;\n  let remainder96 = 0;\n  let remainder97 = 0;\n  let remainder98 = 0;\n  let remainder99 = 0;\n  let remainder100 = 0;\n  let remainder101 = 0;\n  let remainder102 = 0;\n  let remainder103 = 0;\n  let remainder104 = 0;\n  let remainder105 = 0;\n  let remainder106 = 0;\n  let remainder107 = 0;\n  let remainder108 = 0;\n  let remainder109 = 0;\n  let remainder110 = 0;\n  let remainder111 = 0;\n  let remainder112 = 0;\n  let remainder113 = 0;\n  let remainder114 = 0;\n  let remainder115 = 0;\n  let remainder116 = 0;\n  let remainder117 = 0;\n  let remainder118 = 0;\n  let remainder119 = 0;\n  let remainder120 = 0;\n  let remainder121 = 0;\n  let remainder122 = 0;\n  let remainder123 = 0;\n  let remainder124 = 0;\n  let remainder125 = 0;\n  let remainder126 = 0;\n  let remainder127 = 0;\n  let remainder128 = 0;\n  let remainder129 = 0;\n  let remainder130 = 0;\n  let remainder131 = 0;\n  let remainder132 = 0;\n  let remainder133 = 0;\n  let remainder134 = 0;\n  let remainder135 = 0;\n  let remainder136 = 0;\n  let remainder137 = 0;\n  let remainder138 = 0;\n  let remainder139 = 0;\n  let remainder140 = 0;\n  let remainder141 = 0;\n  let remainder142 = 0;\n  let remainder143 = 0;\n  let remainder144 = 0;\n  let remainder145 = 0;\n  let remainder146 = 0;\n  let remainder147 = 0;\n  let remainder148 = 0;\n  let remainder149 = 0;\n  let remainder150 = 0;\n  let remainder151 = 0;\n  let remainder152 = 0;\n  let remainder153 = 0;\n  let remainder154 = 0;\n  let remainder155 = 0;\n  let remainder156 = 0;\n  let remainder157 = 0;\n  let remainder158 = 0;\n  let remainder159 = 0;\n  let remainder160 = 0;\n  let remainder161 = 0;\n  let remainder162 = 0;\n  let remainder163 = 0;\n  let remainder164 = 0;\n  let remainder165 = 0;\n  let remainder166 = 0;\n  let remainder167 = 0;\n  let remainder168 = 0;\n  let remainder169 = 0;\n  let remainder170 = 0;\n  let remainder171 = 0;\n  let remainder172 = 0;\n  let remainder173 = 0;\n  let remainder174 = 0;\n  let remainder175 = 0;\n  let remainder176 = 0;\n  let remainder177 = 0;\n  let remainder178 = 0;\n  let remainder179 = 0;\n  let remainder180 = 0;\n  let remainder181 = 0;\n  let remainder182 = 0;\n  let remainder183 = 0;\n  let remainder184 = 0;\n  let remainder185 = 0;\n  let remainder186 = 0;\n  let remainder187 = 0;\n  let remainder188 = 0;\n  let remainder189 = 0;\n  let remainder190 = 0;\n  let remainder191 = 0;\n  let remainder192 = 0;\n  let remainder193 = 0;\n  let remainder194 = 0;\n  let remainder195 = 0;\n  let remainder196 = 0;\n  let remainder197 = 0;\n  let remainder198 = 0;\n  let remainder199 = 0;\n  let remainder200 = 0;\n  let remainder201 = 0;\n  let remainder202 = 0;\n  let remainder203 = 0;\n  let remainder204 = 0;\n  let remainder205 = 0;\n  let remainder206 = 0;\n  let remainder207 = 0;\n  let remainder208 = 0;\n  let remainder209 = 0;\n  let remainder210 = 0;\n  let remainder211 = 0;\n  let remainder212 = 0;\n  let remainder213 = 0;\n  let remainder214 = 0;\n  let remainder215 = 0;\n  let remainder216 = 0;\n  let remainder217 = 0;\n  let remainder218 = 0;\n  let remainder219 = 0;\n  let remainder220 = 0;\n  let remainder221 = 0;\n  let remainder222 = 0;\n  let remainder223 = 0;\n  let remainder224 = 0;\n  let remainder225 = 0;\n  let remainder226 = 0;\n  let remainder227 = 0;\n  let remainder228 = 0;\n  let remainder229 = 0;\n  let remainder230 = 0;\n  let remainder231 = 0;\n  let remainder232 = 0;\n  let remainder233 = 0;\n  let remainder234 = 0;\n  let remainder235 = 0;\n  let remainder236 = 0;\n  let remainder237 = 0;\n  let remainder238 = 0;\n  let remainder239 = 0;\n  let remainder240 = 0;\n  let remainder241 = 0;\n  let remainder24", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  considerUpper('aBCdEf') returns 1\n  considerUpper('abcdefg') returns 0\n  considerUpper('dBBE') returns 0\n  */\nconst considerUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "considerUpper", "gc": "<|endoftext|>/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  considerUpper('aBCdEf') returns 1\n  considerUpper('abcdefg') returns 0\n  considerUpper('dBBE') returns 0\n  */\nconst considerUpper = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/99", "prompt": "/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closeInteger(\"10\")\n  10\n  >>> closeInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closeInteger(\"14.5\") should\n  return 15 and closeInteger(\"-14.5\") should return -15.\n  */\nconst closeInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closeInteger", "gc": "<|endoftext|>/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closeInteger(\"10\")\n  10\n  >>> closeInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closeInteger(\"14.5\") should\n  return 15 and closeInteger(\"-14.5\") should return -15.\n  */\nconst closeInteger = (value) => {\n  const [integer, fraction] = value.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction] = integer.split(\".\");\n  const [integer, fraction", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
