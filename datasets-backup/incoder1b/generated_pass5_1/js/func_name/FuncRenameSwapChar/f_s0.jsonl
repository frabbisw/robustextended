{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> hasCloselEements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloselEements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloselEements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloselEements", "gc": "<|endoftext|>/* Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> hasCloselEements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloselEements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloselEements = (numbers, threshold) => {\n  const numbersList = numbers.map(n => Number(n))\n  const diffs = numbersList.map(n => Math.abs(n - numbersList[0]))\n  const diffsLength = diffs.reduce((acc, curr) => acc + curr, 0)\n  const diffsSum = diffs.reduce((acc, curr) => acc + curr, 0)\n  const diffsMean = diffs.reduce((acc, curr) => acc + curr, 0)\n  const diffsVariance = diffs.reduce((acc, curr) => acc + Math.pow(curr, 2), 0)\n  const diffsStdDev = diffs.reduce((acc, curr) => acc + Math.sqrt(curr), 0)\n  const diffsMax = diffs.reduce((acc, curr) => Math.max(acc, curr), -Infinity)\n  const diffsMin = diffs.reduce((acc, curr) => Math.min(acc, curr), Infinity)\n  const diffsMedian = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsMode = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeVariance = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeStdDev = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeMax = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeMin = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeMedian = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeMode = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeVariance = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeStdDev = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeMax = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeMin = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeMedian = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeMode = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeVariance = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeStdDev = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeMax = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeMin = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeMedian = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeMode = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeVariance = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeStdDev = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeMax = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeMin = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeMedian = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeMode = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeModeVariance = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeModeStdDev = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeModeMax = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeModeMin = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeModeMedian = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeModeMode = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeModeVariance = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeModeStdDev = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeModeMax = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeModeMin = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeModeMedian = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeModeMode = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeModeVariance = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeModeStdDev = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeModeMax = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeModeMin = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeModeMedian = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeModeMode = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeModeVariance = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeModeStdDev = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsModeModeModeModeMax = diffs.reduce((acc, curr) => Math.round((acc + (curr - acc) / 2) / 2), 0)\n  const diffsMode", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/1", "prompt": "/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> separateParenGrousp('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGrousp = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGrousp", "gc": "<|endoftext|>/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> separateParenGrousp('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGrousp = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]+)\\)/ig);\n  const paren_group_strings = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const paren_group = paren_groups[i];\n    const paren_group_string = '';\n    const paren_group_parens = paren_group.match(/\\(([^()]+)\\)/ig);\n    for (let j = 0; j < paren_group_parens.length; j++) {\n      const paren_group_paren = paren_group_parens[j];\n      const paren_group_paren_parens = paren_group_paren.match(/\\(([^()]+)\\)/ig);\n      for (let k = 0; k < paren_group_paren_parens.length; k++) {\n        const paren_group_paren_paren = paren_group_paren_parens[k];\n        const paren_group_paren_parens = paren_group_paren_paren.match(/\\(([^()]+)\\)/ig);\n        for (let l = 0; l < paren_group_paren_parens.length; l++) {\n          const paren_group_paren_paren = paren_group_paren_parens[l];\n          const paren_group_paren_parens = paren_group_paren_paren.match(/\\(([^()]+)\\)/ig);\n          for (let m = 0; m < paren_group_paren_parens.length; m++) {\n            const paren_group_paren_paren = paren_group_paren_parens[m];\n            const paren_group_paren_parens = paren_group_paren_paren.match(/\\(([^()]+)\\)/ig);\n            for (let n = 0; n < paren_group_paren_parens.length; n++) {\n              const paren_group_paren_paren = paren_group_paren_parens[n];\n              const paren_group_paren_parens = paren_group_paren_paren.match(/\\(([^()]+)\\)/ig);\n              for (let o = 0; o < paren_group_paren_parens.length; o++) {\n                const paren_group_paren_paren = paren_group_paren_parens[o];\n                const paren_group_paren_parens = paren_group_paren_paren.match(/\\(([^()]+)\\)/ig);\n                for (let p = 0; p < paren_group_paren_parens.length; p++) {\n                  const paren_group_paren_paren = paren_group_paren_parens[p];\n                  const paren_group_paren_parens = paren_group_paren_paren.match(/\\(([^()]+)\\)/ig);\n                  for (let q = 0; q < paren_group_paren_parens.length; q++) {\n                    const paren_group_paren_paren = paren_group_paren_parens[q];\n                    const paren_group_paren_parens = paren_group_paren_paren.match(/\\(([^()]+)\\)/ig);\n                    for (let r = 0; r < paren_group_paren_parens.length; r++) {\n                      const paren_group_paren_paren = paren_group_paren_parens[r];\n                      const paren_group_paren_parens = paren_group_paren_paren.match(/\\(([^()]+)\\)/ig);\n                      for (let s = 0; s < paren_group_paren_parens.length; s++) {\n                        const paren_group_paren_paren = paren_group_paren_parens[s];\n                        const paren_group_paren_parens = paren_group_paren_paren.match(/\\(([^()]+)\\)/ig);\n                        for (let t = 0; t < paren_group_paren_parens.length; t++) {\n                          const paren_group_paren_paren = paren_group_paren_parens[t];\n                          const paren_group_paren_parens = paren_group_paren_paren.match(/\\(([^()]+)\\)/ig);\n                          for (let u = 0; u < paren_group_paren_parens.length; u++) {\n                            const paren_group_paren_paren = paren_group_paren_parens[u];\n                            const paren_group_paren_parens = paren_group_paren_paren.match(/\\(([^()]+)\\)/ig);\n                            for (let v = 0; v < paren_group_paren_parens.length; v++) {\n                              const paren_group_paren_paren = paren_group_paren_parens[v];\n                              const paren_group_paren_parens = paren_group_paren_paren.match(/\\(([^()]+)\\)/ig);\n                              for (let w = 0; w < paren_group_paren_parens.length; w++) {\n                                const paren_group_paren_paren = paren_group_paren_parens[w];\n                                const paren_group_paren_parens = paren_group_paren_paren.match(/\\(([^()]+)\\)/ig);\n                                for (let x = 0; x < paren_group_paren_parens.length; x++) {\n                                  const paren_group_paren_paren = paren_group_paren_parens[x];\n                                  const paren_group_paren_parens = paren_group_paren_paren.match(/\\(([^()]+)\\)/ig);\n                                  for (let y = 0; y < paren_group_paren_parens.length; y++) {\n                                    const paren_group_paren_paren = paren_group_paren_parens[y];\n                                    const paren_group_paren_parens = paren_group_paren_paren.match(/\\(([^()]+)\\)/ig);\n                                    for (let z = 0; z < paren_group_paren_parens.length; z++) {\n                                      const paren_group_paren_paren = paren_group_paren_parens[z];\n                                      const paren_group_paren_parens = paren_group_paren_paren.match(/\\(([^()]+)\\)/ig);\n                                      for (let a = 0; a < paren_group_paren_parens.length; a++) {\n                                        const paren_group_paren_paren = paren_group_paren_parens[a];\n                                        const paren_group_paren_parens = paren_group_paren_paren.match(/\\(([^()]+)\\)/ig);\n                                        for (let b = 0; b < paren_group_paren_parens.length; b++) {\n                                          const paren_group_paren_paren = paren_group_paren_parens[b];\n                                          const paren_group_paren_parens = paren_group_paren_paren.match(/\\(([^()]+)\\)/ig);\n                                          for (let c = 0; c < paren_group_paren_parens.length; c++) {\n                                            const paren_group_paren_paren = paren_group_paren_parens[c];\n                                            const paren_group_paren_parens = paren_group_paren_paren.match(/\\(([^()]+)\\)/ig);\n                                            for (let d = 0; d < paren_group_paren_parens.length; d++) {\n                                              const paren_group_paren_paren = paren_group_paren_parens[d];\n                                              const paren_group_paren_parens = paren_group_paren_paren.match(/\\(([^()]+)\\)/ig);\n                                              for (let e = 0; e < paren_group_paren_parens.length; e++) {\n                                                const paren_group_paren_paren = paren_group_paren_parens[e];\n                                                const paren_group_paren_parens = paren_group_paren_paren.", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "gc": "<|endoftext|>/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPalindromeLength = 0;\n  let longestPalindromeSuffix = '';\n  let longestPalindromePrefix = '';\n  let longestPalindromeSuffixLength = 0;\n\n  for (let i = string.length - 1; i >= 0; i--) {\n    if (isPalindrome(string[i])) {\n      longestPalindrome = string[i];\n      longestPalindromeLength = string[i].length;\n      longestPalindromeSuffix = string[i].substr(0, longestPalindromeLength);\n      longestPalindromePrefix = string[i].substr(longestPalindromeLength);\n      longestPalindromeSuffixLength = longestPalindromeSuffix.length;\n    }\n  }\n\n  if (longestPalindromeLength > longestPalindromeSuffixLength) {\n    longestPalindromeSuffix = longestPalindromeSuffix.split('').reverse().join('');\n  }\n\n  if (longestPalindromeLength > longestPalindromePrefixLength) {\n    longestPalindromePrefix = longestPalindromePrefix.split('').reverse().join('');\n  }\n\n  return longestPalindromePrefix + longestPalindromeSuffix;\n}\n\n/* Given a string, find the longest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> longestPalindrome('cat')\n  'catac'\n  >>> longestPalindrome('cata')\n  'catac'\n  */\nconst longestPalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPalindromeLength = 0;\n  let longestPalindromeSuffix = '';\n  let longestPalindromePrefix = '';\n  let longestPalindromeSuffixLength = 0;\n\n  for (let i = string.length - 1; i >= 0; i--) {\n    if (isPalindrome(string[i])) {\n      longestPalindrome = string[i];\n      longestPalindromeLength = string[i].length;\n      longestPalindromeSuffix = string[i].substr(0, longestPalindromeLength);\n      longestPalindromePrefix = string[i].substr(longestPalindromeLength);\n      longestPalindromeSuffixLength = longestPalindromeSuffix.length;\n    }\n  }\n\n  if (longestPalindromeLength > longestPalindromeSuffixLength) {\n    longestPalindromeSuffix = longestPalindromeSuffix.split('').reverse().join('');\n  }\n\n  if (longestPalindromeLength > longestPalindromePrefixLength) {\n    longestPalindromePrefix = longestPalindromePrefix.split('').reverse().join('');\n  }\n\n  return longestPalindromePrefix + longestPalindromeSuffix;\n}\n\n/* Given a string, find the longest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> longestPalindrome('cat')\n  'catac'\n  >>> longestPalindrome('cata')\n  'catac'\n  */\nconst longestPalindromeWithPalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPalindromeLength = 0;\n  let longestPalindromeSuffix = '';\n  let longestPalindromePrefix = '';\n  let longestPalindromeSuffixLength = 0;\n\n  for (let i = string.length - 1; i >= 0; i--) {\n    if (isPalindrome(string[i])) {\n      longestPalindrome = string[i];\n      longestPalindromeLength = string[i].length;\n      longestPalindromeSuffix = string[i].substr(0, longestPalindromeLength);\n      longestPalindromePrefix = string[i].substr(longestPalindromeLength);\n      longestPalindromeSuffixLength = longestPalindromeSuffix.length;\n    }\n  }\n\n  if (longestPalindromeLength > longestPalindromeSuffixLength) {\n    longestPalindromeSuffix = longestPalindromeSuffix.split('').reverse().join('');\n  }\n\n  if (longestPalindromeLength > longestPalindromePrefixLength) {\n    longestPalindromePrefix = longestPalindromePrefix.split('').reverse().join('');\n  }\n\n  return longestPalindromePrefix + longestPalindromeSuffix;\n}\n\n/* Given a string, find the longest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> longestPalindrome('cat')\n  'catac'\n  >>> longestPalindrome('cata')\n  'catac'\n  */\nconst longestPalindromeWithPalindromeWithPalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPalindromeLength = 0;\n  let longestPalindromeSuffix = '';\n  let longestPalindromePrefix = '';\n  let longestPalindromeSuffixLength = 0;\n\n  for (let i = string.length - 1; i >= 0; i--) {\n    if (isPalindrome(string[i])) {\n      longestPalindrome = string[i];\n      longestPalindromeLength = string[i].length;\n      longestPalindromeSuffix = string[i].substr(0, longestPalindromeLength);\n      longestPalindromePrefix = string[i].substr(longestPalindromeLength);\n      longestPalindromeSuffixLength = longestPalindromeSuffix.length;\n    }\n  }\n\n  if (longestPalindromeLength > longestPalindromeSuffixLength) {\n    longestPalindromeSuffix = longestPalindromeSuffix.split('').reverse().join('');\n  }\n\n  if (longestPalindromeLength > longestPalindromePrefixLength) {\n    longestPalindromePrefix = longestPalindromePrefix.split('').reverse().join('');\n  }\n\n  return longestPalindromePrefix + longestPalindromeSuffix;\n}\n\n/* Given a string, find the longest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "gc": "<|endoftext|>/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    const stones = makeAPileStones(i);\n    result.push(stones);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPileStones(3)\n  [3, 5, 7]\n  */\nconst makeAPileStones = (index) => {\n  const result = [];\n  for (let i = 0; i < index; i++) {\n    const stones = makeAPileStonesStones(i);\n    result.push(stones);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPileStones(3)\n  [3, 5, 7]\n  */\nconst makeAPileStonesStones = (index) => {\n  const result = [];\n  for (let i = 0; i < index; i++) {\n    const stones = makeAPileStonesStonesStones(i);\n    result.push(stones);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPileStones(3)\n  [3, 5, 7]\n  */\nconst makeAPileStonesStonesStones = (index) => {\n  const result = [];\n  for (let i = 0; i < index; i++) {\n    const stones = makeAPileStonesStonesStonesStones(i);\n    result.push(stones);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPileStones(3)\n  [3, 5, 7]\n  */\nconst makeAPileStonesStonesStonesStones = (index) => {\n  const result = [];\n  for (let i = 0; i < index; i++) {\n    const stones = makeAPileStonesStonesStonesStonesStones(i);\n    result.push(stones);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPileStones(3)\n  [3, 5, 7]\n  */\nconst makeAPileStonesStonesStonesStonesStones = (index) => {\n  const result = [];\n  for (let i = 0; i < index; i++) {\n    const stones = makeAPileStonesStonesStonesStonesStonesStones(i);\n    result.push(stones);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPileStones(3)\n  [3, 5, 7]\n  */\nconst makeAPileStonesStonesStonesStonesStonesStones = (index) => {\n  const result = [];\n  for (let i = 0; i < index; i++) {\n    const stones = makeAPileStonesStonesStonesStonesStonesStonesStones(i);\n    result.push(stones);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPileStones(3)\n  [3, 5, 7]\n  */\nconst makeAPileStonesStonesStonesStonesStonesStonesStones = (index) => {\n  const result = [];\n  for (let i = 0; i < index; i++) {\n    const stones = makeAPileStonesStonesStonesStonesStonesStonesStonesStones(i);\n    result.push(stones);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPileStones(3)\n  [3, 5, 7]\n  */\nconst makeAPileStonesStonesStonesStonesStonesStonesStonesStones = (index) => {\n  const result = [];\n  for (let i = 0; i < index; i++) {\n    const stones = makeAPileStonesStonesStonesStonesStonesStonesStonesStonesStonesStones(i);\n    result.push(stones);\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "gc": "<|endoftext|>/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words. Your function should\n  return a new array without duplicates.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsStringNoDupes = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words.filter((v, i, a) => a.indexOf(v) === i);\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words. Your function should\n  return a new array without duplicates.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsStringNoDupes2 = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words.filter((v, i, a) => a.indexOf(v) === i && a.indexOf(v) === a.lastIndexOf(v));\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words. Your function should\n  return a new array without duplicates.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsStringNoDupes3 = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words.filter((v, i, a) => a.indexOf(v) === i && a.indexOf(v) === a.lastIndexOf(v) && a.indexOf(v) === a.lastIndexOf(v));\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words. Your function should\n  return a new array without duplicates.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsStringNoDupes4 = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words.filter((v, i, a) => a.indexOf(v) === i && a.indexOf(v) === a.lastIndexOf(v) && a.indexOf(v) === a.lastIndexOf(v) && a.indexOf(v) === a.lastIndexOf(v));\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words. Your function should\n  return a new array without duplicates.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsStringNoDupes5 = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words.filter((v, i, a) => a.indexOf(v) === i && a.indexOf(v) === a.lastIndexOf(v) && a.indexOf(v) === a.lastIndexOf(v) && a.indexOf(v) === a.lastIndexOf(v) && a.indexOf(v) === a.lastIndexOf(v));\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words. Your function should\n  return a new array without duplicates.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsStringNoDupes6 = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words.filter((v, i, a) => a.indexOf(v) === i && a.indexOf(v) === a.lastIndexOf(v) && a.indexOf(v) === a.lastIndexOf(v) && a.indexOf(v) === a.lastIndexOf(v) && a.indexOf(v) === a.lastIndexOf(v) && a.indexOf(v) === a.lastIndexOf(v));\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words. Your function should\n  return a new array without duplicates.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsStringNoDupes7 = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words.filter((v, i, a) => a.indexOf(v) === i && a.indexOf(v) === a.lastIndexOf(v) && a.indexOf(v) === a.lastIndexOf(v) && a.indexOf(v) === a.lastIndexOf(v) && a.indexOf(v) === a.lastIndexOf(v) && a.indexOf(v) === a.lastIndexOf(v) && a.indexOf(v) === a.lastIndexOf(v));\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words. Your function should\n  return a new array without duplicates.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsStringNoDupes8 = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words.filter((v, i, a) => a.indexOf(v) === i && a.indexOf(v) === a.lastIndexOf(v) && a.indexOf(v) === a.lastIndexOf(v) && a.indexOf(v) === a.lastIndexOf(v) && a.indexOf(v) === a.lastIndexOf(v) && a.indexOf(v) === a.lastIndexOf(v) && a.indexOf(v) === a.lastIndexOf(v) && a.indexOf(v) === a.lastIndexOf(v));\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words. Your function should\n  return a new ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "gc": "<|endoftext|>/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  let num;\n  if (x === 0 && y === 0) {\n    return -1;\n  }\n  if (x === 0 && y === 1) {\n    return x;\n  }\n  if (x === 1 && y === 0) {\n    return y;\n  }\n  if (x === 1 && y === 1) {\n    return x;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 0) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 1 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (x % 2 === 0 && y % 2 === 1) {\n    return chooseNum(x / 2, y / 2);\n  }\n  if (", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/103", "prompt": "/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "gc": "<|endoftext|>/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  let binNum = 0;\n  let binNumStr = \"\";\n  let binNumStr2 = \"\";\n  let binNumStr3 = \"\";\n  let binNumStr4 = \"\";\n  let binNumStr5 = \"\";\n  let binNumStr6 = \"\";\n  let binNumStr7 = \"\";\n  let binNumStr8 = \"\";\n  let binNumStr9 = \"\";\n  let binNumStr10 = \"\";\n  let binNumStr11 = \"\";\n  let binNumStr12 = \"\";\n  let binNumStr13 = \"\";\n  let binNumStr14 = \"\";\n  let binNumStr15 = \"\";\n  let binNumStr16 = \"\";\n  let binNumStr17 = \"\";\n  let binNumStr18 = \"\";\n  let binNumStr19 = \"\";\n  let binNumStr20 = \"\";\n  let binNumStr21 = \"\";\n  let binNumStr22 = \"\";\n  let binNumStr23 = \"\";\n  let binNumStr24 = \"\";\n  let binNumStr25 = \"\";\n  let binNumStr26 = \"\";\n  let binNumStr27 = \"\";\n  let binNumStr28 = \"\";\n  let binNumStr29 = \"\";\n  let binNumStr30 = \"\";\n  let binNumStr31 = \"\";\n  let binNumStr32 = \"\";\n  let binNumStr33 = \"\";\n  let binNumStr34 = \"\";\n  let binNumStr35 = \"\";\n  let binNumStr36 = \"\";\n  let binNumStr37 = \"\";\n  let binNumStr38 = \"\";\n  let binNumStr39 = \"\";\n  let binNumStr40 = \"\";\n  let binNumStr41 = \"\";\n  let binNumStr42 = \"\";\n  let binNumStr43 = \"\";\n  let binNumStr44 = \"\";\n  let binNumStr45 = \"\";\n  let binNumStr46 = \"\";\n  let binNumStr47 = \"\";\n  let binNumStr48 = \"\";\n  let binNumStr49 = \"\";\n  let binNumStr50 = \"\";\n  let binNumStr51 = \"\";\n  let binNumStr52 = \"\";\n  let binNumStr53 = \"\";\n  let binNumStr54 = \"\";\n  let binNumStr55 = \"\";\n  let binNumStr56 = \"\";\n  let binNumStr57 = \"\";\n  let binNumStr58 = \"\";\n  let binNumStr59 = \"\";\n  let binNumStr60 = \"\";\n  let binNumStr61 = \"\";\n  let binNumStr62 = \"\";\n  let binNumStr63 = \"\";\n  let binNumStr64 = \"\";\n  let binNumStr65 = \"\";\n  let binNumStr66 = \"\";\n  let binNumStr67 = \"\";\n  let binNumStr68 = \"\";\n  let binNumStr69 = \"\";\n  let binNumStr70 = \"\";\n  let binNumStr71 = \"\";\n  let binNumStr72 = \"\";\n  let binNumStr73 = \"\";\n  let binNumStr74 = \"\";\n  let binNumStr75 = \"\";\n  let binNumStr76 = \"\";\n  let binNumStr77 = \"\";\n  let binNumStr78 = \"\";\n  let binNumStr79 = \"\";\n  let binNumStr80 = \"\";\n  let binNumStr81 = \"\";\n  let binNumStr82 = \"\";\n  let binNumStr83 = \"\";\n  let binNumStr84 = \"\";\n  let binNumStr85 = \"\";\n  let binNumStr86 = \"\";\n  let binNumStr87 = \"\";\n  let binNumStr88 = \"\";\n  let binNumStr89 = \"\";\n  let binNumStr90 = \"\";\n  let binNumStr91 = \"\";\n  let binNumStr92 = \"\";\n  let binNumStr93 = \"\";\n  let binNumStr94 = \"\";\n  let binNumStr95 = \"\";\n  let binNumStr96 = \"\";\n  let binNumStr97 = \"\";\n  let binNumStr98 = \"\";\n  let binNumStr99 = \"\";\n  let binNumStr100 = \"\";\n  let binNumStr101 = \"\";\n  let binNumStr102 = \"\";\n  let binNumStr103 = \"\";\n  let binNumStr104 = \"\";\n  let binNumStr105 = \"\";\n  let binNumStr106 = \"\";\n  let binNumStr107 = \"\";\n  let binNumStr108 = \"\";\n  let binNumStr109 = \"\";\n  let binNumStr110 = \"\";\n  let binNumStr111 = \"\";\n  let binNumStr112 = \"\";\n  let binNumStr113 = \"\";\n  let binNumStr114 = \"\";\n  let binNumStr115 = \"\";\n  let binNumStr116 = \"\";\n  let binNumStr117 = \"\";\n  let binNumStr118 = \"\";\n  let binNumStr119 = \"\";\n  let binNumStr120 = \"\";\n  let binNumStr121 = \"\";\n  let binNumStr122 = \"\";\n  let binNumStr123 = \"\";\n  let binNumStr124 = \"\";\n  let binNumStr125 = \"\";\n  let binNumStr126 = \"\";\n  let binNumStr127 = \"\";\n  let binNumStr128 = \"\";\n  let binNumStr129 = \"\";\n  let binNumStr130 = \"\";\n  let binNumStr131 = \"\";\n  let binNumStr132 = \"\";\n  let binNumStr133 = \"\";\n  let binNumStr134 = \"\";\n  let binNumStr135 = \"\";\n  let binNumStr136 = \"\";\n  let binNumStr137 = \"\";\n  let binNumStr138 = \"\";\n  let binNumStr139 = \"\";\n  let binNumStr140 = \"\";\n  let binNumStr141 = \"\";\n  let binNumStr142 = \"\";\n  let binNumStr143 = \"\";\n  let binNumStr144 = \"\";\n  let binNumStr145 = \"\";\n  let binNumStr146 = \"\";\n  let binNumStr147 = \"\";\n  let binNumStr148 = \"\";\n  let binNumStr149 = \"\";\n  let binNumStr150 = \"\";\n  let binNumStr151 = \"\";\n  let binNumStr152 = \"\";\n  let binNumStr153 = \"\";\n  let binNumStr154 = \"\";\n  let binNumStr155 = \"\";\n  let binNumStr156 = \"\";\n  let binNumStr157 = \"\";\n  let binNumStr158 = \"\";\n  let binNumStr159 = \"\";\n  let binNumStr160 = \"\";\n  let binNumStr161 = \"\";\n  let binNumStr162 = \"\";\n  let binNumStr163 = \"\";\n  let binNumStr164 = \"\";\n  let binNumStr165 = \"\";\n  let binNumStr166 = \"\";\n  let binNumStr167 = \"\";\n  let binNumStr168 = \"\";\n  let binNumStr169 = \"\";\n  let binNumStr170 = \"\";\n  let binNumStr171 = \"\";\n  let binNumStr172 = \"\";\n  let binNumStr173 = \"\";\n  let binNumStr174 = \"\";\n  let binNumStr175 = \"\";\n  let binNumStr176 = \"\";\n  let binNumStr177 = \"\";\n  let binNumStr178 = \"\";\n  let binNumStr179 = \"\";\n  let binNumStr180 = \"\";\n  let binNumStr181 = \"\";\n  let binNumStr182 = \"\";\n  let binNumStr183 = \"\";\n  let binNumStr184 = \"\";\n  let binNumStr185 = \"\";\n  let binNumStr186 = \"\";\n  let binNumStr187 = \"\";\n  let binNumStr188 = \"\";\n  let binNumStr189 = \"\";\n  let bin", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueDigtis([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigtis([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigtis = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigtis", "gc": "<|endoftext|>/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueDigtis([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigtis([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigtis = (x) => {\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < x.length) {\n    if (x[i] % 2 === 0) {\n      result.push(x[i])\n      i++\n    } else {\n      j++\n    }\n  }\n  while (j < x.length) {\n    if (x[j] % 2 === 0) {\n      result.push(x[j])\n      j++\n    } else {\n      k++\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueDigtis([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueDigtis([152, 323, 1422, 10])\n  []\n  */\nconst uniqueEvenDigtis = (x) => {\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < x.length) {\n    if (x[i] % 2 === 0) {\n      result.push(x[i])\n      i++\n    } else {\n      j++\n    }\n  }\n  while (j < x.length) {\n    if (x[j] % 2 === 0) {\n      result.push(x[j])\n      j++\n    } else {\n      k++\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any odd digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueEvenDigtis([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueEvenDigtis([152, 323, 1422, 10])\n  []\n  */\nconst uniqueOddDigtis = (x) => {\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < x.length) {\n    if (x[i] % 2 === 0) {\n      result.push(x[i])\n      i++\n    } else {\n      j++\n    }\n  }\n  while (j < x.length) {\n    if (x[j] % 2 === 0) {\n      result.push(x[j])\n      j++\n    } else {\n      k++\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any multiple of 2 digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueOddDigtis([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueOddDigtis([152, 323, 1422, 10])\n  []\n  */\nconst uniqueMultipleDigtis = (x) => {\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < x.length) {\n    if (x[i] % 2 === 0) {\n      result.push(x[i])\n      i++\n    } else {\n      j++\n    }\n  }\n  while (j < x.length) {\n    if (x[j] % 2 === 0) {\n      result.push(x[j])\n      j++\n    } else {\n      k++\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any multiple of 3 digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueMultipleDigtis([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueMultipleDigtis([152, 323, 1422, 10])\n  []\n  */\nconst uniqueMultipleDigits3 = (x) => {\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < x.length) {\n    if (x[i] % 3 === 0) {\n      result.push(x[i])\n      i++\n    } else {\n      j++\n    }\n  }\n  while (j < x.length) {\n    if (x[j] % 3 === 0) {\n      result.push(x[j])\n      j++\n    } else {\n      k++\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any multiple of 4 digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueMultipleDigits3([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueMultipleDigits3([152, 323, 1422, 10])\n  []\n  */\nconst uniqueMultipleDigits4 = (x) => {\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < x.length) {\n    if (x[i] % 4 === 0) {\n      result.push(x[i])\n      i++\n    } else {\n      j++\n    }\n  }\n  while (j < x.length) {\n    if (x[j] % 4 === 0) {\n      result.push(x[j])\n      j++\n    } else {\n      k++\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any multiple of 5 digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueMultipleDigits4([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueMultipleDigits4([152, 323, 1422, 10])\n  []\n  */\nconst uniqueMultipleDigits5 = (x) => {\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < x.length) {\n    if (x[i] % 5 === 0) {\n      result.push(x[i])\n      i++\n    } else {\n      j++\n    }\n  }\n  while (j < x.length) {\n    if (x[j] % 5 === 0) {\n      result.push(x[j])\n      j++\n    } else {\n      k++\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any multiple of 6 digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueMultipleDigits5([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueMultipleDigits5([152, 323, 1422, 10])\n  []\n  */\nconst uniqueMultipleDigits6 = (x) => {\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < x.length) {\n    if (x[i] % 6 === 0) {\n      result.push(x[i])\n      i++\n    } else {\n      j++\n    }\n  }\n  while (j < x.length) {\n    if (x[j] % 6 === 0) {\n      result.push(x[j])\n      j++\n    } else {\n      k++\n    }\n  }\n  return result\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any multiple of 7 digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueMultipleDigits6([15, 33, 1422, 1])\n  [15, 33, 1422]\n  >>> uniqueMultipleDigits6([152, 323, 1422, 10])\n  []\n  */\nconst uniqueMultipleDigits7 = (x) => {\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < x.length) {\n    if (x[i] % 7 === 0) {\n      result.push(x[i])\n      i++\n    } else {\n      j++\n    }\n  }\n  while (j < x.length) {\n    if (x[j] % 7 === 0) {", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 3, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst ybLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "ybLength", "gc": "<|endoftext|>/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst ybLength = (arr) => {\n  const len = arr.length;\n  const reversed = arr.slice().reverse();\n  const reversedLen = reversed.length;\n  const reversedArr = reversed.map((val, index) => val.toString().padStart(len, '0'));\n  return reversedArr.join(\"\");\n};\n\nconst ybSort = (arr) => {\n  const reversed = arr.slice().reverse();\n  const reversedLen = reversed.length;\n  const reversedArr = reversed.map((val, index) => val.toString().padStart(len, '0'));\n  return reversedArr.join(\"\");\n};\n\nconst ybReverse = (arr) => {\n  const reversed = arr.slice().reverse();\n  const reversedLen = reversed.length;\n  const reversedArr = reversed.map((val, index) => val.toString().padStart(len, '0'));\n  return reversedArr.join(\"\");\n};\n\nconst ybReverseReverse = (arr) => {\n  const reversed = arr.slice().reverse();\n  const reversedLen = reversed.length;\n  const reversedArr = reversed.map((val, index) => val.toString().padStart(len, '0'));\n  return reversedArr.join(\"\");\n};\n\nconst ybReverseReverseReverse = (arr) => {\n  const reversed = arr.slice().reverse();\n  const reversedLen = reversed.length;\n  const reversedArr = reversed.map((val, index) => val.toString().padStart(len, '0'));\n  return reversedArr.join(\"\");\n};\n\nconst ybReverseReverseReverseReverse = (arr) => {\n  const reversed = arr.slice().reverse();\n  const reversedLen = reversed.length;\n  const reversedArr = reversed.map((val, index) => val.toString().padStart(len, '0'));\n  return reversedArr.join(\"\");\n};\n\nconst ybReverseReverseReverseReverseReverse = (arr) => {\n  const reversed = arr.slice().reverse();\n  const reversedLen = reversed.length;\n  const reversedArr = reversed.map((val, index) => val.toString().padStart(len, '0'));\n  return reversedArr.join(\"\");\n};\n\nconst ybReverseReverseReverseReverseReverseReverseReverse = (arr) => {\n  const reversed = arr.slice().reverse();\n  const reversedLen = reversed.length;\n  const reversedArr = reversed.map((val, index) => val.toString().padStart(len, '0'));\n  return reversedArr.join(\"\");\n};\n\nconst ybReverseReverseReverseReverseReverseReverseReverseReverse = (arr) => {\n  const reversed = arr.slice().reverse();\n  const reversedLen = reversed.length;\n  const reversedArr = reversed.map((val, index) => val.toString().padStart(len, '0'));\n  return reversedArr.join(\"\");\n};\n\nconst ybReverseReverseReverseReverseReverseReverseReverseReverseReverse = (arr) => {\n  const reversed = arr.slice().reverse();\n  const reversedLen = reversed.length;\n  const reversedArr = reversed.map((val, index) => val.toString().padStart(len, '0'));\n  return reversedArr.join(\"\");\n};\n\nconst ybReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = (arr) => {\n  const reversed = arr.slice().reverse();\n  const reversedLen = reversed.length;\n  const reversedArr = reversed.map((val, index) => val.toString().padStart(len, '0'));\n  return reversedArr.join(\"\");\n};\n\nconst ybReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = (arr) => {\n  const reversed = arr.slice().reverse();\n  const reversedLen = reversed.length;\n  const reversedArr = reversed.map((val, index) => val.toString().padStart(len, '0'));\n  return reversedArr.join(\"\");\n};\n\nconst ybReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = (arr) => {\n  const reversed = arr.slice().reverse();\n  const reversedLen = reversed.length;\n  const reversedArr = reversed.map((val, index) => val.toString().padStart(len, '0'));\n  return reversedArr.join(\"\");\n};\n\nconst ybReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = (arr) => {\n  const reversed = arr.slice().reverse();\n  const reversedLen = reversed.length;\n  const reversedArr = reversed.map((val, index) => val.toString().padStart(len, '0'));\n  return reversedArr.join(\"\");\n};\n\nconst ybReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = (arr) => {\n  const reversed = arr.slice().reverse();\n  const reversedLen = reversed.length;\n  const reversedArr = reversed.map((val, index) => val.toString().padStart(len, '0'));\n  return reversedArr.join(\"\");\n};\n\nconst ybReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = (arr) => {\n  const reversed = arr.slice().reverse();\n  const reversedLen = reversed.length;\n  const reversedArr = reversed.map((val, index) => val.toString().padStart(len, '0'));\n  return reversedArr.join(\"\");\n};\n\nconst ybReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = (arr) => {\n  const reversed = arr.slice().reverse();\n  const reversedLen = reversed.length;\n  const reversedArr = reversed.map((val, index) => val.toString().padStart(len, '0'));\n  return reversedArr.join(\"\");\n};\n\nconst ybReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = (arr) => {\n  const reversed = arr.slice().reverse();\n  const reversedLen = reversed.length;\n  const reversedArr = reversed.map((val, index) => val.toString().padStart(len, '0'));\n  return reversedArr.join(\"\");\n};\n\nconst ybReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = (arr) => {\n  const reversed = arr.slice().reverse();\n  const reversedLen = reversed.length;\n  const reversedArr = reversed.map((val, index) => val.toString().padStart(len, '0'));\n  return reversedArr.join(\"\");\n};\n\nconst ybReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = (arr) => {\n  const reversed = arr.slice().reverse();\n  const reversedLen = reversed.length;\n  const reversedArr = reversed.map((val, index) => val.toString().padStart(len, '0'));\n  return reversedArr.join(\"\");\n};\n\nconst ybReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = (arr) => {", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/106", "prompt": "/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "gc": "<|endoftext|>/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    const factor = Math.floor(i * Math.sqrt(i));\n    result.push(factor);\n  }\n  return result;\n};\n\n/* Implement the function g that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  g(5) == [1, 2, 6, 24, 15]\n  */\nconst g = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    const gcd = Math.floor(Math.sqrt(i));\n    const remainder = i % gcd;\n    if (remainder!== 0) {\n      result.push(gcd);\n    }\n  }\n  return result;\n};\n\n/* Implement the function h that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the least common multiple of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the least common multiple of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  h(5) == [1, 2, 6, 24, 15]\n  */\nconst h = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    const lcm = Math.floor(Math.sqrt(i));\n    const remainder = i % lcm;\n    if (remainder!== 0) {\n      result.push(lcm);\n    }\n  }\n  return result;\n};\n\n/* Implement the function i that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the sum of numbers from 1 to i is the sum of numbers from 1 to i (1 + 2 + 3 +... + i).\n  Example:\n  i(5) == [1, 2, 6, 24, 15]\n  */\nconst i = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    const sum = i + 1;\n    result.push(sum);\n  }\n  return result;\n};\n\n/* Implement the function j that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the sum of numbers from 1 to i is the sum of numbers from 1 to i (1 + 2 + 3 +... + i).\n  Example:\n  j(5) == [1, 2, 6, 24, 15]\n  */\nconst j = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    const sum = i + 1;\n    result.push(sum);\n  }\n  return result;\n};\n\n/* Implement the function k that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the sum of numbers from 1 to i is the sum of numbers from 1 to i (1 + 2 + 3 +... + i).\n  Example:\n  k(5) == [1, 2, 6, 24, 15]\n  */\nconst k = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    const sum = i + 1;\n    result.push(sum);\n  }\n  return result;\n};\n\n/* Implement the function l that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the sum of numbers from 1 to i is the sum of numbers from 1 to i (1 + 2 + 3 +... + i).\n  Example:\n  l(5) == [1, 2, 6, 24, 15]\n  */\nconst l = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    const sum = i + 1;\n    result.push(sum);\n  }\n  return result;\n};\n\n/* Implement the function m that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the sum of numbers from 1 to i is the sum of numbers from 1 to i (1 + 2 + 3 +... + i).\n  Example:\n  m(5) == [1, 2, 6, 24, 15]\n  */\nconst m = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    const sum = i + 1;\n    result.push(sum);\n  }\n  return result;\n};\n\n/* Implement the function n that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the sum of numbers from 1 to i is the sum of numbers from 1 to i (1 + 2 + 3 +... + i).\n  Example:\n  n(5) == [1, 2, 6, 24, 15]\n  */\nconst n = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    const sum = i + 1;\n    result.push(sum);\n  }\n  return result;\n};\n\n/* Implement the function o that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the sum of numbers from 1 to i is the sum of numbers from 1 to i (1 + 2 + 3 +... + i).\n  Example:\n  o(5) == [1, 2, 6, 24, 15]\n  */\nconst o = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    const sum = i + 1;\n    result.push(sum);\n  }\n  return result;\n};\n\n/* Implement the function p that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the sum of numbers from 1 to i is the sum of numbers from 1 to i (1 + 2 + 3 +... + i).\n  Example:\n  p(5) == [1, 2, 6, 24, 15]\n  */\nconst p = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    const sum = i + 1;\n    result.push(sum);\n  }\n  return result;\n};\n\n/* Implement the function q that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the sum of numbers from 1 to i is the sum of numbers from 1 to i (1 + 2 + 3 +... + i).\n  Example:\n  q(5) == [1, 2, 6, 24, 15]\n  */\nconst q = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    const sum = i + 1;\n    result.push(sum);\n  }\n  return result;\n};\n\n/* Implement the function r that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the sum of numbers from 1 to i is the sum of numbers from 1 to i (1 + 2 + 3 +... + i).\n  Example:\n  r(5) == [1, 2, 6, 24, 15]\n  */\nconst r = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    const sum = i + 1;\n    result.push(sum);\n  }\n  return result;\n};\n\n/* Implement the function t that takes n as a parameter,\n  and returns a list of size n, such ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "gc": "<|endoftext|>/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  let even = 0;\n  let odd = 0;\n  let evenOddPalindromes = [];\n  let oddOddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      even++;\n    } else {\n      odd++;\n    }\n    if (even % 2 === 0) {\n      evenOddPalindromes.push(even);\n      even = 0;\n    }\n    if (odd % 2 === 0) {\n      oddOddPalindromes.push(odd);\n      odd = 0;\n    }\n  }\n  return [evenOddPalindromes, oddOddPalindromes];\n};\n\n/*\n  Given a positive integer n, return an integer array containing all possible palindromes.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1 <= n <= 10^3\n      All palindromes are unique.\n*/\nconst palindromes = (n) => {\n  let palindromes = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      palindromes.push(i);\n    }\n  }\n  return palindromes;\n};\n\n/*\n  Given a positive integer n, return an integer array containing all possible palindromes of length n.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1 <= n <= 10^3\n      All palindromes are unique.\n*/\nconst palindromesLength = (n) => {\n  let palindromes = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      palindromes.push(i);\n    }\n  }\n  return palindromes;\n};\n\n/*\n  Given a positive integer n, return an integer array containing all possible palindromes of length n.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1 <= n <= 10^3\n      All palindromes are unique.\n*/\nconst palindromesLengthAndPalindromes = (n) => {\n  let palindromes = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      palindromes.push(i);\n    }\n  }\n  return palindromes;\n};\n\n/*\n  Given a positive integer n, return an integer array containing all possible palindromes of length n.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1 <= n <= 10^3\n      All palindromes are unique.\n*/\nconst palindromesLengthAndPalindromesLength = (n) => {\n  let palindromes = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      palindromes.push(i);\n    }\n  }\n  return palindromes;\n};\n\n/*\n  Given a positive integer n, return an integer array containing all possible palindromes of length n.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1 <= n <= 10^3\n      All palindromes are unique.\n*/\nconst palindromesLengthAndPalindromesLengthAndPalindromes = (n) => {\n  let palindromes = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      palindromes.push(i);\n    }\n  }\n  return palindromes;\n};\n\n/*\n  Given a positive integer n, return an integer array containing all possible palindromes of length n.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1 <= n <= 10^3\n      All palindromes are unique.\n*/\nconst palindromesLengthAndPalindromesLengthAndPalindromesLength = (n) => {\n  let palindromes = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      palindromes.push(i);\n    }\n  }\n  return palindromes;\n};\n\n/*\n  Given a positive integer n, return an integer array containing all possible palindromes of length n.\n\n  Example 1:\n\n      Input: 3\n      Output: [1, 2, 3]\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11]\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNmus", "gc": "<|endoftext|>/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 0) {\n      return i;\n    }\n  }\n  return arr.length;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 0) {\n      return i;\n    }\n  }\n  return arr.length;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 0) {\n      return i;\n    }\n  }\n  return arr.length;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 0) {\n      return i;\n    }\n  }\n  return arr.length;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 0) {\n      return i;\n    }\n  }\n  return arr.length;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 0) {\n      return i;\n    }\n  }\n  return arr.length;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 0) {\n      return i;\n    }\n  }\n  return arr.length;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 0) {\n      return i;\n    }\n  }\n  return arr.length;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 0) {\n      return i;\n    }\n  }\n  return arr.length;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 0) {\n      return i;\n    }\n  }\n  return arr.length;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 0) {\n      return i;\n    }\n  }\n  return arr.length;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n    if (sum > 0) {\n      return i;\n    }\n  }\n  return arr.length;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "gc": "<|endoftext|>/*We have an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  let arrLength = arr.length;\n  let arrCopy = arr.slice();\n  let arrCopyLength = arrCopy.length;\n  let arrCopyIndex = 0;\n  let arrCopyIndexCopy = 0;\n  let arrCopyIndexCopyLength = 0;\n  let arrCopyIndexCopyLength2 = 0;\n  let arrCopyIndexCopyLength3 = 0;\n  let arrCopyIndexCopyLength4 = 0;\n  let arrCopyIndexCopyLength5 = 0;\n  let arrCopyIndexCopyLength6 = 0;\n  let arrCopyIndexCopyLength7 = 0;\n  let arrCopyIndexCopyLength8 = 0;\n  let arrCopyIndexCopyLength9 = 0;\n  let arrCopyIndexCopyLength10 = 0;\n  let arrCopyIndexCopyLength11 = 0;\n  let arrCopyIndexCopyLength12 = 0;\n  let arrCopyIndexCopyLength13 = 0;\n  let arrCopyIndexCopyLength14 = 0;\n  let arrCopyIndexCopyLength15 = 0;\n  let arrCopyIndexCopyLength16 = 0;\n  let arrCopyIndexCopyLength17 = 0;\n  let arrCopyIndexCopyLength18 = 0;\n  let arrCopyIndexCopyLength19 = 0;\n  let arrCopyIndexCopyLength20 = 0;\n  let arrCopyIndexCopyLength21 = 0;\n  let arrCopyIndexCopyLength22 = 0;\n  let arrCopyIndexCopyLength23 = 0;\n  let arrCopyIndexCopyLength24 = 0;\n  let arrCopyIndexCopyLength25 = 0;\n  let arrCopyIndexCopyLength26 = 0;\n  let arrCopyIndexCopyLength27 = 0;\n  let arrCopyIndexCopyLength28 = 0;\n  let arrCopyIndexCopyLength29 = 0;\n  let arrCopyIndexCopyLength30 = 0;\n  let arrCopyIndexCopyLength31 = 0;\n  let arrCopyIndexCopyLength32 = 0;\n  let arrCopyIndexCopyLength33 = 0;\n  let arrCopyIndexCopyLength34 = 0;\n  let arrCopyIndexCopyLength35 = 0;\n  let arrCopyIndexCopyLength36 = 0;\n  let arrCopyIndexCopyLength37 = 0;\n  let arrCopyIndexCopyLength38 = 0;\n  let arrCopyIndexCopyLength39 = 0;\n  let arrCopyIndexCopyLength40 = 0;\n  let arrCopyIndexCopyLength41 = 0;\n  let arrCopyIndexCopyLength42 = 0;\n  let arrCopyIndexCopyLength43 = 0;\n  let arrCopyIndexCopyLength44 = 0;\n  let arrCopyIndexCopyLength45 = 0;\n  let arrCopyIndexCopyLength46 = 0;\n  let arrCopyIndexCopyLength47 = 0;\n  let arrCopyIndexCopyLength48 = 0;\n  let arrCopyIndexCopyLength49 = 0;\n  let arrCopyIndexCopyLength50 = 0;\n  let arrCopyIndexCopyLength51 = 0;\n  let arrCopyIndexCopyLength52 = 0;\n  let arrCopyIndexCopyLength53 = 0;\n  let arrCopyIndexCopyLength54 = 0;\n  let arrCopyIndexCopyLength55 = 0;\n  let arrCopyIndexCopyLength56 = 0;\n  let arrCopyIndexCopyLength57 = 0;\n  let arrCopyIndexCopyLength58 = 0;\n  let arrCopyIndexCopyLength59 = 0;\n  let arrCopyIndexCopyLength60 = 0;\n  let arrCopyIndexCopyLength61 = 0;\n  let arrCopyIndexCopyLength62 = 0;\n  let arrCopyIndexCopyLength63 = 0;\n  let arrCopyIndexCopyLength64 = 0;\n  let arrCopyIndexCopyLength65 = 0;\n  let arrCopyIndexCopyLength66 = 0;\n  let arrCopyIndexCopyLength67 = 0;\n  let arrCopyIndexCopyLength68 = 0;\n  let arrCopyIndexCopyLength69 = 0;\n  let arrCopyIndexCopyLength70 = 0;\n  let arrCopyIndexCopyLength71 = 0;\n  let arrCopyIndexCopyLength72 = 0;\n  let arrCopyIndexCopyLength73 = 0;\n  let arrCopyIndexCopyLength74 = 0;\n  let arrCopyIndexCopyLength75 = 0;\n  let arrCopyIndexCopyLength76 = 0;\n  let arrCopyIndexCopyLength77 = 0;\n  let arrCopyIndexCopyLength78 = 0;\n  let arrCopyIndexCopyLength79 = 0;\n  let arrCopyIndexCopyLength80 = 0;\n  let arrCopyIndexCopyLength81 = 0;\n  let arrCopyIndexCopyLength82 = 0;\n  let arrCopyIndexCopyLength83 = 0;\n  let arrCopyIndexCopyLength84 = 0;\n  let arrCopyIndexCopyLength85 = 0;\n  let arrCopyIndexCopyLength86 = 0;\n  let arrCopyIndexCopyLength87 = 0;\n  let arrCopyIndexCopyLength88 = 0;\n  let arrCopyIndexCopyLength89 = 0;\n  let arrCopyIndexCopyLength90 = 0;\n  let arrCopyIndexCopyLength91 = 0;\n  let arrCopyIndexCopyLength92 = 0;\n  let arrCopyIndexCopyLength93 = 0;\n  let arrCopyIndexCopyLength94 = 0;\n  let arrCopyIndexCopyLength95 = 0;\n  let arrCopyIndexCopyLength96 = 0;\n  let arrCopyIndexCopyLength97 = 0;\n  let arrCopyIndexCopyLength98 = 0;\n  let arrCopyIndexCopyLength99 = 0;\n  let arrCopyIndexCopyLength100 = 0;\n  let arrCopyIndexCopyLength101 = 0;\n  let arrCopyIndexCopyLength102 = 0;\n  let arrCopyIndexCopyLength103 = 0;\n  let arrCopyIndexCopyLength104 = 0;\n  let arrCopyIndexCopyLength105 = 0;\n  let arrCopyIndexCopyLength106 = 0;\n  let arrCopyIndexCopyLength107 = 0;\n  let arrCopyIndexCopyLength108 = 0;\n  let arrCopyIndexCopyLength109 = 0;\n  let arrCopyIndexCopyLength110 = 0;\n  let arrCopyIndexCopyLength111 = 0;\n  let arrCopyIndexCopyLength112 = 0;\n  let arrCopyIndexCopyLength113 = 0;\n  let arrCopyIndexCopyLength114 = 0;\n  let arrCopyIndexCopyLength115 = 0;\n  let arrCopyIndexCopyLength116 = 0;\n  let arrCopyIndexCopyLength117 = 0;\n  let arrCopyIndexCopyLength118 = 0;\n  let arrCopyIndexCopyLength119 = 0;\n  let arrCopyIndexCopyLength120 = 0;\n  let arrCopyIndexCopyLength121 = 0;\n  let arrCopyIndexCopyLength122 = 0;\n  let arrCopyIndexCopyLength123 = 0;\n  let arrCopyIndexCopyLength124 = 0;\n  let arrCopyIndexCopyLength125 = 0;\n  let arrCopyIndexCopyLength126 = 0;\n  let arrCopyIndexCopyLength127 = 0;\n  let arrCopyIndexCopyLength128 = 0;\n  let arrCopyIndexCopyLength129 = 0;\n  let arrCopyIndexCopyLength130 = 0;\n  let arrCopyIndexCopyLength131 = 0;\n  let arrCopyIndexCopyLength132 = 0;\n  let arrCopyIndexCopyLength133 = 0;\n  let arrCopyIndexCopyLength134 = 0;\n  let arrCopyIndexCopyLength135 = 0;\n  let arrCopyIndexCopyLength136 = 0;\n  let arrCopyIndexCopyLength137 = 0;\n  let arrCopyIndexCopyLength138 = 0;\n  let arrCopyIndexCopyLength139 = 0;\n  let arrCopyIndexCopyLength", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/11", "prompt": "/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> strinXgor('010', '110')\n  '100'\n  */\nconst strinXgor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "strinXgor", "gc": "<|endoftext|>/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> strinXgor('010', '110')\n  '100'\n  */\nconst strinXgor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += String.fromCharCode(a[i] ^ b[i]);\n  }\n  return result;\n};\n\n/**\n  Convert a string to binary (base 2) representation.\n  >>> bin2str('100')\n  '1010'\n  */\nconst bin2str = (n) => {\n  let result = '';\n  for (let i = 0; i < n.length; i++) {\n    result += String.fromCharCode(n[i] % 2);\n  }\n  return result;\n};\n\n/**\n  Convert binary to string (base 2) representation.\n  >>> bin2str(bin2str('1010'))\n  '100'\n  */\nconst bin2str2 = (n) => {\n  let result = '';\n  for (let i = 0; i < n.length; i++) {\n    result += String.fromCharCode(n[i] / 2);\n  }\n  return result;\n};\n\n/**\n  Convert binary to base 2 representation (base 10).\n  >>> bin2str(bin2str2('1010'))\n  '1010'\n  */\nconst bin2str10 = (n) => {\n  let result = '';\n  for (let i = 0; i < n.length; i++) {\n    result += String.fromCharCode(n[i] * Math.pow(10, i));\n  }\n  return result;\n};\n\n/**\n  Convert binary to base 2 representation (base 16).\n  >>> bin2str(bin2str2('1010'))\n  '1010'\n  */\nconst bin2str16 = (n) => {\n  let result = '';\n  for (let i = 0; i < n.length; i++) {\n    result += String.fromCharCode(n[i] * Math.pow(16, i));\n  }\n  return result;\n};\n\n/**\n  Convert binary to base 2 representation (base 256).\n  >>> bin2str(bin2str2('1010'))\n  '1010'\n  */\nconst bin2str256 = (n) => {\n  let result = '';\n  for (let i = 0; i < n.length; i++) {\n    result += String.fromCharCode(n[i] * Math.pow(256, i));\n  }\n  return result;\n};\n\n/**\n  Convert binary to base 2 representation (base 65536).\n  >>> bin2str(bin2str2('1010'))\n  '1010'\n  */\nconst bin2str65536 = (n) => {\n  let result = '';\n  for (let i = 0; i < n.length; i++) {\n    result += String.fromCharCode(n[i] * Math.pow(65536, i));\n  }\n  return result;\n};\n\n/**\n  Convert binary to base 2 representation (base 10).\n  >>> bin2str(bin2str2('1010'))\n  '1010'\n  */\nconst bin2str102 = (n) => {\n  let result = '';\n  for (let i = 0; i < n.length; i++) {\n    result += String.fromCharCode(n[i] * Math.pow(10, i));\n  }\n  return result;\n};\n\n/**\n  Convert binary to base 2 representation (base 16).\n  >>> bin2str(bin2str2('1010'))\n  '1010'\n  */\nconst bin2str162 = (n) => {\n  let result = '';\n  for (let i = 0; i < n.length; i++) {\n    result += String.fromCharCode(n[i] * Math.pow(16, i));\n  }\n  return result;\n};\n\n/**\n  Convert binary to base 2 representation (base 256).\n  >>> bin2str(bin2str2('1010'))\n  '1010'\n  */\nconst bin2str256 = (n) => {\n  let result = '';\n  for (let i = 0; i < n.length; i++) {\n    result += String.fromCharCode(n[i] * Math.pow(256, i));\n  }\n  return result;\n};\n\n/**\n  Convert binary to base 2 representation (base 65536).\n  >>> bin2str(bin2str2('1010'))\n  '1010'\n  */\nconst bin2str655362 = (n) => {\n  let result = '';\n  for (let i = 0; i < n.length; i++) {\n    result += String.fromCharCode(n[i] * Math.pow(65536, i));\n  }\n  return result;\n};\n\n/**\n  Convert binary to base 2 representation (base 10).\n  >>> bin2str(bin2str2('1010'))\n  '1010'\n  */\nconst bin2str1022 = (n) => {\n  let result = '';\n  for (let i = 0; i < n.length; i++) {\n    result += String.fromCharCode(n[i] * Math.pow(10, i));\n  }\n  return result;\n};\n\n/**\n  Convert binary to base 2 representation (base 16).\n  >>> bin2str(bin2str2('1010'))\n  '1010'\n  */\nconst bin2str1622 = (n) => {\n  let result = '';\n  for (let i = 0; i < n.length; i++) {\n    result += String.fromCharCode(n[i] * Math.pow(16, i));\n  }\n  return result;\n};\n\n/**\n  Convert binary to base 2 representation (base 256).\n  >>> bin2str(bin2str2('1010'))\n  '1010'\n  */\nconst bin2str2562 = (n) => {\n  let result = '';\n  for (let i = 0; i < n.length; i++) {\n    result += String.fromCharCode(n[i] * Math.pow(256, i));\n  }\n  return result;\n};\n\n/**\n  Convert binary to base 2 representation (base 65536).\n  >>> bin2str(bin2str2('1010'))\n  '1010'\n  */\nconst bin2str6553622 = (n) => {\n  let result = '';\n  for (let i = 0; i < n.length; i++) {\n    result += String.fromCharCode(n[i] * Math.pow(65536, i));\n  }\n  return result;\n};\n\n/**\n  Convert binary to base 2 representation (base 10).\n  >>> bin2str(bin2str2('1010'))\n  '1010'\n  */\nconst bin2str10222 = (n) => {\n  let result = '';\n  for (let i = 0; i < n.length; i++) {\n    result += String.fromCharCode(n[i] * Math.pow(10, i));\n  }\n  return result;\n};\n\n/**\n  Convert binary to base 2 representation (base 16).\n  >>> bin2str(bin2str2('1010'))\n  '1010'\n  */\nconst bin2str16222 = (n) => {\n  let result = '';\n  for (let i = 0; i < n.length; i++) {\n    result += String.fromCharCode(n[i] * Math.pow(16, i));\n  }\n  return result;\n};\n\n/**\n  Convert binary to base 2 representation (base 256).\n  >>> bin2str(bin2str2('1010'))\n  '1010'\n  */\nconst bin2str25622 = (n) => {\n  let result = '';\n  for (let i = 0; i < n.length; i++) {\n    result += String.fromCharCode(n[i] * Math.pow(256, i));\n  }\n  return result;\n};\n\n/**\n  Convert binary to base 2 representation (base 65536).\n  >>> bin2str(bin2str2('1010'))\n  '1010'\n  */\nconst bin2str65536222 = (n) => {\n  let result = '';\n  for (let i = 0; i < n.length; i++) {\n    result += String.fromCharCode(n[i] * Math.pow(65536, i));\n  }\n  return result;\n};\n\n/**\n  Convert binary to base 2 representation (base 10).\n  >>> bin2str(bin2str2('1010'))\n  '1010'\n  */\nconst bin2str102222 = (n) => {\n  let result = '';\n  for (let i = 0; i < n.length; i++) {\n    result += String.fromCharCode(n[i] * Math.pow(10, i));\n  }\n  return result;\n};\n\n/**\n  Convert binary to base 2 representation (base 16).\n  >>> bin2str(bin2str2('1010'))\n  '1010'\n  */\nconst bin2str162222 = (n) => {\n  let result = '';\n  for (let i = 0; i < n.length; i++) {\n    result += String.", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an xechange of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of xechanged elements between lst1 and lst2.\n  If it is possible to xechange elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  xechange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  xechange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst xechange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "xechange", "gc": "<|endoftext|>/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an xechange of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of xechanged elements between lst1 and lst2.\n  If it is possible to xechange elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  xechange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  xechange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst xechange = (lst1, lst2) => {\n  let isXechanged = false\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2!== lst2[i] % 2) {\n      isXechanged = true\n      break\n    }\n  }\n  return isXechanged\n}\n\n/*\n  Write a function that takes an array of numbers and a target number.\n  If the target number is even, return true; otherwise, return false.\n  For example:\n  evens([1, 3, 5, 7, 9], [5]) => true\n  evens([1, 3, 5, 7, 9], [4]) => false\n  It is assumed that the input arrays will be non-empty.\n  */\nconst evens = (nums, target) => {\n  let isEven = false\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === target) {\n      isEven = true\n      break\n    }\n  }\n  return isEven\n}\n\n/*\n  Write a function that takes an array of numbers and a target number.\n  If the target number is odd, return true; otherwise, return false.\n  For example:\n  odds([1, 3, 5, 7, 9], [5]) => true\n  odds([1, 3, 5, 7, 9], [4]) => false\n  It is assumed that the input arrays will be non-empty.\n  */\nconst odds = (nums, target) => {\n  let isOdd = false\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2!== target) {\n      isOdd = true\n      break\n    }\n  }\n  return isOdd\n}\n\n/*\n  Write a function that takes an array of numbers and a target number.\n  If the target number is divisible by 2, return true; otherwise, return false.\n  For example:\n  divisible([3, 7, 9], [2, 5]) => true\n  divisible([3, 7, 9], [2, 4]) => false\n  It is assumed that the input arrays will be non-empty.\n  */\nconst divisible = (nums, target) => {\n  let isDivisible = false\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === target) {\n      isDivisible = true\n      break\n    }\n  }\n  return isDivisible\n}\n\n/*\n  Write a function that takes an array of numbers and a target number.\n  If the target number is divisible by 3, return true; otherwise, return false.\n  For example:\n  divisible([3, 7, 9], [2, 5]) => true\n  divisible([3, 7, 9], [2, 4]) => false\n  It is assumed that the input arrays will be non-empty.\n  */\nconst divisible = (nums, target) => {\n  let isDivisible = false\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 3 === target) {\n      isDivisible = true\n      break\n    }\n  }\n  return isDivisible\n}\n\n/*\n  Write a function that takes an array of numbers and a target number.\n  If the target number is divisible by 5, return true; otherwise, return false.\n  For example:\n  divisible([3, 7, 9], [2, 5]) => true\n  divisible([3, 7, 9], [2, 4]) => false\n  It is assumed that the input arrays will be non-empty.\n  */\nconst divisible = (nums, target) => {\n  let isDivisible = false\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 5 === target) {\n      isDivisible = true\n      break\n    }\n  }\n  return isDivisible\n}\n\n/*\n  Write a function that takes an array of numbers and a target number.\n  If the target number is divisible by 7, return true; otherwise, return false.\n  For example:\n  divisible([3, 7, 9], [2, 5]) => true\n  divisible([3, 7, 9], [2, 4]) => false\n  It is assumed that the input arrays will be non-empty.\n  */\nconst divisible = (nums, target) => {\n  let isDivisible = false\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 7 === target) {\n      isDivisible = true\n      break\n    }\n  }\n  return isDivisible\n}\n\n/*\n  Write a function that takes an array of numbers and a target number.\n  If the target number is divisible by 11, return true; otherwise, return false.\n  For example:\n  divisible([3, 7, 9], [2, 5]) => true\n  divisible([3, 7, 9], [2, 4]) => false\n  It is assumed that the input arrays will be non-empty.\n  */\nconst divisible = (nums, target) => {\n  let isDivisible = false\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 11 === target) {\n      isDivisible = true\n      break\n    }\n  }\n  return isDivisible\n}\n\n/*\n  Write a function that takes an array of numbers and a target number.\n  If the target number is divisible by 13, return true; otherwise, return false.\n  For example:\n  divisible([3, 7, 9], [2, 5]) => true\n  divisible([3, 7, 9], [2, 4]) => false\n  It is assumed that the input arrays will be non-empty.\n  */\nconst divisible = (nums, target) => {\n  let isDivisible = false\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 13 === target) {\n      isDivisible = true\n      break\n    }\n  }\n  return isDivisible\n}\n\n/*\n  Write a function that takes an array of numbers and a target number.\n  If the target number is divisible by 17, return true; otherwise, return false.\n  For example:\n  divisible([3, 7, 9], [2, 5]) => true\n  divisible([3, 7, 9], [2, 4]) => false\n  It is assumed that the input arrays will be non-empty.\n  */\nconst divisible = (nums, target) => {\n  let isDivisible = false\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 17 === target) {\n      isDivisible = true\n      break\n    }\n  }\n  return isDivisible\n}\n\n/*\n  Write a function that takes an array of numbers and a target number.\n  If the target number is divisible by 19, return true; otherwise, return false.\n  For example:\n  divisible([3, 7, 9], [2, 5]) => true\n  divisible([3, 7, 9], [2, 4]) => false\n  It is assumed that the input arrays will be non-empty.\n  */\nconst divisible = (nums, target) => {\n  let isDivisible = false\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 19 === target) {\n      isDivisible = true\n      break\n    }\n  }\n  return isDivisible\n}\n\n/*\n  Write a function that takes an array of numbers and a target number.\n  If the target number is divisible by 23, return true; otherwise, return false.\n  For example:\n  divisible([3, 7, 9], [2, 5]) => true\n  divisible([3, 7, 9], [2, 4]) => false\n  It is assumed that the input arrays will be non-empty.\n  */\nconst divisible = (nums, target) => {\n  let isDivisible = false\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 23 === target) {\n      isDivisible = true\n      break\n    }\n  }\n  return isDivisible\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/111", "prompt": "/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "gc": "<|endoftext|>/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split(' ');\n  const counts = {};\n  letters.forEach((letter) => {\n    counts[letter] = (counts[letter] || 0) + 1;\n  });\n  return counts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst count = (test) => {\n  const letters = test.split(' ');\n  const counts = {};\n  letters.forEach((letter) => {\n    counts[letter] = (counts[letter] || 0) + 1;\n  });\n  return counts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst countLetters = (test) => {\n  const letters = test.split(' ');\n  const counts = {};\n  letters.forEach((letter) => {\n    counts[letter] = (counts[letter] || 0) + 1;\n  });\n  return counts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst countLettersLetter = (test) => {\n  const letters = test.split(' ');\n  const counts = {};\n  letters.forEach((letter) => {\n    counts[letter] = (counts[letter] || 0) + 1;\n  });\n  return counts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst countLettersLetterLetterLetter = (test) => {\n  const letters = test.split(' ');\n  const counts = {};\n  letters.forEach((letter) => {\n    counts[letter] = (counts[letter] || 0) + 1;\n  });\n  return counts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst countLettersLetterLetterLetterLetterLetter = (test) => {\n  const letters = test.split(' ');\n  const counts = {};\n  letters.forEach((letter) => {\n    counts[letter] = (counts[letter] || 0) + 1;\n  });\n  return counts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst countLettersLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetterLetter", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reveresDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reveresDelete", "gc": "<|endoftext|>/*Task\n  We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reveresDelete = (s, c) => {\n  let result = ''\n  let isPalindrome = false\n  let len = s.length\n  let i = 0\n  let j = 0\n  let temp = ''\n  while(i < len) {\n    temp = s[i]\n    i++\n    for(j = 0; j < len; j++) {\n      if(s[j] === temp) {\n        temp = s[j]\n        i++\n      }\n    }\n    if(temp === c) {\n      isPalindrome = true\n      break\n    }\n  }\n  return [result, isPalindrome]\n}\n\n/*Task\n  You are given a string s and an integer n, you have to delete all the characters in s that is equal to n\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", n = 2, the result should be ('bcd',false)\n  For s = \"abcdef\", n = 2, the result should be ('acdef',false)\n  For s = \"abcdedcba\", n = 2, the result should be ('cdedc',true)\n  */\nconst reveresDeleteN = (s, n) => {\n  let result = ''\n  let isPalindrome = false\n  let len = s.length\n  let i = 0\n  let j = 0\n  let temp = ''\n  while(i < len) {\n    temp = s[i]\n    i++\n    for(j = 0; j < len; j++) {\n      if(s[j] === temp) {\n        temp = s[j]\n        i++\n      }\n    }\n    if(temp === n) {\n      isPalindrome = true\n      break\n    }\n  }\n  return [result, isPalindrome]\n}\n\n/*Task\n  You are given a string s and an integer n, you have to delete all the characters in s that is equal to n\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", n = 2, the result should be ('bcd',false)\n  For s = \"abcdef\", n = 2, the result should be ('acdef',false)\n  For s = \"abcdedcba\", n = 2, the result should be ('cdedc',true)\n  */\nconst reveresDeleteN2 = (s, n) => {\n  let result = ''\n  let isPalindrome = false\n  let len = s.length\n  let i = 0\n  let j = 0\n  let temp = ''\n  while(i < len) {\n    temp = s[i]\n    i++\n    for(j = 0; j < len; j++) {\n      if(s[j] === temp) {\n        temp = s[j]\n        i++\n      }\n    }\n    if(temp === n) {\n      isPalindrome = true\n      break\n    }\n  }\n  return [result, isPalindrome]\n}\n\n/*Task\n  You are given a string s and an integer n, you have to delete all the characters in s that is equal to n\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", n = 2, the result should be ('bcd',false)\n  For s = \"abcdef\", n = 2, the result should be ('acdef',false)\n  For s = \"abcdedcba\", n = 2, the result should be ('cdedc',true)\n  */\nconst reveresDeleteN3 = (s, n) => {\n  let result = ''\n  let isPalindrome = false\n  let len = s.length\n  let i = 0\n  let j = 0\n  let temp = ''\n  while(i < len) {\n    temp = s[i]\n    i++\n    for(j = 0; j < len; j++) {\n      if(s[j] === temp) {\n        temp = s[j]\n        i++\n      }\n    }\n    if(temp === n) {\n      isPalindrome = true\n      break\n    }\n  }\n  return [result, isPalindrome]\n}\n\n/*Task\n  You are given a string s and an integer n, you have to delete all the characters in s that is equal to n\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", n = 2, the result should be ('bcd',false)\n  For s = \"abcdef\", n = 2, the result should be ('acdef',false)\n  For s = \"abcdedcba\", n = 2, the result should be ('cdedc',true)\n  */\nconst reveresDeleteN4 = (s, n) => {\n  let result = ''\n  let isPalindrome = false\n  let len = s.length\n  let i = 0\n  let j = 0\n  let temp = ''\n  while(i < len) {\n    temp = s[i]\n    i++\n    for(j = 0; j < len; j++) {\n      if(s[j] === temp) {\n        temp = s[j]\n        i++\n      }\n    }\n    if(temp === n) {\n      isPalindrome = true\n      break\n    }\n  }\n  return [result, isPalindrome]\n}\n\n/*Task\n  You are given a string s and an integer n, you have to delete all the characters in s that is equal to n\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", n = 2, the result should be ('bcd',false)\n  For s = \"abcdef\", n = 2, the result should be ('acdef',false)\n  For s = \"abcdedcba\", n = 2, the result should be ('cdedc',true)\n  */\nconst reveresDeleteN5 = (s, n) => {\n  let result = ''\n  let isPalindrome = false\n  let len = s.length\n  let i = 0\n  let j = 0\n  let temp = ''\n  while(i < len) {\n    temp = s[i]\n    i++\n    for(j = 0; j < len; j++) {\n      if(s[j] === temp) {\n        temp = s[j]\n        i++\n      }\n    }\n    if(temp === n) {\n      isPalindrome = true\n      break\n    }\n  }\n  return [result, isPalindrome]\n}\n\n/*Task\n  You are given a string s and an integer n, you have to delete all the characters in s that is equal to n\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", n = 2, the result should be ('bcd',false)\n  For s = \"abcdef\", n = 2, the result should be ('acdef',false)\n  For s = \"abcdedcba\", n = 2, the result should be ('cdedc',true)\n  */\nconst reveresDeleteN6 = (s, n) => {\n  let result = ''\n  let isPalindrome = false\n  let len = s.length\n  let i = 0\n  let j = 0\n  let temp = ''\n  while(i < len) {\n    temp = s[i]\n    i++\n    for(j = 0; j < len; j++) {\n      if(s[j] === temp) {\n        temp = s[j]\n        i++\n      }\n    }\n    if(", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "gc": "<|endoftext|>/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let oddCounts = [];\n  for (let i = 0; i < lst.length; i++) {\n    let oddCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j].match(/\\d/)) {\n        oddCount++;\n      }\n    }\n    oddCounts.push(oddCount);\n  }\n  return oddCounts;\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCounts = [];\n  for (let i = 0; i < lst.length; i++) {\n    let evenCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j].match(/\\d/)) {\n        evenCount++;\n      }\n    }\n    evenCounts.push(evenCount);\n  }\n  return evenCounts;\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> oddEvenCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddEvenCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddEvenCount = (lst) => {\n  let oddEvenCounts = [];\n  for (let i = 0; i < lst.length; i++) {\n    let oddEvenCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j].match(/\\d/)) {\n        oddEvenCount++;\n      }\n    }\n    oddEvenCounts.push(oddEvenCount);\n  }\n  return oddEvenCounts;\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> oddEvenCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddEvenCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddEvenCount = (lst) => {\n  let oddEvenCounts = [];\n  for (let i = 0; i < lst.length; i++) {\n    let oddEvenCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j].match(/\\d/)) {\n        oddEvenCount++;\n      }\n    }\n    oddEvenCounts.push(oddEvenCount);\n  }\n  return oddEvenCounts;\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> oddEvenCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddEvenCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddEvenCount = (lst) => {\n  let oddEvenCounts = [];\n  for (let i = 0; i < lst.length; i++) {\n    let oddEvenCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j].match(/\\d/)) {\n        oddEvenCount++;\n      }\n    }\n    oddEvenCounts.push(oddEvenCount);\n  }\n  return oddEvenCounts;\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> oddEvenCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddEvenCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddEvenCount = (lst) => {\n  let oddEvenCounts = [];\n  for (let i = 0; i < lst.length; i++) {\n    let oddEvenCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j].match(/\\d/)) {\n        oddEvenCount++;\n      }\n    }\n    oddEvenCounts.push(oddEvenCount);\n  }\n  return oddEvenCounts;\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> oddEvenCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddEvenCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddEvenCount = (lst) => {\n  let oddEvenCounts = [];\n  for (let i = 0; i < lst.length; i++) {\n    let oddEvenCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j].match(/\\d/)) {\n        oddEvenCount++;\n      }\n    }\n    oddEvenCounts.push(oddEvenCount);\n  }\n  return oddEvenCounts;\n};\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> oddEvenCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddEvenCount(['3',\"11111111\"])\n  [\"", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "gc": "<|endoftext|>/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\nmodule.exports = {\n  minSubArraySum,\n};\n\n},{}],9:[function(require,module,exports){\nconst { minSubArraySum } = require('./minSubArraySum');\n\n/**\n * Given an array of integers nums, find the maximum sum of any non-empty sub-array\n * of nums.\n * Example\n * maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n * maxSubArraySum([-1, -2, -3]) == -3\n */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\nmodule.exports = {\n  maxSubArraySum,\n};\n\n},{\"./minSubArraySum\":8}],10:[function(require,module,exports){\nconst { maxSubArraySum } = require('./maxSubArraySum');\n\n/**\n * Given an array of integers nums, find the maximum sum of any non-empty sub-array\n * of nums.\n * Example\n * maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n * maxSubArraySum([-1, -2, -3]) == -3\n */\nconst minSubArraySum = (nums) => {\n  let sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\nmodule.exports = {\n  minSubArraySum,\n};\n\n},{\"./maxSubArraySum\":8}],11:[function(require,module,exports){\nconst { minSubArraySum } = require('./minSubArraySum');\n\n/**\n * Given an array of integers nums, find the maximum sum of any non-empty sub-array\n * of nums.\n * Example\n * maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n * maxSubArraySum([-1, -2, -3]) == -3\n */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\nmodule.exports = {\n  maxSubArraySum,\n};\n\n},{\"./minSubArraySum\":8}],12:[function(require,module,exports){\nconst { maxSubArraySum } = require('./maxSubArraySum');\n\n/**\n * Given an array of integers nums, find the maximum sum of any non-empty sub-array\n * of nums.\n * Example\n * maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n * maxSubArraySum([-1, -2, -3]) == -3\n */\nconst minSubArraySum = (nums) => {\n  let sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\nmodule.exports = {\n  minSubArraySum,\n};\n\n},{\"./maxSubArraySum\":8}],13:[function(require,module,exports){\nconst { maxSubArraySum } = require('./maxSubArraySum');\n\n/**\n * Given an array of integers nums, find the maximum sum of any non-empty sub-array\n * of nums.\n * Example\n * maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n * maxSubArraySum([-1, -2, -3]) == -3\n */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\nmodule.exports = {\n  maxSubArraySum,\n};\n\n},{\"./maxSubArraySum\":8}],14:[function(require,module,exports){\nconst { maxSubArraySum } = require('./maxSubArraySum');\n\n/**\n * Given an array of integers nums, find the maximum sum of any non-empty sub-array\n * of nums.\n * Example\n * maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n * maxSubArraySum([-1, -2, -3]) == -3\n */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\nmodule.exports = {\n  maxSubArraySum,\n};\n\n},{\"./maxSubArraySum\":8}],15:[function(require,module,exports){\nconst { maxSubArraySum } = require('./maxSubArraySum');\n\n/**\n * Given an array of integers nums, find the maximum sum of any non-empty sub-array\n * of nums.\n * Example\n * maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n * maxSubArraySum([-1, -2, -3]) == -3\n */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\nmodule.exports = {\n  maxSubArraySum,\n};\n\n},{\"./maxSubArraySum\":8}],16:[function(require,module,exports){\nconst { maxSubArraySum } = require('./maxSubArraySum');\n\n/**\n * Given an array of integers nums, find the maximum sum of any non-empty sub-array\n * of nums.\n * Example\n * maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n * maxSubArraySum([-1, -2, -3]) == -3\n */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\nmodule.exports = {\n  maxSubArraySum,\n};\n\n},{\"./maxSubArraySum\":8}],17:[function(require,module,exports){\nconst { maxSubArraySum } = require('./maxSubArraySum');\n\n/**\n * Given an array of integers nums, find the maximum sum of any non-empty sub-array\n * of nums.\n * Example\n * maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n * maxSubArraySum([-1, -2, -3]) == -3\n */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\nmodule.exports = {\n  maxSubArraySum,\n};", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "gc": "<|endoftext|>/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const result = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        result += (grid[i][j] * capacity);\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Your maxFill function will be called as many times as the number of test cases, \n * each time you need to lower the capacity of a bucket.\n * \n * Example:\n * \n * Input: \n * grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n * bucket_capacity : 1\n * \n * Output: 6\n * \n * Explanation:\n * \n * You need to lower the capacity of bucket 0 to 0.\n * You need to lower the capacity of bucket 1 to 0.\n * You need to lower the capacity of bucket 2 to 0.\n * You need to lower the capacity of bucket 3 to 0.\n * You need to lower the capacity of bucket 4 to 0.\n * You need to lower the capacity of bucket 5 to 0.\n * You need to lower the capacity of bucket 6 to 0.\n * You need to lower the capacity of bucket 7 to 0.\n * You need to lower the capacity of bucket 8 to 0.\n * You need to lower the capacity of bucket 9 to 0.\n * You need to lower the capacity of bucket 10 to 0.\n * You need to lower the capacity of bucket 11 to 0.\n * You need to lower the capacity of bucket 12 to 0.\n * You need to lower the capacity of bucket 13 to 0.\n * You need to lower the capacity of bucket 14 to 0.\n * You need to lower the capacity of bucket 15 to 0.\n * You need to lower the capacity of bucket 16 to 0.\n * You need to lower the capacity of bucket 17 to 0.\n * You need to lower the capacity of bucket 18 to 0.\n * You need to lower the capacity of bucket 19 to 0.\n * You need to lower the capacity of bucket 20 to 0.\n * You need to lower the capacity of bucket 21 to 0.\n * You need to lower the capacity of bucket 22 to 0.\n * You need to lower the capacity of bucket 23 to 0.\n * You need to lower the capacity of bucket 24 to 0.\n * You need to lower the capacity of bucket 25 to 0.\n * You need to lower the capacity of bucket 26 to 0.\n * You need to lower the capacity of bucket 27 to 0.\n * You need to lower the capacity of bucket 28 to 0.\n * You need to lower the capacity of bucket 29 to 0.\n * You need to lower the capacity of bucket 30 to 0.\n * You need to lower the capacity of bucket 31 to 0.\n * You need to lower the capacity of bucket 32 to 0.\n * You need to lower the capacity of bucket 33 to 0.\n * You need to lower the capacity of bucket 34 to 0.\n * You need to lower the capacity of bucket 35 to 0.\n * You need to lower the capacity of bucket 36 to 0.\n * You need to lower the capacity of bucket 37 to 0.\n * You need to lower the capacity of bucket 38 to 0.\n * You need to lower the capacity of bucket 39 to 0.\n * You need to lower the capacity of bucket 40 to 0.\n * You need to lower the capacity of bucket 41 to 0.\n * You need to lower the capacity of bucket 42 to 0.\n * You need to lower the capacity of bucket 43 to 0.\n * You need to lower the capacity of bucket 44 to 0.\n * You need to lower the capacity of bucket 45 to 0.\n * You need to lower the capacity of bucket 46 to 0.\n * You need to lower the capacity of bucket 47 to 0.\n * You need to lower the capacity of bucket 48 to 0.\n * You need to lower the capacity of bucket 49 to 0.\n * You need to lower the capacity of bucket 50 to 0.\n * You need to lower the capacity of bucket 51 to 0.\n * You need to lower the capacity of bucket 52 to 0.\n * You need to lower the capacity of bucket 53 to 0.\n * You need to lower the capacity of bucket 54 to 0.\n * You need to lower the capacity of bucket 55 to 0.\n * You need to lower the capacity of bucket 56 to 0.\n * You need to lower the capacity of bucket 57 to 0.\n * You need to lower the capacity of bucket 58 to 0.\n * You need to lower the capacity of bucket 59 to 0.\n * You need to lower the capacity of bucket 60 to 0.\n * You need to lower the capacity of bucket 61 to 0.\n * You need to lower the capacity of bucket 62 to 0.\n * You need to lower the capacity of bucket 63 to 0.\n * You need to lower the capacity of bucket 64 to 0.\n * You need to lower the capacity of bucket 65 to 0.\n * You need to lower the capacity of bucket 66 to 0.\n * You need to lower the capacity of bucket 67 to 0.\n * You need to lower the capacity of bucket 68 to 0.\n * You need to lower the capacity of bucket 69 to 0.\n * You need to lower the capacity of bucket 70 to 0.\n * You need to lower the capacity of bucket 71 to 0.\n * You need to lower the capacity of bucket 72 to 0.\n * You need to lower the capacity of bucket 73 to 0.\n * You need to lower the capacity of bucket 74 to 0.\n * You need to lower the capacity of bucket 75 to 0.\n * You need to lower the capacity of bucket 76 to 0.\n * You need to lower the capacity of bucket 77 to 0.\n * You need to lower the capacity of bucket 78 to 0.\n * You need to lower the capacity of bucket 79 to 0.\n * You need to lower the capacity of bucket 80 to 0.\n * You need to lower the capacity of bucket 81 to 0.\n * You need to lower the capacity of bucket 82 to 0.\n * You need to lower the capacity of bucket 83 to 0.\n * You need to lower the capacity of bucket 84 to 0.\n * You need to lower the capacity of bucket 85 to 0.\n * You need to lower the capacity of bucket 86 to 0.\n * You need to lower the capacity of bucket 87 to 0.\n * You need to lower the capacity of bucket 88 to 0.\n * You need to lower the capacity of bucket 89 to 0.\n * You need to lower the capacity of bucket 90 to 0.\n * You need to lower the capacity of bucket 91 to 0.\n * You need to lower the capacity of bucket 92 to 0.\n * You need to lower the capacity of bucket 93 to 0.\n * You need to lower the capacity of bucket 94 to 0.\n * You need to lower the capacity of bucket 95 to 0.\n * You need to lower the capacity of bucket 96 to 0.\n * You need to lower the capacity of bucket 97 to 0.\n * You need to lower the capacity of bucket 98 to 0.\n * You need to lower the capacity of bucket 99 to 0.\n * You need to lower the capacity of bucket 100 to 0.\n * You need to lower the capacity of bucket 101 to 0.\n * You need to lower the capacity of bucket 102 to 0.\n * You need to lower the capacity of bucket 103 to 0.\n * You need to lower the capacity of bucket 104 to 0.\n * You need to lower the capacity of bucket 105 to 0.\n * You need to lower the ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "gc": "<|endoftext|>/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sortedArray = arr.sort((a, b) => {\n    return a > b? 1 : -1;\n  });\n  return sortedArray;\n};\n\n/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sortedArray = arr.sort((a, b) => {\n    return a > b? 1 : -1;\n  });\n  return sortedArray;\n};\n\n/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sortedArray = arr.sort((a, b) => {\n    return a > b? 1 : -1;\n  });\n  return sortedArray;\n};\n\n/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sortedArray = arr.sort((a, b) => {\n    return a > b? 1 : -1;\n  });\n  return sortedArray;\n};\n\n/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sortedArray = arr.sort((a, b) => {\n    return a > b? 1 : -1;\n  });\n  return sortedArray;\n};\n\n/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sortedArray = arr.sort((a, b) => {\n    return a > b? 1 : -1;\n  });\n  return sortedArray;\n};\n\n/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sortedArray = arr.sort((a, b) => {\n    return a > b? 1 : -1;\n  });\n  return sortedArray;\n};\n\n/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sortedArray = arr.sort((a, b) => {\n    return a > b? 1 : -1;\n  });\n  return sortedArray;\n};\n\n/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sortedArray = arr.sort((a, b) => {\n    return a > b? 1 : -1;\n  });\n  return sortedArray;\n};\n\n/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sortedArray = arr.sort((a, b) => {\n    return a > b? 1 : -1;\n  });\n  return sortedArray;\n};\n\n/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sortedArray = arr.sort((a, b) => {\n    return a > b? 1 : -1;\n  });\n  return sortedArray;\n};\n\n/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selectWdors(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWdors(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWdors(\"simple white space\", 2) ==> []\n  selectWdors(\"Hello world\", 4) ==> [\"world\"]\n  selectWdors(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWdors = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWdors", "gc": "<|endoftext|>/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selectWdors(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWdors(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWdors(\"simple white space\", 2) ==> []\n  selectWdors(\"Hello world\", 4) ==> [\"world\"]\n  selectWdors(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWdors = (s, n) => {\n  let words = [];\n  let word = '';\n  let i = 0;\n  let j = 0;\n  let count = 0;\n  let wordCount = 0;\n  let wordCount2 = 0;\n  let wordCount3 = 0;\n  let wordCount4 = 0;\n  let wordCount5 = 0;\n  let wordCount6 = 0;\n  let wordCount7 = 0;\n  let wordCount8 = 0;\n  let wordCount9 = 0;\n  let wordCount10 = 0;\n  let wordCount11 = 0;\n  let wordCount12 = 0;\n  let wordCount13 = 0;\n  let wordCount14 = 0;\n  let wordCount15 = 0;\n  let wordCount16 = 0;\n  let wordCount17 = 0;\n  let wordCount18 = 0;\n  let wordCount19 = 0;\n  let wordCount20 = 0;\n  let wordCount21 = 0;\n  let wordCount22 = 0;\n  let wordCount23 = 0;\n  let wordCount24 = 0;\n  let wordCount25 = 0;\n  let wordCount26 = 0;\n  let wordCount27 = 0;\n  let wordCount28 = 0;\n  let wordCount29 = 0;\n  let wordCount30 = 0;\n  let wordCount31 = 0;\n  let wordCount32 = 0;\n  let wordCount33 = 0;\n  let wordCount34 = 0;\n  let wordCount35 = 0;\n  let wordCount36 = 0;\n  let wordCount37 = 0;\n  let wordCount38 = 0;\n  let wordCount39 = 0;\n  let wordCount40 = 0;\n  let wordCount41 = 0;\n  let wordCount42 = 0;\n  let wordCount43 = 0;\n  let wordCount44 = 0;\n  let wordCount45 = 0;\n  let wordCount46 = 0;\n  let wordCount47 = 0;\n  let wordCount48 = 0;\n  let wordCount49 = 0;\n  let wordCount50 = 0;\n  let wordCount51 = 0;\n  let wordCount52 = 0;\n  let wordCount53 = 0;\n  let wordCount54 = 0;\n  let wordCount55 = 0;\n  let wordCount56 = 0;\n  let wordCount57 = 0;\n  let wordCount58 = 0;\n  let wordCount59 = 0;\n  let wordCount60 = 0;\n  let wordCount61 = 0;\n  let wordCount62 = 0;\n  let wordCount63 = 0;\n  let wordCount64 = 0;\n  let wordCount65 = 0;\n  let wordCount66 = 0;\n  let wordCount67 = 0;\n  let wordCount68 = 0;\n  let wordCount69 = 0;\n  let wordCount70 = 0;\n  let wordCount71 = 0;\n  let wordCount72 = 0;\n  let wordCount73 = 0;\n  let wordCount74 = 0;\n  let wordCount75 = 0;\n  let wordCount76 = 0;\n  let wordCount77 = 0;\n  let wordCount78 = 0;\n  let wordCount79 = 0;\n  let wordCount80 = 0;\n  let wordCount81 = 0;\n  let wordCount82 = 0;\n  let wordCount83 = 0;\n  let wordCount84 = 0;\n  let wordCount85 = 0;\n  let wordCount86 = 0;\n  let wordCount87 = 0;\n  let wordCount88 = 0;\n  let wordCount89 = 0;\n  let wordCount90 = 0;\n  let wordCount91 = 0;\n  let wordCount92 = 0;\n  let wordCount93 = 0;\n  let wordCount94 = 0;\n  let wordCount95 = 0;\n  let wordCount96 = 0;\n  let wordCount97 = 0;\n  let wordCount98 = 0;\n  let wordCount99 = 0;\n  let wordCount100 = 0;\n  let wordCount101 = 0;\n  let wordCount102 = 0;\n  let wordCount103 = 0;\n  let wordCount104 = 0;\n  let wordCount105 = 0;\n  let wordCount106 = 0;\n  let wordCount107 = 0;\n  let wordCount108 = 0;\n  let wordCount109 = 0;\n  let wordCount110 = 0;\n  let wordCount111 = 0;\n  let wordCount112 = 0;\n  let wordCount113 = 0;\n  let wordCount114 = 0;\n  let wordCount115 = 0;\n  let wordCount116 = 0;\n  let wordCount117 = 0;\n  let wordCount118 = 0;\n  let wordCount119 = 0;\n  let wordCount120 = 0;\n  let wordCount121 = 0;\n  let wordCount122 = 0;\n  let wordCount123 = 0;\n  let wordCount124 = 0;\n  let wordCount125 = 0;\n  let wordCount126 = 0;\n  let wordCount127 = 0;\n  let wordCount128 = 0;\n  let wordCount129 = 0;\n  let wordCount130 = 0;\n  let wordCount131 = 0;\n  let wordCount132 = 0;\n  let wordCount133 = 0;\n  let wordCount134 = 0;\n  let wordCount135 = 0;\n  let wordCount136 = 0;\n  let wordCount137 = 0;\n  let wordCount138 = 0;\n  let wordCount139 = 0;\n  let wordCount140 = 0;\n  let wordCount141 = 0;\n  let wordCount142 = 0;\n  let wordCount143 = 0;\n  let wordCount144 = 0;\n  let wordCount145 = 0;\n  let wordCount146 = 0;\n  let wordCount147 = 0;\n  let wordCount148 = 0;\n  let wordCount149 = 0;\n  let wordCount150 = 0;\n  let wordCount151 = 0;\n  let wordCount152 = 0;\n  let wordCount153 = 0;\n  let wordCount154 = 0;\n  let wordCount155 = 0;\n  let wordCount156 = 0;\n  let wordCount157 = 0;\n  let wordCount158 = 0;\n  let wordCount159 = 0;\n  let wordCount160 = 0;\n  let wordCount161 = 0;\n  let wordCount162 = 0;\n  let wordCount163 = 0;\n  let wordCount164 = 0;\n  let wordCount165 = 0;\n  let wordCount166 = 0;\n  let wordCount167 = 0;\n  let wordCount168 = 0;\n  let wordCount169 = 0;\n  let wordCount170 = 0;\n  let wordCount171 = 0;\n  let wordCount172 = 0;\n  let wordCount173 = 0;\n  let wordCount174 = 0;\n  let wordCount175 = 0;\n  let wordCount176 = 0;\n  let wordCount177 = 0;\n  let wordCount178 = 0;\n  let wordCount179 = 0;\n  let wordCount180 = 0;\n  let wordCount181 = 0;\n  let wordCount182 = 0;\n  let wordCount183 = 0;\n  let wordCount184 = 0;\n  let wordCount185 = 0;\n  let wordCount186 = 0;\n  let wordCount187 = 0;\n  let wordCount188 = 0;\n  let wordCount189 = 0;\n  let wordCount190 = 0;\n  let wordCount191 = 0;\n  let wordCount192 = 0;\n  let wordCount193 = 0;\n  let wordCount194 = 0;\n  let wordCount195 = 0;\n  let wordCount196 = 0;\n  let wordCount197 = 0;\n  let wordCount198 = 0;\n  let wordCount199 = 0;\n  let wordCount200 = 0;\n  let wordCount201 = 0;\n  let wordCount202 = 0;\n  let wordCount203 = 0;\n  let wordCount204 = 0;\n  let wordCount205 = 0;\n  let wordCount206 = 0;\n  let wordCount207 = 0;\n  let wordCount208 = 0;\n  let wordCount209 = 0;\n  let wordCount210 = 0;\n  let wordCount211 = 0;\n  let wordCount212 = 0;\n  let wordCount213 = 0;\n  let wordCount214 = 0;\n  let wordCount215 = 0;\n  let wordCount216 = 0;\n  let wordCount217 = 0;\n  let wordCount218 = 0;\n  let wordCount219 = 0;\n  let wordCount220 = 0;\n  let wordCount221 = 0;\n  let wordCount222 = 0;\n  let wordCount223 = 0;\n  let wordCount224 = 0;\n  let wordCount225 = 0;\n  let wordCount226 = 0;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/118", "prompt": "/*You are given a word. Your task is to find the closest vowel that stands between \n  two consonants from the right side of the word (case sensitive).\n  \n  Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contains English letter only.\n\n  Example:\n  getClossetVowel(\"yogurt\") ==> \"u\"\n  getClossetVowel(\"FULL\") ==> \"U\"\n  getClossetVowel(\"quick\") ==> \"\"\n  getClossetVowel(\"ab\") ==> \"\"\n  */\nconst getClossetVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClossetVowel", "gc": "<|endoftext|>/*You are given a word. Your task is to find the closest vowel that stands between \n  two consonants from the right side of the word (case sensitive).\n  \n  Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contains English letter only.\n\n  Example:\n  getClossetVowel(\"yogurt\") ==> \"u\"\n  getClossetVowel(\"FULL\") ==> \"U\"\n  getClossetVowel(\"quick\") ==> \"\"\n  getClossetVowel(\"ab\") ==> \"\"\n  */\nconst getClossetVowel = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelIndex = 0;\n  let vowelLength = 0;\n  let vowelDistance = 0;\n  let vowelIndex2 = 0;\n  let vowelLength2 = 0;\n  let vowelDistance2 = 0;\n  let vowelIndex3 = 0;\n  let vowelLength3 = 0;\n  let vowelDistance3 = 0;\n  let vowelIndex4 = 0;\n  let vowelLength4 = 0;\n  let vowelDistance4 = 0;\n  let vowelIndex5 = 0;\n  let vowelLength5 = 0;\n  let vowelDistance5 = 0;\n  let vowelIndex6 = 0;\n  let vowelLength6 = 0;\n  let vowelDistance6 = 0;\n  let vowelIndex7 = 0;\n  let vowelLength7 = 0;\n  let vowelDistance7 = 0;\n  let vowelIndex8 = 0;\n  let vowelLength8 = 0;\n  let vowelDistance8 = 0;\n  let vowelIndex9 = 0;\n  let vowelLength9 = 0;\n  let vowelDistance9 = 0;\n  let vowelIndex10 = 0;\n  let vowelLength10 = 0;\n  let vowelDistance10 = 0;\n  let vowelIndex11 = 0;\n  let vowelLength11 = 0;\n  let vowelDistance11 = 0;\n  let vowelIndex12 = 0;\n  let vowelLength12 = 0;\n  let vowelDistance12 = 0;\n  let vowelIndex13 = 0;\n  let vowelLength13 = 0;\n  let vowelDistance13 = 0;\n  let vowelIndex14 = 0;\n  let vowelLength14 = 0;\n  let vowelDistance14 = 0;\n  let vowelIndex15 = 0;\n  let vowelLength15 = 0;\n  let vowelDistance15 = 0;\n  let vowelIndex16 = 0;\n  let vowelLength16 = 0;\n  let vowelDistance16 = 0;\n  let vowelIndex17 = 0;\n  let vowelLength17 = 0;\n  let vowelDistance17 = 0;\n  let vowelIndex18 = 0;\n  let vowelLength18 = 0;\n  let vowelDistance18 = 0;\n  let vowelIndex19 = 0;\n  let vowelLength19 = 0;\n  let vowelDistance19 = 0;\n  let vowelIndex20 = 0;\n  let vowelLength20 = 0;\n  let vowelDistance20 = 0;\n  let vowelIndex21 = 0;\n  let vowelLength21 = 0;\n  let vowelDistance21 = 0;\n  let vowelIndex22 = 0;\n  let vowelLength22 = 0;\n  let vowelDistance22 = 0;\n  let vowelIndex23 = 0;\n  let vowelLength23 = 0;\n  let vowelDistance23 = 0;\n  let vowelIndex24 = 0;\n  let vowelLength24 = 0;\n  let vowelDistance24 = 0;\n  let vowelIndex25 = 0;\n  let vowelLength25 = 0;\n  let vowelDistance25 = 0;\n  let vowelIndex26 = 0;\n  let vowelLength26 = 0;\n  let vowelDistance26 = 0;\n  let vowelIndex27 = 0;\n  let vowelLength27 = 0;\n  let vowelDistance27 = 0;\n  let vowelIndex28 = 0;\n  let vowelLength28 = 0;\n  let vowelDistance28 = 0;\n  let vowelIndex29 = 0;\n  let vowelLength29 = 0;\n  let vowelDistance29 = 0;\n  let vowelIndex30 = 0;\n  let vowelLength30 = 0;\n  let vowelDistance30 = 0;\n  let vowelIndex31 = 0;\n  let vowelLength31 = 0;\n  let vowelDistance31 = 0;\n  let vowelIndex32 = 0;\n  let vowelLength32 = 0;\n  let vowelDistance32 = 0;\n  let vowelIndex33 = 0;\n  let vowelLength33 = 0;\n  let vowelDistance33 = 0;\n  let vowelIndex34 = 0;\n  let vowelLength34 = 0;\n  let vowelDistance34 = 0;\n  let vowelIndex35 = 0;\n  let vowelLength35 = 0;\n  let vowelDistance35 = 0;\n  let vowelIndex36 = 0;\n  let vowelLength36 = 0;\n  let vowelDistance36 = 0;\n  let vowelIndex37 = 0;\n  let vowelLength37 = 0;\n  let vowelDistance37 = 0;\n  let vowelIndex38 = 0;\n  let vowelLength38 = 0;\n  let vowelDistance38 = 0;\n  let vowelIndex39 = 0;\n  let vowelLength39 = 0;\n  let vowelDistance39 = 0;\n  let vowelIndex40 = 0;\n  let vowelLength40 = 0;\n  let vowelDistance40 = 0;\n  let vowelIndex41 = 0;\n  let vowelLength41 = 0;\n  let vowelDistance41 = 0;\n  let vowelIndex42 = 0;\n  let vowelLength42 = 0;\n  let vowelDistance42 = 0;\n  let vowelIndex43 = 0;\n  let vowelLength43 = 0;\n  let vowelDistance43 = 0;\n  let vowelIndex44 = 0;\n  let vowelLength44 = 0;\n  let vowelDistance44 = 0;\n  let vowelIndex45 = 0;\n  let vowelLength45 = 0;\n  let vowelDistance45 = 0;\n  let vowelIndex46 = 0;\n  let vowelLength46 = 0;\n  let vowelDistance46 = 0;\n  let vowelIndex47 = 0;\n  let vowelLength47 = 0;\n  let vowelDistance47 = 0;\n  let vowelIndex48 = 0;\n  let vowelLength48 = 0;\n  let vowelDistance48 = 0;\n  let vowelIndex49 = 0;\n  let vowelLength49 = 0;\n  let vowelDistance49 = 0;\n  let vowelIndex50 = 0;\n  let vowelLength50 = 0;\n  let vowelDistance50 = 0;\n  let vowelIndex51 = 0;\n  let vowelLength51 = 0;\n  let vowelDistance51 = 0;\n  let vowelIndex52 = 0;\n  let vowelLength52 = 0;\n  let vowelDistance52 = 0;\n  let vowelIndex53 = 0;\n  let vowelLength53 = 0;\n  let vowelDistance53 = 0;\n  let vowelIndex54 = 0;\n  let vowelLength54 = 0;\n  let vowelDistance54 = 0;\n  let vowelIndex55 = 0;\n  let vowelLength55 = 0;\n  let vowelDistance55 = 0;\n  let vowelIndex56 = 0;\n  let vowelLength56 = 0;\n  let vowelDistance56 = 0;\n  let vowelIndex57 = 0;\n  let vowelLength57 = 0;\n  let vowelDistance57 = 0;\n  let vowelIndex58 = 0;\n  let vowelLength58 = 0;\n  let vowelDistance58 = 0;\n  let vowelIndex59 = 0;\n  let vowelLength59 = 0;\n  let vowelDistance59 = 0;\n  let vowelIndex60 = 0;\n  let vowelLength60 = 0;\n  let vowelDistance60 = 0;\n  let vowelIndex61 = 0;\n  let vowelLength61 = 0;\n  let vowelDistance61 = 0;\n  let vowelIndex62 = 0;\n  let vowelLength62 = 0;\n  let vowelDistance62 = 0;\n  let vowelIndex63 = 0;\n  let vowelLength63 = 0;\n  let vowelDistance63 = 0;\n  let vowelIndex64 = 0;\n  let vowelLength64 = 0;\n  let vowelDistance64 = 0;\n  let vowelIndex65 = 0;\n  let vowelLength65 = 0;\n  let vowelDistance65 = 0;\n  let vowelIndex66 = 0;\n  let vowelLength66 = 0;\n  let vowelDistance66 = 0;\n  let vowelIndex67 = 0;\n  let vowelLength67 = 0;\n  let vowelDistance67 = 0;\n  let vowelIndex68 = 0;\n  let vowelLength68 = 0;\n  let vowelDistance68 = 0;\n  let vowelIndex69 = 0;\n  let vowelLength69 = 0;\n  let vowelDistance69 = 0;\n  let vowelIndex70 = 0;\n  let vowelLength70 = 0;\n  let vowelDistance70 = 0;\n  let vowelIndex71 = 0;\n  let vowelLength71 = 0;\n  let vowelDistance71 = 0;\n  let vowelIndex72 = 0;\n  let vowelLength72 = 0;\n  let vowelDistance72 = 0;\n  let vowelIndex73 = 0;\n  let vowelLength73 = 0;\n  let vowelDistance73 = 0;\n  let vowelIndex74 = 0;\n  let vowelLength74 = 0;\n  let vowelDistance74 = 0;\n  let vowelIndex75 = 0;\n  let vowelLength75 = 0;\n  let vowelDistance75 = 0;\n  let vowelIndex76 = 0;\n  let vowelLength76 = 0;\n  let vowelDistance76 = 0;\n  let vowelIndex77 = 0;\n  let vowelLength77 = 0;\n  let vowelDistance77 = 0;\n  let vowelIndex", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of two strings, both strings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible to concatenate the two strings in\n  some order, that the resulting string will be good.\n  A string S is considered to be good if and only if all parentheses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "gc": "<|endoftext|>/* You are given a list of two strings, both strings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible to concatenate the two strings in\n  some order, that the resulting string will be good.\n  A string S is considered to be good if and only if all parentheses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  const stack = [lst[0]];\n  while (stack.length) {\n    const curr = stack.pop();\n    if (curr === ')') {\n      stack.push(curr);\n    } else if (curr === '(') {\n      stack.push(curr);\n    } else {\n      return 'No';\n    }\n  }\n  return 'Yes';\n};\n\n/* You are given a string S consisting of N characters and a number N. Your job\n  is to find out whether there is a way to convert S into another string of\n  length N. For example, the string '(())()' can be converted to '()()', but the\n  string '()()' cannot be converted to '()()'.\n  Return 'Yes' if there's a way to convert S into another string of length N,\n  and return 'No' otherwise.\n  Examples:\n  convertTo('(())()', 3) == '(())()'\n  convertTo('()()', 3) == '()()'\n  convertTo('()()', 2) == '()()'\n  convertTo('()()', 1) == '()'\n  */\nconst convertTo = (str, n) => {\n  const stack = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let result = '';\n  let len = str.length;\n  while (i < len) {\n    if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      j++;\n      i++;\n    } else if (str[i] === '(') {\n      k++;\n      i++;\n    } else if (str[i] === ')') {\n      k--;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      j--;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      k++;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      j--;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      k--;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      j++;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      k++;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      j--;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      k--;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      j++;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      k++;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      j--;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      k--;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      j++;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      k++;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      j--;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      k--;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      j++;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      k++;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      j--;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      k--;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      j++;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      k--;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      j--;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      k++;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      j++;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      k--;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      j--;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      k++;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      j++;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      k--;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      j--;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      k++;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      j++;\n      i++;\n    } else if (str[i] === '(') {\n      stack.push(str[i]);\n      i++;\n    } else if (str[i] === ')') {\n      k--;\n      i++;\n    } else if (str[i] === '", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "gc": "<|endoftext|>/* Out of list of strings, return the longest one. Return the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n\n  let longestLength = 0\n  let longestString = ''\n\n  for (let i = 0; i < strings.length; i++) {\n    const string = strings[i]\n\n    if (string.length > longestLength) {\n      longestLength = string.length\n      longestString = string\n    }\n  }\n\n  return longestString\n}\n\nmodule.exports = longest\n\n},{}],17:[function(require,module,exports){\n'use strict'\n\nconst { isString } = require('lodash')\n\nconst { longest, shortest } = require('./longest')\n\nconst { isArray } = Array\n\nconst isString = isString(str)\n\nconst isNumber = (val) => typeof val === 'number'\n\nconst isBoolean = (val) => typeof val === 'boolean'\n\nconst isNull = (val) => val === null\n\nconst isRegExp = (val) => val instanceof RegExp\n\nconst isDate = (val) => val instanceof Date\n\nconst isError = (val) => val instanceof Error\n\nconst isMap = (val) => val instanceof Map\n\nconst isSet = (val) => val instanceof Set\n\nconst isWeakMap = (val) => val instanceof WeakMap\n\nconst isWeakSet = (val) => val instanceof WeakSet\n\nconst isSetLike = (val) => isSet(val) || isWeakSet(val)\n\nconst isMapLike = (val) => isMap(val) || isWeakMap(val)\n\nconst isSetLikeArray = (val) => isSet(val) || isWeakSet(val)\n\nconst isMapLikeArray = (val) => isMap(val) || isWeakMap(val)\n\nconst isStringArray = (val) => isArray(val) && isString(val[0])\n\nconst isNumberArray = (val) => isArray(val) && isNumber(val[0])\n\nconst isBooleanArray = (val) => isArray(val) && isBoolean(val[0])\n\nconst isNullArray = (val) => isArray(val) && isNull(val[0])\n\nconst isRegExpArray = (val) => isArray(val) && isRegExp(val[0])\n\nconst isDateArray = (val) => isArray(val) && isDate(val[0])\n\nconst isErrorArray = (val) => isArray(val) && isError(val[0])\n\nconst isMapArray = (val) => isArray(val) && isMap(val[0])\n\nconst isWeakMapArray = (val) => isArray(val) && isWeakMap(val[0])\n\nconst isWeakSetArray = (val) => isArray(val) && isWeakSet(val[0])\n\nconst isSetLikeArray = (val) => isArray(val) && isSetLike(val[0])\n\nconst isMapLikeArray = (val) => isArray(val) && isMapLike(val[0])\n\nconst isSetLikeObject = (val) => isSetLikeArray(val[0]) || isSetLike(val[0])\n\nconst isMapLikeObject = (val) => isMapLikeArray(val[0]) || isMapLike(val[0])\n\nconst isStringObject = (val) => isStringArray(val[0]) && isString(val[1])\n\nconst isNumberObject = (val) => isNumberArray(val[0]) && isNumber(val[1])\n\nconst isBooleanObject = (val) => isBooleanArray(val[0]) && isBoolean(val[1])\n\nconst isNullObject = (val) => isNullArray(val[0]) && isNull(val[1])\n\nconst isRegExpObject = (val) => isRegExpArray(val[0]) && isRegExp(val[1])\n\nconst isDateObject = (val) => isDateArray(val[0]) && isDate(val[1])\n\nconst isErrorObject = (val) => isErrorArray(val[0]) && isError(val[1])\n\nconst isMapObject = (val) => isMapArray(val[0]) && isMap(val[1])\n\nconst isWeakMapObject = (val) => isWeakMapArray(val[0]) && isWeakMap(val[1])\n\nconst isWeakSetObject = (val) => isWeakSetArray(val[0]) && isWeakSet(val[1])\n\nconst isSetLikeObject = (val) => isSetLikeArray(val[0]) || isSetLike(val[0])\n\nconst isMapLikeObject = (val) => isMapLikeArray(val[0]) || isMapLike(val[0])\n\nconst isStringArrayObject = (val) => isStringArray(val[0]) && isStringObject(val[1])\n\nconst isNumberArrayObject = (val) => isNumberArray(val[0]) && isNumberObject(val[1])\n\nconst isBooleanArrayObject = (val) => isBooleanArray(val[0]) && isBooleanObject(val[1])\n\nconst isNullArrayObject = (val) => isNullArray(val[0]) && isNullObject(val[1])\n\nconst isRegExpArrayObject = (val) => isRegExpArray(val[0]) && isRegExpObject(val[1])\n\nconst isDateArrayObject = (val) => isDateArray(val[0]) && isDateObject(val[1])\n\nconst isErrorArrayObject = (val) => isErrorArray(val[0]) && isErrorObject(val[1])\n\nconst isMapArrayObject = (val) => isMapArray(val[0]) && isMapObject(val[1])\n\nconst isWeakMapArrayObject = (val) => isWeakMapArray(val[0]) && isWeakMapObject(val[1])\n\nconst isWeakSetArrayObject = (val) => isWeakSetArray(val[0]) && isWeakSetObject(val[1])\n\nconst isSetLikeArrayObject = (val) => isSetLikeArray(val[0]) || isSetLike(val[0])\n\nconst isMapLikeArrayObject = (val) => isMapLikeArray(val[0]) || isMapLike(val[0])\n\nconst isStringObjectObject = (val) => isStringArray(val[0]) && isStringObject(val[1])\n\nconst isNumberObjectObject = (val) => isNumberArray(val[0]) && isNumberObject(val[1])\n\nconst isBooleanObjectObject = (val) => isBooleanArray(val[0]) && isBooleanObject(val[1])\n\nconst isNullObjectObject = (val) => isNullArray(val[0]) && isNullObject(val[1])\n\nconst isRegExpObjectObject = (val) => isRegExpArray(val[0]) && isRegExpObject(val[1])\n\nconst isDateObjectObject = (val) => isDateArray(val[0]) && isDateObject(val[1])\n\nconst isErrorObjectObject = (val) => isErrorArray(val[0]) && isErrorObject(val[1])\n\nconst isMapObjectObject = (val) => isMapArray(val[0]) && isMapObject(val[1])\n\nconst isWeakMapObjectObject = (val) => isWeakMapArray(val[0]) && isWeakMapObject(val[1])\n\nconst isWeakSetObjectObject = (val) => isWeakSetArray(val[0]) && isWeakSetObject(val[1])\n\nconst isSetLikeObjectObject = (val) => isSetLikeArray(val[0]) || isSetLike(val[0])\n\nconst isMapLikeObjectObject = (val) => isMapLikeArray(val[0]) || isMapLike(val[0])\n\nconst isStringArrayArray = (val) => isStringArray(val[0]) && isStringArray(val[1])\n\nconst isNumberArrayArray = (val) => isNumberArray(val[0]) && isNumberArray(val[1])\n\nconst isBooleanArrayArray = (val) => isBooleanArray(val[0]) && isBooleanArray(val[1])\n\nconst isNullArrayArray = (val) => isNullArray(val[0]) && isNullArray(val[1])\n\nconst isRegExpArrayArray = (val) => isRegExpArray(val[0]) && isRegExpArray(val[1])\n\nconst isDateArrayArray = (val) => isDateArray(val[0]) && isDateArray(val[1])\n\nconst isErrorArrayArray = (val) => isErrorArray(val[0]) && isErrorArray(val[1])\n\nconst isMapArrayArray = (val) => isMapArray(val[0]) && isMapArray(val[1])\n\nconst isWeakMapArrayArray = (val) => isWeakMapArray(val[0]) && isWeakMapArray(val[1])\n\nconst isWeakSetArrayArray = (val) => isWeakSetArray(val[0]) && isWeakSetArray(", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n  of length k with the maxmium k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maxmium = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maxmium", "gc": "<|endoftext|>/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n  of length k with the maxmium k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maxmium = (arr, k) => {\n  if (k === 0) return arr;\n  const len = arr.length;\n  const result = [];\n  let max = 0;\n  let i = 0;\n  while (i < len) {\n    if (arr[i] > max) {\n      max = arr[i];\n      result.push(max);\n    }\n    i++;\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum/discuss/73487/Java-solution-for-the-problem\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar findMaxSubArraySum = function(head, k) {\n  const stack = [];\n  let sum = 0;\n  let curr = head;\n  while (curr) {\n    stack.push(curr);\n    sum += curr.val;\n    curr = curr.next;\n  }\n  while (stack.length) {\n    const curr = stack.pop();\n    if (sum >= k) {\n      sum -= curr.val;\n      curr.next = head;\n      head = curr;\n    } else {\n      curr.next = findMaxSubArraySum(curr.next, k);\n    }\n  }\n  return head;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum/discuss/73487/Java-solution-for-the-problem\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar findMaxSubArraySum = function(head, k) {\n  const stack = [];\n  let sum = 0;\n  let curr = head;\n  while (curr) {\n    stack.push(curr);\n    sum += curr.val;\n    curr = curr.next;\n  }\n  while (stack.length) {\n    const curr = stack.pop();\n    if (sum >= k) {\n      sum -= curr.val;\n      curr.next = head;\n      head = curr;\n    } else {\n      curr.next = findMaxSubArraySum(curr.next, k);\n    }\n  }\n  return head;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum/discuss/73487/Java-solution-for-the-problem\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar findMaxSubArraySum = function(head, k) {\n  const stack = [];\n  let sum = 0;\n  let curr = head;\n  while (curr) {\n    stack.push(curr);\n    sum += curr.val;\n    curr = curr.next;\n  }\n  while (stack.length) {\n    const curr = stack.pop();\n    if (sum >= k) {\n      sum -= curr.val;\n      curr.next = head;\n      head = curr;\n    } else {\n      curr.next = findMaxSubArraySum(curr.next, k);\n    }\n  }\n  return head;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum/discuss/73487/Java-solution-for-the-problem\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar findMaxSubArraySum = function(head, k) {\n  const stack = [];\n  let sum = 0;\n  let curr = head;\n  while (curr) {\n    stack.push(curr);\n    sum += curr.val;\n    curr = curr.next;\n  }\n  while (stack.length) {\n    const curr = stack.pop();\n    if (sum >= k) {\n      sum -= curr.val;\n      curr.next = head;\n      head = curr;\n    } else {\n      curr.next = findMaxSubArraySum(curr.next, k);\n    }\n  }\n  return head;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum/discuss/73487/Java-solution-for-the-problem\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar findMaxSubArraySum = function(head, k) {\n  const stack = [];\n  let sum = 0;\n  let curr = head;\n  while (curr) {\n    stack.push(curr);\n    sum += curr.val;\n    curr = curr.next;\n  }\n  while (stack.length) {\n    const curr = stack.pop();\n    if (sum >= k) {\n      sum -= curr.val;\n      curr.next = head;\n      head = curr;\n    } else {\n      curr.next = findMaxSubArraySum(curr.next, k);\n    }\n  }\n  return head;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum/discuss/73487/Java-solution-for-the-problem\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar findMaxSubArraySum = function(head, k) {\n  const stack = [];\n  let sum = 0;\n  let curr = head;\n  while (curr) {\n    stack.push(curr);\n    sum += curr.val;\n    curr = curr.next;\n  }\n  while (stack.length) {\n    const curr = stack.pop();\n    if (sum >= k) {\n      sum -= curr.val;\n      curr.next = head;\n      head = curr;\n    } else {\n      curr.next = findMaxSubArraySum(curr.next, k);\n    }\n  }\n  return head;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum/discuss/73487/Java-solution-for-the-problem\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar findMaxSubArraySum = function(head, k) {\n  const stack = [];\n  let sum = 0;\n  let curr = head;\n  while (curr) {\n    stack.push(curr);\n    sum += curr.val;\n    curr = curr.next;\n  }\n  while (stack.length) {\n    const curr = stack.pop();\n    if (sum >= k) {\n      sum -= curr.val;\n      curr.", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/121", "prompt": "/*Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "gc": "<|endoftext|>/*Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    if (num % 2 === 0) {\n      sum += num;\n    }\n  });\n  return sum;\n};\n\nmodule.exports = solution;\n\n},{}],3:[function(require,module,exports){\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    if (num % 2 === 0) {\n      sum += num;\n    }\n  });\n  return sum;\n};\n\nmodule.exports = solution;\n\n},{}],4:[function(require,module,exports){\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    if (num % 2 === 0) {\n      sum += num;\n    }\n  });\n  return sum;\n};\n\nmodule.exports = solution;\n\n},{}],5:[function(require,module,exports){\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    if (num % 2 === 1) {\n      sum += num;\n    }\n  });\n  return sum;\n};\n\nmodule.exports = solution;\n\n},{}],6:[function(require,module,exports){\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    if (num % 2 === 1) {\n      sum += num;\n    }\n  });\n  return sum;\n};\n\nmodule.exports = solution;\n\n},{}],7:[function(require,module,exports){\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    if (num % 2 === 1) {\n      sum += num;\n    }\n  });\n  return sum;\n};\n\nmodule.exports = solution;\n\n},{}],8:[function(require,module,exports){\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    if (num % 2 === 1) {\n      sum += num;\n    }\n  });\n  return sum;\n};\n\nmodule.exports = solution;\n\n},{}],9:[function(require,module,exports){\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    if (num % 2 === 1) {\n      sum += num;\n    }\n  });\n  return sum;\n};\n\nmodule.exports = solution;\n\n},{}],10:[function(require,module,exports){\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    if (num % 2 === 1) {\n      sum += num;\n    }\n  });\n  return sum;\n};\n\nmodule.exports = solution;\n\n},{}],11:[function(require,module,exports){\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    if (num % 2 === 1) {\n      sum += num;\n    }\n  });\n  return sum;\n};\n\nmodule.exports = solution;\n\n},{}],12:[function(require,module,exports){\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    if (num % 2 === 1) {\n      sum += num;\n    }\n  });\n  return sum;\n};\n\nmodule.exports = solution;\n\n},{}],13:[function(require,module,exports){\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    if (num % 2 === 1) {\n      sum += num;\n    }\n  });\n  return sum;\n};\n\nmodule.exports = solution;\n\n},{}],14:[function(require,module,exports){\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    if (num % 2 === 1) {\n      sum += num;\n    }\n  });\n  return sum;\n};\n\nmodule.exports = solution;\n\n},{}],15:[function(require,module,exports){\n/*Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "gc": "<|endoftext|>/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum + addElements(arr.slice(k), k);\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the maximum element in the array that is at most k digits from the first k elements of arr.\n\n * Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 4000 # maximum element in the array that is at most 4 digits from the first 4 elements of arr\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst maxElement = (arr, k) => {\n  let max = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0) {\n      max = Math.max(max, arr[i]);\n    }\n  }\n  return max;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the minimum element in the array that is at most k digits from the first k elements of arr.\n\n * Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 111 # minimum element in the array that is at most 4 digits from the first 4 elements of arr\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst minElement = (arr, k) => {\n  let min = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0) {\n      min = Math.min(min, arr[i]);\n    }\n  }\n  return min;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the maximum element in the array that is at most k digits from the first k elements of arr.\n\n * Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 900 # maximum element in the array that is at most 4 digits from the first 4 elements of arr\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst maxElementWithK = (arr, k) => {\n  let max = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0) {\n      max = Math.max(max, arr[i]);\n    }\n  }\n  return max;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the minimum element in the array that is at most k digits from the first k elements of arr.\n\n * Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 111 # minimum element in the array that is at most 4 digits from the first 4 elements of arr\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst minElementWithK = (arr, k) => {\n  let min = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0) {\n      min = Math.min(min, arr[i]);\n    }\n  }\n  return min;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the maximum element in the array that is at most k digits from the first k elements of arr.\n\n * Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 900 # maximum element in the array that is at most 4 digits from the first 4 elements of arr\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst maxElementWithKWithK = (arr, k) => {\n  let max = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0) {\n      max = Math.max(max, arr[i]);\n    }\n  }\n  return max;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the maximum element in the array that is at most k digits from the first k elements of arr.\n\n * Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 900 # maximum element in the array that is at most 4 digits from the first 4 elements of arr\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst minElementWithKWithK = (arr, k) => {\n  let min = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0) {\n      min = Math.min(min, arr[i]);\n    }\n  }\n  return min;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the maximum element in the array that is at most k digits from the first k elements of arr.\n\n * Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 900 # maximum element in the array that is at most 4 digits from the first 4 elements of arr\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst maxElementWithKWithKWithK = (arr, k) => {\n  let max = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0) {\n      max = Math.max(max, arr[i]);\n    }\n  }\n  return max;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the maximum element in the array that is at most k digits from the first k elements of arr.\n\n * Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 900 # maximum element in the array that is at most 4 digits from the first 4 elements of arr\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst minElementWithKWithKWithK = (arr, k) => {\n  let min = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0) {\n      min = Math.min(min, arr[i]);\n    }\n  }\n  return min;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the maximum element in the array that is at most k digits from the first k elements of arr.\n\n * Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 900 # maximum element in the array that is at most 4 digits from the first 4 elements of arr\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst maxElementWithKWithKWithKWithK = (arr, k) => {\n  let max = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0) {\n      max = Math.max(max, arr[i]);\n    }\n  }\n  return max;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the maximum element in the array that is at most k digits from the first k elements of arr.\n\n * Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 900 # maximum element in the array that is at most 4 digits from the first 4 elements of arr\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst maxElementWithKWithKWithKWithKWithK = (arr, k) => {\n  let max = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0) {\n      max = Math.max(max, arr[i]);\n    }\n  }\n  return max;\n};\n\n/**\n * Given a non-empty array of ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "gc": "<|endoftext|>/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] < n) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 1] + 1;\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the even numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5, 16, 8, 4, 2] # The collatz sequence for 5 is [1, 5, 16, 8, 4, 2, 1], \n  so the even numbers are 1, 5, 16, 8, 4, and 2.\n  */\nconst getEvenCollatz = (n) => {\n  let collatz = [1, 1];\n  let i = 1;\n  while (collatz[i] > n) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 1] + 1;\n    i++;\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime factors of n.\n\n  The prime factors of n are those numbers that have no positive divisors other than themselves.\n\n  For example:\n  getPrimeFactors(5) returns [2, 3] # The prime factors of 5 is [2, 3], so 2 & 3 are prime factors.\n  */\nconst getPrimeFactors = (n) => {\n  let factors = [];\n  let i = 1;\n  while (n % i!== 0) {\n    factors.push(i);\n    i++;\n  }\n  return factors;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime factors of n.\n\n  The prime factors of n are those numbers that have no positive divisors other than themselves.\n\n  For example:\n  getPrimeFactors(5) returns [2, 3] # The prime factors of 5 is [2, 3], so 2 & 3 are prime factors.\n  */\nconst getPrimeFactors2 = (n) => {\n  let factors = [];\n  let i = 1;\n  while (n % i!== 0) {\n    factors.push(i);\n    i++;\n  }\n  return factors;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime factors of n.\n\n  The prime factors of n are those numbers that have no positive divisors other than themselves.\n\n  For example:\n  getPrimeFactors(5) returns [2, 3] # The prime factors of 5 is [2, 3], so 2 & 3 are prime factors.\n  */\nconst getPrimeFactors3 = (n) => {\n  let factors = [];\n  let i = 1;\n  while (n % i!== 0) {\n    factors.push(i);\n    i++;\n  }\n  return factors;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime factors of n.\n\n  The prime factors of n are those numbers that have no positive divisors other than themselves.\n\n  For example:\n  getPrimeFactors(5) returns [2, 3] # The prime factors of 5 is [2, 3], so 2 & 3 are prime factors.\n  */\nconst getPrimeFactors4 = (n) => {\n  let factors = [];\n  let i = 1;\n  while (n % i!== 0) {\n    factors.push(i);\n    i++;\n  }\n  return factors;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime factors of n.\n\n  The prime factors of n are those numbers that have no positive divisors other than themselves.\n\n  For example:\n  getPrimeFactors(5) returns [2, 3] # The prime factors of 5 is [2, 3], so 2 & 3 are prime factors.\n  */\nconst getPrimeFactors5 = (n) => {\n  let factors = [];\n  let i = 1;\n  while (n % i!== 0) {\n    factors.push(i);\n    i++;\n  }\n  return factors;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime factors of n.\n\n  The prime factors of n are those numbers that have no positive divisors other than themselves.\n\n  For example:\n  getPrimeFactors(5) returns [2, 3] # The prime factors of 5 is [2, 3], so 2 & 3 are prime factors.\n  */\nconst getPrimeFactors6 = (n) => {\n  let factors = [];\n  let i = 1;\n  while (n % i!== 0) {\n    factors.push(i);\n    i++;\n  }\n  return factors;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime factors of n.\n\n  The prime factors of n are those numbers that have no positive divisors other than themselves.\n\n  For example:\n  getPrimeFactors(5) returns [2, 3] # The prime factors of 5 is [2, 3], so 2 & 3 are prime factors.\n  */\nconst getPrimeFactors7 = (n) => {\n  let factors = [];\n  let i = 1;\n  while (n % i!== 0) {\n    factors.push(i);\n    i++;\n  }\n  return factors;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime factors of n.\n\n  The prime factors of n are those numbers that have no positive divisors other than themselves.\n\n  For example:\n  getPrimeFactors(5) returns [2, 3] # The prime factors of 5 is [2, 3], so 2 & 3 are prime factors.\n  */\nconst getPrimeFactors8 = (n) => {\n  let factors = [];\n  let i = 1;\n  while (n % i!== 0) {\n    factors.push(i);\n    i++;\n  }\n  return factors;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime factors of n.\n\n  The prime factors of n are those numbers that have no positive divisors other than themselves.\n\n  For example:\n  getPrimeFactors(5) returns [2, 3] # The prime factors of 5 is [2, 3], so 2 & 3 are prime factors.\n  */\nconst getPrimeFactors9 = (n) => {\n  let factors = [];\n  let i = 1;\n  while (n % i!== 0) {\n    factors.push(i);\n    i++;\n  }\n  return factors;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime factors of n.\n\n  The prime factors of n are those numbers that have no positive divisors other than themselves.\n\n  For example:\n  getPrimeFactors(5) returns [2, 3] # The prime factors of 5 is [2, 3], so 2 & 3 are prime factors.\n  */\nconst getPrimeFactors10 = (n) => {\n  let factors = [];\n  let i = 1;\n  while (n % i!== 0) {\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/124", "prompt": "/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "gc": "<|endoftext|>/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const dateString = date.toString();\n  const [month, day, year] = dateString.split('-');\n  const isValid = year >= 1900;\n  const isValidMonth = month >= 1 && month <= 12;\n  const isValidDay = day >= 1 && day <= 31;\n  const isValidYear = year >= 1900;\n  return isValid && isValidMonth && isValidDay && isValidYear;\n};\n\n/*\n  Given a date string and a month number, returns the date in that month.\n  If the month number is invalid, returns null.\n  If the date string is invalid, returns null.\n  If the date string is valid but the month number is invalid, returns null.\n  If the date string is valid but the month number is valid, returns null.\n  If the date string is valid but the day number is invalid, returns null.\n  If the date string is valid but the day number is valid, returns null.\n  If the date string is valid but the year number is invalid, returns null.\n  If the date string is valid but the year number is valid, returns null.\n  If the date string is valid but the day number is valid but the month number is invalid, returns null.\n  If the date string is valid but the day number is valid but the month number is valid, returns null.\n  If the date string is valid but the day number is valid but the year number is invalid, returns null.\n  If the date string is valid but the day number is valid but the year number is valid, returns null.\n  If the date string is valid but the day number is valid but the month number is valid but the year number is valid, returns null.\n  If the date string is valid but the day number is valid but the month number is valid and the year number is invalid, returns null.\n  If the date string is valid but the day number is valid but the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid but the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid but the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid but the day number is valid and the month number is valid and the year number is valid, returns null.\n  If the date string is valid ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/125", "prompt": "/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "gc": "<|endoftext|>/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(\" \");\n  const splitWordsArr = [];\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "gc": "<|endoftext|>/* Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  return sorted.length === lst.length;\n};\n\n/**\n * Given a list of numbers, return whether or not they are sorted\n  in descending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5, 1, 6, 2, 3])  false\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isDescending = (lst) => {\n  const sorted = lst.sort((a, b) => b - a);\n  return sorted.length === lst.length;\n};\n\n/**\n * Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5, 1, 6, 2, 3])  true\n  isSorted([1, 2, 3, 4, 5])  false\n  isSorted([1, 3, 2, 4, 5])  true\n  isSorted([1, 2, 3, 4, 5, 6])  false\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isAscending = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  return sorted.length === lst.length;\n};\n\n/**\n * Given a list of numbers, return whether or not they are sorted\n  in descending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5, 1, 6, 2, 3])  true\n  isSorted([1, 2, 3, 4, 5])  false\n  isSorted([1, 3, 2, 4, 5])  true\n  isSorted([1, 2, 3, 4, 5, 6])  false\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isDescendingAscending = (lst) => {\n  const sorted = lst.sort((a, b) => b - a);\n  return sorted.length === lst.length;\n};\n\n/**\n * Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5, 1, 6, 2, 3])  true\n  isSorted([1, 2, 3, 4, 5])  false\n  isSorted([1, 3, 2, 4, 5])  true\n  isSorted([1, 2, 3, 4, 5, 6])  false\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isAscendingDescending = (lst) => {\n  const sorted = lst.sort((a, b) => b - a);\n  return sorted.length === lst.length;\n};\n\n/**\n * Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5, 1, 6, 2, 3])  true\n  isSorted([1, 2, 3, 4, 5])  false\n  isSorted([1, 3, 2, 4, 5])  true\n  isSorted([1, 2, 3, 4, 5, 6])  false\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isDescendingAscendingDescending = (lst) => {\n  const sorted = lst.sort((a, b) => b - a);\n  return sorted.length === lst.length;\n};\n\n/**\n * Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5, 1, 6, 2, 3])  true\n  isSorted([1, 2, 3, 4, 5])  false\n  isSorted([1, 3, 2, 4, 5])  true\n  isSorted([1, 2, 3, 4, 5, 6])  false\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isAscendingDescendingAscending = (lst) => {\n  const sorted = lst.sort((a, b) => b - a);\n  return sorted.length === lst.length;\n};\n\n/**\n * Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5, 1, 6, 2, 3])  true\n  isSorted([1, 2, 3, 4, 5])  false\n  isSorted([1, 3, 2, 4, 5])  true\n  isSorted([1, 2, 3, 4, 5, 6])  false\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isDescendingAscendingDescendingAscending = (lst) => {\n  const sorted = lst.sort((a, b) => b - a);\n  return sorted.length === lst.length;\n};\n\n/**\n * Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/127", "prompt": "/*You are given two intervals,\n  where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "gc": "<|endoftext|>/*You are given two intervals,\n  where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  if (start1 < start2) return false;\n  if (end1 < end2) return false;\n  if (start1 > end2) return false;\n  if (end1 > start2) return false;\n  if (start1 < end1 && end1 < start2) return false;\n  if (start1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > end1 && end1 > start2) return false;\n  if (start1 < end1 && end1 < start1 && end1 < end2) return false;\n  if (start1 > end1 && end1 > ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigsn([1, 2, 2, -4]) == -9\n  >>> prodSigsn([0, 1]) == 0\n  >>> prodSigsn([]) == null\n  */\nconst prodSigsn = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigsn", "gc": "<|endoftext|>/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigsn([1, 2, 2, -4]) == -9\n  >>> prodSigsn([0, 1]) == 0\n  >>> prodSigsn([]) == null\n  */\nconst prodSigsn = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += arr[i] * -1;\n    } else if (arr[i] < 0) {\n      sum += arr[i] * 1;\n    }\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of absolute values of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> absSigsn([1, 2, 2, -4]) == -9\n  >>> absSigsn([0, 1]) == 0\n  >>> absSigsn([]) == null\n  */\nconst absSigsn = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += Math.abs(arr[i]);\n    } else if (arr[i] < 0) {\n      sum += Math.abs(arr[i]) * -1;\n    }\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of squares of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> sqSigsn([1, 2, 2, -4]) == 9\n  >>> sqSigsn([0, 1]) == 0\n  >>> sqSigsn([]) == null\n  */\nconst sqSigsn = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += arr[i] * arr[i];\n    } else if (arr[i] < 0) {\n      sum += arr[i] * arr[i] * -1;\n    }\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of cubes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> cubsSigsn([1, 2, 2, -4]) == 27\n  >>> cubsSigsn([0, 1]) == 0\n  >>> cubsSigsn([]) == null\n  */\nconst cubsSigsn = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += arr[i] * arr[i] * arr[i];\n    } else if (arr[i] < 0) {\n      sum += arr[i] * arr[i] * arr[i] * -1;\n    }\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of cubes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> cubsSigsn([1, 2, 2, -4]) == 27\n  >>> cubsSigsn([0, 1]) == 0\n  >>> cubsSigsn([]) == null\n  */\nconst cubsSigsn = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += arr[i] * arr[i] * arr[i] * arr[i];\n    } else if (arr[i] < 0) {\n      sum += arr[i] * arr[i] * arr[i] * arr[i] * -1;\n    }\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of cubes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> cubsSigsn([1, 2, 2, -4]) == 27\n  >>> cubsSigsn([0, 1]) == 0\n  >>> cubsSigsn([]) == null\n  */\nconst cubsSigsn = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += arr[i] * arr[i] * arr[i] * arr[i] * arr[i];\n    } else if (arr[i] < 0) {\n      sum += arr[i] * arr[i] * arr[i] * arr[i] * arr[i] * -1;\n    }\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of cubes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> cubsSigsn([1, 2, 2, -4]) == 27\n  >>> cubsSigsn([0, 1]) == 0\n  >>> cubsSigsn([]) == null\n  */\nconst cubsSigsn = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += arr[i] * arr[i] * arr[i] * arr[i] * arr[i] * arr[i];\n    } else if (arr[i] < 0) {\n      sum += arr[i] * arr[i] * arr[i] * arr[i] * arr[i] * arr[i] * -1;\n    }\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of cubes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> cubsSigsn([1, 2, 2, -4]) == 27\n  >>> cubsSigsn([0, 1]) == 0\n  >>> cubsSigsn([]) == null\n  */\nconst cubsSigsn = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += arr[i] * arr[i] * arr[i] * arr[i] * arr[i] * arr[i] * arr[i];\n    } else if (arr[i] < 0) {\n      sum += arr[i] * arr[i] * arr[i] * arr[i] * arr[i] * arr[i] * arr[i] * -1;\n    }\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of cubes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> cubsSigsn([1, 2, 2, -4]) == 27\n  >>> cubsSigsn([0, 1]) == 0\n  >>> cubsSigsn([]) == null\n  */\nconst cubsSigsn = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += arr[i] * arr[i] * arr[i] * arr[i] * arr[i] * arr[i] * arr[i] * arr[i];\n    } else if (arr[i] < 0) {\n      sum += arr[i] * arr[i] * arr[i] * arr[i] * arr[i] * arr[i] * arr[i] * arr[i] * arr[i] * -1;\n    }\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of cubes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> cubsSigsn([1, 2, 2, -4]) == 27\n  >>> cubsSigsn([0, 1]) == 0\n  >>> cubsSigsn([]) == null\n  */\nconst cubsSigsn = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      sum += arr[i] * arr[i] * arr[i] * arr[i] * arr[i] * arr[i] * arr[i] * arr[i] * arr[i];\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "gc": "<|endoftext|>/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  let lst_A = [], lst_B = [], ans = Number.MAX_VALUE;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === k) {\n        lst_A.push(grid[i][j]);\n      } else if (grid[i][j] > k) {\n        lst_B.push(grid[i][j]);\n      }\n    }\n  }\n  for (let i = 0; i < lst_A.length; i++) {\n    for (let j = 0; j < lst_B.length; j++) {\n      if (lst_A[i] < lst_B[j]) {\n        ans = Math.min(ans, lst_A[i] + lst_B[j]);\n      }\n    }\n  }\n  return ans;\n};\n\n/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  let lst_A = [], lst_B = [], ans = Number.MAX_VALUE;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === k) {\n        lst_A.push(grid[i][j]);\n      } else if (grid[i][j] > k) {\n        lst_B.push(grid[i][j]);\n      }\n    }\n  }\n  for (let i = 0; i < lst_A.length; i++) {\n    for (let j = 0; j < lst_B.length; j++) {\n      if (lst_A[i] < lst_B[j]) {\n        ans = Math.min(ans, lst_A[i] + lst_B[j]);\n      }\n    }\n  }\n  return ans;\n};\n\n/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  let lst_A = [], lst_B = [], ans = Number.MAX_VALUE;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === k) {\n        lst_A.push(grid[i][j]);\n      } else if (grid[i][j] > k) {\n        lst_B.push(grid[i][j]);\n      }\n    }\n  }\n  for (let i = 0; i < lst_A.length; i++) {\n    for (let j = 0; j < lst_B.length; j++) {\n      if (lst_A[i] < lst_B[j]) {\n        ans = Math.min(ans, lst_A[i] + lst_B[j]);\n      }\n    }\n  }\n  return ans;\n};\n\n/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/13", "prompt": "/* Return a greatest common divisor of two integers a and b\n  >>> rgeatestCommonDivisor(3, 5)\n  1\n  >>> rgeatestCommonDivisor(25, 15)\n  5\n  */\nconst rgeatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "rgeatestCommonDivisor", "gc": "<|endoftext|>/* Return a greatest common divisor of two integers a and b\n  >>> rgeatestCommonDivisor(3, 5)\n  1\n  >>> rgeatestCommonDivisor(25, 15)\n  5\n  */\nconst rgeatestCommonDivisor = (a, b) => {\n  let gcd = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n\n  while (i < a && j < b) {\n    if (a % j === 0) {\n      gcd = j;\n      i++;\n    }\n    if (b % j === 0) {\n      gcd = j;\n      j++;\n    }\n    if (a % j === 0 && b % j === 0) {\n      gcd = j;\n      k++;\n    }\n  }\n\n  return gcd;\n};\n\nconst rgeatestCommonDivisors = (a, b) => {\n  let gcd = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n\n  while (i < a && j < b) {\n    if (a % j === 0) {\n      gcd = j;\n      i++;\n    }\n    if (b % j === 0) {\n      gcd = j;\n      j++;\n    }\n    if (a % j === 0 && b % j === 0) {\n      gcd = j;\n      k++;\n    }\n  }\n\n  return gcd;\n};\n\nconst rgeatestCommonDivisorsOrZero = (a, b) => {\n  let gcd = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n\n  while (i < a && j < b) {\n    if (a % j === 0) {\n      gcd = j;\n      i++;\n    }\n    if (b % j === 0) {\n      gcd = j;\n      j++;\n    }\n    if (a % j === 0 && b % j === 0) {\n      gcd = j;\n      k++;\n    }\n  }\n\n  return gcd;\n};\n\nconst rgeatestCommonDivisorsOrZeros = (a, b) => {\n  let gcd = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n\n  while (i < a && j < b) {\n    if (a % j === 0) {\n      gcd = j;\n      i++;\n    }\n    if (b % j === 0) {\n      gcd = j;\n      j++;\n    }\n    if (a % j === 0 && b % j === 0) {\n      gcd = j;\n      k++;\n    }\n  }\n\n  return gcd;\n};\n\nconst rgeatestCommonDivisorsOrOne = (a, b) => {\n  let gcd = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n\n  while (i < a && j < b) {\n    if (a % j === 0) {\n      gcd = j;\n      i++;\n    }\n    if (b % j === 0) {\n      gcd = j;\n      j++;\n    }\n    if (a % j === 0 && b % j === 0) {\n      gcd = j;\n      k++;\n    }\n  }\n\n  return gcd;\n};\n\nconst rgeatestCommonDivisorsOrOnes = (a, b) => {\n  let gcd = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n\n  while (i < a && j < b) {\n    if (a % j === 0) {\n      gcd = j;\n      i++;\n    }\n    if (b % j === 0) {\n      gcd = j;\n      j++;\n    }\n    if (a % j === 0 && b % j === 0) {\n      gcd = j;\n      k++;\n    }\n  }\n\n  return gcd;\n};\n\nconst rgeatestCommonDivisorsOrTwo = (a, b) => {\n  let gcd = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n\n  while (i < a && j < b) {\n    if (a % j === 0) {\n      gcd = j;\n      i++;\n    }\n    if (b % j === 0) {\n      gcd = j;\n      j++;\n    }\n    if (a % j === 0 && b % j === 0) {\n      gcd = j;\n      k++;\n    }\n  }\n\n  return gcd;\n};\n\nconst rgeatestCommonDivisorsOrTwos = (a, b) => {\n  let gcd = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n\n  while (i < a && j < b) {\n    if (a % j === 0) {\n      gcd = j;\n      i++;\n    }\n    if (b % j === 0) {\n      gcd = j;\n      j++;\n    }\n    if (a % j === 0 && b % j === 0) {\n      gcd = j;\n      k++;\n    }\n  }\n\n  return gcd;\n};\n\nconst rgeatestCommonDivisorsOrThree = (a, b) => {\n  let gcd = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n\n  while (i < a && j < b) {\n    if (a % j === 0) {\n      gcd = j;\n      i++;\n    }\n    if (b % j === 0) {\n      gcd = j;\n      j++;\n    }\n    if (a % j === 0 && b % j === 0) {\n      gcd = j;\n      k++;\n    }\n  }\n\n  return gcd;\n};\n\nconst rgeatestCommonDivisorsOrThrees = (a, b) => {\n  let gcd = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n\n  while (i < a && j < b) {\n    if (a % j === 0) {\n      gcd = j;\n      i++;\n    }\n    if (b % j === 0) {\n      gcd = j;\n      j++;\n    }\n    if (a % j === 0 && b % j === 0) {\n      gcd = j;\n      k++;\n    }\n  }\n\n  return gcd;\n};\n\nconst rgeatestCommonDivisorsOrFour = (a, b) => {\n  let gcd = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n\n  while (i < a && j < b) {\n    if (a % j === 0) {\n      gcd = j;\n      i++;\n    }\n    if (b % j === 0) {\n      gcd = j;\n      j++;\n    }\n    if (a % j === 0 && b % j === 0) {\n      gcd = j;\n      k++;\n    }\n  }\n\n  return gcd;\n};\n\nconst rgeatestCommonDivisorsOrFours = (a, b) => {\n  let gcd = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n\n  while (i < a && j < b) {\n    if (a % j === 0) {\n      gcd = j;\n      i++;\n    }\n    if (b % j === 0) {\n      gcd = j;\n      j++;\n    }\n    if (a % j === 0 && b % j === 0) {\n      gcd = j;\n      k++;\n    }\n  }\n\n  return gcd;\n};\n\nconst rgeatestCommonDivisorsOrFive = (a, b) => {\n  let gcd = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n\n  while (i < a && j < b) {\n    if (a % j === 0) {\n      gcd = j;\n      i++;\n    }\n    if (b % j === 0) {\n      gcd = j;\n      j++;\n    }\n    if (a % j === 0 && b % j === 0) {\n      gcd = j;\n      k++;\n    }\n  }\n\n  return gcd;\n};\n\nconst rgeatestCommonDivisorsOrFives = (a, b) => {\n  let gcd = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n\n  while (i < a && j < b) {\n    if (a % j === 0) {\n      gcd = j;\n      i++;\n    }\n    if (b % j === 0) {\n      gcd = j;\n      j++;\n    }\n    if (a % j === 0 && b % j === 0) {\n      gcd = j;\n      k++;\n    }\n  }\n\n  return gcd;\n};\n\nconst rgeatestCommonDivisor", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, what people don't know is Tribonacci sequence.\n  Tribonacci sequence is defined by the recurrence:\n  tir(1) = 3\n  tir(n) = 1 + n / 2, if n is even.\n  tir(n) =  tir(n - 1) + tir(n - 2) + tir(n + 1), if n is odd.\n  For example:\n  tir(2) = 1 + (2 / 2) = 2\n  tir(4) = 3\n  tir(3) = tir(2) + tir(1) + tir(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tir(3) = [1, 3, 2, 8]\n  */\nconst tir = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tir", "gc": "<|endoftext|>/*Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, what people don't know is Tribonacci sequence.\n  Tribonacci sequence is defined by the recurrence:\n  tir(1) = 3\n  tir(n) = 1 + n / 2, if n is even.\n  tir(n) =  tir(n - 1) + tir(n - 2) + tir(n + 1), if n is odd.\n  For example:\n  tir(2) = 1 + (2 / 2) = 2\n  tir(4) = 3\n  tir(3) = tir(2) + tir(1) + tir(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tir(3) = [1, 3, 2, 8]\n  */\nconst tir = (n) => {\n  if (n <= 1) return [1];\n  if (n <= 2) return [n, 1];\n  if (n <= 3) return [n, 1, 1];\n  if (n <= 5) return [n, 1, 3, 2];\n  if (n <= 8) return [n, 1, 5, 3, 7, 5, 9, 3, 8, 1];\n  if (n <= 15) return [n, 1, 5, 8, 4, 7, 9, 2, 6, 3, 7, 1, 4, 2, 5, 8, 3, 6, 1, 5, 3, 7, 4, 2, 8, 1];\n  if (n <= 30) return [n, 1, 5, 8, 4, 7, 9, 2, 6, 3, 7, 1, 4, 2, 5, 8, 3, 6, 1, 5, 3, 7, 4, 2, 8, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 2];\n  if (n <= 100) return [n, 1, 5, 8, 4, 7, 9, 2, 6, 3, 7, 1, 4, 2, 5, 8, 3, 6, 1, 5, 3, 7, 4, 2, 8, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, 2, 5, 8, 4, 7, 9, 1, 3, 6, ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive integer n, return the product of the odd digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "gc": "<|endoftext|>/*Given a positive integer n, return the product of the odd digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let product = 1;\n  for (let i = 2; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the even digits.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_even = (n) => {\n  let product = 1;\n  for (let i = 2; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 15\n  */\nconst digits_number = (n) => {\n  let product = 1;\n  for (let i = 2; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 15\n  */\nconst digits_string = (n) => {\n  let product = 1;\n  for (let i = 2; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 15\n  */\nconst digits_boolean = (n) => {\n  let product = 1;\n  for (let i = 2; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 15\n  */\nconst digits_array = (n) => {\n  let product = 1;\n  for (let i = 2; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 15\n  */\nconst digits_object = (n) => {\n  let product = 1;\n  for (let i = 2; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 15\n  */\nconst digits_string_key = (n) => {\n  let product = 1;\n  for (let i = 2; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 15\n  */\nconst digits_boolean_key = (n) => {\n  let product = 1;\n  for (let i = 2; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 15\n  */\nconst digits_array_key = (n) => {\n  let product = 1;\n  for (let i = 2; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 15\n  */\nconst digits_object_key = (n) => {\n  let product = 1;\n  for (let i = 2; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 15\n  */\nconst digits_string_key = (n) => {\n  let product = 1;\n  for (let i = 2; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 15\n  */\nconst digits_boolean_key = (n) => {\n  let product = 1;\n  for (let i = 2; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 15\n  */\nconst digits_array_key = (n) => {\n  let product = 1;\n  for (let i = 2; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 15\n  */\nconst digits_object_key = (n) => {\n  let product = 1;\n  for (let i = 2; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 15\n  */\nconst digits_string_key = (n) => {\n  let product = 1;\n  for (let i = 2; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 15\n  */\nconst digits_boolean_key = (n) => {\n  let product = 1;\n  for (let i = 2; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  false\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "gc": "<|endoftext|>/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  false\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n  const isNested = (string) => {\n    const stack = [];\n    const stackLength = 0;\n    const stackIndex = 0;\n    const stackLengthMax = string.length;\n    const stackIndexMax = string.length;\n    const stackIndexMax2 = string.length;\n    const stackIndexMax3 = string.length;\n    let currentIndex = 0;\n    let currentIndex2 = 0;\n    let currentIndex3 = 0;\n    let currentIndex4 = 0;\n    let currentIndex5 = 0;\n    let currentIndex6 = 0;\n    let currentIndex7 = 0;\n    let currentIndex8 = 0;\n    let currentIndex9 = 0;\n    let currentIndex10 = 0;\n    let currentIndex11 = 0;\n    let currentIndex12 = 0;\n    let currentIndex13 = 0;\n    let currentIndex14 = 0;\n    let currentIndex15 = 0;\n    let currentIndex16 = 0;\n    let currentIndex17 = 0;\n    let currentIndex18 = 0;\n    let currentIndex19 = 0;\n    let currentIndex20 = 0;\n    let currentIndex21 = 0;\n    let currentIndex22 = 0;\n    let currentIndex23 = 0;\n    let currentIndex24 = 0;\n    let currentIndex25 = 0;\n    let currentIndex26 = 0;\n    let currentIndex27 = 0;\n    let currentIndex28 = 0;\n    let currentIndex29 = 0;\n    let currentIndex30 = 0;\n    let currentIndex31 = 0;\n    let currentIndex32 = 0;\n    let currentIndex33 = 0;\n    let currentIndex34 = 0;\n    let currentIndex35 = 0;\n    let currentIndex36 = 0;\n    let currentIndex37 = 0;\n    let currentIndex38 = 0;\n    let currentIndex39 = 0;\n    let currentIndex40 = 0;\n    let currentIndex41 = 0;\n    let currentIndex42 = 0;\n    let currentIndex43 = 0;\n    let currentIndex44 = 0;\n    let currentIndex45 = 0;\n    let currentIndex46 = 0;\n    let currentIndex47 = 0;\n    let currentIndex48 = 0;\n    let currentIndex49 = 0;\n    let currentIndex50 = 0;\n    let currentIndex51 = 0;\n    let currentIndex52 = 0;\n    let currentIndex53 = 0;\n    let currentIndex54 = 0;\n    let currentIndex55 = 0;\n    let currentIndex56 = 0;\n    let currentIndex57 = 0;\n    let currentIndex58 = 0;\n    let currentIndex59 = 0;\n    let currentIndex60 = 0;\n    let currentIndex61 = 0;\n    let currentIndex62 = 0;\n    let currentIndex63 = 0;\n    let currentIndex64 = 0;\n    let currentIndex65 = 0;\n    let currentIndex66 = 0;\n    let currentIndex67 = 0;\n    let currentIndex68 = 0;\n    let currentIndex69 = 0;\n    let currentIndex70 = 0;\n    let currentIndex71 = 0;\n    let currentIndex72 = 0;\n    let currentIndex73 = 0;\n    let currentIndex74 = 0;\n    let currentIndex75 = 0;\n    let currentIndex76 = 0;\n    let currentIndex77 = 0;\n    let currentIndex78 = 0;\n    let currentIndex79 = 0;\n    let currentIndex80 = 0;\n    let currentIndex81 = 0;\n    let currentIndex82 = 0;\n    let currentIndex83 = 0;\n    let currentIndex84 = 0;\n    let currentIndex85 = 0;\n    let currentIndex86 = 0;\n    let currentIndex87 = 0;\n    let currentIndex88 = 0;\n    let currentIndex89 = 0;\n    let currentIndex90 = 0;\n    let currentIndex91 = 0;\n    let currentIndex92 = 0;\n    let currentIndex93 = 0;\n    let currentIndex94 = 0;\n    let currentIndex95 = 0;\n    let currentIndex96 = 0;\n    let currentIndex97 = 0;\n    let currentIndex98 = 0;\n    let currentIndex99 = 0;\n    let currentIndex100 = 0;\n    let currentIndex101 = 0;\n    let currentIndex102 = 0;\n    let currentIndex103 = 0;\n    let currentIndex104 = 0;\n    let currentIndex105 = 0;\n    let currentIndex106 = 0;\n    let currentIndex107 = 0;\n    let currentIndex108 = 0;\n    let currentIndex109 = 0;\n    let currentIndex110 = 0;\n    let currentIndex111 = 0;\n    let currentIndex112 = 0;\n    let currentIndex113 = 0;\n    let currentIndex114 = 0;\n    let currentIndex115 = 0;\n    let currentIndex116 = 0;\n    let currentIndex117 = 0;\n    let currentIndex118 = 0;\n    let currentIndex119 = 0;\n    let currentIndex120 = 0;\n    let currentIndex121 = 0;\n    let currentIndex122 = 0;\n    let currentIndex123 = 0;\n    let currentIndex124 = 0;\n    let currentIndex125 = 0;\n    let currentIndex126 = 0;\n    let currentIndex127 = 0;\n    let currentIndex128 = 0;\n    let currentIndex129 = 0;\n    let currentIndex130 = 0;\n    let currentIndex131 = 0;\n    let currentIndex132 = 0;\n    let currentIndex133 = 0;\n    let currentIndex134 = 0;\n    let currentIndex135 = 0;\n    let currentIndex136 = 0;\n    let currentIndex137 = 0;\n    let currentIndex138 = 0;\n    let currentIndex139 = 0;\n    let currentIndex140 = 0;\n    let currentIndex141 = 0;\n    let currentIndex142 = 0;\n    let currentIndex143 = 0;\n    let currentIndex144 = 0;\n    let currentIndex145 = 0;\n    let currentIndex146 = 0;\n    let currentIndex147 = 0;\n    let currentIndex148 = 0;\n    let currentIndex149 = 0;\n    let currentIndex150 = 0;\n    let currentIndex151 = 0;\n    let currentIndex152 = 0;\n    let currentIndex153 = 0;\n    let currentIndex154 = 0;\n    let currentIndex155 = 0;\n    let currentIndex156 = 0;\n    let currentIndex157 = 0;\n    let currentIndex158 = 0;\n    let currentIndex159 = 0;\n    let currentIndex160 = 0;\n    let currentIndex161 = 0;\n    let currentIndex162 = 0;\n    let currentIndex163 = 0;\n    let currentIndex164 = 0;\n    let currentIndex165 = 0;\n    let currentIndex166 = 0;\n    let currentIndex167 = 0;\n    let currentIndex168 = 0;\n    let currentIndex169 = 0;\n    let currentIndex170 = 0;\n    let currentIndex171 = 0;\n    let currentIndex172 = 0;\n    let currentIndex173 = 0;\n    let currentIndex174 = 0;\n    let currentIndex175 = 0;\n    let currentIndex176 = 0;\n    let currentIndex177 = 0;\n    let currentIndex178 = 0;\n    let currentIndex179 = 0;\n    let currentIndex180 = 0;\n    let currentIndex181 = 0;\n    let currentIndex182 = 0;\n    let currentIndex183 = 0;\n    let currentIndex184 = 0;\n    let currentIndex185 = 0;\n    let currentIndex186 = 0;\n    let currentIndex187 = 0;\n    let currentIndex188 = 0;\n    let currentIndex189 = 0;\n    let currentIndex190 = 0;\n    let currentIndex191 = 0;\n    let currentIndex192 = 0;\n    let currentIndex193 = 0;\n    let currentIndex194 = 0;\n    let currentIndex195 = 0;\n    let currentIndex196 = 0;\n    let currentIndex197 = 0;\n    let currentIndex198 = 0;\n    let currentIndex199 = 0;\n    let currentIndex200 = 0;\n    let currentIndex201 = 0;\n    let currentIndex202 = 0;\n    let currentIndex203 = 0;\n    let currentIndex204 = 0;\n    let currentIndex205 = 0;\n    let currentIndex206 = 0;\n    let currentIndex207 = 0;\n    let currentIndex208 = 0;\n    let currentIndex209 = 0;\n    let currentIndex210 = 0;\n    let currentIndex211 = 0;\n    let currentIndex212 = 0;\n    let currentIndex213 = 0;\n    let currentIndex214 = 0;\n    let currentIndex215 = 0;\n    let currentIndex216 = 0;\n    let currentIndex217 = 0;\n    let currentIndex218 = 0;\n    let currentIndex219 = 0;\n    let currentIndex220 = 0;\n    let currentIndex221 = 0;\n    let currentIndex222 = 0;\n    let currentIndex223 = 0;\n    let currentIndex224 = 0;\n    let currentIndex225 = 0;\n    let currentIndex226 = 0;\n    let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/133", "prompt": "/*You are given a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "gc": "<|endoftext|>/*You are given a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.pow(lst[i], 2);\n  }\n  return Math.ceil(sum);\n};\n\n/*\n  You are given a list of numbers.\n  You are given two numbers a and b. Return the product of numbers in the given list.\n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = [1,4,9] the output should be 24\n  For lst = [1,3,5,7] the output should be 720\n  For lst = [1.4,4.2,0] the output should be 720\n  For lst = [-2.4,1,1] the output should be 720\n  */\nconst product = (lst) => {\n  let product = 1;\n  for (let i = 0; i < lst.length; i++) {\n    product *= lst[i];\n  }\n  return product;\n};\n\n/*\n  You are given a list of numbers.\n  You are given two numbers a and b. Return the sum of numbers in the given list.\n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = [1,4,9] the output should be 24\n  For lst = [1,3,5,7] the output should be 720\n  For lst = [1.4,4.2,0] the output should be 720\n  For lst = [-2.4,1,1] the output should be 720\n  */\nconst sum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\n/*\n  You are given a list of numbers.\n  You are given two numbers a and b. Return the difference of numbers in the given list.\n  Examples:\n  For lst = [1,2,3] the output should be 1\n  For lst = [1,4,9] the output should be 2\n  For lst = [1,3,5,7] the output should be 3\n  For lst = [1.4,4.2,0] the output should be 1\n  For lst = [-2.4,1,1] the output should be -1\n  */\nconst difference = (lst) => {\n  let difference = 0;\n  for (let i = 0; i < lst.length; i++) {\n    difference += lst[i] - lst[i + 1];\n  }\n  return difference;\n};\n\n/*\n  You are given a list of numbers.\n  You are given two numbers a and b. Return the product of numbers in the given list.\n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = [1,4,9] the output should be 24\n  For lst = [1,3,5,7] the output should be 720\n  For lst = [1.4,4.2,0] the output should be 720\n  For lst = [-2.4,1,1] the output should be 720\n  */\nconst productOf = (lst) => {\n  let product = 1;\n  for (let i = 0; i < lst.length; i++) {\n    product *= lst[i];\n  }\n  return product;\n};\n\n/*\n  You are given a list of numbers.\n  You are given two numbers a and b. Return the sum of numbers in the given list.\n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = [1,4,9] the output should be 24\n  For lst = [1,3,5,7] the output should be 720\n  For lst = [1.4,4.2,0] the output should be 720\n  For lst = [-2.4,1,1] the output should be 720\n  */\nconst sumOf = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\n/*\n  You are given a list of numbers.\n  You are given two numbers a and b. Return the difference of numbers in the given list.\n  Examples:\n  For lst = [1,2,3] the output should be 1\n  For lst = [1,4,9] the output should be 2\n  For lst = [1,3,5,7] the output should be 3\n  For lst = [1.4,4.2,0] the output should be 1\n  For lst = [-2.4,1,1] the output should be -1\n  */\nconst differenceOf = (lst) => {\n  let difference = 0;\n  for (let i = 0; i < lst.length; i++) {\n    difference += lst[i] - lst[i + 1];\n  }\n  return difference;\n};\n\n/*\n  You are given a list of numbers.\n  You are given two numbers a and b. Return the product of numbers in the given list.\n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = [1,4,9] the output should be 24\n  For lst = [1,3,5,7] the output should be 720\n  For lst = [1.4,4.2,0] the output should be 720\n  For lst = [-2.4,1,1] the output should be 720\n  */\nconst productOfOf = (lst) => {\n  let product = 1;\n  for (let i = 0; i < lst.length; i++) {\n    product *= lst[i];\n  }\n  return product;\n};\n\n/*\n  You are given a list of numbers.\n  You are given two numbers a and b. Return the sum of numbers in the given list.\n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = [1,4,9] the output should be 24\n  For lst = [1,3,5,7] the output should be 720\n  For lst = [1.4,4.2,0] the output should be 720\n  For lst = [-2.4,1,1] the output should be 720\n  */\nconst sumOfOf = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\n/*\n  You are given a list of numbers.\n  You are given two numbers a and b. Return the difference of numbers in the given list.\n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = [1,4,9] the output should be 24\n  For lst = [1,3,5,7] the output should be 720\n  For lst = [1.4,4.2,0] the output should be 720\n  For lst = [-2.4,1,1] the output should be 720\n  */\nconst differenceOfOf = (lst) => {\n  let difference = 0;\n  for (let i = 0; i < lst.length; i++) {\n    difference += lst[i] - lst[i + 1];\n  }\n  return difference;\n};\n\n/*\n  You are given a list of numbers.\n  You are given two numbers a and b. Return the product of numbers in the given list.\n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = [1,4,9] the output should be 24\n  For lst = [1,3,5,7] the output should be 720\n  For lst = [1.4,4.2,0] the output should be 720\n  For lst = [-2.4,1,1] the output should be 720\n  */\nconst productOfOfOf = (lst) => {\n  let product = 1;\n  for (let i = 0; i < lst.length; i++) {\n    product *= lst[i];\n  }\n  return product;\n};\n\n/*\n  You are given a list of numbers.\n  You are given two numbers a and b. Return the sum of numbers in the given list.\n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = [1,4,9] the output should be 24\n  For lst = [1,3,5,7] the output should be 720\n  For lst = [1.4,4.2,0] the output should be 720\n  For lst = [-2.4,1,1] the output should be 720\n  */\nconst sumOfOfOf = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\n/*\n  You are given a list of numbers.\n  You are given two numbers a and b. Return the difference of numbers in the given list.\n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = [1,4,9] the output should be 24\n  For lst = [1,3,5,7] the output should be 720\n", "passed": 1, "run_status": 0, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/134", "prompt": "/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "gc": "<|endoftext|>/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!=='' && lastChar!== '.' && lastChar!== '?' && lastChar!== '!';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!== '.' && lastChar!== '?' && lastChar!== '!' && lastChar!== '.' && lastChar!== '!';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!== '.' && lastChar!== '?' && lastChar!== '!' && lastChar!== '.' && lastChar!== '!';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!== '.' && lastChar!== '?' && lastChar!== '!' && lastChar!== '.' && lastChar!== '!';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!== '.' && lastChar!== '?' && lastChar!== '!' && lastChar!== '.' && lastChar!== '!';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!== '.' && lastChar!== '?' && lastChar!== '!' && lastChar!== '.' && lastChar!== '!';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!== '.' && lastChar!== '?' && lastChar!== '!' && lastChar!== '.' && lastChar!== '!';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!== '.' && lastChar!== '?' && lastChar!== '!' && lastChar!== '.' && lastChar!== '!';\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIf", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/135", "prompt": "/*Create a function which returns the largest index of an element which\n  is not greater than or equal to the element immediately preceding it. If\n  no such element exists then return -1. The given array will not contain\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "gc": "<|endoftext|>/*Create a function which returns the largest index of an element which\n  is not greater than or equal to the element immediately preceding it. If\n  no such element exists then return -1. The given array will not contain\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let index = -1;\n  let max = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      index = i;\n    }\n  }\n  return index;\n};\n\n/*\n  Given an array of integers, return an array which contains all possible pairs of\n  integers such that each pair contains at least one element from arr and\n  no element from arr itself.\n\n  Examples:\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/136", "prompt": "/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestSmallestIntgeers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "lagrestSmallestIntgeers", "gc": "<|endoftext|>/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestSmallestIntgeers = (lst) => {\n  let maxIntgeer = 0;\n  let minIntgeer = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > maxIntgeer) {\n      maxIntgeer = lst[i];\n    }\n    if (lst[i] < minIntgeer) {\n      minIntgeer = lst[i];\n    }\n  }\n  return [minIntgeer, maxIntgeer];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestSmallestIntgeers2 = (lst, maxIntgeer) => {\n  let maxIntgeer2 = 0;\n  let minIntgeer2 = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > maxIntgeer2) {\n      maxIntgeer2 = lst[i];\n    }\n    if (lst[i] < minIntgeer2) {\n      minIntgeer2 = lst[i];\n    }\n  }\n  return [minIntgeer2, maxIntgeer2];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestSmallestIntgeers3 = (lst, maxIntgeer) => {\n  let maxIntgeer3 = 0;\n  let minIntgeer3 = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > maxIntgeer3) {\n      maxIntgeer3 = lst[i];\n    }\n    if (lst[i] < minIntgeer3) {\n      minIntgeer3 = lst[i];\n    }\n  }\n  return [minIntgeer3, maxIntgeer3];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestSmallestIntgeers4 = (lst, maxIntgeer) => {\n  let maxIntgeer4 = 0;\n  let minIntgeer4 = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > maxIntgeer4) {\n      maxIntgeer4 = lst[i];\n    }\n    if (lst[i] < minIntgeer4) {\n      minIntgeer4 = lst[i];\n    }\n  }\n  return [minIntgeer4, maxIntgeer4];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestSmallestIntgeers5 = (lst, maxIntgeer) => {\n  let maxIntgeer5 = 0;\n  let minIntgeer5 = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > maxIntgeer5) {\n      maxIntgeer5 = lst[i];\n    }\n    if (lst[i] < minIntgeer5) {\n      minIntgeer5 = lst[i];\n    }\n  }\n  return [minIntgeer5, maxIntgeer5];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestSmallestIntgeers6 = (lst, maxIntgeer) => {\n  let maxIntgeer6 = 0;\n  let minIntgeer6 = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > maxIntgeer6) {\n      maxIntgeer6 = lst[i];\n    }\n    if (lst[i] < minIntgeer6) {\n      minIntgeer6 = lst[i];\n    }\n  }\n  return [minIntgeer6, maxIntgeer6];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestSmallestIntgeers7 = (lst, maxIntgeer) => {\n  let maxIntgeer7 = 0;\n  let minIntgeer7 = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > maxIntgeer7) {\n      maxIntgeer7 = lst[i];\n    }\n    if (lst[i] < minIntgeer7) {\n      minIntgeer7 = lst[i];\n    }\n  }\n  return [minIntgeer7, maxIntgeer7];\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrest", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be . or ,\n\n  compaerOne(1, 2.5)  2.5\n  compaerOne(1, \"2,3\")  \"2,3\"\n  compaerOne(\"5,1\", \"6\")  \"6\"\n  compaerOne(\"1\", 1)  null\n  */\nconst compaerOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compaerOne", "gc": "<|endoftext|>/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compaerOne(1, 2.5)  2.5\n  compaerOne(1, \"2,3\")  \"2,3\"\n  compaerOne(\"5,1\", \"6\")  \"6\"\n  compaerOne(\"1\", 1)  null\n  */\nconst compaerOne = (a, b) => {\n  if (a === null || b === null) {\n    return null\n  }\n  if (a === \"\" || b === \"\") {\n    return null\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (isNaN(a) && isNaN(b)) {\n    return null\n  }\n  if (isNaN(b)) {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "gc": "<|endoftext|>/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === 4;\n};\n\n/*\n  Given a number n, return true if the number n is divisible by 2, 3, 5, or 7.\n  Example\n  isDivisibleBy(3, 2) == true\n  isDivisibleBy(3, 5) == true\n  isDivisibleBy(3, 7) == false\n  isDivisibleBy(5, 2) == false\n  isDivisibleBy(5, 5) == true\n  isDivisibleBy(5, 7) == false\n  isDivisibleBy(7, 2) == true\n  isDivisibleBy(7, 5) == false\n  isDivisibleBy(7, 7) == false\n  */\nconst isDivisibleBy = (n, divisor) => {\n  let isDivisible = false;\n  if (divisor === 2) {\n    isDivisible = true;\n  } else if (divisor === 5) {\n    isDivisible = true;\n  } else if (divisor === 7) {\n    isDivisible = false;\n  }\n  return isDivisible;\n};\n\n/*\n  Given a number n, return true if the number n is divisible by 2, 3, 5, or 7.\n  Example\n  isDivisibleBySumEven(3, 2) == true\n  isDivisibleBySumEven(3, 5) == true\n  isDivisibleBySumEven(3, 7) == false\n  isDivisibleBySumEven(5, 2) == false\n  isDivisibleBySumEven(5, 5) == true\n  isDivisibleBySumEven(5, 7) == false\n  isDivisibleBySumEven(7, 2) == true\n  isDivisibleBySumEven(7, 5) == false\n  isDivisibleBySumEven(7, 7) == false\n  */\nconst isDivisibleBySumEven = (n, divisor) => {\n  let isDivisible = false;\n  if (divisor === 2) {\n    isDivisible = true;\n  } else if (divisor === 5) {\n    isDivisible = true;\n  } else if (divisor === 7) {\n    isDivisible = false;\n  }\n  return isDivisible;\n};\n\n/*\n  Given a number n, return true if the number n is divisible by 2, 3, 5, or 7.\n  Example\n  isDivisibleBySumEvenSumEven(3, 2) == true\n  isDivisibleBySumEvenSumEven(3, 5) == true\n  isDivisibleBySumEvenSumEven(3, 7) == false\n  isDivisibleBySumEvenSumEven(5, 2) == false\n  isDivisibleBySumEvenSumEven(5, 5) == true\n  isDivisibleBySumEvenSumEven(5, 7) == false\n  isDivisibleBySumEvenSumEven(7, 2) == true\n  isDivisibleBySumEvenSumEven(7, 5) == false\n  isDivisibleBySumEvenSumEven(7, 7) == false\n  */\nconst isDivisibleBySumEvenSumEven = (n, divisor) => {\n  let isDivisible = false;\n  if (divisor === 2) {\n    isDivisible = true;\n  } else if (divisor === 5) {\n    isDivisible = true;\n  } else if (divisor === 7) {\n    isDivisible = false;\n  }\n  return isDivisible;\n};\n\n/*\n  Given a number n, return true if the number n is divisible by 2, 3, 5, or 7.\n  Example\n  isDivisibleBySumEvenSumEven(3, 2) == true\n  isDivisibleBySumEvenSumEven(3, 5) == true\n  isDivisibleBySumEvenSumEven(3, 7) == false\n  isDivisibleBySumEvenSumEven(5, 2) == false\n  isDivisibleBySumEvenSumEven(5, 5) == true\n  isDivisibleBySumEvenSumEven(5, 7) == false\n  isDivisibleBySumEvenSumEven(7, 2) == true\n  isDivisibleBySumEvenSumEven(7, 5) == false\n  isDivisibleBySumEvenSumEven(7, 7) == false\n  */\nconst isDivisibleBySumEvenSumEven = (n, divisor) => {\n  let isDivisible = false;\n  if (divisor === 2) {\n    isDivisible = true;\n  } else if (divisor === 5) {\n    isDivisible = true;\n  } else if (divisor === 7) {\n    isDivisible = false;\n  }\n  return isDivisible;\n};\n\n/*\n  Given a number n, return true if the number n is divisible by 2, 3, 5, or 7.\n  Example\n  isDivisibleBySumEvenSumEven(3, 2) == true\n  isDivisibleBySumEvenSumEven(3, 5) == true\n  isDivisibleBySumEvenSumEven(3, 7) == false\n  isDivisibleBySumEvenSumEven(5, 2) == false\n  isDivisibleBySumEvenSumEven(5, 5) == true\n  isDivisibleBySumEvenSumEven(5, 7) == false\n  isDivisibleBySumEvenSumEven(7, 2) == true\n  isDivisibleBySumEvenSumEven(7, 5) == false\n  isDivisibleBySumEvenSumEven(7, 7) == false\n  */\nconst isDivisibleBySumEvenSumEven = (n, divisor) => {\n  let isDivisible = false;\n  if (divisor === 2) {\n    isDivisible = true;\n  } else if (divisor === 5) {\n    isDivisible = true;\n  } else if (divisor === 7) {\n    isDivisible = false;\n  }\n  return isDivisible;\n};\n\n/*\n  Given a number n, return true if the number n is divisible by 2, 3, 5, or 7.\n  Example\n  isDivisibleBySumEvenSumEven(3, 2) == true\n  isDivisibleBySumEvenSumEven(3, 5) == true\n  isDivisibleBySumEvenSumEven(3, 7) == false\n  isDivisibleBySumEvenSumEven(5, 2) == false\n  isDivisibleBySumEvenSumEven(5, 5) == true\n  isDivisibleBySumEvenSumEven(5, 7) == false\n  isDivisibleBySumEvenSumEven(7, 2) == true\n  isDivisibleBySumEvenSumEven(7, 5) == false\n  isDivisibleBySumEvenSumEven(7, 7) == false\n  */\nconst isDivisibleBySumEvenSumEven = (n, divisor) => {\n  let isDivisible = false;\n  if (divisor === 2) {\n    isDivisible = true;\n  } else if (divisor === 5) {\n    isDivisible = true;\n  } else if (divisor === 7) {\n    isDivisible = false;\n  }\n  return isDivisible;\n};\n\n/*\n  Given a number n, return true if the number n is divisible by 2, 3, 5, or 7.\n  Example\n  isDivisibleBySumEvenSumEven(3, 2) == true\n  isDivisibleBySumEvenSumEven(3, 5) == true\n  isDivisibleBySumEvenSumEven(3, 7) == false\n  isDivisibleBySumEvenSumEven(5, 2) == false\n  isDivisibleBySumEvenSumEven(5, 5) == true\n  isDivisibleBySumEvenSumEven(5, 7) == false\n  isDivisibleBySumEvenSumEven(7, 2) == true\n  isDivisibleBySumEvenSumEven(7, 5) == false\n  isDivisibleBySumEvenSumEven(7, 7) == false\n  */\nconst isDivisibleBySumEvenSumEven = (n, divisor) => {\n  let isDivisible = false;\n  if (divisor === 2) {\n    isDivisible = true;\n  } else if (divisor === 5) {\n    isDivisible = true;\n  } else if (divisor === 7) {\n    isDivisible = false;\n  }\n  return isDivisible;\n};\n\n/*\n  Given a number n, return true if the number n is divisible by 2, 3, 5, or 7.\n  Example\n  isDivisibleBySumEvenSumEven(3, 2) == true", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "gc": "<|endoftext|>/*The Brazilian factorial is defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * n * n * n * n * n;\n};\n\n/*\n  Returns the factorial of n\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/*\n  Returns the factorial of n\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial2 = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * factorial2(n - 1);\n};\n\n/*\n  Returns the factorial of n\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial3 = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * factorial3(n - 1);\n};\n\n/*\n  Returns the factorial of n\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial4 = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * factorial4(n - 1);\n};\n\n/*\n  Returns the factorial of n\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial5 = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * factorial5(n - 1);\n};\n\n/*\n  Returns the factorial of n\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial6 = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * factorial6(n - 1);\n};\n\n/*\n  Returns the factorial of n\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial7 = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * factorial7(n - 1);\n};\n\n/*\n  Returns the factorial of n\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial8 = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * factorial8(n - 1);\n};\n\n/*\n  Returns the factorial of n\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial9 = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * factorial9(n - 1);\n};\n\n/*\n  Returns the factorial of n\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial10 = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * factorial10(n - 1);\n};\n\n/*\n  Returns the factorial of n\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial11 = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * factorial11(n - 1);\n};\n\n/*\n  Returns the factorial of n\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial12 = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * factorial12(n - 1);\n};\n\n/*\n  Returns the factorial of n\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial13 = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * factorial13(n - 1);\n};\n\n/*\n  Returns the factorial of n\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial14 = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * factorial14(n - 1);\n};\n\n/*\n  Returns the factorial of n\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial15 = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * factorial15(n - 1);\n};\n\n/*\n  Returns the factorial of n\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial16 = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * factorial16(n - 1);\n};\n\n/*\n  Returns the factorial of n\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial17 = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * factorial17(n - 1);\n};\n\n/*\n  Returns the factorial of n\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial18 = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * factorial18(n - 1);\n};\n\n/*\n  Returns the factorial of n\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial19 = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * factorial19(n - 1);\n};\n\n/*\n  Returns the factorial of n\n  \n  For example:\n  >>> factorial(4)\n  120\n\n  The function will receive an integer as input and should return the factorial of this\n  integer.\n  */\nconst factorial20 = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * factorial20(n - 1);\n};\n\n/*\n  Returns the factorial of n\n  \n  For example:\n  >>> factorial(4)\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/14", "prompt": "/* Return list of all prefixes from shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "gc": "<|endoftext|>/* Return list of all prefixes from shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  let prefixes = []\n  let currentPrefix = string[0]\n  for (let i = 1; i < string.length; i++) {\n    if (string[i]!== currentPrefix) {\n      prefixes.push(currentPrefix)\n      currentPrefix = string[i]\n    }\n  }\n  return prefixes\n}\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffixes('abc')\n  ['c', 'ba', 'cab']\n  */\nconst allSuffixes = (string) => {\n  let suffixes = []\n  let currentSuffix = string[string.length - 1]\n  for (let i = string.length - 1; i >= 0; i--) {\n    if (string[i]!== currentSuffix) {\n      suffixes.push(currentSuffix)\n      currentSuffix = string[i]\n    }\n  }\n  return suffixes\n}\n\n/* Return list of all common prefixes from shortest to longest of the input string\n  >>> commonPrefixes('abc')\n  ['a', 'b', 'c']\n  */\nconst commonPrefixes = (string) => {\n  let prefixes = []\n  let currentPrefix = string[0]\n  for (let i = 1; i < string.length; i++) {\n    if (string[i]!== currentPrefix) {\n      prefixes.push(currentPrefix)\n      currentPrefix = string[i]\n    }\n  }\n  return prefixes\n}\n\n/* Return list of all common suffixes from shortest to longest of the input string\n  >>> commonSuffixes('abc')\n  ['c', 'ba', 'cab']\n  */\nconst commonSuffixes = (string) => {\n  let suffixes = []\n  let currentSuffix = string[string.length - 1]\n  for (let i = string.length - 1; i >= 0; i--) {\n    if (string[i]!== currentSuffix) {\n      suffixes.push(currentSuffix)\n      currentSuffix = string[i]\n    }\n  }\n  return suffixes\n}\n\n/* Return list of all common characters from shortest to longest of the input string\n  >>> commonCharacters('abc')\n  ['a', 'b', 'c']\n  */\nconst commonCharacters = (string) => {\n  let characters = []\n  let currentCharacter = string[0]\n  for (let i = 1; i < string.length; i++) {\n    if (string[i]!== currentCharacter) {\n      characters.push(currentCharacter)\n      currentCharacter = string[i]\n    }\n  }\n  return characters\n}\n\n/* Return list of all common words from shortest to longest of the input string\n  >>> commonWords('abc')\n  ['a', 'b', 'c']\n  */\nconst commonWords = (string) => {\n  let words = []\n  let currentWord = string[0]\n  for (let i = 1; i < string.length; i++) {\n    if (string[i]!== currentWord) {\n      words.push(currentWord)\n      currentWord = string[i]\n    }\n  }\n  return words\n}\n\n/* Return list of all common words from shortest to longest of the input string\n  >>> commonWords('abc')\n  ['a', 'b', 'c']\n  */\nconst commonWordsWithSpacesAndPunctuation = (string) => {\n  let words = []\n  let currentWord = string[0]\n  for (let i = 1; i < string.length; i++) {\n    if (string[i]!== currentWord) {\n      words.push(currentWord)\n      currentWord = string[i]\n    }\n  }\n  return words\n}\n\n/* Return list of all common words from shortest to longest of the input string\n  >>> commonWordsWithSpacesAndPunctuation('abc')\n  ['a', 'b', 'c']\n  */\nconst commonWordsWithSpacesAndPunctuation = (string) => {\n  let words = []\n  let currentWord = string[0]\n  for (let i = 1; i < string.length; i++) {\n    if (string[i]!== currentWord) {\n      words.push(currentWord)\n      currentWord = string[i]\n    }\n  }\n  return words\n}\n\n/* Return list of all common words from shortest to longest of the input string\n  >>> commonWordsWithSpacesAndPunctuation('abc')\n  ['a', 'b', 'c']\n  */\nconst commonWordsWithSpacesAndPunctuation = (string) => {\n  let words = []\n  let currentWord = string[0]\n  for (let i = 1; i < string.length; i++) {\n    if (string[i]!== currentWord) {\n      words.push(currentWord)\n      currentWord = string[i]\n    }\n  }\n  return words\n}\n\n/* Return list of all common words from shortest to longest of the input string\n  >>> commonWordsWithSpacesAndPunctuation('abc')\n  ['a', 'b', 'c']\n  */\nconst commonWordsWithSpacesAndPunctuation = (string) => {\n  let words = []\n  let currentWord = string[0]\n  for (let i = 1; i < string.length; i++) {\n    if (string[i]!== currentWord) {\n      words.push(currentWord)\n      currentWord = string[i]\n    }\n  }\n  return words\n}\n\n/* Return list of all common words from shortest to longest of the input string\n  >>> commonWordsWithSpacesAndPunctuation('abc')\n  ['a', 'b', 'c']\n  */\nconst commonWordsWithSpacesAndPunctuation = (string) => {\n  let words = []\n  let currentWord = string[0]\n  for (let i = 1; i < string.length; i++) {\n    if (string[i]!== currentWord) {\n      words.push(currentWord)\n      currentWord = string[i]\n    }\n  }\n  return words\n}\n\n/* Return list of all common words from shortest to longest of the input string\n  >>> commonWordsWithSpacesAndPunctuation('abc')\n  ['a', 'b', 'c']\n  */\nconst commonWordsWithSpacesAndPunctuation = (string) => {\n  let words = []\n  let currentWord = string[0]\n  for (let i = 1; i < string.length; i++) {\n    if (string[i]!== currentWord) {\n      words.push(currentWord)\n      currentWord = string[i]\n    }\n  }\n  return words\n}\n\n/* Return list of all common words from shortest to longest of the input string\n  >>> commonWordsWithSpacesAndPunctuation('abc')\n  ['a', 'b', 'c']\n  */\nconst commonWordsWithSpacesAndPunctuation = (string) => {\n  let words = []\n  let currentWord = string[0]\n  for (let i = 1; i < string.length; i++) {\n    if (string[i]!== currentWord) {\n      words.push(currentWord)\n      currentWord = string[i]\n    }\n  }\n  return words\n}\n\n/* Return list of all common words from shortest to longest of the input string\n  >>> commonWordsWithSpacesAndPunctuation('abc')\n  ['a', 'b', 'c']\n  */\nconst commonWordsWithSpacesAndPunctuation = (string) => {\n  let words = []\n  let currentWord = string[0]\n  for (let i = 1; i < string.length; i++) {\n    if (string[i]!== currentWord) {\n      words.push(currentWord)\n      currentWord = string[i]\n    }\n  }\n  return words\n}\n\n/* Return list of all common words from shortest to longest of the input string\n  >>> commonWordsWithSpacesAndPunctuation('abc')\n  ['a', 'b', 'c']\n  */\nconst commonWordsWithSpacesAndPunctuation = (string) => {\n  let words = []\n  let currentWord = string[0]\n  for (let i = 1; i < string.length; i++) {\n    if (string[i]!== currentWord) {\n      words.push(currentWord)\n      currentWord = string[i]\n    }\n  }\n  return words\n}\n\n/* Return list of all common words from shortest to longest of the input string\n  >>> commonWordsWithSpacesAndPunctuation('abc')\n  ['a', 'b', 'c']\n  */\nconst commonWordsWithSpacesAndPunctuation = (string) => {\n  let words = []\n  let currentWord = string[0]\n  for (let i = 1; i < string.length; i++) {\n    if (string[i]!== currentWord) {\n      words.push(currentWord)\n      currentWord = string[i]\n    }\n  }\n  return words\n}\n\n/* Return list of ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacse(\"Example\") == \"Example\"\n  fixSpacse(\"Example 1\") == \"Example_1\"\n  fixSpacse(\" Example 2\") == \"_Example_2\"\n  fixSpacse(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpacse = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpacse", "gc": "<|endoftext|>/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacse(\"Example\") == \"Example\"\n  fixSpacse(\"Example 1\") == \"Example_1\"\n  fixSpacse(\" Example 2\") == \"_Example_2\"\n  fixSpacse(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpacse = (text) => {\n  let newText = text;\n  newText = newText.replace(/ /g, \"_\");\n  newText = newText.replace(/ {2,}/g, \" -\");\n  return newText;\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacse(\"Example\") == \"Example\"\n  fixSpacse(\"Example 1\") == \"Example_1\"\n  fixSpacse(\" Example 2\") == \"_Example_2\"\n  fixSpacse(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpacse2 = text => {\n  let newText = text;\n  newText = newText.replace(/ /g, \"_\");\n  newText = newText.replace(/ {2,}/g, \" -\");\n  return newText;\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacse(\"Example\") == \"Example\"\n  fixSpacse(\"Example 1\") == \"Example_1\"\n  fixSpacse(\" Example 2\") == \"_Example_2\"\n  fixSpacse(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpacse3 = text => {\n  let newText = text;\n  newText = newText.replace(/ /g, \"_\");\n  newText = newText.replace(/ {2,}/g, \" -\");\n  return newText;\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacse(\"Example\") == \"Example\"\n  fixSpacse(\"Example 1\") == \"Example_1\"\n  fixSpacse(\" Example 2\") == \"_Example_2\"\n  fixSpacse(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpacse4 = text => {\n  let newText = text;\n  newText = newText.replace(/ /g, \"_\");\n  newText = newText.replace(/ {2,}/g, \" -\");\n  return newText;\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacse(\"Example\") == \"Example\"\n  fixSpacse(\"Example 1\") == \"Example_1\"\n  fixSpacse(\" Example 2\") == \"_Example_2\"\n  fixSpacse(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpacse5 = text => {\n  let newText = text;\n  newText = newText.replace(/ /g, \"_\");\n  newText = newText.replace(/ {2,}/g, \" -\");\n  return newText;\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacse(\"Example\") == \"Example\"\n  fixSpacse(\"Example 1\") == \"Example_1\"\n  fixSpacse(\" Example 2\") == \"_Example_2\"\n  fixSpacse(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpacse6 = text => {\n  let newText = text;\n  newText = newText.replace(/ /g, \"_\");\n  newText = newText.replace(/ {2,}/g, \" -\");\n  return newText;\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacse(\"Example\") == \"Example\"\n  fixSpacse(\"Example 1\") == \"Example_1\"\n  fixSpacse(\" Example 2\") == \"_Example_2\"\n  fixSpacse(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpacse7 = text => {\n  let newText = text;\n  newText = newText.replace(/ /g, \"_\");\n  newText = newText.replace(/ {2,}/g, \" -\");\n  return newText;\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacse(\"Example\") == \"Example\"\n  fixSpacse(\"Example 1\") == \"Example_1\"\n  fixSpacse(\" Example 2\") == \"_Example_2\"\n  fixSpacse(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpacse8 = text => {\n  let newText = text;\n  newText = newText.replace(/ /g, \"_\");\n  newText = newText.replace(/ {2,}/g, \" -\");\n  return newText;\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacse(\"Example\") == \"Example\"\n  fixSpacse(\"Example 1\") == \"Example_1\"\n  fixSpacse(\" Example 2\") == \"_Example_2\"\n  fixSpacse(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpacse9 = text => {\n  let newText = text;\n  newText = newText.replace(/ /g, \"_\");\n  newText = newText.replace(/ {2,}/g, \" -\");\n  return newText;\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacse(\"Example\") == \"Example\"\n  fixSpacse(\"Example 1\") == \"Example_1\"\n  fixSpacse(\" Example 2\") == \"_Example_2\"\n  fixSpacse(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpacse10 = text => {\n  let newText = text;\n  newText = newText.replace(/ /g, \"_\");\n  newText = newText.replace(/ {2,}/g, \" -\");\n  return newText;\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacse(\"Example\") == \"Example\"\n  fixSpacse(\"Example 1\") == \"Example_1\"\n  fixSpacse(\" Example 2\") == \"_Example_2\"\n  fixSpacse(\" Example   3\") == \"_Example-3\"\n  */\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "gc": "<|endoftext|>/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const file_name_length = file_name.length;\n  const file_name_without_dot = file_name.substring(0, file_name_length - 1);\n  const file_name_without_dot_length = file_name_without_dot.length;\n  const file_name_without_dot_is_valid_letter = file_name_without_dot_length >= 1 && file_name_without_dot_is_valid_letter(file_name_without_dot);\n  const file_name_without_dot_is_valid_number = file_name_without_dot_length >= 1 && file_name_without_dot_is_valid_number(file_name_without_dot);\n  const file_name_without_dot_is_valid_letter_in_the_latin_alphabet = file_name_without_dot_length >= 1 && file_name_without_dot_is_valid_letter_in_the_latin_alphabet(file_name_without_dot);\n  const file_name_without_dot_is_valid_number_in_the_latin_alphabet = file_name_without_dot_length >= 1 && file_name_without_dot_is_valid_number_in_the_latin_alphabet(file_name_without_dot);\n  const file_name_without_dot_is_valid_letter_in_the_latin_alphabet_in_the_latin_alphabet = file_name_without_dot_length >= 1 && file_name_without_dot_is_valid_letter_in_the_latin_alphabet_in_the_latin_alphabet(file_name_without_dot);\n  const file_name_without_dot_is_valid_number_in_the_latin_alphabet_in_the_latin_alphabet = file_name_without_dot_length >= 1 && file_name_without_dot_is_valid_number_in_the_latin_alphabet_in_the_latin_alphabet(file_name_without_dot);\n  const file_name_without_dot_is_valid_letter_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet = file_name_without_dot_length >= 1 && file_name_without_dot_is_valid_letter_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet(file_name_without_dot);\n  const file_name_without_dot_is_valid_number_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet = file_name_without_dot_length >= 1 && file_name_without_dot_is_valid_number_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet(file_name_without_dot);\n  const file_name_without_dot_is_valid_letter_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet = file_name_without_dot_length >= 1 && file_name_without_dot_is_valid_letter_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet(file_name_without_dot);\n  const file_name_without_dot_is_valid_number_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet = file_name_without_dot_length >= 1 && file_name_without_dot_is_valid_number_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet(file_name_without_dot);\n  const file_name_without_dot_is_valid_letter_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet = file_name_without_dot_length >= 1 && file_name_without_dot_is_valid_letter_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet(file_name_without_dot);\n  const file_name_without_dot_is_valid_number_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet = file_name_without_dot_length >= 1 && file_name_without_dot_is_valid_number_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet(file_name_without_dot);\n  const file_name_without_dot_is_valid_letter_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet = file_name_without_dot_length >= 1 && file_name_without_dot_is_valid_letter_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet(file_name_without_dot);\n  const file_name_without_dot_is_valid_number_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet = file_name_without_dot_length >= 1 && file_name_without_dot_is_valid_number_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet(file_name_without_dot);\n  const file_name_without_dot_is_valid_letter_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet = file_name_without_dot_length >= 1 && file_name_without_dot_is_valid_letter_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet(file_name_without_dot);\n  const file_name_without_dot_is_valid_number_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet = file_name_without_dot_length >= 1 && file_name_without_dot_is_valid_number_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet(file_name_without_dot);\n  const file_name_without_dot_is_valid_letter_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet = file_name_without_dot_length >= 1 && file_name_without_dot_is_valid_letter_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet(file_name_without_dot);\n  const file_name_without_dot_is_valid_number_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet = file_name_without_dot_length >= 1 && file_name_without_dot_is_valid_number_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet(file_name_without_dot);\n  const file_name_without_dot_is_valid_letter_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet = file_name_without_dot_length >= 1 && file_name_without_dot_is_valid_letter_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet(file_name_without_dot);\n  const file_name_without_dot_is_valid_number_in_the_latin_alphabet_in_the_latin_alphabet_in_the_latin_alphabet_in_the_", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "gc": "<|endoftext|>/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubes = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubesSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubesSquaresSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubesSquaresSquaresSquaresSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubesSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSquaresSqu", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wrodsInSentenec = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wrodsInSentenec", "gc": "<|endoftext|>/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wrodsInSentenec = (sentence) => {\n  const words = sentence.split(\" \");\n  let newWords = [];\n  let newWordsLength = 0;\n  let newWordsOrder = [];\n  let newWordsIndex = 0;\n  let newWordsLengthIndex = 0;\n  let newWordsLengthIndex2 = 0;\n  let newWordsIndex2 = 0;\n  let newWordsLengthIndex3 = 0;\n  let newWordsIndex3 = 0;\n  let newWordsLengthIndex4 = 0;\n  let newWordsIndex4 = 0;\n  let newWordsLengthIndex5 = 0;\n  let newWordsIndex5 = 0;\n  let newWordsLengthIndex6 = 0;\n  let newWordsIndex6 = 0;\n  let newWordsLengthIndex7 = 0;\n  let newWordsIndex7 = 0;\n  let newWordsLengthIndex8 = 0;\n  let newWordsIndex8 = 0;\n  let newWordsLengthIndex9 = 0;\n  let newWordsIndex9 = 0;\n  let newWordsLengthIndex10 = 0;\n  let newWordsIndex10 = 0;\n  let newWordsLengthIndex11 = 0;\n  let newWordsIndex11 = 0;\n  let newWordsLengthIndex12 = 0;\n  let newWordsIndex12 = 0;\n  let newWordsLengthIndex13 = 0;\n  let newWordsIndex13 = 0;\n  let newWordsLengthIndex14 = 0;\n  let newWordsIndex14 = 0;\n  let newWordsLengthIndex15 = 0;\n  let newWordsIndex15 = 0;\n  let newWordsLengthIndex16 = 0;\n  let newWordsIndex16 = 0;\n  let newWordsLengthIndex17 = 0;\n  let newWordsIndex17 = 0;\n  let newWordsLengthIndex18 = 0;\n  let newWordsIndex18 = 0;\n  let newWordsLengthIndex19 = 0;\n  let newWordsIndex19 = 0;\n  let newWordsLengthIndex20 = 0;\n  let newWordsIndex20 = 0;\n  let newWordsLengthIndex21 = 0;\n  let newWordsIndex21 = 0;\n  let newWordsLengthIndex22 = 0;\n  let newWordsIndex22 = 0;\n  let newWordsLengthIndex23 = 0;\n  let newWordsIndex23 = 0;\n  let newWordsLengthIndex24 = 0;\n  let newWordsIndex24 = 0;\n  let newWordsLengthIndex25 = 0;\n  let newWordsIndex25 = 0;\n  let newWordsLengthIndex26 = 0;\n  let newWordsIndex26 = 0;\n  let newWordsLengthIndex27 = 0;\n  let newWordsIndex27 = 0;\n  let newWordsLengthIndex28 = 0;\n  let newWordsIndex28 = 0;\n  let newWordsLengthIndex29 = 0;\n  let newWordsIndex29 = 0;\n  let newWordsLengthIndex30 = 0;\n  let newWordsIndex30 = 0;\n  let newWordsLengthIndex31 = 0;\n  let newWordsIndex31 = 0;\n  let newWordsLengthIndex32 = 0;\n  let newWordsIndex32 = 0;\n  let newWordsLengthIndex33 = 0;\n  let newWordsIndex33 = 0;\n  let newWordsLengthIndex34 = 0;\n  let newWordsIndex34 = 0;\n  let newWordsLengthIndex35 = 0;\n  let newWordsIndex35 = 0;\n  let newWordsLengthIndex36 = 0;\n  let newWordsIndex36 = 0;\n  let newWordsLengthIndex37 = 0;\n  let newWordsIndex37 = 0;\n  let newWordsLengthIndex38 = 0;\n  let newWordsIndex38 = 0;\n  let newWordsLengthIndex39 = 0;\n  let newWordsIndex39 = 0;\n  let newWordsLengthIndex40 = 0;\n  let newWordsIndex40 = 0;\n  let newWordsLengthIndex41 = 0;\n  let newWordsIndex41 = 0;\n  let newWordsLengthIndex42 = 0;\n  let newWordsIndex42 = 0;\n  let newWordsLengthIndex43 = 0;\n  let newWordsIndex43 = 0;\n  let newWordsLengthIndex44 = 0;\n  let newWordsIndex44 = 0;\n  let newWordsLengthIndex45 = 0;\n  let newWordsIndex45 = 0;\n  let newWordsLengthIndex46 = 0;\n  let newWordsIndex46 = 0;\n  let newWordsLengthIndex47 = 0;\n  let newWordsIndex47 = 0;\n  let newWordsLengthIndex48 = 0;\n  let newWordsIndex48 = 0;\n  let newWordsLengthIndex49 = 0;\n  let newWordsIndex49 = 0;\n  let newWordsLengthIndex50 = 0;\n  let newWordsIndex50 = 0;\n  let newWordsLengthIndex51 = 0;\n  let newWordsIndex51 = 0;\n  let newWordsLengthIndex52 = 0;\n  let newWordsIndex52 = 0;\n  let newWordsLengthIndex53 = 0;\n  let newWordsIndex53 = 0;\n  let newWordsLengthIndex54 = 0;\n  let newWordsIndex54 = 0;\n  let newWordsLengthIndex55 = 0;\n  let newWordsIndex55 = 0;\n  let newWordsLengthIndex56 = 0;\n  let newWordsIndex56 = 0;\n  let newWordsLengthIndex57 = 0;\n  let newWordsIndex57 = 0;\n  let newWordsLengthIndex58 = 0;\n  let newWordsIndex58 = 0;\n  let newWordsLengthIndex59 = 0;\n  let newWordsIndex59 = 0;\n  let newWordsLengthIndex60 = 0;\n  let newWordsIndex60 = 0;\n  let newWordsLengthIndex61 = 0;\n  let newWordsIndex61 = 0;\n  let newWordsLengthIndex62 = 0;\n  let newWordsIndex62 = 0;\n  let newWordsLengthIndex63 = 0;\n  let newWordsIndex63 = 0;\n  let newWordsLengthIndex64 = 0;\n  let newWordsIndex64 = 0;\n  let newWordsLengthIndex65 = 0;\n  let newWordsIndex65 = 0;\n  let newWordsLengthIndex66 = 0;\n  let newWordsIndex66 = 0;\n  let newWordsLengthIndex67 = 0;\n  let newWordsIndex67 = 0;\n  let newWordsLengthIndex68 = 0;\n  let newWordsIndex68 = 0;\n  let newWordsLengthIndex69 = 0;\n  let newWordsIndex69 = 0;\n  let newWordsLengthIndex70 = 0;\n  let newWordsIndex70 = 0;\n  let newWordsLengthIndex71 = 0;\n  let newWordsIndex71 = 0;\n  let newWordsLengthIndex72 = 0;\n  let newWordsIndex72 = 0;\n  let newWordsLengthIndex73 = 0;\n  let newWordsIndex73 = 0;\n  let newWordsLengthIndex74 = 0;\n  let newWordsIndex74 = 0;\n  let newWordsLengthIndex75 = 0;\n  let newWordsIndex75 = 0;\n  let newWordsLengthIndex76 = 0;\n  let newWordsIndex76 = 0;\n  let newWordsLengthIndex77 = 0;\n  let newWordsIndex77 = 0;\n  let newWordsLengthIndex78 = 0;\n  let newWordsIndex78 = 0;\n  let newWordsLengthIndex79 = 0;\n  let newWordsIndex79 = 0;\n  let newWordsLengthIndex80 = 0;\n  let newWordsIndex80 = 0;\n  let newWordsLengthIndex81 = 0;\n  let newWordsIndex81 = 0;\n  let newWordsLengthIndex82 = 0;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function that will simpilfy the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simpilfy(\"1/5\", \"5/1\") = true\n  simpilfy(\"1/6\", \"2/1\") = false\n  simpilfy(\"7/10\", \"10/2\") = false\n  */\nconst simpilfy = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simpilfy", "gc": "<|endoftext|>/*Your task is to implement a function that will simpilfy the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simpilfy(\"1/5\", \"5/1\") = true\n  simpilfy(\"1/6\", \"2/1\") = false\n  simpilfy(\"7/10\", \"10/2\") = false\n  */\nconst simpilfy = (x, n) => {\n  if (isNaN(x) || isNaN(n)) {\n    return false;\n  }\n  if (x === 0 || n === 0 || n === 1) {\n    return true;\n  }\n  if (x.toString().indexOf(\"/\")!== -1) {\n    if (n.toString().indexOf(\"/\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"%\")!== -1) {\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"/\")!== -1) {\n    if (n.toString().indexOf(\"/\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"%\")!== -1) {\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"/\")!== -1) {\n    if (n.toString().indexOf(\"/\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"%\")!== -1) {\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"/\")!== -1) {\n    if (n.toString().indexOf(\"/\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"%\")!== -1) {\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"/\")!== -1) {\n    if (n.toString().indexOf(\"/\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"%\")!== -1) {\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"/\")!== -1) {\n    if (n.toString().indexOf(\"/\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"%\")!== -1) {\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"/\")!== -1) {\n    if (n.toString().indexOf(\"/\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"%\")!== -1) {\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"/\")!== -1) {\n    if (n.toString().indexOf(\"/\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"%\")!== -1) {\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"/\")!== -1) {\n    if (n.toString().indexOf(\"/\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"%\")!== -1) {\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"/\")!== -1) {\n    if (n.toString().indexOf(\"/\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"%\")!== -1) {\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"/\")!== -1) {\n    if (n.toString().indexOf(\"/\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"%\")!== -1) {\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"/\")!== -1) {\n    if (n.toString().indexOf(\"/\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"%\")!== -1) {\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"/\")!== -1) {\n    if (n.toString().indexOf(\"/\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"%\")!== -1) {\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"/\")!== -1) {\n    if (n.toString().indexOf(\"/\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"%\")!== -1) {\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"/\")!== -1) {\n    if (n.toString().indexOf(\"/\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"%\")!== -1) {\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"/\")!== -1) {\n    if (n.toString().indexOf(\"/\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"%\")!== -1) {\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }\n  }\n  if (x.toString().indexOf(\"/\")!== -1) {\n    if (n.toString().indexOf(\"/\")!== -1) {\n      return false;\n    }\n    if (n.toString().indexOf(\"%\")!== -1) {\n      return false;\n    }", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> roderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> roderByPoints([]) == []\n  */\nconst roderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "roderByPoints", "gc": "<|endoftext|>/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> roderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> roderByPoints([]) == []\n  */\nconst roderByPoints = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    acc[num] = acc[num] || 0;\n    acc[num] += 1;\n    return acc;\n  }, {});\n  return nums.sort((a, b) => sums[a] - sums[b]);\n};\n\n/*\n  Write a function which returns the number of digits in a\n  given number.\n\n  For example:\n  >>> digits(123) == 3\n  >>> digits(-123) == 3\n  >>> digits(0) == 0\n  >>> digits(-1) == 0\n  >>> digits(-2) == 0\n  >>> digits(-3) == 0\n  >>> digits(4) == 2\n  >>> digits(5) == 3\n  >>> digits(6) == 4\n  >>> digits(7) == 5\n  >>> digits(8) == 6\n  >>> digits(9) == 7\n  >>> digits(10) == 8\n  >>> digits(11) == 9\n  >>> digits(12) == 10\n  >>> digits(13) == 11\n  >>> digits(14) == 12\n  >>> digits(15) == 13\n  >>> digits(16) == 14\n  >>> digits(17) == 15\n  >>> digits(18) == 16\n  >>> digits(19) == 17\n  >>> digits(20) == 18\n  >>> digits(21) == 19\n  >>> digits(22) == 20\n  >>> digits(23) == 21\n  >>> digits(24) == 22\n  >>> digits(25) == 23\n  >>> digits(26) == 24\n  >>> digits(27) == 25\n  >>> digits(28) == 26\n  >>> digits(29) == 27\n  >>> digits(30) == 28\n  >>> digits(31) == 29\n  >>> digits(32) == 30\n  >>> digits(33) == 31\n  >>> digits(34) == 32\n  >>> digits(35) == 33\n  >>> digits(36) == 34\n  >>> digits(37) == 35\n  >>> digits(38) == 36\n  >>> digits(39) == 37\n  >>> digits(40) == 38\n  >>> digits(41) == 39\n  >>> digits(42) == 40\n  >>> digits(43) == 41\n  >>> digits(44) == 42\n  >>> digits(45) == 43\n  >>> digits(46) == 44\n  >>> digits(47) == 45\n  >>> digits(48) == 46\n  >>> digits(49) == 47\n  >>> digits(50) == 48\n  >>> digits(51) == 49\n  >>> digits(52) == 50\n  >>> digits(53) == 51\n  >>> digits(54) == 52\n  >>> digits(55) == 53\n  >>> digits(56) == 54\n  >>> digits(57) == 55\n  >>> digits(58) == 56\n  >>> digits(59) == 57\n  >>> digits(60) == 58\n  >>> digits(61) == 59\n  >>> digits(62) == 60\n  >>> digits(63) == 61\n  >>> digits(64) == 62\n  >>> digits(65) == 63\n  >>> digits(66) == 64\n  >>> digits(67) == 65\n  >>> digits(68) == 66\n  >>> digits(69) == 67\n  >>> digits(70) == 68\n  >>> digits(71) == 69\n  >>> digits(72) == 70\n  >>> digits(73) == 71\n  >>> digits(74) == 72\n  >>> digits(75) == 73\n  >>> digits(76) == 74\n  >>> digits(77) == 75\n  >>> digits(78) == 76\n  >>> digits(79) == 77\n  >>> digits(80) == 78\n  >>> digits(81) == 79\n  >>> digits(82) == 80\n  >>> digits(83) == 81\n  >>> digits(84) == 82\n  >>> digits(85) == 83\n  >>> digits(86) == 84\n  >>> digits(87) == 85\n  >>> digits(88) == 86\n  >>> digits(89) == 87\n  >>> digits(90) == 88\n  >>> digits(91) == 89\n  >>> digits(92) == 90\n  >>> digits(93) == 91\n  >>> digits(94) == 92\n  >>> digits(95) == 93\n  >>> digits(96) == 94\n  >>> digits(97) == 95\n  >>> digits(98) == 96\n  >>> digits(99) == 97\n  >>> digits(100) == 98\n  >>> digits(101) == 99\n  >>> digits(102) == 100\n  >>> digits(103) == 101\n  >>> digits(104) == 102\n  >>> digits(105) == 103\n  >>> digits(106) == 104\n  >>> digits(107) == 105\n  >>> digits(108) == 106\n  >>> digits(109) == 107\n  >>> digits(110) == 108\n  >>> digits(111) == 109\n  >>> digits(112) == 110\n  >>> digits(113) == 110\n  >>> digits(114) == 111\n  >>> digits(115) == 112\n  >>> digits(116) == 113\n  >>> digits(117) == 114\n  >>> digits(118) == 115\n  >>> digits(119) == 116\n  >>> digits(120) == 117\n  >>> digits(121) == 118\n  >>> digits(122) == 119\n  >>> digits(123) == 120\n  >>> digits(124) == 121\n  >>> digits(125) == 122\n  >>> digits(126) == 123\n  >>> digits(127) == 124\n  >>> digits(128) == 125\n  >>> digits(129) == 126\n  >>> digits(130) == 127\n  >>> digits(131) == 128\n  >>> digits(132) == 129\n  >>> digits(133) == 130\n  >>> digits(134) == 131\n  >>> digits(135) == 132\n  >>> digits(136) == 133\n  >>> digits(137) == 134\n  >>> digits(138) == 135\n  >>> digits(139) == 136\n  >>> digits(140) == 137\n  >>> digits(141) == 138\n  >>> digits(142) == 139\n  >>> digits(143) == 140\n  >>> digits(144) == 141\n  >>> digits(145) == 142\n  >>> digits(146) == 143\n  >>> digits(147) == 144\n  >>> digits(148) == 145\n  >>> digits(149) == 146\n  >>> digits(150) == 147\n  >>> digits(151) == 148\n  >>> digits(152) == 149\n  >>> digits(153) == 150\n  >>> digits(154) == 151\n  >>> digits(155) == 152\n  >>> digits(156) == 153\n  >>> digits(157) == 154\n  >>> digits(158) == 155\n  >>> digits(159) == 156\n  >>> digits(160) == 157\n  >>> digits(161) == 158\n  >>> digits(162) == 159\n  >>> digits(163) == 160\n  >>> digits(164) == 161\n  >>> digits(165) == 162\n  >>> digits(166) == 163\n  >>> digit", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/146", "prompt": "/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "gc": "<|endoftext|>/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i] >= 10) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are even (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterEven = (nums) => {\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i] >= 10) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterOdd = (nums) => {\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i] >= 10) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are even (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterEvenOdd = (nums) => {\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i] >= 10) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterOddEven = (nums) => {\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i] >= 10) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterOddEvenOdd = (nums) => {\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i] >= 10) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are even (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterEvenOddEven = (nums) => {\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i] >= 10) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterOddEvenOddEven = (nums) => {\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i] >= 10) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterOddEvenOddOddEven = (nums) => {\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i] >= 10) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterOddEvenOddOddOddEven = (nums) => {\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i] >= 10) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterOddEvenOddOddO", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTrpiles = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTrpiles", "gc": "<|endoftext|>/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTrpiles = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 2\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTrpiles2 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 3\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTrpiles3 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 4\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTrpiles4 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 5\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTrpiles5 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 6\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTrpiles6 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 7\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTrpiles7 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 8\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTrpiles8 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 9\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTrpiles9 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1  i  n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 10\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid tri", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "gc": "<|endoftext|>/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planet1Orbit = orbit(planet1);\n  const planet2Orbit = orbit(planet2);\n  const planet1OrbitOrbit = orbit(planet1Orbit);\n  const planet2OrbitOrbit = orbit(planet2Orbit);\n  const planet1OrbitOrbitOrbit = orbit(planet1OrbitOrbit);\n  const planet2OrbitOrbitOrbit = orbit(planet2OrbitOrbit);\n  const planet1OrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbit);\n  const planet2OrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbit);\n  const planet1OrbitOrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbitOrbit);\n  const planet2OrbitOrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbitOrbit);\n  const planet1OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbitOrbitOrbit);\n  const planet2OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbitOrbitOrbit);\n  const planet1OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbitOrbitOrbit);\n  const planet2OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbitOrbitOrbit);\n  const planet1OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbitOrbitOrbit);\n  const planet2OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbitOrbitOrbit);\n  const planet1OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbitOrbitOrbit);\n  const planet2OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbitOrbitOrbit);\n  const planet1OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbitOrbitOrbit);\n  const planet2OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbitOrbit);\n  const planet1OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbitOrbitOrbit);\n  const planet2OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbitOrbit);\n  const planet1OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbitOrbit);\n  const planet2OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbitOrbit);\n  const planet1OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbitOrbit);\n  const planet2OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbitOrbit);\n  const planet1OrbitOrbitOrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbit);\n  const planet2OrbitOrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbit);\n  const planet1OrbitOrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbit);\n  const planet2OrbitOrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbit);\n  const planet1OrbitOrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbit);\n  const planet2OrbitOrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbit);\n  const planet1OrbitOrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbit);\n  const planet2OrbitOrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbit);\n  const planet1OrbitOrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbit);\n  const planet2OrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbit);\n  const planet1OrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbit);\n  const planet2OrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbit);\n  const planet1OrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbit);\n  const planet2OrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbit);\n  const planet1OrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbit);\n  const planet2OrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbit);\n  const planet1OrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbit);\n  const planet2OrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbit);\n  const planet1OrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbit);\n  const planet2OrbitOrbitOrbitOrbit = orbit(planet2OrbitOrbitOrbit);\n  const planet1OrbitOrbitOrbitOrbit = orbit(planet1OrbitOrbitOrbit);\n  const planet2OrbitOr", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "gc": "<|endoftext|>/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 === 0) {\n      sum += lst[i].length;\n    }\n  }\n  return lst.sort((a, b) => a - b).map(s => s.length);\n};\n\n/*\n  Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListProduct = (lst) => {\n  let product = 1;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 === 0) {\n      product *= lst[i].length;\n    }\n  }\n  return lst.sort((a, b) => a - b).map(s => s * product);\n};\n\n/*\n  Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListMod = (lst) => {\n  let mod = 1;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 === 0) {\n      mod *= lst[i].length;\n    }\n  }\n  return lst.sort((a, b) => a - b).map(s => s % mod);\n};\n\n/*\n  Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListPower = (lst) => {\n  let pow = 1;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 === 0) {\n      pow *= lst[i].length;\n    }\n  }\n  return lst.sort((a, b) => a - b).map(s => Math.pow(s, pow));\n};\n\n/*\n  Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListExp = (lst) => {\n  let exp = 1;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 === 0) {\n      exp *= lst[i].length;\n    }\n  }\n  return lst.sort((a, b) => a - b).map(s => Math.pow(s, exp));\n};\n\n/*\n  Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListLog = (lst) => {\n  let log = 1;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 === 0) {\n      log *= lst[i].length;\n    }\n  }\n  return lst.sort((a, b) => a - b).map(s => Math.log(s));\n};\n\n/*\n  Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListExp2d = (lst) => {\n  let exp = 1;\n  let log = 1;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 === 0) {\n      exp *= lst[i].length;\n      log *= lst[i].length;\n    }\n  }\n  return lst.sort((a, b) => a - b).map(s => Math.pow(s, exp) * Math.log(s));\n};\n\n/*\n  Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sor", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/15", "prompt": "/* Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "gc": "<|endoftext|>/* Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += '0';\n  }\n  return s;\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringSequenceFrom = (n) => {\n  if (n < 0 || n >= stringSequenceLength()) {\n    return '';\n  }\n  return stringSequence(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringSequenceFromZero = (n) => {\n  if (n < 0 || n >= stringSequenceLength()) {\n    return '';\n  }\n  return stringSequence(0);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringSequenceFromN = (n) => {\n  if (n < 0 || n >= stringSequenceLength()) {\n    return '';\n  }\n  return stringSequence(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringSequenceFromNZero = (n) => {\n  if (n < 0 || n >= stringSequenceLength()) {\n    return '';\n  }\n  return stringSequence(0);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringSequenceFromNN = (n) => {\n  if (n < 0 || n >= stringSequenceLength()) {\n    return '';\n  }\n  return stringSequence(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringSequenceFromNNN = (n) => {\n  if (n < 0 || n >= stringSequenceLength()) {\n    return '';\n  }\n  return stringSequence(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringSequenceFromNNNN = (n) => {\n  if (n < 0 || n >= stringSequenceLength()) {\n    return '';\n  }\n  return stringSequence(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringSequenceFromNNNNNN = (n) => {\n  if (n < 0 || n >= stringSequenceLength()) {\n    return '';\n  }\n  return stringSequence(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringSequenceFromNNNNNNNN = (n) => {\n  if (n < 0 || n >= stringSequenceLength()) {\n    return '';\n  }\n  return stringSequence(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringSequenceFromNNNNNNNNNN = (n) => {\n  if (n < 0 || n >= stringSequenceLength()) {\n    return '';\n  }\n  return stringSequence(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringSequenceFromNNNNNNNNNNNN = (n) => {\n  if (n < 0 || n >= stringSequenceLength()) {\n    return '';\n  }\n  return stringSequence(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringSequenceFromNNNNNNNNNNNNNN = (n) => {\n  if (n < 0 || n >= stringSequenceLength()) {\n    return '';\n  }\n  return stringSequence(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringSequenceFromNNNNNNNNNNNNNNNN = (n) => {\n  if (n < 0 || n >= stringSequenceLength()) {\n    return '';\n  }\n  return stringSequence(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringSequenceFromNNNNNNNNNNNNNNNNNN = (n) => {\n  if (n < 0 || n >= stringSequenceLength()) {\n    return '';\n  }\n  return stringSequence(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n * If n is greater than the length of the string, return an empty string.\n */\nconst stringSequenceFromNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/150", "prompt": "/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "gc": "<|endoftext|>/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrY(n/2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(3, 34, 12) == 12\n  for xOrY(3, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrY(n/2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(3, 34, 12) == 12\n  for xOrY(3, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrY(n/2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(3, 34, 12) == 12\n  for xOrY(3, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrY(n/2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(3, 34, 12) == 12\n  for xOrY(3, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrY(n/2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(3, 34, 12) == 12\n  for xOrY(3, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrY(n/2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(3, 34, 12) == 12\n  for xOrY(3, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrY(n/2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(3, 34, 12) == 12\n  for xOrY(3, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrY(n/2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(3, 34, 12) == 12\n  for xOrY(3, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrY(n/2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(3, 34, 12) == 12\n  for xOrY(3, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrY(n/2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(3, 34, 12) == 12\n  for xOrY(3, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrY(n/2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(3, 34, 12) == 12\n  for xOrY(3, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrY(n/2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(3, 34, 12) == 12\n  for xOrY(3, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrY(n/2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(3, 34, 12) == 12\n  for xOrY(3, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrY(n/2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(3, 34, 12) == 12\n  for xOrY(3, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrY(n/2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(3, 34, 12) == 12\n  for xOrY(3, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrY(n/2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(3, 34, 12) == 12\n  for xOrY(3, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 2) return y;\n  if (n % 2 === 0) return x;\n  return xOrY(n/2, y, x);\n};\n\n/*\n  A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(3, 34, 12) == 12\n  for xOrY(3, 8, 5) == 5\n  \n  */\nconst xOrY = (n, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doublehTeDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doublehTeDifference([-1, -2, 0]) == 0\n  doublehTeDifference([9, -2]) == 81\n  doublehTeDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doublehTeDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doublehTeDifference", "gc": "<|endoftext|>/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doublehTeDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doublehTeDifference([-1, -2, 0]) == 0\n  doublehTeDifference([9, -2]) == 81\n  doublehTeDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doublehTeDifference = (lst) => {\n  if (!lst) return 0;\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are even. Ignore numbers that are negative or not integers.\n  doublehTeEvenDifference([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 10\n  doublehTeEvenDifference([-1, -2, 0]) == -1\n  doublehTeEvenDifference([9, -2]) == 81\n  doublehTeEvenDifference([0]) == 10\n  If the input list is empty, return 0.\n  */\nconst doublehTeEvenDifference = (lst) => {\n  if (!lst) return 0;\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 3 and 5. If the input list is empty,\n  return 0.\n  */\nconst doublehTeDivisibleBy3 = (lst) => {\n  if (!lst) return 0;\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 5 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 3 and 5. If the input list is empty,\n  return 0.\n  */\nconst doublehTeDivisibleBy5 = (lst) => {\n  if (!lst) return 0;\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 5!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 3 and 5. If the input list is empty,\n  return 0.\n  */\nconst doublehTeDivisibleBy3And5 = (lst) => {\n  if (!lst) return 0;\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 5!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 3 and 5. If the input list is empty,\n  return 0.\n  */\nconst doublehTeDivisibleBy3And5AndEven = (lst) => {\n  if (!lst) return 0;\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 5!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 3 and 5. If the input list is empty,\n  return 0.\n  */\nconst doublehTeDivisibleBy3And5AndEvenAndNegative = (lst) => {\n  if (!lst) return 0;\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 5!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 3 and 5. If the input list is empty,\n  return 0.\n  */\nconst doublehTeDivisibleBy3And5AndEvenAndNegativeAndEven = (lst) => {\n  if (!lst) return 0;\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 5!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 3 and 5. If the input list is empty,\n  return 0.\n  */\nconst doublehTeDivisibleBy3And5AndEvenAndNegativeAndEvenAndNegative = (lst) => {\n  if (!lst) return 0;\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 5!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 3 and 5. If the input list is empty,\n  return 0.\n  */\nconst doublehTeDivisibleBy3And5AndEvenAndNegativeAndEvenAndNegativeAndEven = (lst) => {\n  if (!lst) return 0;\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 5!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 3 and 5. If the input list is empty,\n  return 0.\n  */\nconst doublehTeDivisibleBy3And5AndEvenAndNegativeAndEvenAndNegativeAndEvenAndNegative = (lst) => {\n  if (!lst) return 0;\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 5!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 3 and 5. If the input list is empty,\n  return 0.\n  */\nconst doublehTeDivisibleBy3And5AndEvenAndNegativeAndEvenAndNegativeAndEvenAndNegativeAndEven = (lst) => {\n  if (!lst) return 0;\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 5!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 3 and 5. If the input list is empty,\n  return 0.\n  */\nconst doublehTeDivisibleBy3And5AndEvenAndNegativeAndEvenAndNegativeAndEvenAndNegativeAndEvenAndNegative = (lst) => {\n  if (!lst) return 0;\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 5!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 3 and 5. If the input list is empty,\n  return 0.\n  */\nconst doublehTeDivisibleBy3And5AndEvenAndNegativeAndEvenAndNegativeAndEvenAndNegativeAndEvenAndNegativeAndEven = (lst) => {\n  if (!lst) return 0;\n  const len = lst.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 5!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by 3 and 5. If the input list is empty,\n  return 0.\n  */\nconst ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "gc": "<|endoftext|>/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const gameScores = game.map((score) => score);\n  const guessScores = guess.map((score) => score);\n  const gameScoreDifferences = gameScores.map((score) => Math.abs(score - guessScores[0]));\n  const gameScoreDifferenceDifferences = gameScoreDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferenceDifferenceDifferenceDifferences.", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/153", "prompt": "/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "gc": "<|endoftext|>/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_class = class_name;\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const extension_strength_i = extension.match(/[A-Z]/);\n    if (extension_strength_i) {\n      extension_strength = extension_strength_i.length * -1;\n    }\n    if (extension_strength > extension_strength_i) {\n      extension_class = extension;\n    }\n  }\n  return extension_class;\n};\n\n/*\n  Given a class name and a set of extensions, return the class name that\n  has the strongest extension.\n  Example:\n  Given'my_class', ['AA', 'Be', 'CC'], return'my_class.AA'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD'], return'my_class.DD'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD', 'EE'], return'my_class.DD'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD', 'EE', 'FF'], return'my_class.EE'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD', 'EE', 'FF', 'GG'], return'my_class.EE'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH'], return'my_class.HH'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II'], return'my_class.II'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ'], return'my_class.JJ'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ', 'KK'], return'my_class.KK'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ', 'KK', 'LL'], return'my_class.LL'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ', 'KK', 'LL', 'MM'], return'my_class.MM'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ', 'KK', 'LL', 'MM', 'NN'], return'my_class.NN'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ', 'KK', 'LL', 'MM', 'NN', 'OO'], return'my_class.OO'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ', 'KK', 'LL', 'MM', 'NN', 'OO', 'PP'], return'my_class.PP'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ', 'KK', 'LL', 'MM', 'NN', 'OO', 'PP', 'QQ'], return'my_class.QQ'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ', 'KK', 'LL', 'MM', 'NN', 'OO', 'PP', 'QQ', 'RR'], return'my_class.RR'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ', 'KK', 'LL', 'MM', 'NN', 'OO', 'PP', 'QQ', 'RR', 'SS'], return'my_class.SS'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ', 'KK', 'LL', 'MM', 'NN', 'OO', 'PP', 'QQ', 'RR', 'SS', 'SS'], return'my_class.SS'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ', 'KK', 'LL', 'MM', 'NN', 'OO', 'PP', 'QQ', 'RR', 'SS', 'SS', 'SS'], return'my_class.SS'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ', 'KK', 'LL', 'MM', 'NN', 'OO', 'PP', 'QQ', 'RR', 'SS', 'SS', 'SS', 'SS'], return'my_class.SS'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ', 'KK', 'LL', 'MM', 'NN', 'OO', 'PP', 'QQ', 'RR', 'SS', 'SS', 'SS', 'SS', 'SS'], return'my_class.SS'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ', 'KK', 'LL', 'MM', 'NN', 'OO', 'PP', 'QQ', 'RR', 'SS', 'SS', 'SS', 'SS', 'SS', 'SS'], return'my_class.SS'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ', 'KK', 'LL', 'MM', 'NN', 'OO', 'PP', 'QQ', 'RR', 'SS', 'SS', 'SS', 'SS', 'SS', 'SS', 'SS'], return'my_class.SS'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ', 'KK', 'LL', 'MM', 'NN', 'OO', 'PP', 'QQ', 'RR', 'SS', 'SS', 'SS', 'SS', 'SS', 'SS', 'SS'], return'my_class.SS'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ', 'KK', 'LL', 'MM', 'NN', 'OO', 'PP', 'QQ', 'RR', 'SS', 'SS', 'SS', 'SS', 'SS', 'SS', 'SS'], return'my_class.SS'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ', 'KK', 'LL', 'MM', 'NN', 'OO', 'PP', 'QQ', 'RR', 'SS', 'SS', 'SS', 'SS', 'SS', 'SS', 'SS'], return'my_class.SS'\n  Given'my_class', ['AA', 'Be', 'CC', 'DD', 'EE', 'FF', 'GG', 'HH', 'II', 'JJ', 'KK', 'LL', 'MM', 'NN', 'OO', 'PP", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/154", "prompt": "/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  ccypatternChekc(\"abcd\",\"abd\") => false\n  ccypatternChekc(\"hello\",\"ell\") => true\n  ccypatternChekc(\"whassup\",\"psus\") => false\n  ccypatternChekc(\"abab\",\"baa\") => true\n  ccypatternChekc(\"efef\",\"eeff\") => false\n  ccypatternChekc(\"himenss\",\"simen\") => true\n  */\nconst ccypatternChekc = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "ccypatternChekc", "gc": "<|endoftext|>/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  ccypatternChekc(\"abcd\",\"abd\") => false\n  ccypatternChekc(\"hello\",\"ell\") => true\n  ccypatternChekc(\"whassup\",\"psus\") => false\n  ccypatternChekc(\"abab\",\"baa\") => true\n  ccypatternChekc(\"efef\",\"eeff\") => false\n  ccypatternChekc(\"himenss\",\"simen\") => true\n  */\nconst ccypatternChekc = (a, b) => {\n  let aArray = a.split('');\n  let bArray = b.split('');\n  let aLen = aArray.length;\n  let bLen = bArray.length;\n  let aRot = aArray[(aLen - 1)];\n  let bRot = bArray[(bLen - 1)];\n  let aRotLen = aRot.length;\n  let bRotLen = bRot.length;\n  let aRotRot = aRot.split('');\n  let bRotRot = bRot.split('');\n  let aRotRotLen = aRotRot.length;\n  let bRotRotLen = bRotRot.length;\n  let aRotRotRot = aRotRot.split('');\n  let bRotRotRot = bRotRot.split('');\n  let aRotRotRotLen = aRotRotRot.length;\n  let bRotRotRotLen = bRotRotRot.length;\n  let aRotRotRotRot = aRotRotRot.split('');\n  let bRotRotRotRot = bRotRotRot.split('');\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRotRot.split('');\n  let bRotRotRotRot = bRotRotRot.split('');\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRotRot.split('');\n  let bRotRotRotRot = bRotRotRot.split('');\n  let aRotRotRotRotRotLen = aRotRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRotRot.split('');\n  let bRotRotRotRot = bRotRotRot.split('');\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRot = aRotRotRotRot.split('');\n  let bRotRotRotRot = bRotRotRot.split('');\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRotRot.split('');\n  let bRotRotRotRot = bRotRotRot.split('');\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRotRot.split('');\n  let bRotRotRotRot = bRotRotRot.split('');\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRotRot.split('');\n  let bRotRotRotRot = bRotRotRot.split('');\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRotRot.split('');\n  let bRotRotRotRot = bRotRotRot.split('');\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRotRot.split('');\n  let bRotRotRotRot = bRotRotRot.split('');\n  let aRotRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRotRot.split('');\n  let bRotRotRotRot = bRotRotRot.split('');\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRot = aRotRotRotRot.split('');\n  let bRotRotRotRot = bRotRotRot.split('');\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRotRot.split('');\n  let bRotRotRotRot = bRotRotRot.split('');\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRot = aRotRotRotRot.split('');\n  let bRotRotRotRot = bRotRotRot.split('');\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRotRot.split('');\n  let bRotRotRotRot = bRotRotRot.split('');\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRotRot.split('');\n  let bRotRotRotRot = bRotRotRot.split('');\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRotRot.split('');\n  let bRotRotRotRot = bRotRotRot.split('');\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRotRot.split('');\n  let bRotRotRotRot = bRotRotRot.split('');\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRotRot = aRotRotRotRot.split('');\n  let bRotRotRotRot = bRotRotRot.split('');\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRot = aRotRotRotRot.split('');\n  let bRotRotRotRot = bRotRotRot.split('');\n  let aRotRotRotRotLen = aRotRotRotRot.length;\n  let bRotRotRotRotLen = bRotRotRotRot.length;\n  let aRotRotRotRot = aRotRotRotRot.split('');\n  let bRotRotRotRot = bRotRotRot.split('');\n  let aRotRotRotRotLen = aRotRotRot", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "gc": "<|endoftext|>/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let count = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let digit;\n\n  do {\n    digit = num % 10;\n    count += digit % 2? 1 : 0;\n    num = Math.floor(num / 10);\n  } while (num > 0);\n\n  do {\n    digit = num % 10;\n    evenCount += digit % 2? 1 : 0;\n    num = Math.floor(num / 10);\n  } while (num > 0);\n\n  do {\n    digit = num % 10;\n    oddCount += digit % 2? 1 : 0;\n    num = Math.floor(num / 10);\n  } while (num > 0);\n\n  return [count, oddCount, evenCount];\n};\n\n/*Given a string. return a tuple that has the number of letters in the string.\n\n   Example:\n      letterCount(\"hello\") ==> (2, 3)\n      letterCount(\" hello\") ==> (2, 3)\n      letterCount(\" hello \") ==> (2, 3)\n      letterCount(\"hello  \") ==> (2, 3)\n      letterCount(\"hello  hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ==> (2, 3)\n      letterCount(\"hello  hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello\") ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMinRioman(19) == 'xix'\n  >>> intToMinRioman(152) == 'clii'\n  >>> intToMinRioman(426) == 'cdxxvi'\n  */\nconst intToMinRioman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMinRioman", "gc": "<|endoftext|>/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMinRioman(19) == 'xix'\n  >>> intToMinRioman(152) == 'clii'\n  >>> intToMinRioman(426) == 'cdxxvi'\n  */\nconst intToMinRioman = (number) => {\n  const numStr = number.toString();\n  const numArr = numStr.split('');\n  let numStrArr = numArr.map(item => item.toString());\n  numStrArr.sort((a, b) => a - b);\n  let numStr = '';\n  for (let i = 0; i < numStrArr.length; i++) {\n    numStr += numStrArr[i][0];\n  }\n  return numStr.toLowerCase();\n};\n\n/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in uppercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRioman(19) == 'XIX'\n  >>> intToRioman(152) == 'CLIII'\n  >>> intToRioman(426) == 'CDXVIII'\n  */\nconst intToRioman = (number) => {\n  const numStr = number.toString();\n  const numArr = numStr.split('');\n  let numStrArr = numArr.map(item => item.toString());\n  numStrArr.sort((a, b) => a - b);\n  let numStr = '';\n  for (let i = 0; i < numStrArr.length; i++) {\n    numStr += numStrArr[i][0];\n  }\n  return numStr.toUpperCase();\n};\n\n/*\n  Given a positive integer, obtain its decimal equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToDec(19) == '19'\n  >>> intToDec(152) == '152'\n  >>> intToDec(426) == '426'\n  */\nconst intToDec = (number) => {\n  const numStr = number.toString();\n  const numArr = numStr.split('');\n  let numStrArr = numArr.map(item => item.toString());\n  numStrArr.sort((a, b) => a - b);\n  let numStr = '';\n  for (let i = 0; i < numStrArr.length; i++) {\n    numStr += numStrArr[i][0];\n  }\n  return numStr.toLowerCase();\n};\n\n/*\n  Given a positive integer, obtain its decimal equivalent as a string,\n  and return it in uppercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToDec(19) == '19'\n  >>> intToDec(152) == '152'\n  >>> intToDec(426) == '426'\n  */\nconst intToDec = (number) => {\n  const numStr = number.toString();\n  const numArr = numStr.split('');\n  let numStrArr = numArr.map(item => item.toString());\n  numStrArr.sort((a, b) => a - b);\n  let numStr = '';\n  for (let i = 0; i < numStrArr.length; i++) {\n    numStr += numStrArr[i][0];\n  }\n  return numStr.toUpperCase();\n};\n\n/*\n  Given a positive integer, obtain its hexadecimal equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToHex(19) == '0x19'\n  >>> intToHex(152) == '0x152'\n  >>> intToHex(426) == '0x426'\n  */\nconst intToHex = (number) => {\n  const numStr = number.toString();\n  const numArr = numStr.split('');\n  let numStrArr = numArr.map(item => item.toString());\n  numStrArr.sort((a, b) => a - b);\n  let numStr = '';\n  for (let i = 0; i < numStrArr.length; i++) {\n    numStr += numStrArr[i][0];\n  }\n  return numStr.toLowerCase();\n};\n\n/*\n  Given a positive integer, obtain its hexadecimal equivalent as a string,\n  and return it in uppercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToHex(19) == '0x19'\n  >>> intToHex(152) == '0x152'\n  >>> intToHex(426) == '0x426'\n  */\nconst intToHex = (number) => {\n  const numStr = number.toString();\n  const numArr = numStr.split('');\n  let numStrArr = numArr.map(item => item.toString());\n  numStrArr.sort((a, b) => a - b);\n  let numStr = '';\n  for (let i = 0; i < numStrArr.length; i++) {\n    numStr += numStrArr[i][0];\n  }\n  return numStr.toUpperCase();\n};\n\n/*\n  Given a positive integer, obtain its octal equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToOctal(19) == '0o19'\n  >>> intToOctal(152) == '0o152'\n  >>> intToOctal(426) == '0o426'\n  */\nconst intToOctal = (number) => {\n  const numStr = number.toString();\n  const numArr = numStr.split('');\n  let numStrArr = numArr.map(item => item.toString());\n  numStrArr.sort((a, b) => a - b);\n  let numStr = '';\n  for (let i = 0; i < numStrArr.length; i++) {\n    numStr += numStrArr[i][0];\n  }\n  return numStr.toLowerCase();\n};\n\n/*\n  Given a positive integer, obtain its octal equivalent as a string,\n  and return it in uppercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToOctal(19) == '0o19'\n  >>> intToOctal(152) == '0o152'\n  >>> intToOctal(426) == '0o426'\n  */\nconst intToOctal = (number) => {\n  const numStr = number.toString();\n  const numArr = numStr.split('');\n  let numStrArr = numArr.map(item => item.toString());\n  numStrArr.sort((a, b) => a - b);\n  let numStr = '';\n  for (let i = 0; i < numStrArr.length; i++) {\n    numStr += numStrArr[i][0];\n  }\n  return numStr.toUpperCase();\n};\n\n/*\n  Given a positive integer, obtain its binary equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToBin(19) == '0b19'\n  >>> intToBin(152) == '0b152'\n  >>> intToBin(426) == '0b426'\n  */\nconst intToBin = (number) => {\n  const numStr = number.toString();\n  const numArr = numStr.split('');\n  let numStrArr = numArr.map(item => item.toString());\n  numStrArr.sort((a, b) => a - b);\n  let numStr = '';\n  for (let i = 0; i < numStrArr.length; i++) {\n    numStr += numStrArr[i][0];\n  }\n  return numStr.toLowerCase();\n};\n\n/*\n  Given a positive integer, obtain its binary equivalent as a string,\n  and return it in uppercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToBin(19) == '0b19'\n  >>> intToBin(152) == '0b152'\n  >>> intToBin(426) == '0b426'\n  */\nconst intToBin = (number) => {\n  const numStr = number.toString();\n  const numArr = numStr.split('');\n  let numStrArr = numArr.map(item => item.toString());\n  numStrArr.sort((a, b) => a - b);\n  let numStr = '';\n  for (let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled triangle is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngelTriangle(3, 4, 5) == true\n  rightAngelTriangle(1, 2, 3) == false\n  */\nconst rightAngelTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngelTriangle", "gc": "<|endoftext|>/*\n Given the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled triangle is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngelTriangle(3, 4, 5) == true\n  rightAngelTriangle(1, 2, 3) == false\n  */\nconst rightAngelTriangle = (a, b, c) => {\n  const a1 = Math.cos(a * Math.PI / 180);\n  const a2 = Math.sin(a * Math.PI / 180);\n  const a3 = Math.cos(b * Math.PI / 180);\n  const a4 = Math.sin(b * Math.PI / 180);\n  const a5 = Math.cos(c * Math.PI / 180);\n  const a6 = Math.sin(c * Math.PI / 180);\n  const b1 = Math.cos(a * Math.PI / 180);\n  const b2 = Math.sin(a * Math.PI / 180);\n  const b3 = Math.cos(b * Math.PI / 180);\n  const b4 = Math.sin(b * Math.PI / 180);\n  const b5 = Math.cos(c * Math.PI / 180);\n  const b6 = Math.sin(c * Math.PI / 180);\n  const c1 = Math.cos(a * Math.PI / 180);\n  const c2 = Math.sin(a * Math.PI / 180);\n  const c3 = Math.cos(b * Math.PI / 180);\n  const c4 = Math.sin(b * Math.PI / 180);\n  const c5 = Math.cos(c * Math.PI / 180);\n  const c6 = Math.sin(c * Math.PI / 180);\n  const d1 = Math.cos(a * Math.PI / 180);\n  const d2 = Math.sin(a * Math.PI / 180);\n  const d3 = Math.cos(b * Math.PI / 180);\n  const d4 = Math.sin(b * Math.PI / 180);\n  const d5 = Math.cos(c * Math.PI / 180);\n  const d6 = Math.sin(c * Math.PI / 180);\n  const e1 = Math.cos(a * Math.PI / 180);\n  const e2 = Math.sin(a * Math.PI / 180);\n  const e3 = Math.cos(b * Math.PI / 180);\n  const e4 = Math.sin(b * Math.PI / 180);\n  const e5 = Math.cos(c * Math.PI / 180);\n  const e6 = Math.sin(c * Math.PI / 180);\n  const f1 = Math.cos(a * Math.PI / 180);\n  const f2 = Math.sin(a * Math.PI / 180);\n  const f3 = Math.cos(b * Math.PI / 180);\n  const f4 = Math.sin(b * Math.PI / 180);\n  const f5 = Math.cos(c * Math.PI / 180);\n  const f6 = Math.sin(c * Math.PI / 180);\n  const g1 = Math.cos(a * Math.PI / 180);\n  const g2 = Math.sin(a * Math.PI / 180);\n  const g3 = Math.cos(b * Math.PI / 180);\n  const g4 = Math.sin(b * Math.PI / 180);\n  const g5 = Math.cos(c * Math.PI / 180);\n  const g6 = Math.sin(c * Math.PI / 180);\n  const h1 = Math.cos(a * Math.PI / 180);\n  const h2 = Math.sin(a * Math.PI / 180);\n  const h3 = Math.cos(b * Math.PI / 180);\n  const h4 = Math.sin(b * Math.PI / 180);\n  const h5 = Math.cos(c * Math.PI / 180);\n  const h6 = Math.sin(c * Math.PI / 180);\n  const i1 = Math.cos(a * Math.PI / 180);\n  const i2 = Math.sin(a * Math.PI / 180);\n  const i3 = Math.cos(b * Math.PI / 180);\n  const i4 = Math.sin(b * Math.PI / 180);\n  const i5 = Math.cos(c * Math.PI / 180);\n  const i6 = Math.sin(c * Math.PI / 180);\n  const j1 = Math.cos(a * Math.PI / 180);\n  const j2 = Math.sin(a * Math.PI / 180);\n  const j3 = Math.cos(b * Math.PI / 180);\n  const j4 = Math.sin(b * Math.PI / 180);\n  const j5 = Math.cos(c * Math.PI / 180);\n  const j6 = Math.sin(c * Math.PI / 180);\n  const k1 = Math.cos(a * Math.PI / 180);\n  const k2 = Math.sin(a * Math.PI / 180);\n  const k3 = Math.cos(b * Math.PI / 180);\n  const k4 = Math.sin(b * Math.PI / 180);\n  const k5 = Math.cos(c * Math.PI / 180);\n  const k6 = Math.sin(c * Math.PI / 180);\n  const l1 = Math.cos(a * Math.PI / 180);\n  const l2 = Math.sin(a * Math.PI / 180);\n  const l3 = Math.cos(b * Math.PI / 180);\n  const l4 = Math.sin(b * Math.PI / 180);\n  const l5 = Math.cos(c * Math.PI / 180);\n  const l6 = Math.sin(c * Math.PI / 180);\n  const m1 = Math.cos(a * Math.PI / 180);\n  const m2 = Math.sin(a * Math.PI / 180);\n  const m3 = Math.cos(b * Math.PI / 180);\n  const m4 = Math.sin(b * Math.PI / 180);\n  const m5 = Math.cos(c * Math.PI / 180);\n  const m6 = Math.sin(c * Math.PI / 180);\n  const n1 = Math.cos(a * Math.PI / 180);\n  const n2 = Math.sin(a * Math.PI / 180);\n  const n3 = Math.cos(b * Math.PI / 180);\n  const n4 = Math.sin(b * Math.PI / 180);\n  const n5 = Math.cos(c * Math.PI / 180);\n  const n6 = Math.sin(c * Math.PI / 180);\n  const o1 = Math.cos(a * Math.PI / 180);\n  const o2 = Math.sin(a * Math.PI / 180);\n  const o3 = Math.cos(b * Math.PI / 180);\n  const o4 = Math.sin(b * Math.PI / 180);\n  const o5 = Math.cos(c * Math.PI / 180);\n  const o6 = Math.sin(c * Math.PI / 180);\n  const p1 = Math.cos(a * Math.PI / 180);\n  const p2 = Math.sin(a * Math.PI / 180);\n  const p3 = Math.cos(b * Math.PI / 180);\n  const p4 = Math.sin(b * Math.PI / 180);\n  const p5 = Math.cos(c * Math.PI / 180);\n  const p6 = Math.sin(c * Math.PI / 180);\n  const q1 = Math.cos(a * Math.PI / 180);\n  const q2 = Math.sin(a * Math.PI / 180);\n  const q3 = Math.cos(b * Math.PI / 180);\n  const q4 = Math.sin(b * Math.PI / 180);\n  const q5 = Math.cos(c * Math.PI / 180);\n  const q6 = Math.sin(c * Math.PI / 180);\n  const r1 = Math.cos(a * Math.PI / 180);\n  const r2 = ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "gc": "<|endoftext|>/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  let maxLength = 0;\n  let maxWord = '';\n  let maxChar = 0;\n  let maxCount = 0;\n  let maxCharCount = 0;\n  let maxCharCount2 = 0;\n  let maxCharCount3 = 0;\n  let maxCharCount4 = 0;\n  let maxCharCount5 = 0;\n  let maxCharCount6 = 0;\n  let maxCharCount7 = 0;\n  let maxCharCount8 = 0;\n  let maxCharCount9 = 0;\n  let maxCharCount10 = 0;\n  let maxCharCount11 = 0;\n  let maxCharCount12 = 0;\n  let maxCharCount13 = 0;\n  let maxCharCount14 = 0;\n  let maxCharCount15 = 0;\n  let maxCharCount16 = 0;\n  let maxCharCount17 = 0;\n  let maxCharCount18 = 0;\n  let maxCharCount19 = 0;\n  let maxCharCount20 = 0;\n  let maxCharCount21 = 0;\n  let maxCharCount22 = 0;\n  let maxCharCount23 = 0;\n  let maxCharCount24 = 0;\n  let maxCharCount25 = 0;\n  let maxCharCount26 = 0;\n  let maxCharCount27 = 0;\n  let maxCharCount28 = 0;\n  let maxCharCount29 = 0;\n  let maxCharCount30 = 0;\n  let maxCharCount31 = 0;\n  let maxCharCount32 = 0;\n  let maxCharCount33 = 0;\n  let maxCharCount34 = 0;\n  let maxCharCount35 = 0;\n  let maxCharCount36 = 0;\n  let maxCharCount37 = 0;\n  let maxCharCount38 = 0;\n  let maxCharCount39 = 0;\n  let maxCharCount40 = 0;\n  let maxCharCount41 = 0;\n  let maxCharCount42 = 0;\n  let maxCharCount43 = 0;\n  let maxCharCount44 = 0;\n  let maxCharCount45 = 0;\n  let maxCharCount46 = 0;\n  let maxCharCount47 = 0;\n  let maxCharCount48 = 0;\n  let maxCharCount49 = 0;\n  let maxCharCount50 = 0;\n  let maxCharCount51 = 0;\n  let maxCharCount52 = 0;\n  let maxCharCount53 = 0;\n  let maxCharCount54 = 0;\n  let maxCharCount55 = 0;\n  let maxCharCount56 = 0;\n  let maxCharCount57 = 0;\n  let maxCharCount58 = 0;\n  let maxCharCount59 = 0;\n  let maxCharCount60 = 0;\n  let maxCharCount61 = 0;\n  let maxCharCount62 = 0;\n  let maxCharCount63 = 0;\n  let maxCharCount64 = 0;\n  let maxCharCount65 = 0;\n  let maxCharCount66 = 0;\n  let maxCharCount67 = 0;\n  let maxCharCount68 = 0;\n  let maxCharCount69 = 0;\n  let maxCharCount70 = 0;\n  let maxCharCount71 = 0;\n  let maxCharCount72 = 0;\n  let maxCharCount73 = 0;\n  let maxCharCount74 = 0;\n  let maxCharCount75 = 0;\n  let maxCharCount76 = 0;\n  let maxCharCount77 = 0;\n  let maxCharCount78 = 0;\n  let maxCharCount79 = 0;\n  let maxCharCount80 = 0;\n  let maxCharCount81 = 0;\n  let maxCharCount82 = 0;\n  let maxCharCount83 = 0;\n  let maxCharCount84 = 0;\n  let maxCharCount85 = 0;\n  let maxCharCount86 = 0;\n  let maxCharCount87 = 0;\n  let maxCharCount88 = 0;\n  let maxCharCount89 = 0;\n  let maxCharCount90 = 0;\n  let maxCharCount91 = 0;\n  let maxCharCount92 = 0;\n  let maxCharCount93 = 0;\n  let maxCharCount94 = 0;\n  let maxCharCount95 = 0;\n  let maxCharCount96 = 0;\n  let maxCharCount97 = 0;\n  let maxCharCount98 = 0;\n  let maxCharCount99 = 0;\n  let maxCharCount100 = 0;\n  let maxCharCount101 = 0;\n  let maxCharCount102 = 0;\n  let maxCharCount103 = 0;\n  let maxCharCount104 = 0;\n  let maxCharCount105 = 0;\n  let maxCharCount106 = 0;\n  let maxCharCount107 = 0;\n  let maxCharCount108 = 0;\n  let maxCharCount109 = 0;\n  let maxCharCount110 = 0;\n  let maxCharCount111 = 0;\n  let maxCharCount112 = 0;\n  let maxCharCount113 = 0;\n  let maxCharCount114 = 0;\n  let maxCharCount115 = 0;\n  let maxCharCount116 = 0;\n  let maxCharCount117 = 0;\n  let maxCharCount118 = 0;\n  let maxCharCount119 = 0;\n  let maxCharCount120 = 0;\n  let maxCharCount121 = 0;\n  let maxCharCount122 = 0;\n  let maxCharCount123 = 0;\n  let maxCharCount124 = 0;\n  let maxCharCount125 = 0;\n  let maxCharCount126 = 0;\n  let maxCharCount127 = 0;\n  let maxCharCount128 = 0;\n  let maxCharCount129 = 0;\n  let maxCharCount130 = 0;\n  let maxCharCount131 = 0;\n  let maxCharCount132 = 0;\n  let maxCharCount133 = 0;\n  let maxCharCount134 = 0;\n  let maxCharCount135 = 0;\n  let maxCharCount136 = 0;\n  let maxCharCount137 = 0;\n  let maxCharCount138 = 0;\n  let maxCharCount139 = 0;\n  let maxCharCount140 = 0;\n  let maxCharCount141 = 0;\n  let maxCharCount142 = 0;\n  let maxCharCount143 = 0;\n  let maxCharCount144 = 0;\n  let maxCharCount145 = 0;\n  let maxCharCount146 = 0;\n  let maxCharCount147 = 0;\n  let maxCharCount148 = 0;\n  let maxCharCount149 = 0;\n  let maxCharCount150 = 0;\n  let maxCharCount151 = 0;\n  let maxCharCount152 = 0;\n  let maxCharCount153 = 0;\n  let maxCharCount154 = 0;\n  let maxCharCount155 = 0;\n  let maxCharCount156 = 0;\n  let maxCharCount157 = 0;\n  let maxCharCount158 = 0;\n  let maxCharCount159 = 0;\n  let maxCharCount160 = 0;\n  let maxCharCount161 = 0;\n  let maxCharCount162 = 0;\n  let maxCharCount163 = 0;\n  let maxCharCount164 = 0;\n  let maxCharCount165 = 0;\n  let maxCharCount166 = 0;\n  let maxCharCount167 = 0;\n  let maxCharCount168 = 0;\n  let maxCharCount169 = 0;\n  let maxCharCount170 = 0;\n  let maxCharCount171 = 0;\n  let maxCharCount172 = 0;\n  let maxCharCount173 = 0;\n  let maxCharCount174 = 0;\n  let maxCharCount175 = 0;\n  let maxCharCount176 = 0;\n  let maxCharCount177 = 0;\n  let maxCharCount178 = 0;\n  let maxCharCount179 = 0;\n  let maxCharCount180 = 0;\n  let maxCharCount181 = 0;\n  let maxCharCount182 = 0;\n  let maxCharCount183 = 0;\n  let maxCharCount184 = 0;\n  let maxCharCount185 = 0;\n  let maxCharCount186 = 0;\n  let maxCharCount187 = 0;\n  let maxCharCount188 = 0;\n  let maxCharCount189 = 0;\n  let maxCharCount190 = 0;\n  let maxCharCount191 = 0;\n  let maxCharCount192 = 0;\n  let maxCharCount193 = 0;\n  let maxCharCount194 = 0;\n  let maxCharCount195 = 0;\n  let maxCharCount196 = 0;\n  let maxCharCount197 = 0;\n  let maxCharCount198 = 0;\n  let maxCharCount199 = 0;\n  let maxCharCount200 = 0;\n  let maxCharCount201 = 0;\n  let maxCharCount202 = 0;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "gc": "<|endoftext|>/*\n  You're a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const totalCarrots = Math.ceil(number * need / remaining);\n  const remainingCarrots = Math.ceil(remaining / number);\n  const remainingEaten = remainingCarrots - totalCarrots;\n  const remainingRemaining = remaining - remainingCarrots;\n  const remainingRemainingEaten = remainingRemainingEaten - totalCarrots;\n  const remainingRemainingEatenRemaining = remainingRemainingEaten - remainingRemaining;\n  const remainingRemainingRemainingEatenRemaining = remainingRemainingRemainingEaten - remainingRemainingRemaining;\n  const remainingRemainingRemainingEatenRemainingRemaining = remainingRemainingRemainingEaten - remainingRemainingRemainingRemaining;\n  const remainingRemainingRemainingEatenRemainingRemainingRemaining = remainingRemainingRemainingEaten - remainingRemainingRemainingRemainingRemaining;\n  const remainingRemainingRemainingEatenRemainingRemainingRemainingRemaining = remainingRemainingRemainingEaten - remainingRemainingRemainingRemainingRemainingRemaining;\n  const remainingRemainingRemainingEatenRemainingRemainingRemainingRemainingRemaining = remainingRemainingRemainingEaten - remainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const remainingRemainingRemainingEatenRemainingRemainingRemainingRemainingRemaining = remainingRemainingRemainingEaten - remainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const remainingRemainingRemainingEatenRemainingRemainingRemainingRemainingRemaining = remainingRemainingRemainingEaten - remainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const remainingRemainingRemainingEatenRemainingRemainingRemainingRemainingRemainingRemaining = remainingRemainingRemainingEaten - remainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const remainingRemainingRemainingEatenRemainingRemainingRemainingRemainingRemainingRemaining = remainingRemainingRemainingEaten - remainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const remainingRemainingRemainingEatenRemainingRemainingRemainingRemainingRemainingRemainingRemaining = remainingRemainingRemainingEaten - remainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const remainingRemainingRemainingEatenRemainingRemainingRemainingRemainingRemainingRemainingRemaining = remainingRemainingRemainingEaten - remainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const remainingRemainingRemainingEatenRemainingRemainingRemainingRemainingRemainingRemainingRemaining = remainingRemainingRemainingEaten - remainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const remainingRemainingRemainingEatenRemainingRemainingRemainingRemainingRemainingRemainingRemaining = remainingRemainingRemainingEaten - remainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const remainingRemainingRemainingEatenRemainingRemainingRemainingRemainingRemainingRemainingRemaining = remainingRemainingRemainingEaten - remainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const remainingRemainingRemainingEatenRemainingRemainingRemainingRemainingRemainingRemainingRemaining = remainingRemainingRemainingEaten - remainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const remainingRemainingRemainingEatenRemainingRemainingRemainingRemainingRemainingRemainingRemaining = remainingRemainingRemainingEaten - remainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const remainingRemainingRemainingEatenRemainingRemainingRemainingRemainingRemainingRemainingRemaining = remainingRemainingRemainingEaten - remainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const remainingRemainingRemainingEatenRemainingRemainingRemainingRemainingRemainingRemainingRemaining = remainingRemainingRemainingEaten - remainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const remainingRemainingRemainingEatenRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining = remainingRemainingRemainingEaten - remainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const remainingRemainingRemainingEatenRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining = remainingRemainingRemainingEaten - remainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const remainingRemainingRemainingEatenRemainingRemainingRemainingRemainingRemainingRemainingRemaining = remainingRemainingRemainingEaten - remainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const remainingRemainingRemainingEatenRemainingRemainingRemainingRemainingRemainingRemainingRemaining = remainingRemainingRemainingEaten - remainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const remainingRemainingRemainingEatenRemainingRemainingRemainingRemainingRemainingRemainingRemaining = remainingRemainingRemainingEaten - remainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining;\n  const remainingRemainingRemainingEatenRemainingRemainingRemainingRemainingRemainingRemainingRemaining = remainingRemainingRemainingEaten - remainingRemainingRemainingRemainingRemainingRemain", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/16", "prompt": "/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "gc": "<|endoftext|>/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    count += chars[i].length;\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words does it consist of\n * >>> countDistinctWords('the quick brown fox jumps over the lazy dog')\n * 3\n * >>> countDistinctWords('the quick brown fox jumps over the lazy dog'.split(' '))\n * 3\n */\nconst countDistinctWords = (string) => {\n  let count = 0;\n  let words = string.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    count += words[i].length;\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct sentences does it consist of\n * >>> countDistinctSentences('the quick brown fox jumps over the lazy dog')\n * 3\n * >>> countDistinctSentences('the quick brown fox jumps over the lazy dog'.split(' '))\n * 3\n */\nconst countDistinctSentences = (string) => {\n  let count = 0;\n  let sentences = string.split(' ');\n  for (let i = 0; i < sentences.length; i++) {\n    count += sentences[i].length;\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words does it consist of\n * >>> countWords('the quick brown fox jumps over the lazy dog')\n * 3\n * >>> countWords('the quick brown fox jumps over the lazy dog'.split(' '))\n * 3\n */\nconst countWords = (string) => {\n  let count = 0;\n  let words = string.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    count += words[i].length;\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct sentences does it consist of\n * >>> countSentences('the quick brown fox jumps over the lazy dog')\n * 3\n * >>> countSentences('the quick brown fox jumps over the lazy dog'.split(' '))\n * 3\n */\nconst countSentences = (string) => {\n  let count = 0;\n  let sentences = string.split(' ');\n  for (let i = 0; i < sentences.length; i++) {\n    count += sentences[i].length;\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words does it consist of\n * >>> countWords('the quick brown fox jumps over the lazy dog'.split(' '))\n * 3\n * >>> countWords('the quick brown fox jumps over the lazy dog'.split(' '))\n * 3\n */\nconst countWordsWithSpace = (string) => {\n  let count = 0;\n  let words = string.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    count += words[i].length;\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words does it consist of\n * >>> countWordsWithSpace('the quick brown fox jumps over the lazy dog'.split(' '))\n * 3\n * >>> countWordsWithSpace('the quick brown fox jumps over the lazy dog'.split(' '))\n * 3\n */\nconst countWordsWithSpacesAndPunctuation = (string) => {\n  let count = 0;\n  let words = string.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    count += words[i].length;\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words does it consist of\n * >>> countWordsWithSpacesAndPunctuation('the quick brown fox jumps over the lazy dog'.split(' '))\n * 3\n * >>> countWordsWithSpacesAndPunctuation('the quick brown fox jumps over the lazy dog'.split(' '))\n * 3\n */\nconst countWordsWithSpacesAndPunctuationAndSpace = (string) => {\n  let count = 0;\n  let words = string.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    count += words[i].length;\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words does it consist of\n * >>> countWordsWithSpacesAndPunctuationAndSpace('the quick brown fox jumps over the lazy dog'.split(' '))\n * 3\n * >>> countWordsWithSpacesAndPunctuationAndSpace('the quick brown fox jumps over the lazy dog'.split(' '))\n * 3\n */\nconst countWordsWithSpacesAndPunctuationAndSpacesAndPunctuation = (string) => {\n  let count = 0;\n  let words = string.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    count += words[i].length;\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words does it consist of\n * >>> countWordsWithSpacesAndPunctuationAndSpacesAndPunctuation('the quick brown fox jumps over the lazy dog'.split(' '))\n * 3\n * >>> countWordsWithSpacesAndPunctuationAndSpacesAndPunctuation('the quick brown fox jumps over the lazy dog'.split(' '))\n * 3\n */\nconst countWordsWithSpacesAndPunctuationAndSpacesAndPunctuationAndSpace = (string) => {\n  let count = 0;\n  let words = string.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    count += words[i].length;\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words does it consist of\n * >>> countWordsWithSpacesAndPunctuationAndSpacesAndPunctuationAndSpace('the quick brown fox jumps over the lazy dog'.split(' '))\n * 3\n * >>> countWordsWithSpacesAndPunctuationAndSpacesAndPunctuationAndSpace('the quick brown fox jumps over the lazy dog'.split(' '))\n * 3\n */\nconst countWordsWithSpacesAndPunctuationAndSpacesAndPunctuationAndSpacesAndPunctuation = (string) => {\n  let count = 0;\n  let words = string.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    count += words[i].length;\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words does it consist of\n * >>> countWordsWithSpacesAndPunctuationAndSpacesAndPunctuationAndSpacesAndPunctuation('the quick brown fox jumps over the lazy dog'.split(' '))\n * 3\n * >>> countWordsWithSpacesAndPunctuationAndSpacesAndPunctuationAndSpacesAndPunctuation('the quick brown fox jumps over the lazy dog'.split(' '))\n * 3\n */\nconst countWordsWithSpacesAndPunctuationAndSpacesAndPunctuationAndSpacesAndPunctuationAndSpacesAndPunctuation = (string) => {\n  let count = 0;\n  let words = string.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    count += words[i].length;\n  }\n  return count;\n};\n\n/**\n * Given a string, find out how many distinct words does it consist of\n * >>> countWordsWithSpacesAndPunctuationAndSpacesAndPunctuationAndSpacesAndPunctuationAndSpacesAndPunctuation('the quick brown fox jumps over the lazy dog'.split(' '))\n * 3\n * >>> countWordsWithSpacesAndPunctuationAndSpacesAndPunctuationAndSpacesAndPunctuationAndSpacesAndPunctuation('the quick brown fox jumps over the lazy dog'.split(' '))\n * 3\n */\nconst ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "gc": "<|endoftext|>/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n\n  for (let i = 0; i < operatorLength; i++) {\n    result += operator[i] * operand[i];\n  }\n\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n\n  for (let i = 0; i < operandLength; i++) {\n    result += operand[i];\n  }\n\n  for (let i = 0; i < operatorLength; i++) {\n    result += operator[i] * operand[i];\n  }\n\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n\n  for (let i = 0; i < operandLength; i++) {\n    result += operand[i];\n  }\n\n  for (let i = 0; i < operatorLength; i++) {\n    result += operator[i] * operand[i];\n  }\n\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n\n  for (let i = 0; i < operandLength; i++) {\n    result += operand[i];\n  }\n\n  for (let i = 0; i < operatorLength; i++) {\n    result += operator[i] * operand[i];\n  }\n\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n\n  for (let i = 0; i < operandLength; i++) {\n    result += operand[i];\n  }\n\n  for (let i = 0; i < operatorLength; i++) {\n    result += operator[i] * operand[i];\n  }\n\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n\n  for (let i = 0; i < operandLength; i++) {\n    result += operand[i];\n  }\n\n  for (let i = 0; i < operatorLength; i++) {\n    result += operator[i] * operand[i];\n  }\n\n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  let result = 0;\n  let operatorLength = operator.length;\n  let operandLength = operand.length;\n\n  for (let i = 0; i < operandLength; i++) {\n    result += operand", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/161", "prompt": "/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "gc": "<|endoftext|>/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let reversed = \"\";\n  let letter = \"\";\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n  let reversedLetter = \"\";\n  let reversedLetters = \"\";\n  let reversedLettersArray = [];\n  let reversedLettersArray2 = [];\n  let reversedLettersArray3 = [];\n  let reversedLettersArray4 = [];\n  let reversedLettersArray5 = [];\n  let reversedLettersArray6 = [];\n  let reversedLettersArray7 = [];\n  let reversedLettersArray8 = [];\n  let reversedLettersArray9 = [];\n  let reversedLettersArray10 = [];\n  let reversedLettersArray11 = [];\n  let reversedLettersArray12 = [];\n  let reversedLettersArray13 = [];\n  let reversedLettersArray14 = [];\n  let reversedLettersArray15 = [];\n  let reversedLettersArray16 = [];\n  let reversedLettersArray17 = [];\n  let reversedLettersArray18 = [];\n  let reversedLettersArray19 = [];\n  let reversedLettersArray20 = [];\n  let reversedLettersArray21 = [];\n  let reversedLettersArray22 = [];\n  let reversedLettersArray23 = [];\n  let reversedLettersArray24 = [];\n  let reversedLettersArray25 = [];\n  let reversedLettersArray26 = [];\n  let reversedLettersArray27 = [];\n  let reversedLettersArray28 = [];\n  let reversedLettersArray29 = [];\n  let reversedLettersArray30 = [];\n  let reversedLettersArray31 = [];\n  let reversedLettersArray32 = [];\n  let reversedLettersArray33 = [];\n  let reversedLettersArray34 = [];\n  let reversedLettersArray35 = [];\n  let reversedLettersArray36 = [];\n  let reversedLettersArray37 = [];\n  let reversedLettersArray38 = [];\n  let reversedLettersArray39 = [];\n  let reversedLettersArray40 = [];\n  let reversedLettersArray41 = [];\n  let reversedLettersArray42 = [];\n  let reversedLettersArray43 = [];\n  let reversedLettersArray44 = [];\n  let reversedLettersArray45 = [];\n  let reversedLettersArray46 = [];\n  let reversedLettersArray47 = [];\n  let reversedLettersArray48 = [];\n  let reversedLettersArray49 = [];\n  let reversedLettersArray50 = [];\n  let reversedLettersArray51 = [];\n  let reversedLettersArray52 = [];\n  let reversedLettersArray53 = [];\n  let reversedLettersArray54 = [];\n  let reversedLettersArray55 = [];\n  let reversedLettersArray56 = [];\n  let reversedLettersArray57 = [];\n  let reversedLettersArray58 = [];\n  let reversedLettersArray59 = [];\n  let reversedLettersArray60 = [];\n  let reversedLettersArray61 = [];\n  let reversedLettersArray62 = [];\n  let reversedLettersArray63 = [];\n  let reversedLettersArray64 = [];\n  let reversedLettersArray65 = [];\n  let reversedLettersArray66 = [];\n  let reversedLettersArray67 = [];\n  let reversedLettersArray68 = [];\n  let reversedLettersArray69 = [];\n  let reversedLettersArray70 = [];\n  let reversedLettersArray71 = [];\n  let reversedLettersArray72 = [];\n  let reversedLettersArray73 = [];\n  let reversedLettersArray74 = [];\n  let reversedLettersArray75 = [];\n  let reversedLettersArray76 = [];\n  let reversedLettersArray77 = [];\n  let reversedLettersArray78 = [];\n  let reversedLettersArray79 = [];\n  let reversedLettersArray80 = [];\n  let reversedLettersArray81 = [];\n  let reversedLettersArray82 = [];\n  let reversedLettersArray83 = [];\n  let reversedLettersArray84 = [];\n  let reversedLettersArray85 = [];\n  let reversedLettersArray86 = [];\n  let reversedLettersArray87 = [];\n  let reversedLettersArray88 = [];\n  let reversedLettersArray89 = [];\n  let reversedLettersArray90 = [];\n  let reversedLettersArray91 = [];\n  let reversedLettersArray92 = [];\n  let reversedLettersArray93 = [];\n  let reversedLettersArray94 = [];\n  let reversedLettersArray95 = [];\n  let reversedLettersArray96 = [];\n  let reversedLettersArray97 = [];\n  let reversedLettersArray98 = [];\n  let reversedLettersArray99 = [];\n  let reversedLettersArray100 = [];\n  let reversedLettersArray101 = [];\n  let reversedLettersArray102 = [];\n  let reversedLettersArray103 = [];\n  let reversedLettersArray104 = [];\n  let reversedLettersArray105 = [];\n  let reversedLettersArray106 = [];\n  let reversedLettersArray107 = [];\n  let reversedLettersArray108 = [];\n  let reversedLettersArray109 = [];\n  let reversedLettersArray110 = [];\n  let reversedLettersArray111 = [];\n  let reversedLettersArray112 = [];\n  let reversedLettersArray113 = [];\n  let reversedLettersArray114 = [];\n  let reversedLettersArray115 = [];\n  let reversedLettersArray116 = [];\n  let reversedLettersArray117 = [];\n  let reversedLettersArray118 = [];\n  let reversedLettersArray119 = [];\n  let reversedLettersArray120 = [];\n  let reversedLettersArray121 = [];\n  let reversedLettersArray122 = [];\n  let reversedLettersArray123 = [];\n  let reversedLettersArray124 = [];\n  let reversedLettersArray125 = [];\n  let reversedLettersArray126 = [];\n  let reversedLettersArray127 = [];\n  let reversedLettersArray128 = [];\n  let reversedLettersArray129 = [];\n  let reversedLettersArray130 = [];\n  let reversedLettersArray131 = [];\n  let reversedLettersArray132 = [];\n  let reversedLettersArray133 = [];\n  let reversedLettersArray134 = [];\n  let reversedLettersArray135 = [];\n  let reversedLettersArray136 = [];\n  let reversedLettersArray137 = [];\n  let reversedLettersArray138 = [];\n  let reversedLettersArray139 = [];\n  let reversedLettersArray140 = [];\n  let reversedLettersArray141 = [];\n  let reversedLettersArray142 = [];\n  let reversedLettersArray143 = [];\n  let reversedLettersArray144 = [];\n  let reversedLettersArray145 = [];\n  let reversedLettersArray146 = [];\n  let reversedLettersArray147 = [];\n  let reversedLettersArray148 = [];\n  let reversedLettersArray149 = [];\n  let reversedLettersArray150 = [];\n  let reversedLettersArray151 = [];\n  let reversedLettersArray152 = ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "gc": "<|endoftext|>/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its sha1 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha1('Hello world') == 'd24a8a6c7a8b1c71f2a335e3a4fc1f5'\n  */\nconst stringToSha1 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const sha1Hash = crypto.createHash('sha1');\n  sha1Hash.update(text);\n  return sha1Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its sha256 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha256('Hello world') == '9c1185a5c5e9f13e774bbc4c6313b364c1'\n  */\nconst stringToSha256 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const sha256Hash = crypto.createHash('sha256');\n  sha256Hash.update(text);\n  return sha256Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its sha512 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == 'a30e0cbd6bb4ebae2a6deb33a0f86e8a94fa547'\n  */\nconst stringToSha512 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const sha512Hash = crypto.createHash('sha512');\n  sha512Hash.update(text);\n  return sha512Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == 'd24a8a6c7a8b1c71f2a335e3a4fc1f5'\n  */\nconst stringToSha512 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const sha512Hash = crypto.createHash('sha512');\n  sha512Hash.update(text);\n  return sha512Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == 'd24a8a6c7a8b1c71f2a335e3a4fc1f5'\n  */\nconst stringToSha512 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const sha512Hash = crypto.createHash('sha512');\n  sha512Hash.update(text);\n  return sha512Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == 'd24a8a6c7a8b1c71f2a335e3a4fc1f5'\n  */\nconst stringToSha512 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const sha512Hash = crypto.createHash('sha512');\n  sha512Hash.update(text);\n  return sha512Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == 'd24a8a6c7a8b1c71f2a335e3a4fc1f5'\n  */\nconst stringToSha512 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const sha512Hash = crypto.createHash('sha512');\n  sha512Hash.update(text);\n  return sha512Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == 'd24a8a6c7a8b1c71f2a335e3a4fc1f5'\n  */\nconst stringToSha512 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const sha512Hash = crypto.createHash('sha512');\n  sha512Hash.update(text);\n  return sha512Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == 'd24a8a6c7a8b1c71f2a335e3a4fc1f5'\n  */\nconst stringToSha512 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const sha512Hash = crypto.createHash('sha512');\n  sha512Hash.update(text);\n  return sha512Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == 'd24a8a6c7a8b1c71f2a335e3a4fc1f5'\n  */\nconst stringToSha512 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const sha512Hash = crypto.createHash('sha512');\n  sha512Hash.update(text);\n  return sha512Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == 'd24a8a6c7a8b1c71f2a335e3a4fc1f5'\n  */\nconst stringToSha512 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const sha512Hash = crypto.createHash('sha512');\n  sha512Hash.update(text);\n  return sha512Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == 'd24a8a6c7a8b1c71f2a335e3a4fc1f5'\n  */\nconst stringToSha512 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  const sha512Hash = crypto.createHash('sha512');\n  sha512Hash.update(text);\n  return sha512Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToSha512('Hello world') == 'd24a8a6c7a8b1c71f2a335e3a4fc1f5'", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two positive integers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "gc": "<|endoftext|>/*\n  Given two positive integers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  let result = [];\n  let i = a;\n  let j = b;\n  while (i > 0) {\n    result.push(i);\n    i = Math.floor(i / 10);\n  }\n  while (j > 0) {\n    result.push(j);\n    j = Math.floor(j / 10);\n  }\n  return result;\n};\n\n/**\n * Given a string, return a string that is the concatenation of all the\n * characters in the string.\n */\nconst stringToArray = str => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    result.push(str[i]);\n  }\n  return result;\n};\n\n/**\n * Given a string, return a string that is the concatenation of all the\n * characters in the string except the characters in the given array.\n */\nconst stringWithoutCharacters = str => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    if (str.indexOf(str[i]) === -1) {\n      result.push(str[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a string, return a string that is the concatenation of all the\n * characters in the string except the characters in the given array.\n */\nconst stringWithoutCharacters = str => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    if (str.indexOf(str[i]) === -1) {\n      result.push(str[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a string, return a string that is the concatenation of all the\n * characters in the string except the characters in the given array.\n */\nconst stringWithoutCharacters = str => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    if (str.indexOf(str[i]) === -1) {\n      result.push(str[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a string, return a string that is the concatenation of all the\n * characters in the string except the characters in the given array.\n */\nconst stringWithoutCharacters = str => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    if (str.indexOf(str[i]) === -1) {\n      result.push(str[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a string, return a string that is the concatenation of all the\n * characters in the string except the characters in the given array.\n */\nconst stringWithoutCharacters = str => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    if (str.indexOf(str[i]) === -1) {\n      result.push(str[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a string, return a string that is the concatenation of all the\n * characters in the string except the characters in the given array.\n */\nconst stringWithoutCharacters = str => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    if (str.indexOf(str[i]) === -1) {\n      result.push(str[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a string, return a string that is the concatenation of all the\n * characters in the string except the characters in the given array.\n */\nconst stringWithoutCharacters = str => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    if (str.indexOf(str[i]) === -1) {\n      result.push(str[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a string, return a string that is the concatenation of all the\n * characters in the string except the characters in the given array.\n */\nconst stringWithoutCharacters = str => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    if (str.indexOf(str[i]) === -1) {\n      result.push(str[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a string, return a string that is the concatenation of all the\n * characters in the string except the characters in the given array.\n */\nconst stringWithoutCharacters = str => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    if (str.indexOf(str[i]) === -1) {\n      result.push(str[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a string, return a string that is the concatenation of all the\n * characters in the string except the characters in the given array.\n */\nconst stringWithoutCharacters = str => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    if (str.indexOf(str[i]) === -1) {\n      result.push(str[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a string, return a string that is the concatenation of all the\n * characters in the string except the characters in the given array.\n */\nconst stringWithoutCharacters = str => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    if (str.indexOf(str[i]) === -1) {\n      result.push(str[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a string, return a string that is the concatenation of all the\n * characters in the string except the characters in the given array.\n */\nconst stringWithoutCharacters = str => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    if (str.indexOf(str[i]) === -1) {\n      result.push(str[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a string, return a string that is the concatenation of all the\n * characters in the string except the characters in the given array.\n */\nconst stringWithoutCharacters = str => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    if (str.indexOf(str[i]) === -1) {\n      result.push(str[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a string, return a string that is the concatenation of all the\n * characters in the string except the characters in the given array.\n */\nconst stringWithoutCharacters = str => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    if (str.indexOf(str[i]) === -1) {\n      result.push(str[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a string, return a string that is the concatenation of all the\n * characters in the string except the characters in the given array.\n */\nconst stringWithoutCharacters = str => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    if (str.indexOf(str[i]) === -1) {\n      result.push(str[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a string, return a string that is the concatenation of all the\n * characters in the string except the characters in the given array.\n */\nconst stringWithoutCharacters = str => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    if (str.indexOf(str[i]) === -1) {\n      result.push(str[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a string, return a string that is the concatenation of all the\n * characters in the string except the characters in the given array.\n */\nconst stringWithoutCharacters = str => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    if (str.indexOf(str[i]) === -1) {\n      result.push(str[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a string, return a string that is the concatenation of all the\n * characters in the string except the characters in the given array.\n */\nconst stringWithoutCharacters = str => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    if (str.indexOf(str[i]) === -1) {\n      result.push(str[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a string, return a string that is the concatenation of all the\n * characters in the string except the characters in the given array.\n */\nconst stringWithoutCharacters = str => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    if (str.indexOf(str[i]) === -1) {\n      result.push(str[i]);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a string, return a string that is the concatenation of all the\n * characters in the string except the characters in the given array.\n */\nconst stringWithoutCharacters = str => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    if (", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/17", "prompt": "/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "gc": "<|endoftext|>/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = music_string.split('|');\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split(' ');\n    const beats = note.map(n => parseInt(n, 10));\n    result.push(beats.length);\n  }\n  return result;\n};\n\nmodule.exports = {\n  parseMusic,\n};\n\n<|/ file ext=.js |><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|>\n \nconst parseNotes = (notes) => {\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split(' ');\n    const beats = note.map(n => parseInt(n, 10));\n    result.push(beats.length);\n  }\n  return result;\n};\n\nconst parseNote = (note) => {\n  const notes = note.split(' ');\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const beats = note.map(n => parseInt(n, 10));\n    result.push(beats.length);\n  }\n  return result;\n};\n\nconst parseNotes = (notes) => {\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const beats = note.map(n => parseInt(n, 10));\n    result.push(beats.length);\n  }\n  return result;\n};\n\nconst parseNote = (note) => {\n  const notes = note.split(' ');\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const beats = note.map(n => parseInt(n, 10));\n    result.push(beats.length);\n  }\n  return result;\n};\n\nconst parseNotes = (notes) => {\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const beats = note.map(n => parseInt(n, 10));\n    result.push(beats.length);\n  }\n  return result;\n};\n\nconst parseNote = (note) => {\n  const notes = note.split(' ');\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const beats = note.map(n => parseInt(n, 10));\n    result.push(beats.length);\n  }\n  return result;\n};\n\nconst parseNotes = (notes) => {\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const beats = note.map(n => parseInt(n, 10));\n    result.push(beats.length);\n  }\n  return result;\n};\n\nconst parseNote = (note) => {\n  const notes = note.split(' ');\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const beats = note.map(n => parseInt(n, 10));\n    result.push(beats.length);\n  }\n  return result;\n};\n\nconst parseNotes = (notes) => {\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const beats = note.map(n => parseInt(n, 10));\n    result.push(beats.length);\n  }\n  return result;\n};\n\nconst parseNote = (note) => {\n  const notes = note.split(' ');\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const beats = note.map(n => parseInt(n, 10));\n    result.push(beats.length);\n  }\n  return result;\n};\n\nconst parseNotes = (notes) => {\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const beats = note.map(n => parseInt(n, 10));\n    result.push(beats.length);\n  }\n  return result;\n};\n\nconst parseNotes = (notes) => {\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const beats = note.map(n => parseInt(n, 10));\n    result.push(beats.length);\n  }\n  return result;\n};\n\nconst parseNotes = (notes) => {\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const beats = note.map(n => parseInt(n, 10));\n    result.push(beats.length);\n  }\n  return result;\n};\n\nconst parseNotes = (notes) => {\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const beats = note.map(n => parseInt(n, 10));\n    result.push(beats.length);\n  }\n  return result;\n};\n\nconst parseNotes = (notes) => {\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const beats = note.map(n => parseInt(n, 10));\n    result.push(beats.length);\n  }\n  return result;\n};\n\nconst parseNotes = (notes) => {\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const beats = note.map(n => parseInt(n, 10));\n    result.push(beats.length);\n  }\n  return result;\n};\n\nconst parseNotes = (notes) => {\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const beats = note.map(n => parseInt(n, 10));\n    result.push(beats.length);\n  }\n  return result;\n};\n\nconst parseNotes = (notes) => {\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const beats = note.map(n => parseInt(n, 10));\n    result.push(beats.length);\n  }\n  return result;\n};\n\nconst parseNotes = (notes) => {\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const beats = note.map(n => parseInt(n, 10));\n    result.push(beats.length);\n  }\n  return result;\n};\n\nconst parseNotes = (notes) => {\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const beats = note.map(n => parseInt(n, 10));\n    result.push(beats.length);\n  }\n  return result;\n};\n\nconst parseNotes = (notes) => {\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const beats = note.map(n => parseInt(n, 10));\n    result.push(beats.length);\n  }\n  return result;\n};\n\nconst parseNotes = (notes) => {\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const beats = note.map(n => parseInt(n, 10));\n    result.push(beats.length);\n  }\n  return result;\n};\n\nconst parseNotes = (notes) => {\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const beats = note.map(n => parseInt(n, 10));\n    result.push(beats.length);\n  }\n  return result;\n};\n\nconst parseNotes = (notes) => {\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const beats = note.map(n => parseInt(n, 10));\n    result.push(", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/18", "prompt": "/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "gc": "<|endoftext|>/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  let index = 0;\n  let length = string.length;\n  while (index < length) {\n    if (string.charAt(index) === substring) {\n      count++;\n    }\n    index++;\n  }\n  return count;\n};\n\n/**\n * Given a string, return all possible permutations of that string.\n * If no permutations can be found, return an empty array.\n * If there are multiple permutations, return an array with all the permutations.\n * Example:\n * permutations(\"\") => []\n * permutations(\"ab\") => [\"a\", \"b\", \"a\"]\n * permutations(\"abc\") => [\"a\", \"b\", \"c\", \"a\", \"b\", \"c\"]\n * permutations(\"abcd\") => [\"a\", \"b\", \"c\", \"d\", \"a\", \"b\", \"c\", \"d\"]\n * permutations(\"abcde\") => [\"a\", \"b\", \"c\", \"d\", \"e\", \"a\", \"b\", \"c\", \"d\", \"e\"]\n * permutations(\"abcdef\") => [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\n * permutations(\"abcdefg\") => [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]\n * permutations(\"abcdefgh\") => [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"]\n * permutations(\"abcdefghi\") => [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"]\n * permutations(\"abcdefghij\") => [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"]\n * permutations(\"abcdefghijk\") => [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"]\n * permutations(\"abcdefghijkl\") => [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"]\n * permutations(\"abcdefghijklm\") => [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"]\n * permutations(\"abcdefghijklmnop\") => [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"]\n * permutations(\"abcdefghijklmnopq\") => [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"q\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"q\"]\n * permutations(\"abcdefghijklmnopqr\") => [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"q\", \"r\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"q\", \"r\"]\n * permutations(\"abcdefghijklmnopqrst\") => [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"q\", \"r\", \"s\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"q\", \"r\", \"s\"]\n * permutations(\"abcdefghijklmnopqrstu\") => [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"q\", \"r\", \"s\", \"u\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"q\", \"r\", \"s\", \"u\"]\n * permutations(\"abcdefghijklmnopqrstuv\") => [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"q\", \"r\", \"s\", \"u\", \"v\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"q\", \"r\", \"s\", \"u\", \"v\"]\n * permutations(\"abcdefghijklmnopqrstuvw\") => [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"q\", \"r\", \"s\", \"u\", \"v\", \"w\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"q\", \"r\", \"s\", \"u\", \"v\", \"w\"]\n * permutations(\"abcdefghijklmnopqrstuvwx\") => [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"q\", \"r\", \"s\", \"u\", \"v\", \"w\", \"x\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"q\", \"r\", \"s\", \"u\", \"v\", \"w\", \"x\"]\n * permutations(\"abcdefghijklmnopqrstuvwxz\") => [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"q\", \"r\", \"s\", \"u\", \"v\", \"w\", \"x\", \"z\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"q\", \"r\", \"s\", \"u\", \"v\", \"w\", \"x\", \"z\"]\n * permutations(\"abcdefghijklmnopqrstuvwxzy\") => [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"q\", \"r\", \"s\", \"u\", \"v\", \"w\", \"x\", \"y\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"q\", \"r\", \"s\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n * permutations(\"abcdefghijklmnopqrstuvwxzz\") => [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"q\", \"r\", \"s\", \"u\", \"v\", \"w\", \"x\", \"z\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"q\", \"r\", \"s\", \"u\", \"v\", \"w\", \"x\", \"z\", \"z\"]\n * permutations(\"abcdefghijklmnopqrstuvwxzzy\") => [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"q\", \"r\", \"s\", \"u\", \"v\", \"w\", \"x\", \"z\", \"y\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"q\", \"r\", \"s\", \"u\", \"v\", \"w\", \"x\", \"z\", \"z\"]\n * permutations(\"abcdefghijklmnopqrstuvwxzzz\") => [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"q\", \"r\", \"s\", \"u\", \"v\", \"w\", \"", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "gc": "<|endoftext|>/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/2", "prompt": "/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNubmer(3.5)\n  0.5\n  */\nconst truncateNubmer = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNubmer", "gc": "<|endoftext|>/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNubmer(3.5)\n  0.5\n  */\nconst truncateNubmer = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : Math.ceil(integer);\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNubmer(3.5)\n  3\n  */\nconst truncateNubmerInt = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : Math.ceil(integer);\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNubmerInt(3.5)\n  3\n  */\nconst truncateNubmerIntN = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : Math.ceil(integer);\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNubmerIntN(3.5)\n  3\n  */\nconst truncateNubmerIntNb = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : Math.ceil(integer);\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNubmerIntNb(3.5)\n  3\n  */\nconst truncateNubmerIntNbN = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : Math.ceil(integer);\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNubmerIntNbN(3.5)\n  3\n  */\nconst truncateNubmerIntNbNb = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : Math.ceil(integer);\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNubmerIntNbNbN(3.5)\n  3\n  */\nconst truncateNubmerIntNbNbN = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : Math.ceil(integer);\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNubmerIntNbNbNb(3.5)\n  3\n  */\nconst truncateNubmerIntNbNbNb = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : Math.ceil(integer);\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNubmerIntNbNbNbNb(3.5)\n  3\n  */\nconst truncateNubmerIntNbNbNbNb = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : Math.ceil(integer);\n};\n\n/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNubmerIntNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbNbN", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n  other and return them in order (smaller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "gc": "<|endoftext|>/* From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n  other and return them in order (smaller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  let minDistance = Number.MAX_VALUE;\n  let minDistanceIndex = -1;\n  let closestElement = undefined;\n  let closestElementIndex = -1;\n  let closestElementDistance = Number.MAX_VALUE;\n\n  for (let i = 0; i < numbers.length; i++) {\n    const distance = numbers[i] - closestElement;\n    if (distance < closestElementDistance) {\n      closestElementDistance = distance;\n      closestElement = numbers[i];\n      closestElementIndex = i;\n    }\n    if (distance < minDistance) {\n      minDistance = distance;\n      minDistanceIndex = i;\n    }\n  }\n\n  return [closestElement, minDistanceIndex, minDistance];\n};\n\n// Given a sorted array of numbers, return all possible permutations of that array (each permutation is a pair).\n// >>> permutations([1, 2, 3, 4])\n// [\n//   [1, 1, 1],\n//   [1, 1, 2],\n//   [1, 1, 3],\n//   [1, 1, 4],\n//   [1, 2, 1],\n//   [1, 2, 2],\n//   [1, 2, 3],\n//   [1, 2, 4],\n//   [1, 3, 1],\n//   [1, 3, 2],\n//   [1, 3, 3],\n//   [1, 3, 4],\n//   [2, 3, 1],\n//   [2, 3, 2],\n//   [2, 3, 3],\n//   [2, 3, 4],\n//   [3, 4, 1],\n//   [3, 4, 2],\n//   [3, 4, 3],\n//   [3, 4, 4],\n// ]\nconst permutations = (arr) => {\n  const result = [];\n  let currentPermutation = [];\n  let currentPermutationIndex = 0;\n  let currentPermutationLength = arr.length;\n  let currentPermutationIndexMax = currentPermutationLength - 1;\n\n  while (currentPermutationIndex < currentPermutationLength) {\n    currentPermutation.push(arr[currentPermutationIndex]);\n    currentPermutationIndex++;\n\n    if (currentPermutationIndexMax < currentPermutationLength) {\n      currentPermutationIndexMax++;\n    }\n  }\n\n  while (currentPermutationIndexMax < currentPermutationLength) {\n    currentPermutation.push(arr[currentPermutationIndexMax]);\n    currentPermutationIndexMax--;\n\n    if (currentPermutationIndex < currentPermutationLength) {\n      currentPermutationIndex++;\n    }\n  }\n\n  currentPermutation.push(arr[currentPermutationLength - 1]);\n\n  result.push(currentPermutation);\n\n  return result;\n};\n\n// Given a sorted array of numbers, return all possible combinations of that array (each combination is a triple).\n// >>> combinations([1, 2, 3, 4])\n// [\n//   [1, 1, 1],\n//   [1, 1, 2],\n//   [1, 1, 3],\n//   [1, 1, 4],\n//   [1, 2, 1],\n//   [1, 2, 2],\n//   [1, 2, 3],\n//   [1, 2, 4],\n//   [1, 3, 1],\n//   [1, 3, 2],\n//   [1, 3, 3],\n//   [1, 3, 4],\n//   [2, 3, 1],\n//   [2, 3, 2],\n//   [2, 3, 3],\n//   [2, 3, 4],\n//   [3, 4, 1],\n//   [3, 4, 2],\n//   [3, 4, 3],\n//   [3, 4, 4],\n// ]\nconst combinations = (arr) => {\n  const result = [];\n  let currentCombination = [];\n  let currentCombinationIndex = 0;\n  let currentCombinationLength = arr.length;\n  let currentCombinationIndexMax = currentCombinationLength - 1;\n\n  while (currentCombinationIndex < currentCombinationLength) {\n    currentCombination.push(arr[currentCombinationIndex]);\n    currentCombinationIndex++;\n\n    if (currentCombinationIndexMax < currentCombinationLength) {\n      currentCombinationIndexMax++;\n    }\n  }\n\n  while (currentCombinationIndexMax < currentCombinationLength) {\n    currentCombination.push(arr[currentCombinationIndexMax]);\n    currentCombinationIndexMax--;\n\n    if (currentCombinationIndex < currentCombinationLength) {\n      currentCombinationIndex++;\n    }\n  }\n\n  currentCombination.push(arr[currentCombinationLength - 1]);\n\n  result.push(currentCombination);\n\n  return result;\n};\n\n// Given a sorted array of numbers, return all possible subsets of that array (each subset is a triplet).\n// >>> subsets([1, 2, 3, 4])\n// [\n//   [1, 1, 1],\n//   [1, 1, 2],\n//   [1, 1, 3],\n//   [1, 1, 4],\n//   [1, 2, 1],\n//   [1, 2, 2],\n//   [1, 2, 3],\n//   [1, 2, 4],\n//   [1, 3, 1],\n//   [1, 3, 2],\n//   [1, 3, 3],\n//   [1, 3, 4],\n//   [2, 3, 1],\n//   [2, 3, 2],\n//   [2, 3, 3],\n//   [2, 3, 4],\n//   [3, 4, 1],\n//   [3, 4, 2],\n//   [3, 4, 3],\n//   [3, 4, 4],\n// ]\nconst subsets = (arr) => {\n  const result = [];\n  let currentSubset = [];\n  let currentSubsetIndex = 0;\n  let currentSubsetLength = arr.length;\n  let currentSubsetIndexMax = currentSubsetLength - 1;\n\n  while (currentSubsetIndex < currentSubsetLength) {\n    currentSubset.push(arr[currentSubsetIndex]);\n    currentSubsetIndex++;\n\n    if (currentSubsetIndexMax < currentSubsetLength) {\n      currentSubsetIndexMax++;\n    }\n  }\n\n  while (currentSubsetIndexMax < currentSubsetLength) {\n    currentSubset.push(arr[currentSubsetIndexMax]);\n    currentSubsetIndexMax--;\n\n    if (currentSubsetIndex < currentSubsetLength) {\n      currentSubsetIndex++;\n    }\n  }\n\n  currentSubset.push(arr[currentSubsetLength - 1]);\n\n  result.push(currentSubset);\n\n  return result;\n};\n\n// Given a sorted array of numbers, return all possible unique permutations of that array (each permutation is a pair).\n// >>> uniquePermutations([1, 2, 3, 4])\n// [\n//   [1, 1, 1],\n//   [1, 1, 2],\n//   [1, 1, 3],\n//   [1, 1, 4],\n//   [1, 2, 1],\n//   [1, 2, 2],\n//   [1, 2, 3],\n//   [1, 2, 4],\n//   [1, 3, 1],\n//   [1, 3, 2],\n//   [1, 3, 3],\n//   [1, 3, 4],\n//   [2, 3, 1],\n//   [2, 3, 2],\n//   [2, 3, 3],\n//   [2, 3, 4],\n//   [3, 4, 1],\n//   [3, 4, 2],\n//   [3, 4, 3],\n//   [3, 4, 4],\n// ]\nconst uniquePermutations = (arr) => {\n  const result = [];\n  let currentPermutation = [];\n  let currentPermutationIndex = 0;\n  let currentPermutationLength = arr.length;\n  let currentPermutationIndexMax = currentPermutationLength - 1;\n\n  while (currentPermutationIndex < currentPermutationLength) {\n    currentPermutation.push(arr[currentPermutationIndex]);\n    currentPermutationIndex++;\n\n    if (currentPermutationIndexMax < currentPermutationLength) {\n      currentPermutationIndexMax++;\n    }\n  }\n\n  while (currentPermutationIndexMax < currentPermutationLength) {\n    currentPermutation.push(arr[currentPermutationIndexMax]);\n    currentPermutationIndexMax--;\n\n    if (currentPermutationIndex < currentPermutationLength) {\n      currentPermutationIndex++;\n    }\n  }\n\n  currentPermutation.push(arr[currentPermutationLength - 1]);\n\n  result.push(currentPermutation);\n\n  return result;\n};\n\n// Given a sorted array of numbers, return all possible unique combinations of that array (each combination is a triple).\n// >>> uniqueCombinations([1, 2, 3, 4])\n// [\n//   [1, 1, 1],\n//   [1, 1, 2],\n//   [1, 1, 3],\n//   [1, 1, 4],\n//   [1, 2, 1],\n//   [1, 2, 2],\n//   [1, 2, 3],\n//   [1, 2, 4],\n//   [1, 3, 1],\n//   [1, 3, 2],\n//   [1, 3, 3],\n//   [1, 3, 4],\n//   [2, 3, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleTonUit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleTonUit", "gc": "<|endoftext|>/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleTonUit = (numbers) => {\n  const minValue = Math.min.apply(null, numbers);\n  const maxValue = Math.max.apply(null, numbers);\n  const scale = (maxValue - minValue) / (numbers.length - 1);\n  return numbers.map((number) => number / scale);\n};\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleTonUitWithOffset = (numbers, offset) => {\n  const minValue = Math.min.apply(null, numbers);\n  const maxValue = Math.max.apply(null, numbers);\n  const scale = (maxValue - minValue) / (numbers.length - 1);\n  return numbers.map((number, index) => {\n    const offset = index * offset;\n    return number / scale + offset;\n  });\n};\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleTonUitWithOffset([1.0, 2.0, 3.0, 4.0, 5.0], 2)\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleTonUitWithOffsetWithOffset = (numbers, offset, offsetOffset) => {\n  const minValue = Math.min.apply(null, numbers);\n  const maxValue = Math.max.apply(null, numbers);\n  const scale = (maxValue - minValue) / (numbers.length - 1);\n  return numbers.map((number, index) => {\n    const offset = index * offsetOffset;\n    return number / scale + offset;\n  });\n};\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleTonUitWithOffsetWithOffset([1.0, 2.0, 3.0, 4.0, 5.0], 2, 2)\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleTonUitWithOffsetWithOffsetWithOffset = (numbers, offset, offsetOffset, offsetOffsetOffset) => {\n  const minValue = Math.min.apply(null, numbers);\n  const maxValue = Math.max.apply(null, numbers);\n  const scale = (maxValue - minValue) / (numbers.length - 1);\n  return numbers.map((number, index) => {\n    const offset = index * offsetOffsetOffset;\n    return number / scale + offset;\n  });\n};\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleTonUitWithOffsetWithOffsetWithOffset([1.0, 2.0, 3.0, 4.0, 5.0], 2, 2, 2, 2)\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleTonUitWithOffsetWithOffsetWithOffsetWithOffset = (numbers, offset, offsetOffset, offsetOffsetOffset, offsetOffsetOffsetOffset) => {\n  const minValue = Math.min.apply(null, numbers);\n  const maxValue = Math.max.apply(null, numbers);\n  const scale = (maxValue - minValue) / (numbers.length - 1);\n  return numbers.map((number, index) => {\n    const offset = index * offsetOffsetOffsetOffset;\n    return number / scale + offset;\n  });\n};\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleTonUitWithOffsetWithOffsetWithOffsetWithOffset([1.0, 2.0, 3.0, 4.0, 5.0], 2, 2, 2, 2, 2, 2)\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleTonUitWithOffsetWithOffsetWithOffsetWithOffsetWithOffset = (numbers, offset, offsetOffset, offsetOffsetOffset, offsetOffsetOffsetOffset, offsetOffsetOffsetOffsetOffset) => {\n  const minValue = Math.min.apply(null, numbers);\n  const maxValue = Math.max.apply(null, numbers);\n  const scale = (maxValue - minValue) / (numbers.length - 1);\n  return numbers.map((number, index) => {\n    const offset = index * offsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffsetOffset", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of any python values only for integers\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filetrItnegers", "gc": "<|endoftext|>/* Filter given list of any python values only for integers\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegers = (values) => {\n  return values.filter(value =>!isNaN(value))\n}\n\n/* Filter given list of any python values only for floats\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersFloats = (values) => {\n  return values.filter(value =>!isNaN(value))\n}\n\n/* Filter given list of any python values only for strings\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersStrings = (values) => {\n  return values.filter(value => typeof value ==='string')\n}\n\n/* Filter given list of any python values only for booleans\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersBools = (values) => {\n  return values.filter(value => typeof value === 'boolean')\n}\n\n/* Filter given list of any python values only for None\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersNones = (values) => {\n  return values.filter(value => value === null)\n}\n\n/* Filter given list of any python values only for empty list\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyLists = (values) => {\n  return values.filter(value => value === [])\n}\n\n/* Filter given list of any python values only for empty dict\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyDicts = (values) => {\n  return values.filter(value => value === {})\n}\n\n/* Filter given list of any python values only for empty string\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyStrings = (values) => {\n  return values.filter(value => value === \"\")\n}\n\n/* Filter given list of any python values only for empty tuple\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyTuples = (values) => {\n  return values.filter(value => value === [])\n}\n\n/* Filter given list of any python values only for empty list\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyListsTuples = (values) => {\n  return values.filter(value => value === [])\n}\n\n/* Filter given list of any python values only for empty dict\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyDictsTuples = (values) => {\n  return values.filter(value => value === {})\n}\n\n/* Filter given list of any python values only for empty string\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyStringsTuples = (values) => {\n  return values.filter(value => value === \"\")\n}\n\n/* Filter given list of any python values only for empty tuple\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyTuplesTuples = (values) => {\n  return values.filter(value => value === [])\n}\n\n/* Filter given list of any python values only for empty list\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyListsTuplesTuples = (values) => {\n  return values.filter(value => value === [])\n}\n\n/* Filter given list of any python values only for empty dict\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyDictsTuplesTuples = (values) => {\n  return values.filter(value => value === {})\n}\n\n/* Filter given list of any python values only for empty string\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyStringsTuplesTuples = (values) => {\n  return values.filter(value => value === \"\")\n}\n\n/* Filter given list of any python values only for empty tuple\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyTuplesTuplesTuples = (values) => {\n  return values.filter(value => value === [])\n}\n\n/* Filter given list of any python values only for empty list\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyListsTuplesTuplesTuples = (values) => {\n  return values.filter(value => value === [])\n}\n\n/* Filter given list of any python values only for empty dict\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyDictsTuplesTuplesTuples = (values) => {\n  return values.filter(value => value === {})\n}\n\n/* Filter given list of any python values only for empty string\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyStringsTuplesTuplesTuples = (values) => {\n  return values.filter(value => value === \"\")\n}\n\n/* Filter given list of any python values only for empty tuple\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst file", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/23", "prompt": "/* Return length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "gc": "<|endoftext|>/* Return length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  let len = 0;\n  for (let i = 0; i < string.length; i++) {\n    len += string.charCodeAt(i).length;\n  }\n  return len;\n};\n\n/**\n * Return true if given string ends with given suffix\n * >>> endsWith('abc', 'b')\n  true\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  false\n  >>> endsWith('abc', 'b')\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/24", "prompt": "/* For a given number n, find the largest number that divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "gc": "<|endoftext|>/* For a given number n, find the largest number that divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let divisor = 1;\n  while (divisor <= n) {\n    divisor *= 2;\n  }\n  return divisor;\n};\n\n// Given a number n, find the largest number that divides n evenly, smaller than n\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> lar", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/25", "prompt": "/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "gc": "<|endoftext|>/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/* Given a number return its prime factorization\n  >>> primeFactorization(2)\n  [2, 1]\n  >>> primeFactorization(3)\n  [2, 3, 1]\n  >>> primeFactorization(5)\n  [5, 1, 3]\n  >>> primeFactorization(7)\n  [7, 5, 3]\n  >>> primeFactorization(11)\n  [11, 5, 7, 3, 1]\n  */\nconst primeFactorization = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/* Given a number return its prime factorization\n  >>> primeFactorization(2)\n  [2, 1]\n  >>> primeFactorization(3)\n  [2, 3, 1]\n  >>> primeFactorization(5)\n  [5, 1, 3]\n  >>> primeFactorization(7)\n  [7, 5, 3]\n  >>> primeFactorization(11)\n  [11, 5, 7, 3, 1]\n  */\nconst primeFactorization2 = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/* Given a number return its prime factorization\n  >>> primeFactorization(2)\n  [2, 1]\n  >>> primeFactorization(3)\n  [2, 3, 1]\n  >>> primeFactorization(5)\n  [5, 1, 3]\n  >>> primeFactorization(7)\n  [7, 5, 3]\n  >>> primeFactorization(11)\n  [11, 5, 7, 3, 1]\n  */\nconst primeFactorization3 = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/* Given a number return its prime factorization\n  >>> primeFactorization(2)\n  [2, 1]\n  >>> primeFactorization(3)\n  [2, 3, 1]\n  >>> primeFactorization(5)\n  [5, 1, 3]\n  >>> primeFactorization(7)\n  [7, 5, 3]\n  >>> primeFactorization(11)\n  [11, 5, 7, 3, 1]\n  */\nconst primeFactorization4 = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/* Given a number return its prime factorization\n  >>> primeFactorization(2)\n  [2, 1]\n  >>> primeFactorization(3)\n  [2, 3, 1]\n  >>> primeFactorization(5)\n  [5, 1, 3]\n  >>> primeFactorization(7)\n  [7, 5, 3]\n  >>> primeFactorization(11)\n  [11, 5, 7, 3, 1]\n  */\nconst primeFactorization5 = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/* Given a number return its prime factorization\n  >>> primeFactorization(2)\n  [2, 1]\n  >>> primeFactorization(3)\n  [2, 3, 1]\n  >>> primeFactorization(5)\n  [5, 1, 3]\n  >>> primeFactorization(7)\n  [7, 5, 3]\n  >>> primeFactorization(11)\n  [11, 5, 7, 3, 1]\n  */\nconst primeFactorization6 = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/* Given a number return its prime factorization\n  >>> primeFactorization(2)\n  [2, 1]\n  >>> primeFactorization(3)\n  [2, 3, 1]\n  >>> primeFactorization(5)\n  [5, 1, 3]\n  >>> primeFactorization(7)\n  [7, 5, 3]\n  >>> primeFactorization(11)\n  [11, 5, 7, 3, 1]\n  */\nconst primeFactorization7 = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/* Given a number return its prime factorization\n  >>> primeFactorization(2)\n  [2, 1]\n  >>> primeFactorization(3)\n  [2, 3, 1]\n  >>> primeFactorization(5)\n  [5, 1, 3]\n  >>> primeFactorization(7)\n  [7, 5, 3]\n  >>> primeFactorization(11)\n  [11, 5, 7, 3, 1]\n  */\nconst primeFactorization8 = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/* Given a number return its prime factorization\n  >>> primeFactorization(2)\n  [2, 1]\n  >>> primeFactorization(3)\n  [2, 3, 1]\n  >>> primeFactorization(5)\n  [5, 1, 3]\n  >>> primeFactorization(7)\n  [7, 5, 3]\n  >>> primeFactorization(11)\n  [11, 5, 7, 3, 1]\n  */\nconst primeFactorization9 = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/* Given a number return its prime factorization\n  >>> primeFactorization(2)\n  [2, 1]\n  >>> primeFactorization(3)\n  [2, 3, 1]\n  >>> primeFactorization(5)\n  [5, 1, 3]\n  >>> primeFactorization(7)\n  [7, 5, 3]\n  >>> primeFactorization(11)\n  [11, 5, 7, 3, 1]\n  */\nconst primeFactorization10 = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/* Given a number return its prime factorization\n  >>> primeFactorization(2)\n  [2, 1]\n  >>> primeFactorization(3)\n  [2, 3, 1]\n  >>> primeFactorization(5)\n  [5, 1, 3]\n  >>> primeFactorization(7)\n  [7, 5, 3]\n  >>> primeFactorization(11)\n  [11, 5, 7, 3, 1]\n  */\nconst primeFactorization11 = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/* Given a number return its prime factorization\n  >>> primeFactorization(2)\n  [2, 1]\n  >>> primeFactorization(3)\n  [2, 3, 1]\n  >>> primeFactorization(5)\n  [5, 1, 3]\n  >>> primeFactorization(7)\n  [7, 5, 3]\n  >>> primeFactorization(11)\n  [11, 5, 7, 3, 1]\n  */\nconst primeFactorization12 = (n) => {\n  const factors = [];\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 10;\n    factors.push(factor);\n  }\n  return factors;\n};\n\n/* Given ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers, remove all elements that occur more than once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "gc": "<|endoftext|>/* From a list of integers, remove all elements that occur more than once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const seen = new Set();\n  return numbers.reduce((acc, curr) => {\n    if (seen.has(curr)) {\n      seen.delete(curr);\n    } else {\n      seen.add(curr);\n      acc.push(curr);\n    }\n    return acc;\n  }, []);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return Math.floor(Math.random() * 1000);\n};\n\nconst getRandomInt = () => {\n  return ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "gc": "<|endoftext|>/* For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.toLowerCase().replace(/[A-Z]/g, (_, char) => char.toUpperCase())\n}\n\n/**\n * Given a string, return the first letter of the string capitalized.\n * If the string starts with a capital letter, return that capital letter.\n * If the string starts with a lowercase letter, return that lowercase letter.\n * If the string starts with a number, return that number.\n * If the string starts with a special character, return that special character.\n * If the string starts with a non-alphabetic character, return that non-alphabetic character.\n * If the string starts with a non-numeric character, return that non-numeric character.\n * If the string starts with a non-special character, return that non-special character.\n * If the string starts with a non-uppercase character, return that non-uppercase character.\n * If the string starts with a non-lowercase character, return that non-lowercase character.\n * If the string starts with a non-alphabetic character, return that non-alphabetic character.\n * If the string starts with a non-numeric character, return that non-numeric character.\n * If the string starts with a non-special character, return that non-special character.\n * If the string starts with a non-uppercase character, return that non-uppercase character.\n * If the string starts with a non-lowercase character, return that non-lowercase character.\n * If the string starts with a non-alphabetic character, return that non-alphabetic character.\n * If the string starts with a non-numeric character, return that non-numeric character.\n * If the string starts with a non-special character, return that non-special character.\n * If the string starts with a non-uppercase character, return that non-uppercase character.\n * If the string starts with a non-lowercase character, return that non-lowercase character.\n * If the string starts with a non-alphabetic character, return that non-alphabetic character.\n * If the string starts with a non-numeric character, return that non-numeric character.\n * If the string starts with a non-special character, return that non-special character.\n * If the string starts with a non-uppercase character, return that non-uppercase character.\n * If the string starts with a non-lowercase character, return that non-lowercase character.\n * If the string starts with a non-alphabetic character, return that non-alphabetic character.\n * If the string starts with a non-numeric character, return that non-numeric character.\n * If the string starts with a non-special character, return that non-special character.\n * If the string starts with a non-uppercase character, return that non-uppercase character.\n * If the string starts with a non-lowercase character, return that non-lowercase character.\n * If the string starts with a non-alphabetic character, return that non-alphabetic character.\n * If the string starts with a non-numeric character, return that non-numeric character.\n * If the string starts with a non-special character, return that non-special character.\n * If the string starts with a non-uppercase character, return that non-uppercase character.\n * If the string starts with a non-lowercase character, return that non-lowercase character.\n * If the string starts with a non-alphabetic character, return that non-alphabetic character.\n * If the string starts with a non-numeric character, return that non-numeric character.\n * If the string starts with a non-special character, return that non-special character.\n * If the string starts with a non-uppercase character, return that non-uppercase character.\n * If the string starts with a non-lowercase character, return that non-lowercase character.\n * If the string starts with a non-alphabetic character, return that non-alphabetic character.\n * If the string starts with a non-numeric character, return that non-numeric character.\n * If the string starts with a non-special character, return that non-special character.\n * If the string starts with a non-uppercase character, return that non-uppercase character.\n * If the string starts with a non-lowercase character, return that non-lowercase character.\n * If the string starts with a non-alphabetic character, return that non-alphabetic character.\n * If the string starts with a non-numeric character, return that non-numeric character.\n * If the string starts with a non-special character, return that non-special character.\n * If the string starts with a non-uppercase character, return that non-uppercase character.\n * If the string starts with a non-lowercase character, return that non-lowercase character.\n * If the string starts with a non-alphabetic character, return that non-alphabetic character.\n * If the string starts with a non-numeric character, return that non-numeric character.\n * If the string starts with a non-special character, return that non-special character.\n * If the string starts with a non-uppercase character, return that non-uppercase character.\n * If the string starts with a non-lowercase character, return that non-lowercase character.\n * If the string starts with a non-alphabetic character, return that non-alphabetic character.\n * If the string starts with a non-numeric character, return that non-numeric character.\n * If the string starts with a non-special character, return that non-special character.\n * If the string starts with a non-uppercase character, return that non-uppercase character.\n * If the string starts with a non-lowercase character, return that non-lowercase character.\n * If the string starts with a non-alphabetic character, return that non-alphabetic character.\n * If the string starts with a non-numeric character, return that non-numeric character.\n * If the string starts with a non-special character, return that non-special character.\n * If the string starts with a non-uppercase character, return that non-uppercase character.\n * If the string starts with a non-lowercase character, return that non-lowercase character.\n * If the string starts with a non-alphabetic character, return that non-alphabetic character.\n * If the string starts with a non-numeric character, return that non-numeric character.\n * If the string starts with a non-special character, return that non-special character.\n * If the string starts with a non-uppercase character, return that non-uppercase character.\n * If the string starts with a non-lowercase character, return that non-lowercase character.\n * If the string starts with a non-alphabetic character, return that non-alphabetic character.\n * If the string starts with a non-numeric character, return that non-numeric character.\n * If the string starts with a non-special character, return that non-special character.\n * If the string starts with a non-uppercase character, return that non-uppercase character.\n * If the string starts with a non-lowercase character, return that non-lowercase character.\n * If the string starts with a non-alphabetic character, return that non-alphabetic character.\n * If the string starts with a non-numeric character, return that non-numeric character.\n * If the string starts with a non-special character, return that non-special character.\n * If the string starts with a non-uppercase character, return that non-uppercase character.\n * If the string starts with a non-lowercase character, return that non-lowercase character.\n * If the string starts with a non-alphabetic character, return that non-alphabetic character.\n * If the string starts with a non-numeric character, return that non-numeric character.\n * If the string starts with a non-special character, return that non-special character.\n * If the string starts with a non-uppercase character, return that non-uppercase character.\n * If the string starts with a non-lowercase character, return that non-lowercase character.\n * If the string starts with a non-alphabetic character, return that non-alphabetic character.\n * If the string starts with a non-numeric character, return that non-numeric character.\n * If the string starts with a non-special character, return that non-special character.\n * If the string starts with a non-uppercase character, return that non-uppercase character.\n * If the string starts with a non-lowercase character, return ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single string\n  >>> conactenate([])\n  ''\n  >>> conactenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst conactenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "conactenate", "gc": "<|endoftext|>/* Concatenate list of strings into a single string\n  >>> conactenate([])\n  ''\n  >>> conactenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst conactenate = (strings) => {\n  return strings.reduce((acc, curr, index) => {\n    return acc + (curr? curr.charAt(0).toUpperCase() + curr.slice(1) : curr);\n  }, '');\n};\n\n/* Convert string to camel case\n  >>> camelcase('hello')\n  'hello'\n  >>> camelcase('hello_world')\n  'helloWorld'\n  */\nconst camelcase = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n};\n\n/* Convert string to dash case\n  >>> dashcase('hello')\n  'hello'\n  >>> dashcase('hello_world')\n  'hello-world'\n  */\nconst dashcase = (string) => {\n  return string.replace(/([A-Z])/g, '-$1').toLowerCase();\n};\n\n/* Convert string to underscore case\n  >>> underscore('hello')\n  'hello'\n  >>> underscore('hello_world')\n  'hello_world'\n  */\nconst underscore = (string) => {\n  return string.replace(/_/g, '').toLowerCase();\n};\n\n/* Convert string to pascal case\n  >>> pascalcase('hello')\n  'Hello'\n  >>> pascalcase('hello_world')\n  'HelloWorld'\n  */\nconst pascalcase = (string) => {\n  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n};\n\n/* Convert string to snake case\n  >>> snakecase('hello')\n  'hello'\n  >>> snakecase('hello_world')\n  'hello_world'\n  */\nconst snakecase = (string) => {\n  return string.replace(/([A-Z])/g, '-$1').toLowerCase();\n};\n\n/* Convert string to snake case with underscore\n  >>> snake_case('hello')\n  'hello'\n  >>> snake_case('hello_world')\n  'hello_world'\n  */\nconst snake_case = (string) => {\n  return string.replace(/([A-Z])/g, '-$1').toLowerCase();\n};\n\n/* Convert string to pascal case with underscore\n  >>> snake_case_with_underscore('hello')\n  'hello'\n  >>> snake_case_with_underscore('hello_world')\n  'hello_world'\n  */\nconst snake_case_with_underscore = (string) => {\n  return string.replace(/([A-Z])/g, '-$1').toLowerCase();\n};\n\n/* Convert string to pascal case with underscore\n  >>> snake_case_with_underscore_with_underscore('hello')\n  'hello'\n  >>> snake_case_with_underscore_with_underscore('hello_world')\n  'hello_world'\n  */\nconst snake_case_with_underscore_with_underscore = (string) => {\n  return string.replace(/([A-Z])/g, '-$1').toLowerCase();\n};\n\n/* Convert string to pascal case with underscore\n  >>> snake_case_with_underscore_with_underscore('hello_world')\n  'hello_world'\n  */\nconst snake_case_with_underscore_with_underscore_with_underscore = (string) => {\n  return string.replace(/([A-Z])/g, '-$1').toLowerCase();\n};\n\n/* Convert string to pascal case with underscore\n  >>> snake_case_with_underscore_with_underscore_with_underscore('hello_world')\n  'hello_world'\n  */\nconst snake_case_with_underscore_with_underscore_with_underscore_with_underscore = (string) => {\n  return string.replace(/([A-Z])/g, '-$1').toLowerCase();\n};\n\n/* Convert string to pascal case with underscore\n  >>> snake_case_with_underscore_with_underscore_with_underscore_with_underscore('hello_world')\n  'hello_world'\n  */\nconst snake_case_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore = (string) => {\n  return string.replace(/([A-Z])/g, '-$1').toLowerCase();\n};\n\n/* Convert string to pascal case with underscore\n  >>> snake_case_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore('hello_world')\n  'hello_world'\n  */\nconst snake_case_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore = (string) => {\n  return string.replace(/([A-Z])/g, '-$1').toLowerCase();\n};\n\n/* Convert string to pascal case with underscore\n  >>> snake_case_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_underscore_with_under", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings only for ones that start with a given prefix.\n  >>> iflterByrPefix([], 'a')\n  []\n  >>> iflterByrPefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst iflterByrPefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "iflterByrPefix", "gc": "<|endoftext|>/* Filter an input list of strings only for ones that start with a given prefix.\n  >>> iflterByrPefix([], 'a')\n  []\n  >>> iflterByrPefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst iflterByrPefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix));\n};\n\n/**\n * Filter an input list of strings only for ones that end with a given suffix.\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], '')\n  ['array']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'c')\n  ['array', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'd')\n  ['array', 'cde', 'array']\n  */\nconst iflterByrSuffix = (strings, suffix) => {\n  return strings.filter(s => s.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for ones that do not start with a given prefix.\n  >>> iflterByrNoPrefix(['abc', 'bcd', 'cde', 'array'], '')\n  ['array']\n  >>> iflterByrNoPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'bcd', 'cde']\n  >>> iflterByrNoPrefix(['abc', 'bcd', 'cde', 'array'], 'c')\n  ['array', 'cde']\n  >>> iflterByrNoPrefix(['abc', 'bcd', 'cde', 'array'], 'd')\n  ['array', 'cde', 'array']\n  */\nconst iflterByrNoPrefix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix));\n};\n\n/**\n * Filter an input list of strings only for ones that do not end with a given suffix.\n  >>> iflterByrNoSuffix(['abc', 'bcd', 'cde', 'array'], '')\n  ['array']\n  >>> iflterByrNoSuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'bcd', 'cde']\n  >>> iflterByrNoSuffix(['abc', 'bcd', 'cde', 'array'], 'c')\n  ['array', 'cde']\n  >>> iflterByrNoSuffix(['abc', 'bcd', 'cde', 'array'], 'd')\n  ['array', 'cde', 'array']\n  */\nconst iflterByrNoSuffix = (strings, suffix) => {\n  return strings.filter(s =>!s.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for ones that do not start with a given prefix.\n  >>> iflterByrNoPrefixAndSuffix(['abc', 'bcd', 'cde', 'array'], '')\n  ['array']\n  >>> iflterByrNoPrefixAndSuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'bcd', 'cde']\n  >>> iflterByrNoPrefixAndSuffix(['abc', 'bcd', 'cde', 'array'], 'c')\n  ['array', 'cde']\n  >>> iflterByrNoPrefixAndSuffix(['abc', 'bcd', 'cde', 'array'], 'd')\n  ['array', 'cde', 'array']\n  */\nconst iflterByrNoPrefixAndSuffix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix) && s.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for ones that do not end with a given suffix.\n  >>> iflterByrNoSuffixAndPrefix(['abc', 'bcd', 'cde', 'array'], '')\n  ['array']\n  >>> iflterByrNoSuffixAndPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'bcd', 'cde']\n  >>> iflterByrNoSuffixAndPrefix(['abc', 'bcd', 'cde', 'array'], 'c')\n  ['array', 'cde']\n  >>> iflterByrNoSuffixAndPrefix(['abc', 'bcd', 'cde', 'array'], 'd')\n  ['array', 'cde', 'array']\n  */\nconst iflterByrNoSuffixAndPrefix = (strings, suffix) => {\n  return strings.filter(s =>!s.endsWith(suffix) && s.startsWith(prefix));\n};\n\n/**\n * Filter an input list of strings only for ones that do not start with a given prefix.\n  >>> iflterByrNoPrefixAndSuffix(['abc', 'bcd', 'cde', 'array'], '')\n  ['array']\n  >>> iflterByrNoPrefixAndSuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'bcd', 'cde']\n  >>> iflterByrNoPrefixAndSuffix(['abc', 'bcd', 'cde', 'array'], 'c')\n  ['array', 'cde']\n  >>> iflterByrNoPrefixAndSuffix(['abc', 'bcd', 'cde', 'array'], 'd')\n  ['array', 'cde', 'array']\n  */\nconst iflterByrNoPrefixAndSuffix = (strings, prefix) => {\n  return strings.filter(s =>!s.startsWith(prefix) && s.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for ones that start with a given prefix.\n  >>> iflterByrPrefixAndSuffix(['abc', 'bcd', 'cde', 'array'], '')\n  ['array']\n  >>> iflterByrPrefixAndSuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'bcd', 'cde']\n  >>> iflterByrPrefixAndSuffix(['abc', 'bcd', 'cde', 'array'], 'c')\n  ['array', 'cde']\n  >>> iflterByrPrefixAndSuffix(['abc', 'bcd', 'cde', 'array'], 'd')\n  ['array', 'cde', 'array']\n  */\nconst iflterByrPrefixAndSuffix = (strings, suffix) => {\n  return strings.filter(s => s.startsWith(prefix) && s.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for ones that end with a given suffix.\n  >>> iflterByrSuffixAndPrefix(['abc', 'bcd', 'cde', 'array'], '')\n  ['array']\n  >>> iflterByrSuffixAndPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'bcd', 'cde']\n  >>> iflterByrSuffixAndPrefix(['abc', 'bcd', 'cde', 'array'], 'c')\n  ['array', 'cde']\n  >>> iflterByrSuffixAndPrefix(['abc', 'bcd', 'cde', 'array'], 'd')\n  ['array', 'cde', 'array']\n  */\nconst iflterByrSuffixAndPrefix = (strings, suffix) => {\n  return strings.filter(s => s.endsWith(suffix) && s.startsWith(prefix));\n};\n\n/**\n * Filter an input list of strings only for ones that do not start with a given prefix.\n  >>> iflterByrNoPrefixAndSuffix(['abc', 'bcd', 'cde', 'array'], '')\n  ['array']\n  >>> iflterByrNoPrefixAndSuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'bcd', 'cde']\n  >>> iflterByrNoPrefixAndSuffix(['abc', 'bcd', 'cde', 'array'], 'c')\n  ['array', 'cde']\n  >>> iflterByrNoPrefixAndSuffix(['abc', 'bcd', 'cde', 'array'], 'd')\n  ['", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeor([1, 2, 3])\n  false\n  >>> belowZeor([1, 2, -4, 5])\n  true\n  */\nconst belowZeor = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZeor", "gc": "<|endoftext|>/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeor([1, 2, 3])\n  false\n  >>> belowZeor([1, 2, -4, 5])\n  true\n  */\nconst belowZeor = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeor([-4, -5, -6, 7])\n  false\n  >>> belowZeor([-4, -5, -6, 7])\n  true\n  */\nconst belowZeor2 = operationArray => {\n  let balance = 0;\n  for (let i = 0; i < operationArray.length; i++) {\n    balance += operationArray[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeor2([-4, -5, -6, 7])\n  false\n  >>> belowZeor2([-4, -5, -6, 7])\n  true\n  */\nconst belowZeor3 = operationArray => {\n  let balance = 0;\n  for (let i = 0; i < operationArray.length; i++) {\n    balance += operationArray[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeor3([-4, -5, -6, 7])\n  false\n  >>> belowZeor3([-4, -5, -6, 7])\n  true\n  */\nconst belowZeor4 = operationArray => {\n  let balance = 0;\n  for (let i = 0; i < operationArray.length; i++) {\n    balance += operationArray[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeor4([-4, -5, -6, 7])\n  false\n  >>> belowZeor4([-4, -5, -6, 7])\n  true\n  */\nconst belowZeor5 = operationArray => {\n  let balance = 0;\n  for (let i = 0; i < operationArray.length; i++) {\n    balance += operationArray[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeor5([-4, -5, -6, 7])\n  false\n  >>> belowZeor5([-4, -5, -6, 7])\n  true\n  */\nconst belowZeor6 = operationArray => {\n  let balance = 0;\n  for (let i = 0; i < operationArray.length; i++) {\n    balance += operationArray[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeor6([-4, -5, -6, 7])\n  false\n  >>> belowZeor6([-4, -5, -6, 7])\n  true\n  */\nconst belowZeor7 = operationArray => {\n  let balance = 0;\n  for (let i = 0; i < operationArray.length; i++) {\n    balance += operationArray[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeor7([-4, -5, -6, 7])\n  false\n  >>> belowZeor7([-4, -5, -6, 7])\n  true\n  */\nconst belowZeor8 = operationArray => {\n  let balance = 0;\n  for (let i = 0; i < operationArray.length; i++) {\n    balance += operationArray[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeor8([-4, -5, -6, 7])\n  false\n  >>> belowZeor8([-4, -5, -6, 7])\n  true\n  */\nconst belowZeor9 = operationArray => {\n  let balance = 0;\n  for (let i = 0; i < operationArray.length; i++) {\n    balance += operationArray[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeor9([-4, -5, -6, 7])\n  false\n  >>> belowZeor9([-4, -5, -6, 7])\n  true\n  */\nconst belowZeor10 = operationArray => {\n  let balance = 0;\n  for (let i = 0; i < operationArray.length; i++) {\n    balance += operationArray[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeor10([-4, -5, -6, 7])\n  false\n  >>> belowZeor10([-4, -5, -6, 7])\n  true\n  */\nconst belowZeor11 = operationArray => {\n  let balance = 0;\n  for (let i = 0; i < operationArray.length; i++) {\n    balance += operationArray[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeor11([-4, -5, -6, 7])\n  false\n  >>> belowZeor11([-4, -5, -6, 7])\n  true\n  */\nconst belowZeor12 = operationArray => {\n  let balance = 0;\n  for (let i = 0; i < ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/30", "prompt": "/*Return only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "gc": "<|endoftext|>/*Return only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(x => x > 0).map(x => x);\n};\n\n/**\n * Remove all negative numbers from the list.\n * >>> removeNegative([-1, 2, -4, 5, 6])\n * [2, 4, 5, 6]\n * >>> removeNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst removeNegative = (l) => {\n  return l.filter(x => x < 0).map(x => x);\n};\n\n/**\n * Remove all numbers that are not in the list.\n * >>> removeNotIn([-1, 2, -4, 5, 6])\n * [2, 4, 5, 6]\n * >>> removeNotIn([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst removeNotIn = (l) => {\n  return l.filter(x =>!l.includes(x));\n};\n\n/**\n * Remove all numbers that are not in the list.\n * >>> removeNotIn([-1, 2, -4, 5, 6])\n * [2, 4, 5, 6]\n * >>> removeNotIn([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst removeNotInAll = (l) => {\n  return l.filter(x =>!l.includes(x));\n};\n\n/**\n * Remove all numbers that are not in the list.\n * >>> removeNotInAll([-1, 2, -4, 5, 6])\n * [2, 4, 5, 6]\n * >>> removeNotInAll([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst removeNotInAllNegative = (l) => {\n  return l.filter(x =>!l.includes(x));\n};\n\n/**\n * Remove all numbers that are not in the list.\n * >>> removeNotInAllNegative([-1, 2, -4, 5, 6])\n * [2, 4, 5, 6]\n * >>> removeNotInAllNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst removeNotInAllNegativeAll = (l) => {\n  return l.filter(x =>!l.includes(x));\n};\n\n/**\n * Remove all numbers that are not in the list.\n * >>> removeNotInAllNegativeAll([-1, 2, -4, 5, 6])\n * [2, 4, 5, 6]\n * >>> removeNotInAllNegativeAll([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst removeNotInAllNegativeAllNegative = (l) => {\n  return l.filter(x =>!l.includes(x));\n};\n\n/**\n * Remove all numbers that are not in the list.\n * >>> removeNotInAllNegativeAllNegative([-1, 2, -4, 5, 6])\n * [2, 4, 5, 6]\n * >>> removeNotInAllNegativeAllNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst removeNotInAllNegativeAllNegativeAll = (l) => {\n  return l.filter(x =>!l.includes(x));\n};\n\n/**\n * Remove all numbers that are not in the list.\n * >>> removeNotInAllNegativeAllNegativeAll([-1, 2, -4, 5, 6])\n * [2, 4, 5, 6]\n * >>> removeNotInAllNegativeAllNegativeAll([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst removeNotInAllNegativeAllNegativeAllNegative = (l) => {\n  return l.filter(x =>!l.includes(x));\n};\n\n/**\n * Remove all numbers that are not in the list.\n * >>> removeNotInAllNegativeAllNegativeAllNegative([-1, 2, -4, 5, 6])\n * [2, 4, 5, 6]\n * >>> removeNotInAllNegativeAllNegativeAllNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst removeNotInAllNegativeAllNegativeAllNegativeAll = (l) => {\n  return l.filter(x =>!l.includes(x));\n};\n\n/**\n * Remove all numbers that are not in the list.\n * >>> removeNotInAllNegativeAllNegativeAllNegativeAllNegative([-1, 2, -4, 5, 6])\n * [2, 4, 5, 6]\n * >>> removeNotInAllNegativeAllNegativeAllNegativeAll([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst removeNotInAllNegativeAllNegativeAllNegativeAllNegative = (l) => {\n  return l.filter(x =>!l.includes(x));\n};\n\n/**\n * Remove all numbers that are not in the list.\n * >>> removeNotInAllNegativeAllNegativeAllNegativeAllNegative([-1, 2, -4, 5, 6])\n * [2, 4, 5, 6]\n * >>> removeNotInAllNegativeAllNegativeAllNegativeAllNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst removeNotInAllNegativeAllNegativeAllNegativeAllNegativeAll = (l) => {\n  return l.filter(x =>!l.includes(x));\n};\n\n/**\n * Remove all numbers that are not in the list.\n * >>> removeNotInAllNegativeAllNegativeAllNegativeAllNegativeAll([-1, 2, -4, 5, 6])\n * [2, 4, 5, 6]\n * >>> removeNotInAllNegativeAllNegativeAllNegativeAllNegativeAll([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst removeNotInAllNegativeAllNegativeAllNegativeAllNegativeAllNegativeAll = (l) => {\n  return l.filter(x =>!l.includes(x));\n};\n\n/**\n * Remove all numbers that are not in the list.\n * >>> removeNotInAllNegativeAllNegativeAllNegativeAllNegativeAllNegative([-1, 2, -4, 5, 6])\n * [2, 4, 5, 6]\n * >>> removeNotInAllNegativeAllNegativeAllNegativeAllNegativeAllNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst removeNotInAllNegativeAllNegativeAllNegativeAllNegativeAllNegativeAllNegative = (l) => {\n  return l.filter(x =>!l.includes(x));\n};\n\n/**\n * Remove all numbers that are not in the list.\n * >>> removeNotInAllNegativeAllNegativeAllNegativeAllNegativeAllNegativeAll([-1, 2, -4, 5, 6])\n * [2, 4, 5, 6]\n * >>> removeNotInAllNegativeAllNegativeAllNegativeAllNegativeAllNegativeAll([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst removeNotInAllNegativeAllNegativeAllNegativeAllNegativeAllNegativeAllNegativeAll = (l) => {\n  return l.filter(x =>!l.includes(x));\n};\n\n/**\n * Remove all numbers that are not in the list.\n * >>> removeNotInAllNegativeAllNegativeAllNegativeAllNegativeAllNegativeAllNegativeAll([-1, 2, -4, 5, 6])\n * [2, 4, 5, 6]\n * >>> removeNotInAllNegativeAllNegativeAllNegativeAllNegativeAllNegativeAllNegativeAll([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n * [5, 3, 2, 3, 9, 123, 1]\n */\nconst removeNotInAllNegativeAllNegativeAllNegativeAllNegativeAllNegativeAllNegative", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/31", "prompt": "/*Return true if a given number is prime, and false otherwise.\n  >>> siPrime(6)\n  false\n  >>> siPrime(101)\n  true\n  >>> siPrime(11)\n  true\n  >>> siPrime(13441)\n  true\n  >>> siPrime(61)\n  true\n  >>> siPrime(4)\n  false\n  >>> siPrime(1)\n  false\n  */\nconst siPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "siPrime", "gc": "<|endoftext|>/*Return true if a given number is prime, and false otherwise.\n  >>> siPrime(6)\n  false\n  >>> siPrime(101)\n  true\n  >>> siPrime(11)\n  true\n  >>> siPrime(13441)\n  true\n  >>> siPrime(61)\n  true\n  >>> siPrime(4)\n  false\n  >>> siPrime(1)\n  false\n  */\nconst siPrime = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  return true;\n};\n\n/*\n  Return true if a given number is composite, and false otherwise.\n  >>> siComposite(6)\n  true\n  >>> siComposite(101)\n  false\n  >>> siComposite(11)\n  true\n  >>> siComposite(13441)\n  false\n  >>> siComposite(61)\n  false\n  >>> siComposite(4)\n  false\n  >>> siComposite(1)\n  false\n  */\nconst siComposite = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return true;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  return true;\n};\n\n/*\n  Return true if a given number is composite and prime, and false otherwise.\n  >>> siCompositeAndPrime(6)\n  true\n  >>> siCompositeAndPrime(101)\n  false\n  >>> siCompositeAndPrime(11)\n  true\n  >>> siCompositeAndPrime(13441)\n  false\n  >>> siCompositeAndPrime(61)\n  false\n  >>> siCompositeAndPrime(4)\n  false\n  >>> siCompositeAndPrime(1)\n  false\n  */\nconst siCompositeAndPrime = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (siPrime(n)) return true;\n  return false;\n};\n\n/*\n  Return true if a given number is composite and composite, and false otherwise.\n  >>> siCompositeAndComposite(6)\n  true\n  >>> siCompositeAndComposite(101)\n  false\n  >>> siCompositeAndComposite(11)\n  true\n  >>> siCompositeAndComposite(13441)\n  false\n  >>> siCompositeAndComposite(61)\n  false\n  >>> siCompositeAndComposite(4)\n  false\n  >>> siCompositeAndComposite(1)\n  false\n  */\nconst siCompositeAndComposite = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (siComposite(n)) return true;\n  return false;\n};\n\n/*\n  Return true if a given number is composite and prime, and false otherwise.\n  >>> siCompositeAndPrimeAndComposite(6)\n  true\n  >>> siCompositeAndPrimeAndComposite(101)\n  false\n  >>> siCompositeAndPrimeAndComposite(11)\n  true\n  >>> siCompositeAndPrimeAndComposite(13441)\n  false\n  >>> siCompositeAndPrimeAndComposite(61)\n  false\n  >>> siCompositeAndPrimeAndComposite(4)\n  false\n  >>> siCompositeAndPrimeAndComposite(1)\n  false\n  */\nconst siCompositeAndPrimeAndComposite = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (siCompositeAndPrime(n)) return true;\n  return false;\n};\n\n/*\n  Return true if a given number is composite and composite, and false otherwise.\n  >>> siCompositeAndCompositeAndPrime(6)\n  true\n  >>> siCompositeAndCompositeAndPrime(101)\n  false\n  >>> siCompositeAndCompositeAndPrime(11)\n  true\n  >>> siCompositeAndCompositeAndPrime(13441)\n  false\n  >>> siCompositeAndCompositeAndPrime(61)\n  false\n  >>> siCompositeAndCompositeAndPrime(4)\n  false\n  >>> siCompositeAndCompositeAndPrime(1)\n  false\n  */\nconst siCompositeAndCompositeAndPrime = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (siCompositeAndComposite(n)) return true;\n  return false;\n};\n\n/*\n  Return true if a given number is composite and composite, and false otherwise.\n  >>> siCompositeAndCompositeAndPrimeAndComposite(6)\n  true\n  >>> siCompositeAndCompositeAndPrimeAndComposite(101)\n  false\n  >>> siCompositeAndCompositeAndPrimeAndComposite(11)\n  true\n  >>> siCompositeAndCompositeAndPrimeAndComposite(13441)\n  false\n  >>> siCompositeAndCompositeAndPrimeAndComposite(61)\n  false\n  >>> siCompositeAndCompositeAndPrimeAndComposite(4)\n  false\n  >>> siCompositeAndCompositeAndPrimeAndComposite(1)\n  false\n  */\nconst siCompositeAndCompositeAndPrimeAndComposite = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (siCompositeAndCompositeAndPrime(n)) return true;\n  return false;\n};\n\n/*\n  Return true if a given number is composite and composite, and false otherwise.\n  >>> siCompositeAndCompositeAndPrimeAndCompositeAndPrime(6)\n  true\n  >>> siCompositeAndCompositeAndPrimeAndCompositeAndPrime(101)\n  false\n  >>> siCompositeAndCompositeAndPrimeAndCompositeAndPrime(11)\n  true\n  >>> siCompositeAndCompositeAndPrimeAndCompositeAndPrime(13441)\n  false\n  >>> siCompositeAndCompositeAndPrimeAndCompositeAndPrime(61)\n  false\n  >>> siCompositeAndCompositeAndPrimeAndCompositeAndPrime(4)\n  false\n  >>> siCompositeAndCompositeAndPrimeAndCompositeAndPrime(1)\n  false\n  */\nconst siCompositeAndCompositeAndPrimeAndCompositeAndPrime = (n) => {\n  if (n <= 1) return false;\n  if (n % 2 === 0) return false;\n  if (n % 3 === 0) return false;\n  if (n % 5 === 0) return false;\n  if (n % 7 === 0) return false;\n  if (siCompositeAndCompositeAndPrimeAndComposite(n)) return true;\n  return false;\n};\n\n/*\n  Return true if a given number is composite and composite, and false otherwise.\n  >>> siCompositeAndCompositeAndPrimeAndCompositeAndPrimeAndComposite(6)\n  true\n  >>> siCompositeAndCompositeAndPrimeAndCompositeAndPrimeAndComposite(101)\n  false\n  >>> siCompositeAndCompositeAndPrimeAndCompositeAndPrimeAndComposite(11)\n  true\n  >>> siCompositeAndCompositeAndPrimeAndCompositeAndPrimeAndComposite(", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "gc": "<|endoftext|>/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let zero = Infinity;\n  let index = 0;\n  for (let i = 0; i < xs.length; i++) {\n    if (xs[i] === 0) {\n      zero = index;\n      index = i;\n    }\n  }\n  return zero;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findOne find x such that poly(x) = 1.\n  findOne returns only zero point, even if there are many.\n  Moreover, findOne only takes list xs having even number of coefficients\n  and smallest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findOne([1, 2]), 2) # f(x) = 1 + 2x\n  1.0\n  */\nconst findOne = (xs) => {\n  let one = Infinity;\n  let index = 0;\n  for (let i = 0; i < xs.length; i++) {\n    if (xs[i] === 1) {\n      one = index;\n      index = i;\n    }\n  }\n  return one;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findTwo find x such that poly(x) = 2.\n  findTwo returns only zero point, even if there are many.\n  Moreover, findTwo only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findTwo([1, 2]), 2) # f(x) = 1 + 2x\n  2.0\n  */\nconst findTwo = (xs) => {\n  let two = Infinity;\n  let index = 0;\n  for (let i = 0; i < xs.length; i++) {\n    if (xs[i] === 2) {\n      two = index;\n      index = i;\n    }\n  }\n  return two;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findMany find x such that poly(x) = 3.\n  findMany returns only zero point, even if there are many.\n  Moreover, findMany only takes list xs having even number of coefficients\n  and smallest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findMany([1, 2]), 2) # f(x) = 1 + 2x\n  3.0\n  */\nconst findMany = (xs) => {\n  let many = Infinity;\n  let index = 0;\n  for (let i = 0; i < xs.length; i++) {\n    if (xs[i] === 3) {\n      many = index;\n      index = i;\n    }\n  }\n  return many;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findNearest find x such that poly(x) = 4.\n  findNearest returns only zero point, even if there are many.\n  Moreover, findNearest only takes list xs having even number of coefficients\n  and smallest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findNearest([1, 2]), 2) # f(x) = 1 + 2x\n  4.0\n  */\nconst findNearest = (xs) => {\n  let nearest = Infinity;\n  let index = 0;\n  for (let i = 0; i < xs.length; i++) {\n    if (xs[i] === 4) {\n      nearest = index;\n      index = i;\n    }\n  }\n  return nearest;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findNearestNearest find x such that poly(x) = 5.\n  findNearestNearest returns only zero point, even if there are many.\n  Moreover, findNearestNearest only takes list xs having even number of coefficients\n  and smallest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findNearestNearest([1, 2]), 2) # f(x) = 1 + 2x\n  5.0\n  */\nconst findNearestNearest = (xs) => {\n  let nearestNearest = Infinity;\n  let index = 0;\n  for (let i = 0; i < xs.length; i++) {\n    if (xs[i] === 5) {\n      nearestNearest = index;\n      index = i;\n    }\n  }\n  return nearestNearest;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findNearestNearestNearest find x such that poly(x) = 6.\n  findNearestNearestNearest returns only zero point, even if there are many.\n  Moreover, findNearestNearestNearest only takes list xs having even number of coefficients\n  and smallest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findNearestNearestNearest([1, 2]), 2) # f(x) = 1 + 2x\n  6.0\n  */\nconst findNearestNearestNearest = (xs) => {\n  let nearestNearestNearest = Infinity;\n  let index = 0;\n  for (let i = 0; i < xs.length; i++) {\n    if (xs[i] === 6) {\n      nearestNearestNearest = index;\n      index = i;\n    }\n  }\n  return nearestNearestNearest;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findNearestNearestNearestNearest find x such that poly(x) = 7.\n  findNearestNearestNearestNearest returns only zero point, even if there are many.\n  Moreover, findNearestNearestNearestNearest only takes list xs having even number of coefficients\n  and smallest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findNearestNearestNearestNearest([1, 2]), 2) # f(x) = 1 + 2x\n  7.0\n  */\nconst findNearestNearestNearestNearest = (xs) => {\n  let nearestNearestNearestNearest = Infinity;\n  let index = 0;\n  for (let i = 0; i < xs.length; i++) {\n    if (xs[i] === 7) {\n      nearestNearestNearestNearest = index;\n      index = i;\n    }\n  }\n  return nearestNearestNearestNearest;\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findNearestNearestNearestNearest find x such that poly(x) = 8.\n  findNearestNearestNearestNearest returns only zero point, even if there are many.\n  Moreover, findNearestNearestNearestNearest only takes list xs having even number of coefficients\n  and smallest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findNearestNearestNearestNearest([1, 2]), 2) # f(x) = 1 + 2x\n  8.0\n  */\nconst findNearestNearestNearestNearest = (", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  return l.sort((a, b) => a - b)\n}\n\n/*\n  Given a list l, return a new list l' such that l' is a permutation of the elements of l.\n  >>> permutation([1,2,3])\n  [1,3,2,2]\n  >>> permutation([5,6,3,4,8,9,2])\n  [5,6,4,3,2,8,9,1]\n  */\nconst permutation = (l) => {\n  return l.map((item, index) => [item, index])\n}\n\n/*\n  Given a list l, return a new list l' such that l' is a permutation of the elements of l and each element of l is replaced by its permutation of its elements.\n  >>> permutationAndReplace([1,2,3])\n  [1,3,2,2]\n  >>> permutationAndReplace([5,6,3,4,8,9,2])\n  [5,6,4,3,2,8,9,1]\n  */\nconst permutationAndReplace = (l) => {\n  return l.map((item, index) => [index, item])\n}\n\n/*\n  Given a list l, return a new list l' such that l' is a permutation of the elements of l and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element of l is replaced by its permutation of its elements and each element ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "gc": "<|endoftext|>/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let seen = new Set();\n  return l.filter((x) => seen.has(x));\n};\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (key, l) => {\n  let seen = new Set();\n  return l.filter((x) => seen.has(x) && x[key] === x);\n};\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWith = (key, l) => {\n  let seen = new Set();\n  return l.filter((x) => seen.has(x) && x[key] === x);\n};\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKey = (key, l) => {\n  let seen = new Set();\n  return l.filter((x) => seen.has(x) && x[key] === x);\n};\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeys = (keys, l) => {\n  let seen = new Set();\n  return l.filter((x) => seen.has(x) && keys.includes(x[key]));\n};\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysOr = (keys, l) => {\n  let seen = new Set();\n  return l.filter((x) => seen.has(x) || keys.includes(x[key]));\n};\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysAnd = (keys, l) => {\n  let seen = new Set();\n  return l.filter((x) => seen.has(x) && keys.includes(x[key]));\n};\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysAndOr = (keys, l) => {\n  let seen = new Set();\n  return l.filter((x) => seen.has(x) || keys.includes(x[key]));\n};\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysAndOrKeys = (keys, l) => {\n  let seen = new Set();\n  return l.filter((x) => seen.has(x) && keys.includes(x[key]));\n};\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysAndOrKeysOr = (keys, l) => {\n  let seen = new Set();\n  return l.filter((x) => seen.has(x) || keys.includes(x[key]));\n};\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysAndOrKeysAnd = (keys, l) => {\n  let seen = new Set();\n  return l.filter((x) => seen.has(x) && keys.includes(x[key]));\n};\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysAndOrKeysAndOr = (keys, l) => {\n  let seen = new Set();\n  return l.filter((x) => seen.has(x) || keys.includes(x[key]));\n};\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysAndOrKeysAndOrKeys = (keys, l) => {\n  let seen = new Set();\n  return l.filter((x) => seen.has(x) || keys.includes(x[key]));\n};\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysAndOrKeysAndOrKeysAnd = (keys, l) => {\n  let seen = new Set();\n  return l.filter((x) => seen.has(x) || keys.includes(x[key]));\n};\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysAndOrKeysAndOrKeysAndOr = (keys, l) => {\n  let seen = new Set();\n  return l.filter((x) => seen.has(x) || keys.includes(x[key]));\n};\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysAndOrKeysAndOrKeysAndOrKeys = (keys, l) => {\n  let seen = new Set();\n  return l.filter((x) => seen.has(x) || keys.includes(x[key]));\n};\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysAndOrKeysAndOrKeysAndOrKeysAnd = (keys, l) => {\n  let seen = new Set();\n  return l.filter((x) => seen.has(x) || keys.includes(x[key]));\n};\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysAndOrKeysAndOrKeysAndOrKeysAndOr = (keys, l) => {\n  let seen = new Set();\n  return l.filter((x) => seen.has(x) || keys.includes(x[key]));\n};\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysAndOrKeysAndOrKeysAndOrKeysAndOr = (keys, l) => {\n  let seen = new Set();\n  return l.filter((x) => seen.has(x) || keys.includes(x[key]));\n};\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysAndOrKeysAndOrKeysAndOrKeysAndOrKeysAnd = (keys, l) => {\n  let seen = new Set();\n  return l.filter((x) => seen.has(x) || keys.includes(x[key]));\n};\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueWithKeysAndOrKeysAndOrKeysAndOrKeysAndOrKeysAndOr = (keys, l) => {\n  let seen = new Set();\n  return l.filter((x) => seen.has(x) || keys.includes(x[key]));\n};\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "gc": "<|endoftext|>/*Return maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  return l.length > 0? l.reduce((a, b) => a > b? a : b) : undefined;\n};\n\n/*Return minimum element in the list.\n  >>> minElement([1, 2, 3])\n  1\n  >>> minElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -5\n  */\nconst minElement = (l) => {\n  return l.length > 0? l.reduce((a, b) => a < b? a : b) : undefined;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 1)\n  3\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 1)\n  12\n  */\nconst elementAtIndex = (l, i) => {\n  return l.length > i? l[i] : undefined;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 2)\n  3\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 2)\n  12\n  */\nconst elementAt = (l, i) => {\n  return l.length > i? l[i] : undefined;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 3)\n  undefined\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 3)\n  12\n  */\nconst elementAtOrUndefined = (l, i) => {\n  return l.length > i? l[i] : undefined;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 4)\n  undefined\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 4)\n  12\n  */\nconst elementAtOrUndefinedOrUndefined = (l, i) => {\n  return l.length > i? l[i] : undefined;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 5)\n  undefined\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 5)\n  12\n  */\nconst elementAtOrUndefinedOrUndefinedOrUndefined = (l, i) => {\n  return l.length > i? l[i] : undefined;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 6)\n  undefined\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 6)\n  12\n  */\nconst elementAtOrUndefinedOrUndefinedOrUndefinedOrUndefined = (l, i) => {\n  return l.length > i? l[i] : undefined;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 7)\n  undefined\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 7)\n  12\n  */\nconst elementAtOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefined = (l, i) => {\n  return l.length > i? l[i] : undefined;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 8)\n  undefined\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 8)\n  12\n  */\nconst elementAtOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefined = (l, i) => {\n  return l.length > i? l[i] : undefined;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 9)\n  undefined\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 9)\n  12\n  */\nconst elementAtOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefined = (l, i) => {\n  return l.length > i? l[i] : undefined;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 10)\n  undefined\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 10)\n  12\n  */\nconst elementAtOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefined = (l, i) => {\n  return l.length > i? l[i] : undefined;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 11)\n  undefined\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 11)\n  12\n  */\nconst elementAtOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefined = (l, i) => {\n  return l.length > i? l[i] : undefined;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 12)\n  undefined\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 12)\n  12\n  */\nconst elementAtOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefined = (l, i) => {\n  return l.length > i? l[i] : undefined;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 13)\n  undefined\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 13)\n  12\n  */\nconst elementAtOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefined = (l, i) => {\n  return l.length > i? l[i] : undefined;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 14)\n  undefined\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 14)\n  12\n  */\nconst elementAtOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefined = (l, i) => {\n  return l.length > i? l[i] : undefined;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 15)\n  undefined\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 15)\n  12\n  */\nconst elementAtOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefined = (l, i) => {\n  return l.length > i? l[i] : undefined;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 16)\n  undefined\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 16)\n  12\n  */\nconst elementAtOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefinedOrUndefined = (l, i) => {\n  return l.length > i? l[i] : undefined;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 17)\n  undefined\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 17)", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/36", "prompt": "/*Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "gc": "<|endoftext|>/*Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 1 appears in integers less than n which are divisible by 2 or 5.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz2 = (number) => {\n  let count = 0;\n  let digit = number % 2;\n  if (digit === 1) {\n    count++;\n  }\n  if (digit === 5) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 2 appears in integers less than n which are divisible by 2 or 5.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz3 = (number) => {\n  let count = 0;\n  let digit = number % 5;\n  if (digit === 2) {\n    count++;\n  }\n  if (digit === 5) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 3 appears in integers less than n which are divisible by 2 or 5.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz4 = (number) => {\n  let count = 0;\n  let digit = number % 2;\n  if (digit === 3) {\n    count++;\n  }\n  if (digit === 5) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 4 appears in integers less than n which are divisible by 2 or 5.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz5 = (number) => {\n  let count = 0;\n  let digit = number % 5;\n  if (digit === 4) {\n    count++;\n  }\n  if (digit === 5) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 5 appears in integers less than n which are divisible by 2 or 5.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz6 = (number) => {\n  let count = 0;\n  let digit = number % 2;\n  if (digit === 5) {\n    count++;\n  }\n  if (digit === 7) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 6 appears in integers less than n which are divisible by 2 or 5.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz7 = (number) => {\n  let count = 0;\n  let digit = number % 5;\n  if (digit === 6) {\n    count++;\n  }\n  if (digit === 7) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 7 appears in integers less than n which are divisible by 2 or 5.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz8 = (number) => {\n  let count = 0;\n  let digit = number % 2;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 8 appears in integers less than n which are divisible by 2 or 5.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz9 = (number) => {\n  let count = 0;\n  let digit = number % 5;\n  if (digit === 8) {\n    count++;\n  }\n  if (digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 9 appears in integers less than n which are divisible by 2 or 5.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz10 = (number) => {\n  let count = 0;\n  let digit = number % 2;\n  if (digit === 9) {\n    count++;\n  }\n  if (digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 10 appears in integers less than n which are divisible by 2 or 5.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz11 = (number) => {\n  let count = 0;\n  let digit = number % 5;\n  if (digit === 10) {\n    count++;\n  }\n  if (digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 11 appears in integers less than n which are divisible by 2 or 5.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz12 = (number) => {\n  let count = 0;\n  let digit = number % 2;\n  if (digit === 11) {\n    count++;\n  }\n  if (digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 12 appears in integers less than n which are divisible by 2 or 5.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz13 = (number) => {\n  let count = 0;\n  let digit = number % 5;\n  if (digit === 12) {\n    count++;\n  }\n  if (digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Return the number of times the digit 13 appears in integers less than n which are divisible by 2 or 5.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz14 = (number) => {\n  let count = 0;\n  let digit = number % 2;\n  if (digit === 13) {\n    count++;\n  }\n  if (digit === 15) {\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sotrEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sotrEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sotrEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sotrEven", "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sotrEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sotrEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sotrEven = (l) => {\n  const l2 = l.slice();\n  l2.sort((a, b) => a % 2 === b % 2);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sotrOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sotrOdd([5, 6, 3, 4])\n  [4, 3, 6, 5]\n  */\nconst sotrOdd = (l) => {\n  const l2 = l.slice();\n  l2.sort((a, b) => a % 2 === b % 2);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sotrEvenOdd([1, 2, 3])\n  [1, 2, 3, 5]\n  >>> sotrEvenOdd([5, 6, 3, 4])\n  [5, 3, 4, 6]\n  */\nconst sotrEvenOdd = (l) => {\n  const l2 = l.slice();\n  l2.sort((a, b) => a % 2 === b % 2);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sotrOddOdd([1, 2, 3])\n  [3, 2, 5, 1]\n  >>> sotrOddOdd([5, 6, 3, 4])\n  [4, 3, 6, 5, 2]\n  */\nconst sotrOddOdd = (l) => {\n  const l2 = l.slice();\n  l2.sort((a, b) => a % 2 === b % 2);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sotrEvenOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sotrEvenOddOdd([5, 6, 3, 4])\n  [5, 3, 4, 6, 5]\n  */\nconst sotrEvenOddOdd = (l) => {\n  const l2 = l.slice();\n  l2.sort((a, b) => a % 2 === b % 2);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sotrOddEvenOdd([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sotrOddEvenOdd([5, 6, 3, 4])\n  [5, 3, 4, 6, 5, 2]\n  */\nconst sotrOddEvenOdd = (l) => {\n  const l2 = l.slice();\n  l2.sort((a, b) => a % 2 === b % 2);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sotrEvenOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sotrEvenOddOddOdd([5, 6, 3, 4])\n  [5, 3, 4, 6, 5, 2]\n  */\nconst sotrEvenOddEvenOdd = (l) => {\n  const l2 = l.slice();\n  l2.sort((a, b) => a % 2 === b % 2);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sotrOddEvenOddEvenOdd([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sotrOddEvenOddEvenOdd([5, 6, 3, 4])\n  [5, 3, 4, 6, 5, 2]\n  */\nconst sotrOddEvenOddEvenOdd = (l) => {\n  const l2 = l.slice();\n  l2.sort((a, b) => a % 2 === b % 2);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sotrEvenOddOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sotrEvenOddOddOddOdd([5, 6, 3, 4])\n  [5, 3, 4, 6, 5, 2]\n  */\nconst sotrEvenOddOddEvenOdd = (l) => {\n  const l2 = l.slice();\n  l2.sort((a, b) => a % 2 === b % 2);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sotrOddEvenOddOddEvenOdd([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sotrOddEvenOddOddEvenOdd([5, 6, 3, 4])\n  [5, 3, 4, 6, 5, 2]\n  */\nconst sotrOddEvenOddOddEvenOdd = (l) => {\n  const l2 = l.slice();\n  l2.sort((a, b) => a % 2 === b % 2);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sotrEvenOddOddOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sotrEvenOddOddOddOddOdd([5, 6, 3, 4])\n  [5, 3, 4, 6, 5, 2]\n  */\nconst sotrEvenOddOddOddEvenOdd = (l) => {\n  const l2 = l.slice();\n  l2.sort((a, b) => a % 2 === b % 2);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sotrOddEvenOddOddOddEvenOdd([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sotr", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "gc": "<|endoftext|>/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupGroupGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupGroupGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupGroupGroupGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupGroupGroupGroupGroupGroup = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "gc": "<|endoftext|>/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  if (n <= 1) return 1;\n  if (n <= 2) return 2;\n  if (n <= 3) return 3;\n  if (n <= 5) return 5;\n  if (n <= 7) return 7;\n  if (n <= 14) return 14;\n  if (n <= 21) return 21;\n  if (n <= 28) return 28;\n  if (n <= 31) return 31;\n  if (n <= 61) return 61;\n  if (n <= 79) return 79;\n  if (n <= 141) return 141;\n  if (n <= 142) return 142;\n  if (n <= 143) return 143;\n  if (n <= 145) return 145;\n  if (n <= 147) return 147;\n  if (n <= 148) return 148;\n  if (n <= 149) return 149;\n  if (n <= 151) return 151;\n  if (n <= 152) return 152;\n  if (n <= 153) return 153;\n  if (n <= 154) return 154;\n  if (n <= 155) return 155;\n  if (n <= 157) return 157;\n  if (n <= 159) return 159;\n  if (n <= 161) return 161;\n  if (n <= 162) return 162;\n  if (n <= 163) return 163;\n  if (n <= 165) return 165;\n  if (n <= 167) return 167;\n  if (n <= 169) return 169;\n  if (n <= 171) return 171;\n  if (n <= 172) return 172;\n  if (n <= 173) return 173;\n  if (n <= 175) return 175;\n  if (n <= 177) return 177;\n  if (n <= 179) return 179;\n  if (n <= 181) return 181;\n  if (n <= 182) return 182;\n  if (n <= 183) return 183;\n  if (n <= 185) return 185;\n  if (n <= 187) return 187;\n  if (n <= 189) return 189;\n  if (n <= 191) return 191;\n  if (n <= 193) return 193;\n  if (n <= 195) return 195;\n  if (n <= 197) return 197;\n  if (n <= 199) return 199;\n  if (n <= 201) return 201;\n  if (n <= 203) return 203;\n  if (n <= 205) return 205;\n  if (n <= 207) return 207;\n  if (n <= 209) return 209;\n  if (n <= 211) return 211;\n  if (n <= 213) return 213;\n  if (n <= 215) return 215;\n  if (n <= 217) return 217;\n  if (n <= 219) return 219;\n  if (n <= 221) return 221;\n  if (n <= 223) return 223;\n  if (n <= 225) return 225;\n  if (n <= 227) return 227;\n  if (n <= 229) return 229;\n  if (n <= 231) return 231;\n  if (n <= 233) return 233;\n  if (n <= 235) return 235;\n  if (n <= 239) return 239;\n  if (n <= 241) return 241;\n  if (n <= 243) return 243;\n  if (n <= 245) return 245;\n  if (n <= 247) return 247;\n  if (n <= 249) return 249;\n  if (n <= 251) return 251;\n  if (n <= 253) return 253;\n  if (n <= 255) return 255;\n  if (n <= 257) return 257;\n  if (n <= 259) return 259;\n  if (n <= 261) return 261;\n  if (n <= 263) return 263;\n  if (n <= 265) return 26;\n  if (n <= 267) return 267;\n  if (n <= 269) return 269;\n  if (n <= 271) return 271;\n  if (n <= 273) return 273;\n  if (n <= 275) return 275;\n  if (n <= 277) return 277;\n  if (n <= 279) return 279;\n  if (n <= 281) return 281;\n  if (n <= 283) return 283;\n  if (n <= 285) return 285;\n  if (n <= 287) return 287;\n  if (n <= 289) return 289;\n  if (n <= 291) return 291;\n  if (n <= 293) return 293;\n  if (n <= 295) return 295;\n  if (n <= 297) return 297;\n  if (n <= 299) return 299;\n  if (n <= 301) return 301;\n  if (n <= 303) return 303;\n  if (n <= 309) return 309;\n  if (n <= 311) return 311;\n  if (n <= 313) return 313;\n  if (n <= 315) return 315;\n  if (n <= 319) return 319;\n  if (n <= 321) return 321;\n  if (n <= 323) return 323;\n  if (n <= 325) return 325;\n  if (n <= 327) return 327;\n  if (n <= 329) return 329;\n  if (n <= 331) return 331;\n  if (n <= 333) return 333;\n  if (n <= 335) return 335;\n  if (n <= 337) return 337;\n  if (n <= 339) return 339;\n  if (n <= 341) return 341;\n  if (n <= 343) return 343;\n  if (n <= 345) return 345;\n  if (n <= 347) return 347;\n  if (n <= 349) return 349;\n  if (n <= 351) return 351;\n  if (n <= 353) return 353;\n  if (n <= 355) return 355;\n  if (n <= 357) return 357;\n  if (n <= 359) return 359;\n  if (n <= 361) return 361;\n  if (n <= 363) return 363;\n  if (n <= 365) return 365;\n  if (n <= 367) return 367;\n  if (n <= 369) return 369;\n  if (n <= 371) return 371;\n  if (n <= 373) return 373;\n  if (n <= 375) return 375;\n  if (n <= 377) return 377;\n  if (n <= 379) return 379;\n  if (n <= 381) return 381;\n  if (n <= 383) return 383;\n  if (n <= 385) return 385;\n  if (n <= 387) return 387;\n  if (n <= 389) return 389;\n  if (n <= 391) return 391;\n  if (n <= 393) return 393;\n  if (n <= 395) return 395;\n  if (n <= 397) return 397;\n  if (n <= 399) return 399;\n  if (n <= 401) return 401;\n  if (n <= 403) return 403;\n  if (n <= 405) return 405;\n  if (n <= 407) return 407;\n  if (n <= 409) return 409;\n  if (n <= 411) return 411;\n  if (n <= 413) return 413;\n  if (n <= 415) return 415;\n  if (n <= 419) return 419;\n  if (n <= 421) return 421;\n  if (n <= 423) return 423;\n  if (n <= 425) return 425;\n  if (n <= 427) return 427;\n  if (n <= 429) return 429;\n  if (n <= 431) return 431;\n  if (n <= 433) return 433;\n  if (n <= 435) return 435;\n  if (n <= 437) return 437;\n  if (n <= 439) return 439;\n  if (n <= 441) return 441;\n  if (n <= 443) return 443;\n  if (n <= 445) return 445;\n  if (n <= 447) return 447;\n  if (n <= 449) return 449;\n  if (n <= 451) return 451;\n  if (n <= 453) return 453;\n  if (n <= 455) return 455;\n  if (n <= 457) return 457;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoltueDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoltueDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoltueDeviation", "gc": "<|endoftext|>/* For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoltueDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoltueDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map((val) => Math.abs(val - mean));\n};\n\n/**\n  Given a list of input numbers, calculate Mean Squared Deviation\n  around the mean of this dataset.\n  Mean Squared Deviation is the average of squared differences between each\n  element and a centerpoint (mean in this case):\n  MSD = average | x - x_mean |^2\n  >>> meanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanSquaredDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map((val) => Math.pow(val - mean, 2));\n};\n\n/**\n  Given a list of input numbers, calculate Root Mean Squared Deviation\n  around the mean of this dataset.\n  Root Mean Squared Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  RMSE = sqrt(average | x - x_mean |)\n  >>> rootMeanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst rootMeanSquaredDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map((val) => Math.sqrt(val - mean));\n};\n\n/**\n  Given a list of input numbers, calculate Standard Deviation around the mean of this dataset.\n  Standard Deviation is the square root of the mean squared difference between each\n  element and a centerpoint (mean in this case):\n  SD = sqrt(average | x - x_mean |)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map((val) => Math.sqrt(val - mean));\n};\n\n/**\n  Given a list of input numbers, calculate Variance (standard deviation) around the mean of this dataset.\n  Variance is the square root of the mean squared difference between each\n  element and a centerpoint (mean in this case):\n  V = sqrt(average | x - x_mean |)\n  >>> variance([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst variance = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map((val) => Math.pow(val - mean, 2));\n};\n\n/**\n  Given a list of input numbers, calculate Standard Deviation around the mean of this dataset.\n  Standard Deviation is the square root of the mean squared difference between each\n  element and a centerpoint (mean in this case):\n  SD = sqrt(average | x - x_mean |)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map((val) => Math.sqrt(val - mean));\n};\n\n/**\n  Given a list of input numbers, calculate Variance (standard deviation) around the mean of this dataset.\n  Standard Deviation is the square root of the mean squared difference between each\n  element and a centerpoint (mean in this case):\n  V = sqrt(average | x - x_mean |)\n  >>> variance([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst variance = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map((val) => Math.pow(val - mean, 2));\n};\n\n/**\n  Given a list of input numbers, calculate Standard Deviation around the mean of this dataset.\n  Standard Deviation is the square root of the mean squared difference between each\n  element and a centerpoint (mean in this case):\n  SD = sqrt(average | x - x_mean |)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map((val) => Math.sqrt(val - mean));\n};\n\n/**\n  Given a list of input numbers, calculate Standard Deviation around the mean of this dataset.\n  Standard Deviation is the square root of the mean squared difference between each\n  element and a centerpoint (mean in this case):\n  SD = sqrt(average | x - x_mean |)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map((val) => Math.sqrt(val - mean));\n};\n\n/**\n  Given a list of input numbers, calculate Standard Deviation around the mean of this dataset.\n  Standard Deviation is the square root of the mean squared difference between each\n  element and a centerpoint (mean in this case):\n  SD = sqrt(average | x - x_mean |)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map((val) => Math.sqrt(val - mean));\n};\n\n/**\n  Given a list of input numbers, calculate Standard Deviation around the mean of this dataset.\n  Standard Deviation is the square root of the mean squared difference between each\n  element and a centerpoint (mean in this case):\n  SD = sqrt(average | x - x_mean |)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map((val) => Math.sqrt(val - mean));\n};\n\n/**\n  Given a list of input numbers, calculate Standard Deviation around the mean of this dataset.\n  Standard Deviation is the square root of the mean squared difference between each\n  element and a centerpoint (mean in this case):\n  SD = sqrt(average | x - x_mean |)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map((val) => Math.sqrt(val - mean));\n};\n\n/**\n  Given a list of input numbers, calculate Standard Deviation around the mean of this dataset.\n  Standard Deviation is the square root of the mean squared difference between each\n  element and a centerpoint (mean in this case):\n  SD = sqrt(average | x - x_mean |)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, val) => acc + val, 0) / numbers.length;\n  return numbers.map((val) => Math.sqrt(val - mean));\n};\n\n/**\n  Given a list of input numbers, calculate Standard ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "gc": "<|endoftext|>/*\n  triplesSumToZero takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n  A function that takes an array of integers and returns true if there\n  are three distinct elements in the array that sum to zero, and false\n  otherwise.\n\n  >>> triplesSumToZero([1, 1, 0, 1])\n  true\n  >>> triplesSumToZero([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero([1, 1, 0, 1])\n  false\n  */\nconst triplesSumToZero2 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n  A function that takes an array of integers and returns true if there\n  are three distinct elements in the array that sum to zero, and false\n  otherwise.\n\n  >>> triplesSumToZero2([1, 1, 0, 1])\n  true\n  >>> triplesSumToZero2([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero2([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero2([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero2([1, 1, 0, 1])\n  false\n  */\nconst triplesSumToZero3 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n  A function that takes an array of integers and returns true if there\n  are three distinct elements in the array that sum to zero, and false\n  otherwise.\n\n  >>> triplesSumToZero3([1, 1, 0, 1])\n  true\n  >>> triplesSumToZero3([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero3([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero3([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero3([1, 1, 0, 1])\n  false\n  */\nconst triplesSumToZero4 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n  A function that takes an array of integers and returns true if there\n  are three distinct elements in the array that sum to zero, and false\n  otherwise.\n\n  >>> triplesSumToZero4([1, 1, 0, 1])\n  true\n  >>> triplesSumToZero4([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero4([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero4([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero4([1, 1, 0, 1])\n  false\n  */\nconst triplesSumToZero5 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n  A function that takes an array of integers and returns true if there\n  are three distinct elements in the array that sum to zero, and false\n  otherwise.\n\n  >>> triplesSumToZero5([1, 1, 0, 1])\n  true\n  >>> triplesSumToZero5([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero5([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero5([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero5([1, 1, 0, 1])\n  false\n  */\nconst triplesSumToZero6 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n  A function that takes an array of integers and returns true if there\n  are three distinct elements in the array that sum to zero, and false\n  otherwise.\n\n  >>> triplesSumToZero6([1, 1, 0, 1])\n  true\n  >>> triplesSumToZero6([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero6([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero6([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero6([1, 1, 0, 1])\n  false\n  */\nconst triplesSumToZero7 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n  A function that takes an array of integers and returns true if there\n  are three distinct elements in the array that sum to zero, and false\n  otherwise.\n\n  >>> triplesSumToZero7([1, 1, 0, 1])\n  true\n  >>> triplesSumToZero7([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero7([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero7([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero7([1, 1, 0, 1])\n  false\n  */\nconst triplesSumToZero8 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n  A function that takes an array of integers and returns true if there\n  are three distinct elements in the array that sum to zero, and false\n  otherwise.\n\n  >>> triplesSumToZero8([1, 1, 0, 1])\n  true\n  >>> triplesSumToZero8([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero8([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero8([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero8([1, 1, 0, 1])\n  false\n  */\nconst triplesSumToZero9 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n  A function that takes an array of integers and returns true if there\n  are three distinct elements in the array that sum to zero, and false\n  otherwise.\n\n  >>> triplesSumToZero9([1, 1, 0, 1])\n  true\n  >>> triplesSumToZero9([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero9([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero9([1, 1, 0, 1])\n  false\n  >>> triplesSumToZero9([1, 1, 0, 1])\n  false\n  */\nconst triplesSumToZero10 = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst acrRacelColision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "acrRacelColision", "gc": "<|endoftext|>/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst acrRacelColision = (n) => {\n  let collisions = 0;\n  for (let i = 0; i < n; i++) {\n    if (\n      Math.abs(this.cars[i].x - this.cars[(i + 1) % n].x) > Math.abs(this.cars[i].y - this.cars[(i + 1) % n].y)\n    ) {\n      collisions++;\n    }\n  }\n  return collisions;\n};\n\n/*\n  Given a road network, return a list of all roads reachable from any given road.\n  Each road is represented as a list of cars.\n  */\nconst getRoadsFromRoadNetwork = (roadNetwork) => {\n  let roads = [];\n  for (let i = 0; i < roadNetwork.length; i++) {\n    let road = roadNetwork[i];\n    for (let j = 0; j < road.length; j++) {\n      let car = road[j];\n      if (car.roadNetworkId === roadNetwork.id) {\n        roads.push(car);\n      }\n    }\n  }\n  return roads;\n};\n\n/*\n  Given a road network, return a list of all roads reachable from any given road.\n  Each road is represented as a list of cars.\n  */\nconst getRoadsFromRoadNetworkAndRoad = (roadNetwork, road) => {\n  let roads = [];\n  for (let i = 0; i < roadNetwork.length; i++) {\n    let road = roadNetwork[i];\n    for (let j = 0; j < road.length; j++) {\n      let car = road[j];\n      if (car.roadNetworkId === roadNetwork.id) {\n        roads.push(car);\n      }\n    }\n  }\n  return roads;\n};\n\n/*\n  Given a road network, return a list of all roads reachable from any given road.\n  Each road is represented as a list of cars.\n  */\nconst getRoadsFromRoadNetworkAndRoadAndRoad = (roadNetwork, road, road2) => {\n  let roads = [];\n  for (let i = 0; i < roadNetwork.length; i++) {\n    let road = roadNetwork[i];\n    for (let j = 0; j < road.length; j++) {\n      let car = road[j];\n      if (car.roadNetworkId === roadNetwork.id) {\n        roads.push(car);\n      }\n    }\n  }\n  return roads;\n};\n\n/*\n  Given a road network, return a list of all roads reachable from any given road.\n  Each road is represented as a list of cars.\n  */\nconst getRoadsFromRoadNetworkAndRoadAndRoad2 = (roadNetwork, road, road2) => {\n  let roads = [];\n  for (let i = 0; i < roadNetwork.length; i++) {\n    let road = roadNetwork[i];\n    for (let j = 0; j < road.length; j++) {\n      let car = road[j];\n      if (car.roadNetworkId === roadNetwork.id) {\n        roads.push(car);\n      }\n    }\n  }\n  return roads;\n};\n\n/*\n  Given a road network, return a list of all roads reachable from any given road.\n  Each road is represented as a list of cars.\n  */\nconst getRoadsFromRoadNetworkAndRoadAndRoad3 = (roadNetwork, road, road2) => {\n  let roads = [];\n  for (let i = 0; i < roadNetwork.length; i++) {\n    let road = roadNetwork[i];\n    for (let j = 0; j < road.length; j++) {\n      let car = road[j];\n      if (car.roadNetworkId === roadNetwork.id) {\n        roads.push(car);\n      }\n    }\n  }\n  return roads;\n};\n\n/*\n  Given a road network, return a list of all roads reachable from any given road.\n  Each road is represented as a list of cars.\n  */\nconst getRoadsFromRoadNetworkAndRoadAndRoad4 = (roadNetwork, road, road2) => {\n  let roads = [];\n  for (let i = 0; i < roadNetwork.length; i++) {\n    let road = roadNetwork[i];\n    for (let j = 0; j < road.length; j++) {\n      let car = road[j];\n      if (car.roadNetworkId === roadNetwork.id) {\n        roads.push(car);\n      }\n    }\n  }\n  return roads;\n};\n\n/*\n  Given a road network, return a list of all roads reachable from any given road.\n  Each road is represented as a list of cars.\n  */\nconst getRoadsFromRoadNetworkAndRoadAndRoad5 = (roadNetwork, road, road2) => {\n  let roads = [];\n  for (let i = 0; i < roadNetwork.length; i++) {\n    let road = roadNetwork[i];\n    for (let j = 0; j < road.length; j++) {\n      let car = road[j];\n      if (car.roadNetworkId === roadNetwork.id) {\n        roads.push(car);\n      }\n    }\n  }\n  return roads;\n};\n\n/*\n  Given a road network, return a list of all roads reachable from any given road.\n  Each road is represented as a list of cars.\n  */\nconst getRoadsFromRoadNetworkAndRoadAndRoad6 = (roadNetwork, road, road2) => {\n  let roads = [];\n  for (let i = 0; i < roadNetwork.length; i++) {\n    let road = roadNetwork[i];\n    for (let j = 0; j < road.length; j++) {\n      let car = road[j];\n      if (car.roadNetworkId === roadNetwork.id) {\n        roads.push(car);\n      }\n    }\n  }\n  return roads;\n};\n\n/*\n  Given a road network, return a list of all roads reachable from any given road.\n  Each road is represented as a list of cars.\n  */\nconst getRoadsFromRoadNetworkAndRoadAndRoad7 = (roadNetwork, road, road2) => {\n  let roads = [];\n  for (let i = 0; i < roadNetwork.length; i++) {\n    let road = roadNetwork[i];\n    for (let j = 0; j < road.length; j++) {\n      let car = road[j];\n      if (car.roadNetworkId === roadNetwork.id) {\n        roads.push(car);\n      }\n    }\n  }\n  return roads;\n};\n\n/*\n  Given a road network, return a list of all roads reachable from any given road.\n  Each road is represented as a list of cars.\n  */\nconst getRoadsFromRoadNetworkAndRoadAndRoad8 = (roadNetwork, road, road2) => {\n  let roads = [];\n  for (let i = 0; i < roadNetwork.length; i++) {\n    let road = roadNetwork[i];\n    for (let j = 0; j < road.length; j++) {\n      let car = road[j];\n      if (car.roadNetworkId === roadNetwork.id) {\n        roads.push(car);\n      }\n    }\n  }\n  return roads;\n};\n\n/*\n  Given a road network, return a list of all roads reachable from any given road.\n  Each road is represented as a list of cars.\n  */\nconst getRoadsFromRoadNetworkAndRoadAndRoad9 = (roadNetwork, road, road2) => {\n  let roads = [];\n  for (let i = 0; i < roadNetwork.length; i++) {\n    let road = roadNetwork[i];\n    for (let j = 0; j < road.length; j++) {\n      let car = road[j];\n      if (car.roadNetworkId === roadNetwork.id", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "gc": "<|endoftext|>/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let res = []\n  let i = 0\n  while (i++ < l.length) {\n    res.push(l[i] + 1)\n  }\n  return res\n}\n\n/*Return list with elements decremented by 1.\n  >>> decrList([1, 2, 3])\n  [2, 3, 4]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decrList = (l) => {\n  let res = []\n  let i = 0\n  while (i++ < l.length) {\n    res.push(l[i] - 1)\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i++ < l.length) {\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrDecrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrDecrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i++ < l.length) {\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrDecrDecrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrDecrDecrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i++ < l.length) {\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrDecrDecrDecrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrDecrDecrDecrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i++ < l.length) {\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrDecrDecrDecrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrDecrDecrDecrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i++ < l.length) {\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrDecrDecrDecrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrDecrDecrDecrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i++ < l.length) {\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrDecrDecrDecrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrDecrDecrDecrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i++ < l.length) {\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrDecrDecrDecrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrDecrDecrDecrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i++ < l.length) {\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n    res.push(l[i] + 1)\n    res.push(l[i] - 1)\n  }\n  return res\n}\n\n/*Return list with elements incremented by 1.\n  >>> incrDecrDecrDecrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrDecrDecrDecrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrDecrDecrDecrDecrList = (l) => {\n  let res = []\n  let i = 0\n  while (i++ < l.length) {\n    res.push(l[i] + 1)\n    res.push(l[i] - ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/43", "prompt": "/*\n  apirSsumoTZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> apirSsumoTZero([1, 3, 5, 0])\n  false\n  >>> apirSsumoTZero([1, 3, -2, 1])\n  false\n  >>> apirSsumoTZero([1, 2, 3, 7])\n  false\n  >>> apirSsumoTZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoTZero([1])\n  false\n  */\nconst apirSsumoTZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "apirSsumoTZero", "gc": "<|endoftext|>/*\n  apirSsumoTZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> apirSsumoTZero([1, 3, 5, 0])\n  false\n  >>> apirSsumoTZero([1, 3, -2, 1])\n  false\n  >>> apirSsumoTZero([1, 2, 3, 7])\n  false\n  >>> apirSsumoTZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoTZero([1])\n  false\n  */\nconst apirSsumoTZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/**\n  apirSsumoTiny takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to one, and false otherwise.\n  >>> apirSsumoTiny([1, 3, 5, 0])\n  false\n  >>> apirSsumoTiny([1, 3, -2, 1])\n  false\n  >>> apirSsumoTiny([1, 2, 3, 7])\n  false\n  >>> apirSsumoTiny([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoTiny([1])\n  false\n  */\nconst apirSsumoTiny = (l) => {\n  let sum = 1;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 1;\n};\n\n/**\n  apirSsumoTiny takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> apirSsumoTiny([1, 3, 5, 0])\n  false\n  >>> apirSsumoTiny([1, 3, -2, 1])\n  false\n  >>> apirSsumoTiny([1, 2, 3, 7])\n  false\n  >>> apirSsumoTiny([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoTiny([1])\n  false\n  */\nconst apirSsumoTiny = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/**\n  apirSsumoTiny takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to one, and false otherwise.\n  >>> apirSsumoTiny([1, 3, 5, 0])\n  false\n  >>> apirSsumoTiny([1, 3, -2, 1])\n  false\n  >>> apirSsumoTiny([1, 2, 3, 7])\n  false\n  >>> apirSsumoTiny([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoTiny([1])\n  false\n  */\nconst apirSsumoTinyZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 1;\n};\n\n/**\n  apirSsumoTiny takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> apirSsumoTiny([1, 3, 5, 0])\n  false\n  >>> apirSsumoTiny([1, 3, -2, 1])\n  false\n  >>> apirSsumoTiny([1, 2, 3, 7])\n  false\n  >>> apirSsumoTiny([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoTiny([1])\n  false\n  */\nconst apirSsumoTinyZero = (l) => {\n  let sum = 1;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/**\n  apirSsumoTiny takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to one, and false otherwise.\n  >>> apirSsumoTiny([1, 3, 5, 0])\n  false\n  >>> apirSsumoTiny([1, 3, -2, 1])\n  false\n  >>> apirSsumoTiny([1, 2, 3, 7])\n  false\n  >>> apirSsumoTiny([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoTiny([1])\n  false\n  */\nconst apirSsumoTinyZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 1;\n};\n\n/**\n  apirSsumoTiny takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> apirSsumoTiny([1, 3, 5, 0])\n  false\n  >>> apirSsumoTiny([1, 3, -2, 1])\n  false\n  >>> apirSsumoTiny([1, 2, 3, 7])\n  false\n  >>> apirSsumoTiny([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoTiny([1])\n  false\n  */\nconst apirSsumoTinyZero = (l) => {\n  let sum = 1;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/**\n  apirSsumoTiny takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to one, and false otherwise.\n  >>> apirSsumoTiny([1, 3, 5, 0])\n  false\n  >>> apirSsumoTiny([1, 3, -2, 1])\n  false\n  >>> apirSsumoTiny([1, 2, 3, 7])\n  false\n  >>> apirSsumoTiny([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoTiny([1])\n  false\n  */\nconst apirSsumoTinyZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 1;\n};\n\n/**\n  apirSsumoTiny takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> apirSsumoTiny([1, 3, 5, 0])\n  false\n  >>> apirSsumoTiny([1, 3, -2, 1])\n  false\n  >>> apirSsumoTiny([1, 2, 3, 7])\n  false\n  >>> apirSsumoTiny([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoTiny([1])\n  false\n  */\nconst apirSsumoTinyZero = (l) => {\n  let sum = 1;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/**\n  apirSsumoTiny takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to one, and false otherwise.\n  >>> apirSsumoTiny([1, 3, 5, 0])\n  false\n  >>> apirSsumoTiny([1, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "gc": "<|endoftext|>/*Change numerical base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  if (base === 10) {\n    return x.toString();\n  }\n  const digits = x.toString().split('');\n  const result = '';\n  for (let i = 0; i < digits.length; i++) {\n    result += digits[i] * Math.pow(base, i).toString().padStart(base, '0');\n  }\n  return result;\n};\n\n/*\n  Convert a string to its binary representation in base 2.\n  >>> binToBase('0b1010')\n  '1010'\n  >>> binToBase('0b1110')\n  '1110'\n  >>> binToBase('0b11110')\n  '11110'\n  >>> binToBase('0b11111')\n  '11111'\n  */\nconst binToBase = (x) => {\n  if (x.length === 1) {\n    return x;\n  }\n  let result = '';\n  for (let i = 0; i < x.length; i++) {\n    result += String.fromCharCode(x[i] % 2);\n  }\n  return result;\n};\n\n/*\n  Convert a string to its binary representation in base 10.\n  >>> binToBase('0b101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/45", "prompt": "/*Given length of a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "gc": "<|endoftext|>/*Given length of a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 3)\n  15\n  */\nconst triangleArea = (b, h) => {\n  return b * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(7, 3)\n  25\n  */\nconst triangleArea = (c, h) => {\n  return c * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(8, 3)\n  35\n  */\nconst triangleArea = (d, h) => {\n  return d * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(9, 3)\n  55\n  */\nconst triangleArea = (e, h) => {\n  return e * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(10, 3)\n  75\n  */\nconst triangleArea = (f, h) => {\n  return f * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(11, 3)\n  100\n  */\nconst triangleArea = (g, h) => {\n  return g * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(12, 3)\n  125\n  */\nconst triangleArea = (h, h) => {\n  return h * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(13, 3)\n  150\n  */\nconst triangleArea = (i, h) => {\n  return i * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(14, 3)\n  175\n  */\nconst triangleArea = (j, h) => {\n  return j * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(15, 3)\n  200\n  */\nconst triangleArea = (k, h) => {\n  return k * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(16, 3)\n  225\n  */\nconst triangleArea = (l, h) => {\n  return l * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(17, 3)\n  250\n  */\nconst triangleArea = (m, h) => {\n  return m * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(18, 3)\n  275\n  */\nconst triangleArea = (n, h) => {\n  return n * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(19, 3)\n  300\n  */\nconst triangleArea = (o, h) => {\n  return o * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(20, 3)\n  325\n  */\nconst triangleArea = (p, h) => {\n  return p * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(21, 3)\n  350\n  */\nconst triangleArea = (q, h) => {\n  return q * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(22, 3)\n  375\n  */\nconst triangleArea = (r, h) => {\n  return r * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(23, 3)\n  400\n  */\nconst triangleArea = (s, h) => {\n  return s * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(24, 3)\n  425\n  */\nconst triangleArea = (t, h) => {\n  return t * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(25, 3)\n  450\n  */\nconst triangleArea = (u, h) => {\n  return u * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(26, 3)\n  475\n  */\nconst triangleArea = (v, h) => {\n  return v * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(27, 3)\n  500\n  */\nconst triangleArea = (w, h) => {\n  return w * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(28, 3)\n  525\n  */\nconst triangleArea = (x, h) => {\n  return x * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(29, 3)\n  550\n  */\nconst triangleArea = (y, h) => {\n  return y * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(30, 3)\n  565\n  */\nconst triangleArea = (z, h) => {\n  return z * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(31, 3)\n  600\n  */\nconst triangleArea = (a, h) => {\n  return a * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(32, 3)\n  625\n  */\nconst triangleArea = (b, h) => {\n  return b * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(33, 3)\n  650\n  */\nconst triangleArea = (c, h) => {\n  return c * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(34, 3)\n  675\n  */\nconst triangleArea = (d, h) => {\n  return d * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(35, 3)\n  700\n  */\nconst triangleArea = (e, h) => {\n  return e * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(36, 3)\n  725\n  */\nconst triangleArea = (f, h) => {\n  return f * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(37, 3)\n  750\n  */\nconst triangleArea = (g, h) => {\n  return g * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(38, 3)\n  765\n  */\nconst triangleArea = (h, h) => {\n  return h * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(39, 3)\n  800\n  */\nconst triangleArea = (i, h) => {\n  return i * h / 2;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(40, 3)\n  825\n  */\nconst triangleArea = (j, h) => {\n  return j * h / 2;", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "gc": "<|endoftext|>/*The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n <= 1) return 0;\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two terms are 1 and 2.\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(11)\n  89\n  >>> fibonacci(12)\n  144\n  >>> fibonacci(13)\n  233\n  >>> fibonacci(14)\n  377\n  >>> fibonacci(15)\n  610\n  >>> fibonacci(16)\n  987\n  >>> fibonacci(17)\n  1597\n  >>> fibonacci(18)\n  2584\n  >>> fibonacci(19)\n  4181\n  >>> fibonacci(20)\n  6765\n  >>> fibonacci(21)\n  10946\n  >>> fibonacci(22)\n  17711\n  >>> fibonacci(23)\n  28657\n  >>> fibonacci(24)\n  46368\n  >>> fibonacci(25)\n  75025\n  >>> fibonacci(26)\n  121393\n  >>> fibonacci(27)\n  196418\n  >>> fibonacci(28)\n  317811\n  >>> fibonacci(29)\n  514229\n  >>> fibonacci(30)\n  832040\n  >>> fibonacci(31)\n  1346269\n  >>> fibonacci(32)\n  2178309\n  >>> fibonacci(33)\n  3481134\n  >>> fibonacci(34)\n  5702887\n  >>> fibonacci(35)\n  9227439\n  >>> fibonacci(36)\n  14930353\n  >>> fibonacci(37)\n  25841461\n  >>> fibonacci(38)\n  41811903\n  >>> fibonacci(39)\n  67651094\n  >>> fibonacci(40)\n  109460039\n  >>> fibonacci(41)\n  177111621\n  >>> fibonacci(42)\n  286574395\n  >>> fibonacci(43)\n  463682183\n  >>> fibonacci(44)\n  750253393\n  >>> fibonacci(45)\n  1213938019\n  >>> fibonacci(46)\n  1964180839\n  >>> fibonacci(47)\n  3178114973\n  >>> fibonacci(48)\n  5142290039\n  >>> fibonacci(49)\n  8320400039\n  >>> fibonacci(50)\n  13462690039\n  >>> fibonacci(51)\n  2178309019\n  >>> fibonacci(52)\n  34811340039\n  >>> fibonacci(53)\n  5702887019\n  >>> fibonacci(54)\n  92274390039\n  >>> fibonacci(55)\n  149303530039\n  >>> fibonacci(56)\n  258414610039\n  >>> fibonacci(57)\n  418119040039\n  >>> fibonacci(58)\n  67651094019\n  >>> fibonacci(59)\n  1094600390039\n  >>> fibonacci(60)\n  17711162039\n  >>> fibonacci(61)\n  286574395019\n  >>> fibonacci(62)\n  463682183019\n  >>> fibonacci(63)\n  750253393019\n  >>> fibonacci(64)\n  121393802039\n  >>> fibonacci(65)\n  196418083019\n  >>> fibonacci(66)\n  3178114973019\n  >>> fibonacci(67)\n  514229003019\n  >>> fibonacci(68)\n  832040003019\n  >>> fibonacci(69)\n  1346269003019\n  >>> fibonacci(70)\n  217830902039\n  >>> fibonacci(71)\n  3481134003019\n  >>> fibonacci(72)\n  570288702039\n  >>> fibonacci(73)\n  9227439003019\n  >>> fibonacci(74)\n  14930353003019\n  >>> fibonacci(75)\n  25841461003019\n  >>> fibonacci(76)\n  41811904003019\n  >>> fibonacci(77)\n  6765109402039\n  >>> fibonacci(78)\n  109460039003019\n  >>> fibonacci(79)\n  1771116203019\n  >>> fibonacci(80)\n  28657439502039\n  >>> fibonacci(81)\n  46368218302039\n  >>> fibonacci(82)\n  75025339302039\n  >>> fibonacci(83)\n  12139380203019\n  >>> fibonacci(84)\n  19641808302039\n  >>> fibonacci(85)\n  317811497302039\n  >>> fibonacci(86)\n  51422900302039\n  >>> fibonacci(87)\n  83204000302039\n  >>> fibonacci(88)\n  134626900302039\n  >>> fibonacci(89)\n  21783090203019\n  >>> fibonacci(90)\n  348113400302039\n  >>> fibonacci(91)\n  57028870203019\n  >>> fibonacci(92)\n  922743900", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "gc": "<|endoftext|>/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  let m = Math.floor(n / 2)\n  return l[m] + (l[m - 1] || 0)\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  let m = Math.floor(n / 2)\n  return l[m] + (l[m - 1] || 0)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  let m = Math.floor(n / 2)\n  return l[m] + (l[m - 1] || 0)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  let m = Math.floor(n / 2)\n  return l[m] + (l[m - 1] || 0)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  let m = Math.floor(n / 2)\n  return l[m] + (l[m - 1] || 0)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  let m = Math.floor(n / 2)\n  return l[m] + (l[m - 1] || 0)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  let m = Math.floor(n / 2)\n  return l[m] + (l[m - 1] || 0)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  let m = Math.floor(n / 2)\n  return l[m] + (l[m - 1] || 0)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  let m = Math.floor(n / 2)\n  return l[m] + (l[m - 1] || 0)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  let m = Math.floor(n / 2)\n  return l[m] + (l[m - 1] || 0)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  let m = Math.floor(n / 2)\n  return l[m] + (l[m - 1] || 0)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  let m = Math.floor(n / 2)\n  return l[m] + (l[m - 1] || 0)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  let m = Math.floor(n / 2)\n  return l[m] + (l[m - 1] || 0)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  let m = Math.floor(n / 2)\n  return l[m] + (l[m - 1] || 0)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  let m = Math.floor(n / 2)\n  return l[m] + (l[m - 1] || 0)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  let m = Math.floor(n / 2)\n  return l[m] + (l[m - 1] || 0)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  let m = Math.floor(n / 2)\n  return l[m] + (l[m - 1] || 0)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let n = l.length\n  let m = Math.floor(n / 2)\n  return l[m] + (l[m - 1] || 0)\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "gc": "<|endoftext|>/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversedText = '';\n  for (let i = text.length - 1; i >= 0; i--) {\n    reversedText += text.charAt(i);\n  }\n  return reversedText === text;\n};\n\n/*\n  Checks if given string is a palindrome with given length\n  >>> isPalindromeWithLength(3, 'aba')\n  true\n  >>> isPalindromeWithLength(3, 'aaaaa')\n  true\n  >>> isPalindromeWithLength(3, 'zbcd')\n  false\n  */\nconst isPalindromeWithLength = (length, text) => {\n  let reversedText = '';\n  for (let i = text.length - 1; i >= 0; i--) {\n    reversedText += text.charAt(i);\n  }\n  return reversedText.slice(0, length) === reversedText.slice(length - length);\n};\n\n/*\n  Checks if given string is a palindrome with given length and given separator\n  >>> isPalindromeWithSeparator('aba', '|')\n  true\n  >>> isPalindromeWithSeparator('aba', '|')\n  true\n  >>> isPalindromeWithSeparator('aba', '|')\n  false\n  */\nconst isPalindromeWithSeparator = (length, separator, text) => {\n  let reversedText = '';\n  for (let i = text.length - 1; i >= 0; i--) {\n    reversedText += text.charAt(i);\n  }\n  return reversedText.slice(0, length) === reversedText.slice(length - length).split(separator).reverse().join(separator);\n};\n\n/*\n  Checks if given string is a palindrome with given separator\n  >>> isPalindromeWithSeparator('aba', '|')\n  true\n  >>> isPalindromeWithSeparator('aba', '|')\n  true\n  >>> isPalindromeWithSeparator('aba', '|')\n  false\n  */\nconst isPalindromeWithSeparatorAndSeparator = (separator, text) => {\n  let reversedText = '';\n  for (let i = text.length - 1; i >= 0; i--) {\n    reversedText += text.charAt(i);\n  }\n  return reversedText.slice(0, separator.length) === reversedText.slice(separator.length).split(separator).reverse().join(separator);\n};\n\n/*\n  Checks if given string is a palindrome with given separator\n  >>> isPalindromeWithSeparator('aba', '|')\n  true\n  >>> isPalindromeWithSeparator('aba', '|')\n  true\n  >>> isPalindromeWithSeparator('aba', '|')\n  false\n  */\nconst isPalindromeWithSeparatorAndSeparatorAndSeparator = (separator, text) => {\n  let reversedText = '';\n  for (let i = text.length - 1; i >= 0; i--) {\n    reversedText += text.charAt(i);\n  }\n  return reversedText.slice(0, separator.length) === reversedText.slice(separator.length).split(separator).reverse().join(separator);\n};\n\n/*\n  Checks if given string is a palindrome with given separator\n  >>> isPalindromeWithSeparator('aba', '|')\n  true\n  >>> isPalindromeWithSeparator('aba', '|')\n  true\n  >>> isPalindromeWithSeparator('aba', '|')\n  false\n  */\nconst isPalindromeWithSeparatorAndSeparatorAndSeparator = (separator, text) => {\n  let reversedText = '';\n  for (let i = text.length - 1; i >= 0; i--) {\n    reversedText += text.charAt(i);\n  }\n  return reversedText.slice(0, separator.length) === reversedText.slice(separator.length).split(separator).reverse().join(separator);\n};\n\n/*\n  Checks if given string is a palindrome with given separator\n  >>> isPalindromeWithSeparator('aba', '|')\n  true\n  >>> isPalindromeWithSeparator('aba', '|')\n  true\n  >>> isPalindromeWithSeparator('aba', '|')\n  false\n  */\nconst isPalindromeWithSeparatorAndSeparatorAndSeparatorAndSeparator = (separator, text) => {\n  let reversedText = '';\n  for (let i = text.length - 1; i >= 0; i--) {\n    reversedText += text.charAt(i);\n  }\n  return reversedText.slice(0, separator.length) === reversedText.slice(separator.length).split(separator).reverse().join(separator);\n};\n\n/*\n  Checks if given string is a palindrome with given separator\n  >>> isPalindromeWithSeparator('aba', '|')\n  true\n  >>> isPalindromeWithSeparator('aba', '|')\n  true\n  >>> isPalindromeWithSeparator('aba', '|')\n  false\n  */\nconst isPalindromeWithSeparatorAndSeparatorAndSeparatorAndSeparator = (separator, text) => {\n  let reversedText = '';\n  for (let i = text.length - 1; i >= 0; i--) {\n    reversedText += text.charAt(i);\n  }\n  return reversedText.slice(0, separator.length) === reversedText.slice(separator.length).split(separator).reverse().join(separator);\n};\n\n/*\n  Checks if given string is a palindrome with given separator\n  >>> isPalindromeWithSeparator('aba', '|')\n  true\n  >>> isPalindromeWithSeparator('aba', '|')\n  true\n  >>> isPalindromeWithSeparator('aba', '|')\n  false\n  */\nconst isPalindromeWithSeparatorAndSeparatorAndSeparatorAndSeparator = (separator, text) => {\n  let reversedText = '';\n  for (let i = text.length - 1; i >= 0; i--) {\n    reversedText += text.charAt(i);\n  }\n  return reversedText.slice(0, separator.length) === reversedText.slice(separator.length).split(separator).reverse().join(separator);\n};\n\n/*\n  Checks if given string is a palindrome with given separator\n  >>> isPalindromeWithSeparator('aba', '|')\n  true\n  >>> isPalindromeWithSeparator('aba', '|')\n  true\n  >>> isPalindromeWithSeparator('aba', '|')\n  false\n  */\nconst isPalindromeWithSeparatorAndSeparatorAndSeparatorAndSeparator = (separator, text) => {\n  let reversedText = '';\n  for (let i = text.length - 1; i >= 0; i--) {\n    reversedText += text.charAt(i);\n  }\n  return reversedText.slice(0, separator.length) === reversedText.slice(separator.length).split(separator).reverse().join(separator);\n};\n\n/*\n  Checks if given string is a palindrome with given separator\n  >>> isPalindromeWithSeparator('aba', '|')\n  true\n  >>> isPalindromeWithSeparator('aba', '|')\n  true\n  >>> isPalindromeWithSeparator('aba', '|')\n  false\n  */\nconst isPalindromeWithSeparatorAndSeparatorAndSeparatorAndSeparatorAndSeparator = (separator, text) => {\n  let reversedText = '';\n  for (let i = text.length - 1; i >= 0; i--) {\n    reversedText += text.charAt(i);\n  }\n  return reversedText.slice(0, separator.length) === reversedText.slice(separator.length", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "gc": "<|endoftext|>/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (n < 0 || p < 1) return 0;\n  if (n == 0) return 1;\n  if (n == 1) return p;\n  if (p < 1) return 0;\n  if (p > n) return 0;\n  return ((n % p) + p) % p;\n};\n\n/**\n * Test if two numbers are equal.\n * Returns true if the numbers are equal, false otherwise.\n */\nconst equal = (a, b) => {\n  if (a === b) return true;\n  if (a < 0 || b < 0) return false;\n  return a === b || (a < b && equals(a, b));\n};\n\n/**\n * Test if two numbers are equal.\n * Returns true if the numbers are equal, false otherwise.\n */\nconst equals = (a, b) => {\n  if (a === b) return true;\n  if (a < 0 || b < 0) return false;\n  return a === b || (a < b && equals(a, b));\n};\n\n/**\n * Test if two numbers are equal.\n * Returns true if the numbers are equal, false otherwise.\n */\nconst equalsOrZero = (a, b) => {\n  if (a === b) return true;\n  if (a < 0 || b < 0) return false;\n  return a === b || (a < b && equals(a, b));\n};\n\n/**\n * Test if two numbers are equal.\n * Returns true if the numbers are equal, false otherwise.\n */\nconst equalsOrZeroOrZero = (a, b) => {\n  if (a === b) return true;\n  if (a < 0 || b < 0) return false;\n  return a === b || (a < b && equals(a, b));\n};\n\n/**\n * Test if two numbers are equal.\n * Returns true if the numbers are equal, false otherwise.\n */\nconst equalsOrZeroOrOne = (a, b) => {\n  if (a === b) return true;\n  if (a < 0 || b < 0) return false;\n  return a === b || (a < b && equals(a, b));\n};\n\n/**\n * Test if two numbers are equal.\n * Returns true if the numbers are equal, false otherwise.\n */\nconst equalsOrZeroOrOneOrZero = (a, b) => {\n  if (a === b) return true;\n  if (a < 0 || b < 0) return false;\n  return a === b || (a < b && equals(a, b));\n};\n\n/**\n * Test if two numbers are equal.\n * Returns true if the numbers are equal, false otherwise.\n */\nconst equalsOrZeroOrOneOrOne = (a, b) => {\n  if (a === b) return true;\n  if (a < 0 || b < 0) return false;\n  return a === b || (a < b && equals(a, b));\n};\n\n/**\n * Test if two numbers are equal.\n * Returns true if the numbers are equal, false otherwise.\n */\nconst equalsOrZeroOrOneOrOneOrZero = (a, b) => {\n  if (a === b) return true;\n  if (a < 0 || b < 0) return false;\n  return a === b || (a < b && equals(a, b));\n};\n\n/**\n * Test if two numbers are equal.\n * Returns true if the numbers are equal, false otherwise.\n */\nconst equalsOrZeroOrOneOrOneOrOne = (a, b) => {\n  if (a === b) return true;\n  if (a < 0 || b < 0) return false;\n  return a === b || (a < b && equals(a, b));\n};\n\n/**\n * Test if two numbers are equal.\n * Returns true if the numbers are equal, false otherwise.\n */\nconst equalsOrZeroOrOneOrOneOrOneOrZero = (a, b) => {\n  if (a === b) return true;\n  if (a < 0 || b < 0) return false;\n  return a === b || (a < b && equals(a, b));\n};\n\n/**\n * Test if two numbers are equal.\n * Returns true if the numbers are equal, false otherwise.\n */\nconst equalsOrZeroOrOneOrOneOrOneOrOne = (a, b) => {\n  if (a === b) return true;\n  if (a < 0 || b < 0) return false;\n  return a === b || (a < b && equals(a, b));\n};\n\n/**\n * Test if two numbers are equal.\n * Returns true if the numbers are equal, false otherwise.\n */\nconst equalsOrZeroOrOneOrOneOrOneOrOneOrZero = (a, b) => {\n  if (a === b) return true;\n  if (a < 0 || b < 0) return false;\n  return a === b || (a < b && equals(a, b));\n};\n\n/**\n * Test if two numbers are equal.\n * Returns true if the numbers are equal, false otherwise.\n */\nconst equalsOrZeroOrOneOrOneOrOneOrOneOrOne = (a, b) => {\n  if (a === b) return true;\n  if (a < 0 || b < 0) return false;\n  return a === b || (a < b && equals(a, b));\n};\n\n/**\n * Test if two numbers are equal.\n * Returns true if the numbers are equal, false otherwise.\n */\nconst equalsOrZeroOrOneOrOneOrOneOrOneOrOne = (a, b) => {\n  if (a === b) return true;\n  if (a < 0 || b < 0) return false;\n  return a === b || (a < b && equals(a, b));\n};\n\n/**\n * Test if two numbers are equal.\n * Returns true if the numbers are equal, false otherwise.\n */\nconst equalsOrZeroOrOneOrOneOrOneOrOneOrOneOrOne = (a, b) => {\n  if (a === b) return true;\n  if (a < 0 || b < 0) return false;\n  return a === b || (a < b && equals(a, b));\n};\n\n/**\n * Test if two numbers are equal.\n * Returns true if the numbers are equal, false otherwise.\n */\nconst equalsOrZeroOrOneOrOneOrOneOrOneOrOneOrOneOrOne = (a, b) => {\n  if (a === b) return true;\n  if (a < 0 || b < 0) return false;\n  return a === b || (a < b && equals(a, b));\n};\n\n/**\n * Test if two numbers are equal.\n * Returns true if the numbers are equal, false otherwise.\n */\nconst equalsOrZeroOrOneOrOneOrOneOrOneOrOneOrOneOrOneOrOne = (a, b) => {\n  if (a === b) return true;\n  if (a < 0 || b < 0) return false;\n  return a === b || (a < b && equals(a, b));\n};\n\n/**\n * Test if two numbers are equal.\n * Returns true if the numbers are equal, false otherwise.\n */\nconst equalsOrZeroOrOneOrOneOrOneOrOneOrOneOrOneOrOneOrOneOrOne = (a, b) => {\n  if (a === b) return true;\n  if (a < 0 || b < 0) return false;\n  return a === b || (a < b && equals(a, b));\n};\n\n/**\n * Test if two numbers are equal.\n * Returns true if the numbers are equal, false otherwise.\n */\nconst equalsOrZeroOrOneOrOneOrOneOrOneOrOneOrOneOrOneOrOneOrOneOrOne = (a, b) => {\n  if (a === b) return true;\n  if (a < 0 || b < 0) return false;\n  return a === b || (a < b && equals(a, b));\n};\n\n/**\n * Test if two numbers are equal.\n * Returns true if the numbers are equal, false otherwise.\n */\nconst equalsOrZeroOrOneOrOneOrOneOrOneOrOneOrOneOrOneOrOneOrOneOrOneOrOneOr", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> interpserse([], 4)\n  []\n  >>> interpserse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst interpserse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "interpserse", "gc": "<|endoftext|>/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> interpserse([], 4)\n  []\n  >>> interpserse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst interpserse = (numbers, delimeter) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < numbers.length) {\n    if (j === numbers.length - 1) {\n      result.push(numbers[i])\n      i++\n      j = 0\n    } else {\n      result.push(numbers[i])\n      i++\n      j++\n    }\n  }\n  result.push(numbers[i])\n  return result\n}\n\n/**\n * Interpolate between 2 numbers `a` and `b` with given `t`\n * \n * Interpolation between 2 numbers `a` and `b` with given `t` can be done in two ways:\n * \n * 1. `a` and `b` are numbers and `t` is an interpolation function\n * 2. `a` and `b` are arrays and `t` is an interpolation function\n * \n * Interpolation between 2 numbers `a` and `b` with given `t` can be done in two ways:\n * \n * 1. `a` and `b` are numbers and `t` is an interpolation function\n * 2. `a` and `b` are arrays and `t` is an interpolation function\n * \n * Interpolation between 2 numbers `a` and `b` with given `t` can be done in two ways:\n * \n * 1. `a` and `b` are numbers and `t` is an interpolation function\n * 2. `a` and `b` are arrays and `t` is an interpolation function\n * \n * Interpolation between 2 numbers `a` and `b` with given `t` can be done in two ways:\n * \n * 1. `a` and `b` are numbers and `t` is an interpolation function\n * 2. `a` and `b` are arrays and `t` is an interpolation function\n * \n * Interpolation between 2 numbers `a` and `b` with given `t` can be done in two ways:\n * \n * 1. `a` and `b` are numbers and `t` is an interpolation function\n * 2. `a` and `b` are arrays and `t` is an interpolation function\n * \n * Interpolation between 2 numbers `a` and `b` with given `t` can be done in two ways:\n * \n * 1. `a` and `b` are numbers and `t` is an interpolation function\n * 2. `a` and `b` are arrays and `t` is an interpolation function\n * \n * Interpolation between 2 numbers `a` and `b` with given `t` can be done in two ways:\n * \n * 1. `a` and `b` are numbers and `t` is an interpolation function\n * 2. `a` and `b` are arrays and `t` is an interpolation function\n * \n * Interpolation between 2 numbers `a` and `b` with given `t` can be done in two ways:\n * \n * 1. `a` and `b` are numbers and `t` is an interpolation function\n * 2. `a` and `b` are arrays and `t` is an interpolation function\n * \n * Interpolation between 2 numbers `a` and `b` with given `t` can be done in two ways:\n * \n * 1. `a` and `b` are numbers and `t` is an interpolation function\n * 2. `a` and `b` are arrays and `t` is an interpolation function\n * \n * Interpolation between 2 numbers `a` and `b` with given `t` can be done in two ways:\n * \n * 1. `a` and `b` are numbers and `t` is an interpolation function\n * 2. `a` and `b` are arrays and `t` is an interpolation function\n * \n * Interpolation between 2 numbers `a` and `b` with given `t` can be done in two ways:\n * \n * 1. `a` and `b` are numbers and `t` is an interpolation function\n * 2. `a` and `b` are arrays and `t` is an interpolation function\n * \n * Interpolation between 2 numbers `a` and `b` with given `t` can be done in two ways:\n * \n * 1. `a` and `b` are numbers and `t` is an interpolation function\n * 2. `a` and `b` are arrays and `t` is an interpolation function\n * \n * Interpolation between 2 numbers `a` and `b` with given `t` can be done in two ways:\n * \n * 1. `a` and `b` are numbers and `t` is an interpolation function\n * 2. `a` and `b` are arrays and `t` is an interpolation function\n * \n * Interpolation between 2 numbers `a` and `b` with given `t` can be done in two ways:\n * \n * 1. `a` and `b` are numbers and `t` is an interpolation function\n * 2. `a` and `b` are arrays and `t` is an interpolation function\n * \n * Interpolation between 2 numbers `a` and `b` with given `t` can be done in two ways:\n * \n * 1. `a` and `b` are numbers and `t` is an interpolation function\n * 2. `a` and `b` are arrays and `t` is an interpolation function\n * \n * Interpolation between 2 numbers `a` and `b` with given `t` can be done in two ways:\n * \n * 1. `a` and `b` are numbers and `t` is an interpolation function\n * 2. `a` and `b` are arrays and `t` is an interpolation function\n * \n * Interpolation between 2 numbers `a` and `b` with given `t` can be done in two ways:\n * \n * 1. `a` and `b` are numbers and `t` is an interpolation function\n * 2. `a` and `b` are arrays and `t` is an interpolation function\n * \n * Interpolation between 2 numbers `a` and `b` with given `t` can be done in two ways:\n * \n * 1. `a` and `b` are numbers and `t` is an interpolation function\n * 2. `a` and `b` are arrays and `t` is an interpolation function\n * \n * Interpolation between 2 numbers `a` and `b` with given `t` can be done in two ways:\n * \n * 1. `a` and `b` are numbers and `t` is an interpolation function\n * 2. `a` and `b` are arrays and `t` is an interpolation function\n * \n * Interpolation between 2 numbers `a` and `b` with given `t` can be done in two ways:\n * \n * 1. `a` and `b` are numbers and `t` is an interpolation function\n * 2. `a` and `b` are arrays and `t` is an interpolation function\n * \n * Interpolation between 2 numbers `a` and `b` with given `t` can be done in two ways:\n * \n * 1. `a` and `b` are numbers and `t` is an interpolation function\n * 2. `a` and `b` are arrays and `t` is an interpolation function\n * \n * Interpolation between 2 numbers `a` and `b` with given `t` can be done in two ways:\n * \n * 1. `a` and `b` are numbers and `t` is an interpolation function\n * 2. `a` and `b` are arrays and `t` is an interpolation function\n * \n * Interpolation between 2 numbers `a` and `b` with given `t` can be done in two ways:\n * \n * 1. `a` and `b` are numbers and `t` is an interpolation function\n * 2. `a` and `b` are arrays and `t` is an interpolation function\n * \n * Interpolation between 2 numbers `a` and `b` with given `t` can be done in two ways:\n * \n * 1. `a` and `b", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodSehift", "gc": "<|endoftext|>/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - \"a\".charCodeAt(0)", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  remoevVowels is a function that takes string and returns string without vowels.\n  >>> remoevVowels('')\n  ''\n  >>> remoevVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> remoevVowels('abcdef')\n  'bcdf'\n  >>> remoevVowels('aaaaa')\n  ''\n  >>> remoevVowels('aaBAA')\n  'B'\n  >>> remoevVowels('zbcd')\n  'zbcd'\n  */\nconst remoevVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "remoevVowels", "gc": "<|endoftext|>/*\n  remoevVowels is a function that takes string and returns string without vowels.\n  >>> remoevVowels('')\n  ''\n  >>> remoevVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> remoevVowels('abcdef')\n  'bcdf'\n  >>> remoevVowels('aaaaa')\n  ''\n  >>> remoevVowels('aaBAA')\n  'B'\n  >>> remoevVowels('zbcd')\n  'zbcd'\n  */\nconst remoevVowels = (text) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  let newText = '';\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i];\n    if (vowels.includes(char)) {\n      newText += char;\n    }\n  }\n  return newText;\n};\n\n/*\n  removePunctuation is a function that takes string and returns string without punctuation.\n  >>> removePunctuation('')\n  ''\n  >>> removePunctuation(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removePunctuation('abcdef')\n  'abcdef'\n  >>> removePunctuation('aaaaa')\n  ''\n  >>> removePunctuation('aaBAA')\n  'B'\n  >>> removePunctuation('zbcd')\n  'zbcd'\n  */\nconst removePunctuation = (text) => {\n  let newText = '';\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i];\n    if (char ==='' || char === '\\t' || char === '\\n' || char === '\\r' || char === '\\f') {\n      newText += char;\n    }\n  }\n  return newText;\n};\n\n/*\n  removeWhitespace is a function that takes string and returns string without whitespace.\n  >>> removeWhitespace('')\n  ''\n  >>> removeWhitespace(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeWhitespace('abcdef')\n  'abcdef'\n  >>> removeWhitespace('aaaaa')\n  ''\n  >>> removeWhitespace('aaBAA')\n  'B'\n  >>> removeWhitespace('zbcd')\n  'zbcd'\n  */\nconst removeWhitespace = (text) => {\n  let newText = '';\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i];\n    if (char ==='' || char === '\\t' || char === '\\n' || char === '\\r' || char === '\\f') {\n      newText += char;\n    }\n  }\n  return newText;\n};\n\n/*\n  removePunctuation is a function that takes string and returns string without punctuation.\n  >>> removePunctuation('')\n  ''\n  >>> removePunctuation(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removePunctuation('abcdef')\n  'abcdef'\n  >>> removePunctuation('aaaaa')\n  ''\n  >>> removePunctuation('aaBAA')\n  'B'\n  >>> removePunctuation('zbcd')\n  'zbcd'\n  */\nconst removePunctuation = (text) => {\n  let newText = '';\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i];\n    if (char ==='' || char === '\\t' || char === '\\n' || char === '\\r' || char === '\\f') {\n      newText += char;\n    }\n  }\n  return newText;\n};\n\n/*\n  removeWhitespace is a function that takes string and returns string without whitespace.\n  >>> removeWhitespace('')\n  ''\n  >>> removeWhitespace(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeWhitespace('abcdef')\n  'abcdef'\n  >>> removeWhitespace('aaaaa')\n  ''\n  >>> removeWhitespace('aaBAA')\n  'B'\n  >>> removeWhitespace('zbcd')\n  'zbcd'\n  */\nconst removeWhitespace = (text) => {\n  let newText = '';\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i];\n    if (char ==='' || char === '\\t' || char === '\\n' || char === '\\r' || char === '\\f') {\n      newText += char;\n    }\n  }\n  return newText;\n};\n\n/*\n  removePunctuation is a function that takes string and returns string without punctuation.\n  >>> removePunctuation('')\n  ''\n  >>> removePunctuation(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removePunctuation('abcdef')\n  'abcdef'\n  >>> removePunctuation('aaaaa')\n  ''\n  >>> removePunctuation('aaBAA')\n  'B'\n  >>> removePunctuation('zbcd')\n  'zbcd'\n  */\nconst removePunctuation = (text) => {\n  let newText = '';\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i];\n    if (char ==='' || char === '\\t' || char === '\\n' || char === '\\r' || char === '\\f') {\n      newText += char;\n    }\n  }\n  return newText;\n};\n\n/*\n  removeWhitespace is a function that takes string and returns string without whitespace.\n  >>> removeWhitespace('')\n  ''\n  >>> removeWhitespace(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeWhitespace('abcdef')\n  'abcdef'\n  >>> removeWhitespace('aaaaa')\n  ''\n  >>> removeWhitespace('aaBAA')\n  'B'\n  >>> removeWhitespace('zbcd')\n  'zbcd'\n  */\nconst removeWhitespace = (text) => {\n  let newText = '';\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i];\n    if (char ==='' || char === '\\t' || char === '\\n' || char === '\\r' || char === '\\f') {\n      newText += char;\n    }\n  }\n  return newText;\n};\n\n/*\n  removePunctuation is a function that takes string and returns string without punctuation.\n  >>> removePunctuation('')\n  ''\n  >>> removePunctuation(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removePunctuation('abcdef')\n  'abcdef'\n  >>> removePunctuation('aaaaa')\n  ''\n  >>> removePunctuation('aaBAA')\n  'B'\n  >>> removePunctuation('zbcd')\n  'zbcd'\n  */\nconst removePunctuation = (text) => {\n  let newText = '';\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i];\n    if (char ==='' || char === '\\t' || char === '\\n' || char === '\\r' || char === '\\f') {\n      newText += char;\n    }\n  }\n  return newText;\n};\n\n/*\n  removeWhitespace is a function that takes string and returns string without whitespace.\n  >>> removeWhitespace('')\n  ''\n  >>> removeWhitespace(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeWhitespace('abcdef')\n  'abcdef'\n  >>> removeWhitespace('aaaaa')\n  ''\n  >>> removeWhitespace('aaBAA')\n  'B'\n  >>> removeWhitespace('zbcd')\n  'zbcd'\n  */\nconst removeWhitespace = (text) => {\n  let newText = '';\n  for (let i = 0; i < text.length; i++) {\n    const char = text[i];\n    if (char ==='' || char === '\\t' || char === '\\n' || char === '\\r' || char === '\\f') {\n      newText += char;\n    }\n  }\n  return newText;\n};\n\n/*\n  removePunctuation is a function that takes string and returns string without punctuation.\n  >>> removePunctuation('')\n  ''\n  >>> ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all numbers in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "gc": "<|endoftext|>/*Return true if all numbers in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  return l.every(n => n > t);\n};\n\n/*Return true if all numbers in the list l are above threshold t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  true\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst aboveThreshold = (l, t) => {\n  return l.every(n => n < t);\n};\n\n/*Return true if all numbers in the list l are equal to t.\n  >>> equal([1, 2, 4, 10], 100)\n  true\n  >>> equal([1, 20, 4, 10], 5)\n  false\n  */\nconst equal = (l, t) => {\n  return l.length === t.length && l.every((n, i) => n === t[i]);\n};\n\n/*Return true if all numbers in the list l are divisible by t.\n  >>> divisibleBy([1, 2, 4, 10], 100)\n  true\n  >>> divisibleBy([1, 20, 4, 10], 5)\n  false\n  */\nconst divisibleBy = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 100)\n  true\n  >>> multipleOf([2, 4, 6, 8], 2)\n  false\n  */\nconst multipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 100)\n  true\n  >>> multipleOf([2, 4, 6, 8], 2)\n  true\n  */\nconst multipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 100)\n  true\n  >>> multipleOf([2, 4, 6, 8], 2)\n  true\n  */\nconst multipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 100)\n  true\n  >>> multipleOf([2, 4, 6, 8], 2)\n  true\n  */\nconst multipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 100)\n  true\n  >>> multipleOf([2, 4, 6, 8], 2)\n  true\n  */\nconst multipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 100)\n  true\n  >>> multipleOf([2, 4, 6, 8], 2)\n  true\n  */\nconst multipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 100)\n  true\n  >>> multipleOf([2, 4, 6, 8], 2)\n  true\n  */\nconst multipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 100)\n  true\n  >>> multipleOf([2, 4, 6, 8], 2)\n  true\n  */\nconst multipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 100)\n  true\n  >>> multipleOf([2, 4, 6, 8], 2)\n  true\n  */\nconst multipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 100)\n  true\n  >>> multipleOf([2, 4, 6, 8], 2)\n  true\n  */\nconst multipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 100)\n  true\n  >>> multipleOf([2, 4, 6, 8], 2)\n  true\n  */\nconst multipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 100)\n  true\n  >>> multipleOf([2, 4, 6, 8], 2)\n  true\n  */\nconst multipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 100)\n  true\n  >>> multipleOf([2, 4, 6, 8], 2)\n  true\n  */\nconst multipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 100)\n  true\n  >>> multipleOf([2, 4, 6, 8], 2)\n  true\n  */\nconst multipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 100)\n  true\n  >>> multipleOf([2, 4, 6, 8], 2)\n  true\n  */\nconst multipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 100)\n  true\n  >>> multipleOf([2, 4, 6, 8], 2)\n  true\n  */\nconst multipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 100)\n  true\n  >>> multipleOf([2, 4, 6, 8], 2)\n  true\n  */\nconst multipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 100)\n  true\n  >>> multipleOf([2, 4, 6, 8], 2)\n  true\n  */\nconst multipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 100)\n  true\n  >>> multipleOf([2, 4, 6, 8], 2)\n  true\n  */\nconst multipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 100)\n  true\n  >>> multipleOf([2, 4, 6, 8], 2)\n  true\n  */\nconst multipleOf = (l, t) => {\n  return l.every(n => n % t === 0);\n};\n\n/*Return true if all numbers in the list l are a multiple of t.\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "gc": "<|endoftext|>/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y\n}\n\n/*\n  >>> subtract(2, 3)\n  3\n  >>> subtract(5, 7)\n  -1\n  */\nconst subtract = (x, y) => {\n  return x - y\n}\n\n/*\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  24\n  */\nconst multiply = (a, b) => {\n  return a * b\n}\n\n/*\n  >>> divide(2, 3)\n  2\n  >>> divide(5, 7)\n  3\n  */\nconst divide = (x, y) => {\n  return x / y\n}\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  3\n  */\nconst mod = (x, y) => {\n  return x % y\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst power = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  3\n  */\nconst modPow = (x, y) => {\n  return mod(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powMod = (x, y) => {\n  return pow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPow = (x, y) => {\n  return powMod(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPow = (x, y) => {\n  return powModPow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPow = (x, y) => {\n  return powModPowPow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPow = (x, y) => {\n  return powModPowPowPow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPowPow = (x, y) => {\n  return powModPowPowPow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPowPow = (x, y) => {\n  return powModPowPowPow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPowPow = (x, y) => {\n  return powModPowPowPow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPowPow = (x, y) => {\n  return powModPowPowPow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPowPow = (x, y) => {\n  return powModPowPowPow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPowPow = (x, y) => {\n  return powModPowPowPow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPowPowPow = (x, y) => {\n  return powModPowPowPow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPowPow = (x, y) => {\n  return powModPowPowPow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPowPowPow = (x, y) => {\n  return powModPowPowPow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPowPowPow = (x, y) => {\n  return powModPowPowPow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPowPow = (x, y) => {\n  return powModPowPowPow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPowPowPow = (x, y) => {\n  return powModPowPowPowPow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPowPowPow = (x, y) => {\n  return powModPowPowPowPow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPowPowPow = (x, y) => {\n  return powModPowPowPowPow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPowPowPowPow = (x, y) => {\n  return powModPowPowPowPow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPowPowPow = (x, y) => {\n  return powModPowPowPowPow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPowPowPow = (x, y) => {\n  return powModPowPowPowPow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPowPowPowPow = (x, y) => {\n  return powModPowPowPowPow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPowPowPowPow = (x, y) => {\n  return powModPowPowPowPow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPowPowPow = (x, y) => {\n  return powModPowPowPowPow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPowPowPow = (x, y) => {\n  return powModPowPowPowPow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPowPowPow = (x, y) => {\n  return powModPowPowPowPow(x, modPow(y, 2))\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  3\n  */\nconst powModPowPowPowPow = (", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "gc": "<|endoftext|>/*\n  Check if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const len = s1.length\n  const diff = 0\n  for (let i = 0; i < len; i++) {\n    const c = s1.charAt(i)\n    const c0 = s0.charAt(i)\n    if (c!== c0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Check if two words have the same letters.\n  >>> sameLetters('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameLetters('abcd', 'dddddddabc')\n  true\n  >>> sameLetters('dddddddabc', 'abcd')\n  true\n  >>> sameLetters('eabcd', 'dddddddabc')\n  false\n  >>> sameLetters('abcd', 'dddddddabce')\n  false\n  >>> sameLetters('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameLetters = (s0, s1) => {\n  const len = s1.length\n  const diff = 0\n  for (let i = 0; i < len; i++) {\n    const c = s1.charAt(i)\n    const c0 = s0.charAt(i)\n    if (c!== c0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Check if two words have the same words.\n  >>> sameWords('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameWords('abcd', 'dddddddabc')\n  true\n  >>> sameWords('dddddddabc', 'abcd')\n  true\n  >>> sameWords('eabcd', 'dddddddabc')\n  false\n  >>> sameWords('abcd', 'dddddddabce')\n  false\n  >>> sameWords('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameWords = (s0, s1) => {\n  const len = s1.length\n  const diff = 0\n  for (let i = 0; i < len; i++) {\n    const c = s1.charAt(i)\n    const c0 = s0.charAt(i)\n    if (c!== c0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Check if two words have the same length.\n  >>> sameLength('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameLength('abcd', 'dddddddabc')\n  true\n  >>> sameLength('dddddddabc', 'abcd')\n  true\n  >>> sameLength('eabcd', 'dddddddabc')\n  false\n  >>> sameLength('abcd', 'dddddddabce')\n  false\n  >>> sameLength('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameLength = (s0, s1) => {\n  const len = s1.length\n  const diff = 0\n  for (let i = 0; i < len; i++) {\n    const c = s1.charAt(i)\n    const c0 = s0.charAt(i)\n    if (c!== c0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Check if two words have the same capitalization.\n  >>> sameCaps('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameCaps('abcd', 'dddddddabc')\n  true\n  >>> sameCaps('dddddddabc', 'abcd')\n  true\n  >>> sameCaps('eabcd', 'dddddddabc')\n  false\n  >>> sameCaps('abcd', 'dddddddabce')\n  false\n  >>> sameCaps('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCaps = (s0, s1) => {\n  const len = s1.length\n  const diff = 0\n  for (let i = 0; i < len; i++) {\n    const c = s1.charAt(i)\n    const c0 = s0.charAt(i)\n    if (c!== c0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Check if two words have the same punctuation.\n  >>> samePunc('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> samePunc('abcd', 'dddddddabc')\n  true\n  >>> samePunc('dddddddabc', 'abcd')\n  true\n  >>> samePunc('eabcd', 'dddddddabc')\n  false\n  >>> samePunc('abcd', 'dddddddabce')\n  false\n  >>> samePunc('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst samePunc = (s0, s1) => {\n  const len = s1.length\n  const diff = 0\n  for (let i = 0; i < len; i++) {\n    const c = s1.charAt(i)\n    const c0 = s0.charAt(i)\n    if (c!== c0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Check if two words have the same punctuation.\n  >>> samePunc('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> samePunc('abcd', 'dddddddabc')\n  true\n  >>> samePunc('dddddddabc', 'abcd')\n  true\n  >>> samePunc('eabcd', 'dddddddabc')\n  false\n  >>> samePunc('abcd', 'dddddddabce')\n  false\n  >>> samePunc('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst samePunc = (s0, s1) => {\n  const len = s1.length\n  const diff = 0\n  for (let i = 0; i < len; i++) {\n    const c = s1.charAt(i)\n    const c0 = s0.charAt(i)\n    if (c!== c0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Check if two words have the same punctuation.\n  >>> samePunc('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> samePunc('abcd', 'dddddddabc')\n  true\n  >>> samePunc('dddddddabc', 'abcd')\n  true\n  >>> samePunc('eabcd', 'dddddddabc')\n  false\n  >>> samePunc('abcd', 'dddddddabce')\n  false\n  >>> samePunc('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst samePunc = (s0, s1) => {\n  const len = s1.length\n  const diff = 0\n  for (let i = 0; i < len; i++) {\n    const c = s1.charAt(i)\n    const c0 = s0.charAt(i)\n    if (c!== c0) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Check if two words have the same punctuation.\n  >>> samePunc('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> samePunc('abcd', 'dddddddabc')\n  true\n  >>> samePunc('dddddddabc', 'abcd')\n  true\n  >>> samePunc('e", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "gc": "<|endoftext|>/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  175\n  >>> fib(7)\n  265\n  >>> fib(8)\n  341\n  >>> fib(9)\n  610\n  >>> fib(10)\n  981\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(11)\n  175\n  >>> fibonacci(12)\n  265\n  >>> fibonacci(13)\n  341\n  >>> fibonacci(14)\n  610\n  >>> fibonacci(15)\n  981\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(15)\n  55\n  >>> fibonacci(16)\n  175\n  >>> fibonacci(17)\n  265\n  >>> fibonacci(18)\n  341\n  >>> fibonacci(19)\n  610\n  >>> fibonacci(20)\n  981\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(20)\n  55\n  >>> fibonacci(21)\n  175\n  >>> fibonacci(22)\n  265\n  >>> fibonacci(23)\n  341\n  >>> fibonacci(24)\n  610\n  >>> fibonacci(25)\n  981\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(25)\n  55\n  >>> fibonacci(26)\n  175\n  >>> fibonacci(27)\n  265\n  >>> fibonacci(28)\n  341\n  >>> fibonacci(29)\n  610\n  >>> fibonacci(30)\n  981\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(30)\n  55\n  >>> fibonacci(31)\n  175\n  >>> fibonacci(32)\n  265\n  >>> fibonacci(33)\n  341\n  >>> fibonacci(34)\n  610\n  >>> fibonacci(35)\n  981\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(35)\n  55\n  >>> fibonacci(36)\n  175\n  >>> fibonacci(37)\n  265\n  >>> fibonacci(38)\n  341\n  >>> fibonacci(39)\n  610\n  >>> fibonacci(40)\n  981\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(40)\n  55\n  >>> fibonacci(41)\n  175\n  >>> fibonacci(42)\n  265\n  >>> fibonacci(43)\n  341\n  >>> fibonacci(44)\n  610\n  >>> fibonacci(45)\n  981\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(45)\n  55\n  >>> fibonacci(46)\n  175\n  >>> fibonacci(47)\n  265\n  >>> fibonacci(48)\n  341\n  >>> fibonacci(49)\n  610\n  >>> fibonacci(50)\n  981\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(50)\n  55\n  >>> fibonacci(51)\n  175\n  >>> fibonacci(52)\n  265\n  >>> fibonacci(53)\n  341\n  >>> fibonacci(54)\n  610\n  >>> fibonacci(55)\n  981\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(55)\n  55\n  >>> fibonacci(56)\n  175\n  >>> fibonacci(57)\n  265\n  >>> fibonacci(58)\n  341\n  >>> fibonacci(59)\n  610\n  >>> fibonacci(60)\n  981\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(60)\n  55\n  >>> fibonacci(61)\n  175\n  >>> fibonacci(62)\n  265\n  >>> fibonacci(63)\n  341\n  >>> fibonacci(64)\n  610\n  >>> fibonacci(65)\n  981\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibonacci(65)\n  55\n  >>> fibonacci(66)\n  175\n  >>> fibonacci(67)\n  265\n  >>> fibonacci(68)\n  341\n  >>> fibonacci(69)\n  610\n  >>> fibonacci(70)\n  981\n*/\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n-1) + fibonacci(n-2);\n};\n\n/*\n  >>> fibon", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketnig(\"<\")\n  false\n  >>> correctBracketnig(\"<>\")\n  false\n  >>> correctBracketnig(\"<<><>>\")\n  false\n  >>> correctBracketnig(\"><<>\")\n  false\n  */\nconst correctBracketnig = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketnig", "gc": "<|endoftext|>/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketnig(\"<\")\n  false\n  >>> correctBracketnig(\"<>\")\n  false\n  >>> correctBracketnig(\"<<><>>\")\n  false\n  >>> correctBracketnig(\"><<>\")\n  false\n  */\nconst correctBracketnig = (brackets) => {\n  const openingBrackets = brackets.split(\"<\");\n  const closingBrackets = brackets.split(\">\");\n  return openingBrackets.every(opening => closingBrackets.every(closing => opening === closing));\n};\n\n/**\n * Returns true if a word is capitalized.\n *\n * >>> isCapitalized(\"hello\")\n * true\n * >>> isCapitalized(\"HELLO\")\n * true\n * >>> isCapitalized(\"helloWorld\")\n * false\n * >>> isCapitalized(\"HELLOWORLD\")\n * false\n */\nconst isCapitalized = (word) => {\n  return word[0].toUpperCase() === word;\n};\n\n/**\n * Returns true if a word is all caps.\n *\n * >>> isAllCaps(\"hello\")\n * true\n * >>> isAllCaps(\"HELLO\")\n * true\n * >>> isAllCaps(\"helloWorld\")\n * false\n * >>> isAllCaps(\"HELLOWORLD\")\n * false\n */\nconst isAllCaps = (word) => {\n  return word[0] === word[0].toUpperCase() && word[1] === word[1].toUpperCase();\n};\n\n/**\n * Returns true if a word is all lowercase.\n *\n * >>> isAllLowercase(\"hello\")\n * true\n * >>> isAllLowercase(\"HELLO\")\n * true\n * >>> isAllLowercase(\"helloWorld\")\n * false\n * >>> isAllLowercase(\"HELLOWORLD\")\n * false\n */\nconst isAllLowercase = (word) => {\n  return word[0] === word[0].toLowerCase();\n};\n\n/**\n * Returns true if a word is all uppercase.\n *\n * >>> isAllUppercase(\"hello\")\n * true\n * >>> isAllUppercase(\"HELLO\")\n * true\n * >>> isAllUppercase(\"helloWorld\")\n * false\n * >>> isAllUppercase(\"HELLOWORLD\")\n * false\n */\nconst isAllUppercase = (word) => {\n  return word[0] === word[0].toUpperCase() && word[1] === word[1].toLowerCase();\n};\n\n/**\n * Returns true if a word is all numeric.\n *\n * >>> isAllNumeric(\"hello\")\n * true\n * >>> isAllNumeric(\"HELLO\")\n * true\n * >>> isAllNumeric(\"helloWorld\")\n * false\n * >>> isAllNumeric(\"HELLOWORLD\")\n * false\n */\nconst isAllNumeric = (word) => {\n  return word[0] === word[0] && word[1] === word[1] && word[2] === word[2];\n};\n\n/**\n * Returns true if a word is all punctuation.\n *\n * >>> isAllPunctuation(\"hello\")\n * true\n * >>> isAllPunctuation(\"HELLO\")\n * true\n * >>> isAllPunctuation(\"helloWorld\")\n * false\n * >>> isAllPunctuation(\"HELLOWORLD\")\n * false\n */\nconst isAllPunctuation = (word) => {\n  return word[0] === word[0] && word[1] === word[1] && word[2] === word[2] && word[3] === word[3];\n};\n\n/**\n * Returns true if a word is all uppercase and all lowercase.\n *\n * >>> isAllUppercaseAndAllLowercase(\"hello\")\n * true\n * >>> isAllUppercaseAndAllLowercase(\"HELLO\")\n * true\n * >>> isAllUppercaseAndAllLowercase(\"helloWorld\")\n * false\n * >>> isAllUppercaseAndAllLowercase(\"HELLOWORLD\")\n * false\n */\nconst isAllUppercaseAndAllLowercase = (word) => {\n  return isAllUppercase(word) && isAllLowercase(word);\n};\n\n/**\n * Returns true if a word is all uppercase and all numeric.\n *\n * >>> isAllUppercaseAndAllNumeric(\"hello\")\n * true\n * >>> isAllUppercaseAndAllNumeric(\"HELLO\")\n * true\n * >>> isAllUppercaseAndAllNumeric(\"helloWorld\")\n * false\n * >>> isAllUppercaseAndAllNumeric(\"HELLOWORLD\")\n * false\n */\nconst isAllUppercaseAndAllNumeric = (word) => {\n  return isAllUppercase(word) && isAllNumeric(word);\n};\n\n/**\n * Returns true if a word is all uppercase and all punctuation.\n *\n * >>> isAllUppercaseAndAllPunctuation(\"hello\")\n * true\n * >>> isAllUppercaseAndAllPunctuation(\"HELLO\")\n * true\n * >>> isAllUppercaseAndAllPunctuation(\"helloWorld\")\n * false\n * >>> isAllUppercaseAndAllPunctuation(\"HELLOWORLD\")\n * false\n */\nconst isAllUppercaseAndAllPunctuation = (word) => {\n  return isAllUppercase(word) && isAllPunctuation(word);\n};\n\n/**\n * Returns true if a word is all lowercase and all uppercase.\n *\n * >>> isAllLowercaseAndAllUppercase(\"hello\")\n * true\n * >>> isAllLowercaseAndAllUppercase(\"HELLO\")\n * true\n * >>> isAllLowercaseAndAllUppercase(\"helloWorld\")\n * false\n * >>> isAllLowercaseAndAllUppercase(\"HELLOWORLD\")\n * false\n */\nconst isAllLowercaseAndAllUppercase = (word) => {\n  return isAllLowercase(word) && isAllUppercase(word);\n};\n\n/**\n * Returns true if a word is all lowercase and all numeric.\n *\n * >>> isAllLowercaseAndAllNumeric(\"hello\")\n * true\n * >>> isAllLowercaseAndAllNumeric(\"HELLO\")\n * true\n * >>> isAllLowercaseAndAllNumeric(\"helloWorld\")\n * false\n * >>> isAllLowercaseAndAllNumeric(\"HELLOWORLD\")\n * false\n */\nconst isAllLowercaseAndAllNumeric = (word) => {\n  return isAllLowercase(word) && isAllNumeric(word);\n};\n\n/**\n * Returns true if a word is all lowercase and all punctuation.\n *\n * >>> isAllLowercaseAndAllPunctuation(\"hello\")\n * true\n * >>> isAllLowercaseAndAllPunctuation(\"HELLO\")\n * true\n * >>> isAllLowercaseAndAllPunctuation(\"helloWorld\")\n * false\n * >>> isAllLowercaseAndAllPunctuation(\"HELLOWORLD\")\n * false\n */\nconst isAllLowercaseAndAllPunctuation = (word) => {\n  return isAllLowercase(word) && isAllPunctuation(word);\n};\n\n/**\n * Returns true if a word is all uppercase and all lowercase.\n *\n * >>> isAllUppercaseAndAllLowercase(\"hello\")\n * true\n * >>> isAllUppercaseAndAllLowercase(\"HELLO\")\n * true\n * >>> isAllUppercaseAndAllLowercase(\"helloWorld\")\n * false\n * >>> isAllUppercaseAndAllLowercase(\"HELLOWORLD\")\n * false", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/57", "prompt": "/*Return true is list elements are montoonically increasing or decreasing.\n  >>> montoonic([1, 2, 4, 20])\n  true\n  >>> montoonic([1, 20, 4, 10])\n  false\n  >>> montoonic([4, 1, 0, -10])\n  true\n  */\nconst montoonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "montoonic", "gc": "<|endoftext|>/*Return true is list elements are montoonically increasing or decreasing.\n  >>> montoonic([1, 2, 4, 20])\n  true\n  >>> montoonic([1, 20, 4, 10])\n  false\n  >>> montoonic([4, 1, 0, -10])\n  true\n  */\nconst montoonic = (l) => {\n  let n = l.length;\n  let m = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l1 = [];\n  let l2 = [];\n  let l3 = [];\n  let l4 = [];\n  let l5 = [];\n  let l6 = [];\n  let l7 = [];\n  let l8 = [];\n  let l9 = [];\n  let l10 = [];\n  let l11 = [];\n  let l12 = [];\n  let l13 = [];\n  let l14 = [];\n  let l15 = [];\n  let l16 = [];\n  let l17 = [];\n  let l18 = [];\n  let l19 = [];\n  let l20 = [];\n  let l21 = [];\n  let l22 = [];\n  let l23 = [];\n  let l24 = [];\n  let l25 = [];\n  let l26 = [];\n  let l27 = [];\n  let l28 = [];\n  let l29 = [];\n  let l30 = [];\n  let l31 = [];\n  let l32 = [];\n  let l33 = [];\n  let l34 = [];\n  let l35 = [];\n  let l36 = [];\n  let l37 = [];\n  let l38 = [];\n  let l39 = [];\n  let l40 = [];\n  let l41 = [];\n  let l42 = [];\n  let l43 = [];\n  let l44 = [];\n  let l45 = [];\n  let l46 = [];\n  let l47 = [];\n  let l48 = [];\n  let l49 = [];\n  let l50 = [];\n  let l51 = [];\n  let l52 = [];\n  let l53 = [];\n  let l54 = [];\n  let l55 = [];\n  let l56 = [];\n  let l57 = [];\n  let l58 = [];\n  let l59 = [];\n  let l60 = [];\n  let l61 = [];\n  let l62 = [];\n  let l63 = [];\n  let l64 = [];\n  let l65 = [];\n  let l66 = [];\n  let l67 = [];\n  let l68 = [];\n  let l69 = [];\n  let l70 = [];\n  let l71 = [];\n  let l72 = [];\n  let l73 = [];\n  let l74 = [];\n  let l75 = [];\n  let l76 = [];\n  let l77 = [];\n  let l78 = [];\n  let l79 = [];\n  let l80 = [];\n  let l81 = [];\n  let l82 = [];\n  let l83 = [];\n  let l84 = [];\n  let l85 = [];\n  let l86 = [];\n  let l87 = [];\n  let l88 = [];\n  let l89 = [];\n  let l90 = [];\n  let l91 = [];\n  let l92 = [];\n  let l93 = [];\n  let l94 = [];\n  let l95 = [];\n  let l96 = [];\n  let l97 = [];\n  let l98 = [];\n  let l99 = [];\n  let l100 = [];\n  let l101 = [];\n  let l102 = [];\n  let l103 = [];\n  let l104 = [];\n  let l105 = [];\n  let l106 = [];\n  let l107 = [];\n  let l108 = [];\n  let l109 = [];\n  let l110 = [];\n  let l111 = [];\n  let l112 = [];\n  let l113 = [];\n  let l114 = [];\n  let l115 = [];\n  let l116 = [];\n  let l117 = [];\n  let l118 = [];\n  let l119 = [];\n  let l120 = [];\n  let l121 = [];\n  let l122 = [];\n  let l123 = [];\n  let l124 = [];\n  let l125 = [];\n  let l126 = [];\n  let l127 = [];\n  let l128 = [];\n  let l129 = [];\n  let l130 = [];\n  let l131 = [];\n  let l132 = [];\n  let l133 = [];\n  let l134 = [];\n  let l135 = [];\n  let l136 = [];\n  let l137 = [];\n  let l138 = [];\n  let l139 = [];\n  let l140 = [];\n  let l141 = [];\n  let l142 = [];\n  let l143 = [];\n  let l144 = [];\n  let l145 = [];\n  let l146 = [];\n  let l147 = [];\n  let l148 = [];\n  let l149 = [];\n  let l150 = [];\n  let l151 = [];\n  let l152 = [];\n  let l153 = [];\n  let l154 = [];\n  let l155 = [];\n  let l156 = [];\n  let l157 = [];\n  let l158 = [];\n  let l159 = [];\n  let l160 = [];\n  let l161 = [];\n  let l162 = [];\n  let l163 = [];\n  let l164 = [];\n  let l165 = [];\n  let l166 = [];\n  let l167 = [];\n  let l168 = [];\n  let l169 = [];\n  let l170 = [];\n  let l171 = [];\n  let l172 = [];\n  let l173 = [];\n  let l174 = [];\n  let l175 = [];\n  let l176 = [];\n  let l177 = [];\n  let l178 = [];\n  let l179 = [];\n  let l180 = [];\n  let l181 = [];\n  let l182 = [];\n  let l183 = [];\n  let l184 = [];\n  let l185 = [];\n  let l186 = [];\n  let l187 = [];\n  let l188 = [];\n  let l189 = [];\n  let l190 = [];\n  let l191 = [];\n  let l192 = [];\n  let l193 = [];\n  let l194 = [];\n  let l195 = [];\n  let l196 = [];\n  let l197 = [];\n  let l198 = [];\n  let l199 = [];\n  let l200 = [];\n  let l201 = [];\n  let l202 = [];\n  let l203 = [];\n  let l204 = [];\n  let l205 = [];\n  let l206 = [];\n  let l207 = [];\n  let l208 = [];\n  let l209 = [];\n  let l210 = [];\n  let l211 = [];\n  let l212 = [];\n  let l213 = [];\n  let l214 = [];\n  let l215 = [];\n  let l216 = [];\n  let l217 = [];\n  let l218 = [];\n  let l219 = [];\n  let l220 = [];\n  let l221 = [];\n  let l222 = [];\n  let l223 = [];\n  let l224 = [];\n  let l225 = [];\n  let l226 = [];\n  let l227 = [];\n  let l228 = [];\n  let l229 = [];\n  let l230 = [];\n  let l231 = [];\n  let l232 = [];\n  let l233 = [];\n  let l234 = [];\n  let l235 = [];\n  let l236 = [];\n  let l237 = [];\n  let l238 = [];\n  let l239 = [];\n  let l240 = [];\n  let l241 = [];\n  let l242 = [];\n  let l243 = [];\n  let l244 = [];\n  let l245 = [];\n  let l246 = [];\n  let l247 = [];\n  let l248 = [];\n  let l249 = [];\n  let l250 = [];\n  let l251 = [];\n  let l252 = [];\n  let l253 = [];\n  let l254 = [];\n  let l255 = [];\n  let l256 = [];\n  let l257 = [];\n  let l258 = [];\n  let l259 = [];\n  let l260 = [];\n  let l261 = [];\n  let l262 = [];\n  let l263 = [];\n  let l264 = [];\n  let l265 = [];\n  let l266 = [];\n  let l267 = [];\n  let l268 = [];\n  let l269 = [];\n  let l270 = [];\n  let l271 = [];\n  let l272 = ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "gc": "<|endoftext|>/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < l1.length && j < l2.length) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (k === 0) {\n        result.push(l1[i])\n        i++\n      } else {\n        result.push(l1[i])\n        k++\n      }\n    }\n  }\n  return result\n}\n\n/*Return sorted unique elements for two lists.\n  >>> unique([1, 2, 3, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, 5]\n  >>> unique([1, 2, 3, 4, 5])\n  [1, 2, 3, 4, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largetsPrimeFactor(13195)\n  29\n  >>> largetsPrimeFactor(2048)\n  2\n  */\nconst largetsPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largetsPrimeFactor", "gc": "<|endoftext|>/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largetsPrimeFactor(13195)\n  29\n  >>> largetsPrimeFactor(2048)\n  2\n  */\nconst largetsPrimeFactor = (n) => {\n  let i = 2;\n  let factor = 1;\n  while (n >= i) {\n    if (n % i === 0) {\n      n = Math.floor(n / i);\n      factor *= i;\n    }\n    i++;\n  }\n  return factor;\n};\n\n/*\n  Given a number n, return true if n is a prime number.\n  >>> isPrime(13195)\n  true\n  >>> isPrime(2048)\n  false\n  */\nconst isPrime = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return false;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  if (n % 7 === 0) {\n    return false;\n  }\n  return true;\n};\n\n/*\n  Given a number n, return true if n is a composite number.\n  >>> isComposite(13195)\n  true\n  >>> isComposite(2048)\n  false\n  */\nconst isComposite = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  if (n % 3 === 0) {\n    return true;\n  }\n  if (n % 5 === 0) {\n    return false;\n  }\n  if (n % 7 === 0) {\n    return false;\n  }\n  return true;\n};\n\n/*\n  Given a number n, return true if n is a composite number that is\n  composite of itself.\n  >>> isCompositeOf(3, 5)\n  true\n  >>> isCompositeOf(3, 7)\n  false\n  */\nconst isCompositeOf = (n1, n2) => {\n  if (n1 === n2) {\n    return true;\n  }\n  if (n1 === 1) {\n    return false;\n  }\n  if (n2 === 1) {\n    return false;\n  }\n  if (n1 === 2) {\n    return true;\n  }\n  if (n2 === 2) {\n    return false;\n  }\n  if (n1 === 3) {\n    return true;\n  }\n  if (n2 === 3) {\n    return false;\n  }\n  if (n1 === 5) {\n    return true;\n  }\n  if (n2 === 5) {\n    return false;\n  }\n  if (n1 === 7) {\n    return true;\n  }\n  if (n2 === 7) {\n    return false;\n  }\n  return false;\n};\n\n/*\n  Given a number n, return true if n is a composite number that is\n  composite of itself.\n  >>> isCompositeOf(3, 5)\n  true\n  >>> isCompositeOf(3, 7)\n  false\n  */\nconst isCompositeOf = (n1, n2) => {\n  if (n1 === n2) {\n    return true;\n  }\n  if (n1 === 1) {\n    return false;\n  }\n  if (n2 === 1) {\n    return false;\n  }\n  if (n1 === 2) {\n    return true;\n  }\n  if (n2 === 2) {\n    return false;\n  }\n  if (n1 === 3) {\n    return true;\n  }\n  if (n2 === 3) {\n    return false;\n  }\n  if (n1 === 5) {\n    return true;\n  }\n  if (n2 === 5) {\n    return false;\n  }\n  if (n1 === 7) {\n    return true;\n  }\n  if (n2 === 7) {\n    return false;\n  }\n  return false;\n};\n\n/*\n  Given a number n, return true if n is a composite number that is\n  composite of itself.\n  >>> isCompositeOf(3, 5)\n  true\n  >>> isCompositeOf(3, 7)\n  false\n  */\nconst isCompositeOf = (n1, n2) => {\n  if (n1 === n2) {\n    return true;\n  }\n  if (n1 === 1) {\n    return false;\n  }\n  if (n2 === 1) {\n    return false;\n  }\n  if (n1 === 2) {\n    return true;\n  }\n  if (n2 === 2) {\n    return false;\n  }\n  if (n1 === 3) {\n    return true;\n  }\n  if (n2 === 3) {\n    return false;\n  }\n  if (n1 === 5) {\n    return true;\n  }\n  if (n2 === 5) {\n    return false;\n  }\n  if (n1 === 7) {\n    return true;\n  }\n  if (n2 === 7) {\n    return false;\n  }\n  return false;\n};\n\n/*\n  Given a number n, return true if n is a composite number that is\n  composite of itself.\n  >>> isCompositeOf(3, 5)\n  true\n  >>> isCompositeOf(3, 7)\n  false\n  */\nconst isCompositeOf = (n1, n2) => {\n  if (n1 === n2) {\n    return true;\n  }\n  if (n1 === 1) {\n    return false;\n  }\n  if (n2 === 1) {\n    return false;\n  }\n  if (n1 === 2) {\n    return true;\n  }\n  if (n2 === 2) {\n    return false;\n  }\n  if (n1 === 3) {\n    return true;\n  }\n  if (n2 === 3) {\n    return false;\n  }\n  if (n1 === 5) {\n    return true;\n  }\n  if (n2 === 5) {\n    return false;\n  }\n  if (n1 === 7) {\n    return true;\n  }\n  if (n2 === 7) {\n    return false;\n  }\n  return false;\n};\n\n/*\n  Given a number n, return true if n is a composite number that is\n  composite of itself.\n  >>> isCompositeOf(3, 5)\n  true\n  >>> isCompositeOf(3, 7)\n  false\n  */\nconst isCompositeOf = (n1, n2) => {\n  if (n1 === n2) {\n    return true;\n  }\n  if (n1 === 1) {\n    return false;\n  }\n  if (n2 === 1) {\n    return false;\n  }\n  if (n1 === 2) {\n    return true;\n  }\n  if (n2 === 2) {\n    return false;\n  }\n  if (n1 === 3) {\n    return true;\n  }\n  if (n2 === 3) {\n    return false;\n  }\n  if (n1 === 5) {\n    return true;\n  }\n  if (n2 === 5) {\n    return false;\n  }\n  if (n1 === 7) {\n    return true;\n  }\n  if (n2 === 7) {\n    return false;\n  }\n  return false;\n};\n\n/*\n  Given a number n, return true if n is a composite number that is\n  composite of itself.\n  >>> isCompositeOf(3, 5)\n  true\n  >>> isCompositeOf(3, 7)\n  false\n  */\nconst isCompositeOf = (n1, n2) => {\n  if (n1 === n2) {\n    return true;\n  }\n  if (n1 === 1) {\n    return false;\n  }\n  if (n2 === 1) {\n    return false;\n  }\n  if (n1 === 2) {\n    return true;\n  }\n  if (n2 === 2) {\n    return false;\n  }\n  if (n1 === 3) {\n    return true;\n  }\n  if (n2 === 3) {\n    return false;\n  }\n  if (n1 === 5) {\n    return true;\n  }\n  if (n2 === 5) {\n    return false;\n  }\n  if (n1 === 7) {\n    return true;\n  }\n  if (n2 === 7) {\n    return false;\n  }\n  return false;\n};\n\n/*\n  Given a number n, return true if n is a composite number that is\n  composite of itself.\n  >>> isCompositeOf(3, 5)\n  true\n  >>> isCompositeOf(3, 7)\n  false\n  */\nconst isCompositeOf = (n1, n2) => {\n  if (n1 === n2) {\n    return true;\n  }\n  if (n1 === 1) {\n    return false;\n  }\n  if (n2 === 1) {\n    return false;\n  }\n  if (n1 === 2) {\n    return true;\n  }\n  if (n2 === 2) {\n    return false;\n  }\n  if (n1 === 3) {\n    return true;\n  }\n  if (n2 === 3) {\n    return false;\n  }\n  if (n1 === 5) {\n    return true;\n  }\n  if (n2 === 5) {\n    return false;\n  }\n  if (n1 === 7) {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/6", "prompt": "/* Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n  For each of the group, output the deepest level of nesting of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNetsedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNetsedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNetsedParens", "gc": "<|endoftext|>/* Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n  For each of the group, output the deepest level of nesting of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNetsedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNetsedParens = (paren_string) => {\n  const paren_groups = paren_string.split(/\\s+/g);\n  const paren_levels = [];\n  let paren_level = 0;\n  for (let i = 0; i < paren_groups.length; i++) {\n    const group = paren_groups[i];\n    if (group.length > 1) {\n      paren_levels.push(paren_level);\n      paren_level = 0;\n    }\n    if (group[0] === '(') {\n      paren_level++;\n    } else if (group[group.length - 1] === ')') {\n      paren_level--;\n    }\n  }\n  return paren_levels;\n};\n\nconst parseNetsedParensString = (paren_string) => {\n  const paren_levels = parseNetsedParens(paren_string);\n  const paren_level_string = paren_levels.map((level) => paren_string.slice(0, level * paren_string.length));\n  return paren_level_string.join(' ');\n};\n\nconst parseNetsedParensArray = (paren_string) => {\n  const paren_levels = parseNetsedParens(paren_string);\n  const paren_level_string = paren_levels.map((level) => paren_string.slice(0, level * paren_string.length));\n  return paren_level_string.join(' ');\n};\n\nconst parseNetsedParensObject = (paren_string) => {\n  const paren_levels = parseNetsedParens(paren_string);\n  const paren_level_string = paren_levels.map((level) => paren_string.slice(0, level * paren_string.length));\n  return paren_level_string.join(' ');\n};\n\nconst parseNetsedParensArrayObject = (paren_string) => {\n  const paren_levels = parseNetsedParens(paren_string);\n  const paren_level_string = paren_levels.map((level) => paren_string.slice(0, level * paren_string.length));\n  return paren_level_string.join(' ');\n};\n\nconst parseNetsedParensObjectArray = (paren_string) => {\n  const paren_levels = parseNetsedParens(paren_string);\n  const paren_level_string = paren_levels.map((level) => paren_string.slice(0, level * paren_string.length));\n  return paren_level_string.join(' ');\n};\n\nconst parseNetsedParensObjectArrayObject = (paren_string) => {\n  const paren_levels = parseNetsedParens(paren_string);\n  const paren_level_string = paren_levels.map((level) => paren_string.slice(0, level * paren_string.length));\n  return paren_level_string.join(' ');\n};\n\nconst parseNetsedParensObjectArrayObjectArray = (paren_string) => {\n  const paren_levels = parseNetsedParens(paren_string);\n  const paren_level_string = paren_levels.map((level) => paren_string.slice(0, level * paren_string.length));\n  return paren_level_string.join(' ');\n};\n\nconst parseNetsedParensObjectArrayObjectArrayObject = (paren_string) => {\n  const paren_levels = parseNetsedParens(paren_string);\n  const paren_level_string = paren_levels.map((level) => paren_string.slice(0, level * paren_string.length));\n  return paren_level_string.join(' ');\n};\n\nconst parseNetsedParensObjectArrayObjectArrayObjectArray = (paren_string) => {\n  const paren_levels = parseNetsedParens(paren_string);\n  const paren_level_string = paren_levels.map((level) => paren_string.slice(0, level * paren_string.length));\n  return paren_level_string.join(' ');\n};\n\nconst parseNetsedParensObjectArrayObjectArrayObjectArrayObjectArrayObjectArray = (paren_string) => {\n  const paren_levels = parseNetsedParens(paren_string);\n  const paren_level_string = paren_levels.map((level) => paren_string.slice(0, level * paren_string.length));\n  return paren_level_string.join(' ');\n};\n\nconst parseNetsedParensObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArray", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "gc": "<|endoftext|>/*sumToN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that returns the sum of the numbers from 1 to n.\n * It also returns the sum of the squares of the numbers from 1 to n.\n * It also returns the sum of the cubes of the numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the prime numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also returns the sum of the natural numbers from 1 to n.\n * It also ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketnig(\"(\")\n  false\n  >>> correctBracketnig(\"()\")\n  true\n  >>> correctBracketnig(\"(()())\")\n  true\n  >>> correctBracketnig(\")(()\")\n  false\n  */\nconst correctBracketnig = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketnig", "gc": "<|endoftext|>/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketnig(\"(\")\n  false\n  >>> correctBracketnig(\"()\")\n  true\n  >>> correctBracketnig(\"(()())\")\n  true\n  >>> correctBracketnig(\")(()\")\n  false\n  */\nconst correctBracketnig = (brackets) => {\n  const openingBrackets = brackets.split('(');\n  const closingBrackets = brackets.split(')');\n  return openingBrackets.every(opening => closingBrackets.every(closing => opening === closing));\n};\n\n/**\n * Given a string, return true if it starts with \"@\".\n *\n * >>> isAt('@')\n * true\n * >>> isAt('@a')\n * false\n */\nconst isAt = (string) => {\n  return string.startsWith('@');\n};\n\n/**\n * Given a string, return true if it ends with \"@\".\n *\n * >>> isAt('@a')\n * true\n * >>> isAt('@z')\n * false\n */\nconst isAtEnd = (string) => {\n  return string.endsWith('@');\n};\n\n/**\n * Given a string, return true if it starts with \"@\".\n *\n * >>> isAt('@a')\n * true\n * >>> isAt('@z')\n * false\n */\nconst isAtStar = (string) => {\n  return string.startsWith('@');\n};\n\n/**\n * Given a string, return true if it ends with \"@\".\n *\n * >>> isAt('@a')\n * true\n * >>> isAt('@z')\n * false\n */\nconst isAtStarEnd = (string) => {\n  return string.endsWith('@');\n};\n\n/**\n * Given a string, return true if it starts with \"@\".\n *\n * >>> isAt('@a')\n * true\n * >>> isAt('@z')\n * false\n */\nconst isAtStarStar = (string) => {\n  return string.startsWith('@');\n};\n\n/**\n * Given a string, return true if it ends with \"@\".\n *\n * >>> isAt('@a')\n * true\n * >>> isAt('@z')\n * false\n */\nconst isAtStarStarEnd = (string) => {\n  return string.endsWith('@');\n};\n\n/**\n * Given a string, return true if it starts with \"@\".\n *\n * >>> isAt('@a')\n * true\n * >>> isAt('@z')\n * false\n */\nconst isAtStarStarStar = (string) => {\n  return string.startsWith('@');\n};\n\n/**\n * Given a string, return true if it ends with \"@\".\n *\n * >>> isAt('@a')\n * true\n * >>> isAt('@z')\n * false\n */\nconst isAtStarStarStarEnd = (string) => {\n  return string.endsWith('@');\n};\n\n/**\n * Given a string, return true if it starts with \"@\".\n *\n * >>> isAt('@a')\n * true\n * >>> isAt('@z')\n * false\n */\nconst isAtStarStarStarStar = (string) => {\n  return string.startsWith('@');\n};\n\n/**\n * Given a string, return true if it ends with \"@\".\n *\n * >>> isAt('@a')\n * true\n * >>> isAt('@z')\n * false\n */\nconst isAtStarStarStarEnd = (string) => {\n  return string.endsWith('@');\n};\n\n/**\n * Given a string, return true if it starts with \"@\".\n *\n * >>> isAt('@a')\n * true\n * >>> isAt('@z')\n * false\n */\nconst isAtStarStarStarStar = (string) => {\n  return string.startsWith('@');\n};\n\n/**\n * Given a string, return true if it ends with \"@\".\n *\n * >>> isAt('@a')\n * true\n * >>> isAt('@z')\n * false\n */\nconst isAtStarStarStarStarEnd = (string) => {\n  return string.endsWith('@');\n};\n\n/**\n * Given a string, return true if it starts with \"@\".\n *\n * >>> isAt('@a')\n * true\n * >>> isAt('@z')\n * false\n */\nconst isAtStarStarStarStarStar = (string) => {\n  return string.startsWith('@');\n};\n\n/**\n * Given a string, return true if it ends with \"@\".\n *\n * >>> isAt('@a')\n * true\n * >>> isAt('@z')\n * false\n */\nconst isAtStarStarStarStarEnd = (string) => {\n  return string.endsWith('@');\n};\n\n/**\n * Given a string, return true if it starts with \"@\".\n *\n * >>> isAt('@a')\n * true\n * >>> isAt('@z')\n * false\n */\nconst isAtStarStarStarStarStar = (string) => {\n  return string.startsWith('@');\n};\n\n/**\n * Given a string, return true if it ends with \"@\".\n *\n * >>> isAt('@a')\n * true\n * >>> isAt('@z')\n * false\n */\nconst isAtStarStarStarStarStarEnd = (string) => {\n  return string.endsWith('@');\n};\n\n/**\n * Given a string, return true if it starts with \"@\".\n *\n * >>> isAt('@a')\n * true\n * >>> isAt('@z')\n * false\n */\nconst isAtStarStarStarStarStarStar = (string) => {\n  return string.startsWith('@');\n};\n\n/**\n * Given a string, return true if it ends with \"@\".\n *\n * >>> isAt('@a')\n * true\n * >>> isAt('@z')\n * false\n */\nconst isAtStarStarStarStarStarStarEnd = (string) => {\n  return string.endsWith('@');\n};\n\n/**\n * Given a string, return true if it starts with \"@\".\n *\n * >>> isAt('@a')\n * true\n * >>> isAt('@z')\n * false\n */\nconst isAtStarStarStarStarStarStarStar = (string) => {\n  return string.startsWith('@');\n};\n\n/**\n * Given a string, return true if it ends with \"@\".\n *\n * >>> isAt('@a')\n * true\n * >>> isAt('@z')\n * false\n */\nconst isAtStarStarStarStarStarStarEnd = (string) => {\n  return string.endsWith('@');\n};\n\n/**\n * Given a string, return true if it starts with \"@\".\n *\n * >>> isAt('@a')\n * true\n * >>> isAt('@z')\n * false\n */\nconst isAtStarStarStarStarStarStarStar = (string) => {\n  return string.startsWith('@');\n};\n\n/**\n * Given a string, return true if it ends with \"@\".\n *\n * >>> isAt('@a')\n * true\n * >>> isAt('@z')\n * false\n */\nconst isAtStarStarStarStarStarStarEnd = (string) => {\n  return string.endsWith('@');\n};\n\n/**\n * Given a string, return true if it starts with \"@\".\n *\n * >>> isAt('@a')\n * true\n * >>> isAt('@z')\n * false\n */\nconst isAtStarStarStarStarStarStarStar = (string) => {\n  return string.startsWith('@');\n};\n\n/**\n * Given a string, return true if it ends with \"@\".", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "gc": "<|endoftext|>/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  let n = 0;\n  let d = 1;\n  for (let i = 0; i < xs.length; i++) {\n    n += xs[i] * d;\n    d *= xs[i];\n  }\n  return n;\n};\n\n// Returns true if the given point is inside the polygon.\nconst isPointInsidePolygon = (p, polygon) => {\n  let inside = false;\n  let x = 0;\n  let y = 0;\n  for (let i = 0; i < polygon.length; i++) {\n    let p = polygon[i];\n    if (p[0] > x && p[0] < x + polygon[0][2] &&\n        p[1] > y && p[1] < y + polygon[0][3]) {\n      inside = true;\n      break;\n    }\n    x += polygon[0][0];\n    y += polygon[0][1];\n  }\n  return inside;\n};\n\n// Returns true if the given point is inside the polygon.\nconst isPointInsidePolygons = (points, polygons) => {\n  let inside = false;\n  let x = 0;\n  let y = 0;\n  for (let i = 0; i < points.length; i++) {\n    let p = points[i];\n    if (p[0] > x && p[0] < x + polygons[0][2] &&\n        p[1] > y && p[1] < y + polygons[0][3]) {\n      inside = true;\n      break;\n    }\n    x += polygons[0][0];\n    y += polygons[0][1];\n  }\n  return inside;\n};\n\n// Returns true if the given point is inside the polygon.\nconst isPointInsidePolygonsPoint = (p, polygons) => {\n  let inside = false;\n  let x = 0;\n  let y = 0;\n  for (let i = 0; i < polygons.length; i++) {\n    let p = polygons[i];\n    if (p[0] > x && p[0] < x + polygons[i][0] &&\n        p[1] > y && p[1] < y + polygons[i][1]) {\n      inside = true;\n      break;\n    }\n    x += polygons[i][0];\n    y += polygons[i][1];\n  }\n  return inside;\n};\n\n// Returns true if the given point is inside the polygon.\nconst isPointInsidePolygonsPoints = (points, polygons) => {\n  let inside = false;\n  let x = 0;\n  let y = 0;\n  for (let i = 0; i < points.length; i++) {\n    let p = points[i];\n    if (p[0] > x && p[0] < x + polygons[i][0] &&\n        p[1] > y && p[1] < y + polygons[i][1]) {\n      inside = true;\n      break;\n    }\n    x += polygons[i][0];\n    y += polygons[i][1];\n  }\n  return inside;\n};\n\n// Returns true if the given point is inside the polygon.\nconst isPointInsidePolygonsPointsPoint = (p, polygons) => {\n  let inside = false;\n  let x = 0;\n  let y = 0;\n  for (let i = 0; i < polygons.length; i++) {\n    let p = polygons[i];\n    if (p[0] > x && p[0] < x + polygons[i][0] &&\n        p[1] > y && p[1] < y + polygons[i][1]) {\n      inside = true;\n      break;\n    }\n    x += polygons[i][0];\n    y += polygons[i][1];\n  }\n  return inside;\n};\n\n// Returns true if the given point is inside the polygon.\nconst isPointInsidePolygonsPointsPoints = (points, polygons) => {\n  let inside = false;\n  let x = 0;\n  let y = 0;\n  for (let i = 0; i < points.length; i++) {\n    let p = points[i];\n    if (p[0] > x && p[0] < x + polygons[i][0] &&\n        p[1] > y && p[1] < y + polygons[i][1]) {\n      inside = true;\n      break;\n    }\n    x += polygons[i][0];\n    y += polygons[i][1];\n  }\n  return inside;\n};\n\n// Returns true if the given point is inside the polygon.\nconst isPointInsidePolygonsPointsPointsPoint = (p, polygons) => {\n  let inside = false;\n  let x = 0;\n  let y = 0;\n  for (let i = 0; i < polygons.length; i++) {\n    let p = polygons[i];\n    if (p[0] > x && p[0] < x + polygons[i][0] &&\n        p[1] > y && p[1] < y + polygons[i][1]) {\n      inside = true;\n      break;\n    }\n    x += polygons[i][0];\n    y += polygons[i][1];\n  }\n  return inside;\n};\n\n// Returns true if the given point is inside the polygon.\nconst isPointInsidePolygonsPointsPointsPoints = (points, polygons) => {\n  let inside = false;\n  let x = 0;\n  let y = 0;\n  for (let i = 0; i < points.length; i++) {\n    let p = points[i];\n    if (p[0] > x && p[0] < x + polygons[i][0] &&\n        p[1] > y && p[1] < y + polygons[i][1]) {\n      inside = true;\n      break;\n    }\n    x += polygons[i][0];\n    y += polygons[i][1];\n  }\n  return inside;\n};\n\n// Returns true if the given point is inside the polygon.\nconst isPointInsidePolygonsPointsPointsPointsPoint = (p, polygons) => {\n  let inside = false;\n  let x = 0;\n  let y = 0;\n  for (let i = 0; i < polygons.length; i++) {\n    let p = polygons[i];\n    if (p[0] > x && p[0] < x + polygons[i][0] &&\n        p[1] > y && p[1] < y + polygons[i][1]) {\n      inside = true;\n      break;\n    }\n    x += polygons[i][0];\n    y += polygons[i][1];\n  }\n  return inside;\n};\n\n// Returns true if the given point is inside the polygon.\nconst isPointInsidePolygonsPointsPointsPointsPoints = (points, polygons) => {\n  let inside = false;\n  let x = 0;\n  let y = 0;\n  for (let i = 0; i < points.length; i++) {\n    let p = points[i];\n    if (p[0] > x && p[0] < x + polygons[i][0] &&\n        p[1] > y && p[1] < y + polygons[i][1]) {\n      inside = true;\n      break;\n    }\n    x += polygons[i][0];\n    y += polygons[i][1];\n  }\n  return inside;\n};\n\n// Returns true if the given point is inside the polygon.\nconst isPointInsidePolygonsPointsPointsPointsPointsPointsPoint = (p, polygons) => {\n  let inside = false;\n  let x = 0;\n  let y = 0;\n  for (let i = 0; i < polygons.length; i++) {\n    let p = polygons[i];\n    if (p[0] > x && p[0] < x + polygons[i][0] &&\n        p[1] > y && p[1] < y + polygons[i][1]) {\n      inside = true;\n      break;\n    }\n    x += polygons[i][0];\n    y += polygons[i][1];\n  }\n  return inside;\n};\n\n// Returns true if the given point is inside the polygon.\nconst isPointInsidePolygonsPointsPointsPointsPointsPointsPoints = (points, polygons) => {\n  let inside = false;\n  let x = 0;\n  let y = 0;\n  for (let i = 0; i < points.length; i++) {\n    let p = points[i];\n    if (p[0] > x && p[0] < x + polygons[i][0] &&\n        p[1] > y && p[1] < y + polygons[i][1]) {\n      inside = true;\n      break;\n    }\n    x += polygons[i][0];\n    y += polygons[i][1];\n  }\n  return inside;\n};\n\n// Returns true if the given point is inside the polygon.\nconst isPointInsidePolygonsPointsPointsPointsPointsPointsPointsPoint = (p, polygons) => {\n  let inside = false;\n  let x = 0;\n  let y = 0;\n  for (let i = 0; i < polygons.length; i++) {\n    let p = polygons[i];\n    if (p[0] > x && p[0] < x + polygons[i][0] &&\n        p[1] > y && p[1] < y + polygons[i][1]) {\n      inside = true;\n      break;\n    }\n    x += polygons[i][0];\n    y += polygons[i][1];\n  }\n  return inside;\n};\n\n// Returns true if the given point is inside the polygon.\nconst isPointIn", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "gc": "<|endoftext|>/*The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n <= 1) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the Fibonacci sequence up to n.\n  >>> fibonacci(10)\n  [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n  >>> fibonacci(20)\n  [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n  >>> fibonacci(30)\n  [1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n  >>> fibonacci(50)\n  [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]\n  >>> fibonacci(100)\n  [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233]\n  >>> fibonacci(1000)\n  [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]\n  >>> fibonacci(10000)\n  [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]\n  >>> fibonacci(1000000)\n  [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 1215]\n  >>> fibonacci(100000000)\n  [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 1215, 16383]\n  >>> fibonacci(1000000000)\n  [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 1215, 16383, 21373]\n  >>> fibonacci(10000000000)\n  [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 1215, 16383, 21373, 24151]\n  >>> fibonacci(100000000000)\n  [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 1215, 16383, 21373, 24151, 26287]\n  >>> fibonacci(1000000000000)\n  [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 1215, 16383, 21373, 24151, 26287, 29578]\n  >>> fibonacci(10000000000000)\n  [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 1215, 16383, 21373, 24151, 26287, 29578, 31361]\n  >>> fibonacci(100000000000000)\n  [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 1215, 16383, 21373, 24151, 26287, 29578, 31361, 34387]\n  >>> fibonacci(1000000000000000)\n  [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 1215, 16383, 21373, 24151, 26287, 29578, 31361, 34387, 41981]\n  >>> fibonacci(10000000000000000)\n  [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 1215, 16383, 21373, 24151, 26287, 29578, 31361, 34387, 41981, 46281]\n  >>> fibonacci(100000000000000000)\n  [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 1215, 16383, 21373, 24151, 26287, 29578, 31361, 34387, 41981, 46281, 514229]\n  >>> fibonacci(1000000000000000001)\n  [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 1215, 16383, 21373, 24151, 26287, 29578, 31361, 34387, 41981, 46281, 514229, 570319]\n  >>> fibonacci(1000000000000000002)\n  [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 1215, 16383, 21373, 24151, 26287, 29578, 31361, 34387, 41981, 46281, 514229, 570319, 6186999]\n  >>> fibonacci(1000000000000000003)\n  [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 1215, 16383, 21373, 24151, 26287, 29578, 31361, 34387, 41981, 46281, 514229, 570319, 6186999, 7036999]\n  >>> fibonacci(1000000000000000004)\n  [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 1215, 16383, 21373, 24151, 26287, 29578, 31361, 34387, 41981, 46281, 514229, 570319, 6186999, 7036999, 7199999]\n  >>> fibonacci(1000000000000000005)\n  [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 1215, 16383, 21373, 24151, 26287, 29578, 31361, 34387, 41981, 46281, 514229, 570319, 6186999, 7036999, 7199999, 8383999]\n  >>> fibonacci(1000000000000000006)\n  [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 1215, 16383, 21373, 24151, 26287, 29578, 31361, 34387, 41981, 46281, 514229, 570319, 6186999, 7036999, 7199999, 8383999, 9671998]\n  >>> fibonacci(1000000000000000007)\n  [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 1215, 16383, 21373, 24151, 26287, 29578, 31361, 34387, 41981, 46281, 514229, 570319, 6186999, 7036999, 7199999, 8383999, 9671998, 10139199]\n  >>> fibonacci(1000000000000000008)\n  [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 1215, 16383, 21373, 24151, 26287, 29578, 31361, 34387, 41981, 46281, 514229, 570319, 6186999, 7036999, 7199999, 8383999, 9671998, 10139199, 11579201]\n  >>> fibonacci(1000000000000000009)\n  [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 1215, 16", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/64", "prompt": "/*Write a function vowelsConut which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsConut(\"abcde\")\n  2\n  >>> vowelsConut(\"ACEDY\")\n  3\n  */\nconst vowelsConut = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsConut", "gc": "<|endoftext|>/*Write a function vowelsConut which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsConut(\"abcde\")\n  2\n  >>> vowelsConut(\"ACEDY\")\n  3\n  */\nconst vowelsConut = (s) => {\n  let vowels = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      vowels++;\n    }\n  }\n  return vowels;\n};\n\n/*Write a function vowelsConut which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsConut(\"abcde\")\n  2\n  >>> vowelsConut(\"ACEDY\")\n  3\n  */\nconst vowelsConut = (s) => {\n  let vowels = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      vowels++;\n    }\n  }\n  return vowels;\n};\n\n/*Write a function vowelsConut which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsConut(\"abcde\")\n  2\n  >>> vowelsConut(\"ACEDY\")\n  3\n  */\nconst vowelsConut = (s) => {\n  let vowels = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      vowels++;\n    }\n  }\n  return vowels;\n};\n\n/*Write a function vowelsConut which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsConut(\"abcde\")\n  2\n  >>> vowelsConut(\"ACEDY\")\n  3\n  */\nconst vowelsConut = (s) => {\n  let vowels = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      vowels++;\n    }\n  }\n  return vowels;\n};\n\n/*Write a function vowelsConut which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsConut(\"abcde\")\n  2\n  >>> vowelsConut(\"ACEDY\")\n  3\n  */\nconst vowelsConut = (s) => {\n  let vowels = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      vowels++;\n    }\n  }\n  return vowels;\n};\n\n/*Write a function vowelsConut which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsConut(\"abcde\")\n  2\n  >>> vowelsConut(\"ACEDY\")\n  3\n  */\nconst vowelsConut = (s) => {\n  let vowels = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      vowels++;\n    }\n  }\n  return vowels;\n};\n\n/*Write a function vowelsConut which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsConut(\"abcde\")\n  2\n  >>> vowelsConut(\"ACEDY\")\n  3\n  */\nconst vowelsConut = (s) => {\n  let vowels = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      vowels++;\n    }\n  }\n  return vowels;\n};\n\n/*Write a function vowelsConut which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsConut(\"abcde\")\n  2\n  >>> vowelsConut(\"ACEDY\")\n  3\n  */\nconst vowelsConut = (s) => {\n  let vowels = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      vowels++;\n    }\n  }\n  return vowels;\n};\n\n/*Write a function vowelsConut which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsConut(\"abcde\")\n  2\n  >>> vowelsConut(\"ACEDY\")\n  3\n  */\nconst vowelsConut = (s) => {\n  let vowels = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      vowels++;\n    }\n  }\n  return vowels;\n};\n\n/*Write a function vowelsConut which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsConut(\"abcde\")\n  2\n  >>> vowelsConut(\"ACEDY\")\n  3\n  */\nconst vowelsConut = (s) => {\n  let vowels = 0;\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === 'a' || s[i] === 'e' || s[i] === 'i' || s[i] === 'o' || s[i] === 'u') {\n      vowels++;\n    }\n  }\n  return vowels;\n};\n\n/*Write a function vowelsConut which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsConut(\"abcde\")\n  2\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> circularSihft(12, 1)\n  \"21\"\n  >>> circularSihft(12, 2)\n  \"12\"\n  */\nconst circularSihft = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularSihft", "gc": "<|endoftext|>/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> circularSihft(12, 1)\n  \"21\"\n  >>> circularSihft(12, 2)\n  \"12\"\n  */\nconst circularSihft = (x, shift) => {\n  let digits = x.toString(2).split('');\n  let reversed = digits.reverse();\n  let result = reversed.slice(0).reverse().join('');\n  if (shift > digits.length) {\n    result = digits.slice(0).reverse().join('') + result;\n  }\n  return result;\n};\n\n/*\n  Given a number, return its decimal representation in base 10.\n  >>> decimalToBase(10)\n  \"10\"\n  >>> decimalToBase(20)\n  \"20\"\n  >>> decimalToBase(30)\n  \"30\"\n  >>> decimalToBase(100)\n  \"100\"\n  >>> decimalToBase(1000)\n  \"1000\"\n  >>> decimalToBase(10000)\n  \"10000\"\n  >>> decimalToBase(100000)\n  \"100000\"\n  >>> decimalToBase(1000000)\n  \"1000000\"\n  >>> decimalToBase(10000000)\n  \"10000000\"\n  >>> decimalToBase(100000000)\n  \"100000000\"\n  >>> decimalToBase(1000000000)\n  \"1000000000\"\n  >>> decimalToBase(10000000000)\n  \"10000000000\"\n  >>> decimalToBase(100000000000)\n  \"100000000000\"\n  >>> decimalToBase(1000000000000)\n  \"1000000000000\"\n  >>> decimalToBase(1000000000000)\n  \"1000000000000\"\n  >>> decimalToBase(100000000000000)\n  \"100000000000000\"\n  >>> decimalToBase(100000000000000)\n  \"100000000000000\"\n  >>> decimalToBase(10000000000000000)\n  \"10000000000000000\"\n  >>> decimalToBase(10000000000000000)\n  \"10000000000000000\"\n  >>> decimalToBase(100000000000000000)\n  \"100000000000000000\"\n  >>> decimalToBase(100000000000000000)\n  \"100000000000000000\"\n  >>> decimalToBase(1000000000000000000)\n  \"1000000000000000000\"\n  >>> decimalToBase(1000000000000000000)\n  \"1000000000000000000\"\n  >>> decimalToBase(10000000000000000000)\n  \"10000000000000000000\"\n  >>> decimalToBase(10000000000000000000)\n  \"10000000000000000000\"\n  >>> decimalToBase(100000000000000000000)\n  \"100000000000000000000\"\n  >>> decimalToBase(100000000000000000000)\n  \"100000000000000000000\"\n  >>> decimalToBase(10000000000000000000000)\n  \"10000000000000000000000\"\n  >>> decimalToBase(10000000000000000000000)\n  \"10000000000000000000000\"\n  >>> decimalToBase(1000000000000000000000000)\n  \"1000000000000000000000000\"\n  >>> decimalToBase(1000000000000000000000000)\n  \"1000000000000000000000000\"\n  >>> decimalToBase(10000000000000000000000000)\n  \"10000000000000000000000000\"\n  >>> decimalToBase(10000000000000000000000000)\n  \"10000000000000000000000000\"\n  >>> decimalToBase(1000000000000000000)\n  \"1000000000000000000\"\n  >>> decimalToBase(10000000000000000000)\n  \"10000000000000000000\"\n  >>> decimalToBase(100000000000000000000)\n  \"100000000000000000000\"\n  >>> decimalToBase(100000000000000000000)\n  \"100000000000000000000\"\n  >>> decimalToBase(10000000000000000000000)\n  \"10000000000000000000000\"\n  >>> decimalToBase(10000000000000000000000)\n  \"10000000000000000000000\"\n  >>> decimalToBase(1000000000000000000000000)\n  \"1000000000000000000000000\"\n  >>> decimalToBase(1000000000000000000000000)\n  \"1000000000000000000000000\"\n  >>> decimalToBase(10000000000000000000000000)\n  \"10000000000000000000000000\"\n  >>> decimalToBase(10000000000000000000000000)\n  \"10000000000000000000000000\"\n  >>> decimalToBase(100000000000000000000000000)\n  \"100000000000000000000000000\"\n  >>> decimalToBase(100000000000000000000000000)\n  \"100000000000000000000000000\"\n  >>> decimalToBase(1000000000000000000000000000)\n  \"1000000000000000000000000000\"\n  >>> decimalToBase(1000000000000000000000000000)\n  \"1000000000000000000000000000\"\n  >>> decimalToBase(10000000000000000000000000000)\n  \"10000000000000000000000000000\"\n  >>> decimalToBase(10000000000000000000000000000)\n  \"10000000000000000000000000000\"\n  >>> decimalToBase(1000000000000000000000000000000)\n  \"1000000000000000000000000000000\"\n  >>> decimalToBase(1000000000000000000000000000000)\n  \"1000000000000000000000000000000\"\n  >>> decimalToBase(100000000000000000000000000000000)\n  \"100000000000000000000000000000000\"\n  >>> decimalToBase(100000000000000000000000000000000)\n  \"100000000000000000000000000000000\"\n  >>> decimalToBase(1000000000000000000000000000000000)\n  \"1000000000000000000000000000000000\"\n  >>> decimalToBase(1000000000000000000000000000000000)\n  \"1000000000000000000000000000000000\"\n  >>> decimalToBase(10000000000000000000000000000000000)\n  \"10000000000000000000000000000000000\"\n  >>> decimalToBase(10000000000000000000000000000000000)\n  \"10000000000000000000000000000000000\"\n  >>> decimalToBase(100000000000000000000000000000000000)\n  \"100000000000000000000000000000000000\"\n  >>> decimalToBase(100000000000000000000000000000000000)\n  \"100000000000000000000000000000000000\"\n  >>> decimalToBase(1000000000000000000000000000000000000)\n  \"1000000000000000000000000000000000000\"\n  >>> decimalToBase(1000000000000000000000000000000000000)\n  \"1000000000000000000000000000000000000\"\n  >>> decimalToBase(100000000000000000000000000000000000000)\n  \"100000000000000000000000000000000000000\"\n  >>> decimalToBase(100000000000000000000000000000000000000)\n  \"100000000000000000000000000000000000000\"\n  >>> decimalToBase(10000000000000000000000000000000000000000)\n  \"10000000000000000000000000000000000000000\"\n  >>> decimalToBase(10000000000000000000000000000000000000000)\n  \"10000000000000000000000000000000000000000\"\n  >>> decimalToBase(100000000000000000000000000000000000000000)\n  \"100000000000000000000000000000000000000000\"\n  >>> decimalToBase(100000000000000000000000000000000000000000)\n  \"100000000000000000000000000000000000000000\"\n  >>> decimalToBase(1000000000000000000000000000000000000000000)\n  \"1000000000000000000000000000000000000000000\"\n  >>> decimalToBase(1000000000000000000000000000000000000000000)\n  \"1000000000000000000000000000000000000000000\"\n  >>> decimalToBase(100000000000000000000000000000000000)\n  \"10000000000000000000000000000000000000000000\"\n  >>> decimalToBase(100000000000000000000000000000000000)\n  \"10000000000000000000000000000000000000000000\"\n  >>> decimalToBase(1000000000000000000000000000000000000)\n  \"100000000000000000000000000000000000000000000\"\n  >>> decimalToBase(1000000000000000000000000000000000000)\n  \"100000000000000000000000000000000000000000000\"\n  >>> decimalToBase(100000000000000000000000000000000000000)\n  \"10000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(100000000000000000000000000000000000000)\n  \"10000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10000000000000000000000000000000000000000)\n  \"1000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10000000000000000000000000000000000000000)\n  \"1000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(100000000000000000000000000000000000000000)\n  \"10000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(100000000000000000000000000000000000000000)\n  \"10000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(1000000000000000000000000000000000000000000)\n  \"100000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(1000000000000000000000000000000000000000000)\n  \"100000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10000000000000000000000000000000000000000000)\n  \"1000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(10000000000000000000000000000000000000000000)\n  \"1000000000000000000000000000000000000000000000000000\"\n  >>> decimalToBase(100000000000000000000000000000000000000000000)\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a function that takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "gc": "<|endoftext|>/*Task\n  Write a function that takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the lower characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSumLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the digits only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSumDigits = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the uppercase and lowercase only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperCaseAndLowerCase = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the uppercase and lowercase only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperCaseAndLowerCaseLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the uppercase and lowercase only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperCaseAndLowerCaseDigits = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the uppercase and lowercase only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperCaseAndLowerCaseDigitsLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the uppercase and lowercase only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperCaseAndLowerCaseDigitsDigits = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the uppercase and lowercase only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperCaseAndLowerCaseDigitsDigitsLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the uppercase and lowercase only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperCaseAndLowerCaseDigitsDigitsDigits = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the uppercase and lowercase only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperCaseAndLowerCaseDigitsDigitsDigitsLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the uppercase and lowercase only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woAr", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "gc": "<|endoftext|>/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(\" \").length;\n  for (let i = 0; i < fruits; i++) {\n    if (s.includes(\"apples\")) {\n      apples++;\n    } else if (s.includes(\"oranges\")) {\n      oranges++;\n    } else if (s.includes(\"mango\")) {\n      mango++;\n    }\n  }\n  total = apples + oranges + mango;\n  return total;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(\" \").length;\n  for (let i = 0; i < fruits; i++) {\n    if (s.includes(\"apples\")) {\n      apples++;\n    } else if (s.includes(\"oranges\")) {\n      oranges++;\n    } else if (s.includes(\"mango\")) {\n      mango++;\n    }\n  }\n  total = apples + oranges + mango;\n  return total;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(\" \").length;\n  for (let i = 0; i < fruits; i++) {\n    if (s.includes(\"apples\")) {\n      apples++;\n    } else if (s.includes(\"oranges\")) {\n      oranges++;\n    } else if (s.includes(\"mango\")) {\n      mango++;\n    }\n  }\n  total = apples + oranges + mango;\n  return total;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(\" \").length;\n  for (let i = 0; i < fruits; i++) {\n    if (s.includes(\"apples\")) {\n      apples++;\n    } else if (s.includes(\"oranges\")) {\n      oranges++;\n    } else if (s.includes(\"mango\")) {\n      mango++;\n    }\n  }\n  total = apples + oranges + mango;\n  return total;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(\" \").length;\n  for (let i = 0; i < fruits; i++) {\n    if (s.includes(\"apples\")) {\n      apples++;\n    } else if (s.includes(\"oranges\")) {\n      oranges++;\n    } else if (s.includes(\"mango\")) {\n      mango++;\n    }\n  }\n  total = apples + oranges + mango;\n  return total;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let apples = 0;\n  let oranges = 0;\n  let mango = 0;\n  let fruits = n.split(\" \").length;\n  for (let i = 0; i < fruits; i++) {\n    if (s.includes(\"apples\")) {\n      apples++;\n    } else if (s.includes(\"oranges\")) {\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to pluck one of the nodes and return it.\n  The plucked node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The plucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "gc": "<|endoftext|>/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to pluck one of the nodes and return it.\n  The plucked node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The plucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const len = arr.length;\n  let min = 0;\n  let max = len - 1;\n  let even = 0;\n  let index = -1;\n\n  while (min <= max) {\n    even = arr[min];\n    if (even % 2 === 0) {\n      index++;\n    }\n    if (even % 2 === 1) {\n      min++;\n    }\n    if (min === max) {\n      break;\n    }\n    min = min + 1;\n  }\n  return index;\n};\n\n// Given an array representing a tree with non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest odd value.\n// If multiple nodes with the same smallest odd value are found return the node that has smallest index.\n\n// The plucked node should be returned in a list, [ odd_value, its index ],\n// If there are no odd values or the given array is empty, return [].\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest odd value, and 2 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest odd value, and 2 has the smallest index.\n\n// Example 3:\n//     Input: []\n//     Output: []\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the smallest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the smallest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n */\nconst pluckOdd = (arr) => {\n  const len = arr.length;\n  let min = 0;\n  let max = len - 1;\n  let odd = 0;\n  let index = -1;\n\n  while (min <= max) {\n    odd = arr[max];\n    if (odd % 2 === 0) {\n      index++;\n    }\n    if (odd % 2 === 1) {\n      max--;\n    }\n    if (min === max) {\n      break;\n    }\n    min = min + 1;\n  }\n  return index;\n};\n\n// Given an array representing a tree with non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest positive value.\n// If multiple nodes with the same smallest positive value are found return the node that has smallest index.\n\n// The plucked node should be returned in a list, [ positive_value, its index ],\n// If there are no positive values or the given array is empty, return [].\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest positive value, and 2 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest positive value, and 2 has the smallest index.\n\n// Example 3:\n//     Input: []\n//     Output: []\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the smallest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the smallest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n */\nconst pluckPositive = (arr) => {\n  const len = arr.length;\n  let min = 0;\n  let max = len - 1;\n  let positive = 0;\n  let index = -1;\n\n  while (min <= max) {\n    positive = arr[max];\n    if (positive % 2 === 0) {\n      index++;\n    }\n    if (positive % 2 === 1) {\n      max--;\n    }\n    if (min === max) {\n      break;\n    }\n    min = min + 1;\n  }\n  return index;\n};\n\n// Given an array representing a tree with non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest negative value.\n// If multiple nodes with the same smallest negative value are found return the node that has smallest index.\n\n// The plucked node should be returned in a list, [ negative_value, its index ],\n// If there are no negative values or the given array is empty, return [].\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest negative value, and 2 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest negative value, and 2 has the smallest index.\n\n// Example 3:\n//     Input: []\n//     Output: []\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the smallest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the smallest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n */\nconst pluckNegative = (arr) => {\n  const len = arr.length;\n  let min = 0;\n  let max = len - 1;\n  let negative = 0;\n  let index = -1;\n\n  while (min <= max) {\n    negative = arr[min];\n    if (negative % 2 === 0) {\n      index++;\n    }\n    if (negative % 2 === 1) {\n      min++;\n    }\n    if (min === max) {\n      break;\n    }\n    min = min + 1;\n  }\n  return index;\n};\n\n// Given an array representing a tree with non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest positive value.\n// If multiple nodes with the same smallest positive value are found return the node that has smallest index.\n\n// The plucked node should be returned in a list, [ positive_value, its index ],\n// If there are no positive values or the given array is empty, return [].\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest positive value, and 2 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest positive value, and 2 has the smallest index.\n\n// Example 3:\n//     Input: []\n//     Output: []\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the smallest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the smallest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n */\nconst pluckPositiveOdd = (arr) => {\n  const len = arr.length;\n  let min = 0;\n  let max = len - 1;\n  let positive = 0;\n  let index = -1;\n\n  while (min <= max) {\n    ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "gc": "<|endoftext|>/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the smallest integer that is less than\n  zero, and has a frequency less than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 1\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let min = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < min) {\n      min = lst[i];\n      freq = i;\n    }\n  }\n  return min;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the largest integer that is less than\n  zero, and has a frequency less than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 4\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the smallest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 4\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let min = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > min) {\n      min = lst[i];\n      freq = i;\n    }\n  }\n  return min;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the largest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 4\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the smallest integer that is less than\n  zero, and has a frequency less than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 4\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let min = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < min) {\n      min = lst[i];\n      freq = i;\n    }\n  }\n  return min;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the largest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 4\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the smallest integer that is less than\n  zero, and has a frequency less than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 4\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let min = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < min) {\n      min = lst[i];\n      freq = i;\n    }\n  }\n  return min;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the largest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 4\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the smallest integer that is less than\n  zero, and has a frequency less than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 4\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let min = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < min) {\n      min = lst[i];\n      freq = i;\n    }\n  }\n  return min;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the largest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 4\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the smallest integer that is less than\n  zero, and has a frequency less than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 4\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings only for ones that contain given substring\n  >>> filteBrySubstring([], 'a')\n  []\n  >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filteBrySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filteBrySubstring", "gc": "<|endoftext|>/* Filter an input list of strings only for ones that contain given substring\n  >>> filteBrySubstring([], 'a')\n  []\n  >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filteBrySubstring = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filteBrySubstring([], 'b')\n  []\n  >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBryNoSubstring = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) === -1);\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filteBryNoSubstring([], 'b')\n  []\n  >>> filteBryNoSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBryNoSubstring = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) === -1);\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filteBrySubstring([], 'a')\n  []\n  >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBrySubstring = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filteBryNoSubstring([], 'a')\n  []\n  >>> filteBryNoSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBryNoSubstring = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filteBrySubstring([], 'a')\n  []\n  >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBrySubstring = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filteBryNoSubstring([], 'a')\n  []\n  >>> filteBryNoSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBryNoSubstring = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filteBrySubstring([], 'a')\n  []\n  >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBrySubstring = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filteBryNoSubstring([], 'a')\n  []\n  >>> filteBryNoSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBryNoSubstring = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filteBrySubstring([], 'a')\n  []\n  >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBrySubstring = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filteBryNoSubstring([], 'a')\n  []\n  >>> filteBryNoSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBryNoSubstring = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filteBrySubstring([], 'a')\n  []\n  >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBrySubstring = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filteBryNoSubstring([], 'a')\n  []\n  >>> filteBryNoSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBryNoSubstring = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filteBrySubstring([], 'a')\n  []\n  >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBrySubstring = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filteBryNoSubstring([], 'a')\n  []\n  >>> filteBryNoSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBryNoSubstring = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filteBrySubstring([], 'a')\n  []\n  >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBrySubstring = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring)!== -1);\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filteBryNoSubstring([], 'a')\n  []\n  >>> filteBryNoSubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBryNoSubstring = (strings, substring) => {\n  return strings.filter(s => s.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filteBrySubstring([], 'a')\n  []\n  >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', '", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  stranegoSrtList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  stranegoSrtList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  stranegoSrtList([]) == []\n  */\nconst stranegoSrtList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "stranegoSrtList", "gc": "<|endoftext|>/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  stranegoSrtList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  stranegoSrtList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  stranegoSrtList([]) == []\n  */\nconst stranegoSrtList = (lst) => {\n  let min;\n  let max;\n  let minIndex;\n  let maxIndex;\n  let tmp;\n  let tmpIndex;\n  let tmpMin;\n  let tmpMax;\n  let tmpMinIndex;\n  let tmpMaxIndex;\n  let tmpMinMin;\n  let tmpMaxMin;\n  let tmpMinMax;\n  let tmpMinMinIndex;\n  let tmpMaxMinIndex;\n  let tmpMinMaxIndex;\n  let tmpMinMinMin;\n  let tmpMaxMinMin;\n  let tmpMinMaxMinIndex;\n  let tmpMinMinMaxIndex;\n  let tmpMinMinMinMin;\n  let tmpMaxMinMinMin;\n  let tmpMinMaxMinMinIndex;\n  let tmpMinMinMaxMinIndex;\n  let tmpMinMinMinMaxMin;\n  let tmpMaxMinMinMinMin;\n  let tmpMinMaxMinMinMinIndex;\n  let tmpMinMinMaxMinMinIndex;\n  let tmpMinMinMaxMinMinMinMin;\n  let tmpMinMaxMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMin;\n  let tmpMinMaxMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMin;\n  let tmpMinMaxMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMin;\n  let tmpMinMaxMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMin;\n  let tmpMinMaxMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMin;\n  let tmpMinMaxMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMin;\n  let tmpMinMaxMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMin;\n  let tmpMinMaxMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMin;\n  let tmpMinMaxMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMin;\n  let tmpMinMaxMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMin;\n  let tmpMinMaxMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMin;\n  let tmpMinMaxMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMin;\n  let tmpMinMaxMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinIndex;\n  let tmpMinMinMaxMinMinMinMinMin;\n  let tmpMinMaxMinMinMinMinMinIndex;\n  let tmpMin", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "gc": "<|endoftext|>/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  let sumA = a + b;\n  let sumB = a + c;\n  let sumC = a + b;\n  if (sumA > sumB || sumA > sumC) {\n    return -1;\n  }\n  if (sumB > sumC) {\n    return -1;\n  }\n  return sumA + sumB + sumC;\n};\n\n/*\n  Given the lengths of the four sides of a rectangle. Return the area of\n  the rectangle rounded to 2 decimal points if the four sides form a valid rectangle.\n  Otherwise return -1\n  Three sides make a valid rectangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  rectangleArea(3, 4, 5) == 6.00\n  rectangleArea(1, 2, 10) == -1\n  */\nconst rectangleArea = (a, b, c) => {\n  let sumA = a + b;\n  let sumB = a + c;\n  let sumC = a + b;\n  if (sumA > sumB || sumA > sumC) {\n    return -1;\n  }\n  if (sumB > sumC) {\n    return -1;\n  }\n  return sumA + sumB + sumC;\n};\n\n/*\n  Given the lengths of the five sides of a pentagon. Return the area of\n  the pentagon rounded to 2 decimal points if the five sides form a valid pentagon.\n  Otherwise return -1\n  Three sides make a valid pentagon when the sum of any two sides is greater\n  than the third side.\n  Example:\n  pentagonArea(3, 4, 5) == 6.00\n  pentagonArea(1, 2, 10) == -1\n  */\nconst pentagonArea = (a, b, c) => {\n  let sumA = a + b;\n  let sumB = a + c;\n  let sumC = a + b;\n  if (sumA > sumB || sumA > sumC) {\n    return -1;\n  }\n  if (sumB > sumC) {\n    return -1;\n  }\n  return sumA + sumB + sumC;\n};\n\n/*\n  Given the lengths of the six sides of a hexagon. Return the area of\n  the hexagon rounded to 2 decimal points if the six sides form a valid hexagon.\n  Otherwise return -1\n  Three sides make a valid hexagon when the sum of any two sides is greater\n  than the third side.\n  Example:\n  hexagonArea(3, 4, 5) == 6.00\n  hexagonArea(1, 2, 10) == -1\n  */\nconst hexagonArea = (a, b, c) => {\n  let sumA = a + b;\n  let sumB = a + c;\n  let sumC = a + b;\n  if (sumA > sumB || sumA > sumC) {\n    return -1;\n  }\n  if (sumB > sumC) {\n    return -1;\n  }\n  return sumA + sumB + sumC;\n};\n\n/*\n  Given the lengths of the seven sides of a heptagon. Return the area of\n  the heptagon rounded to 2 decimal points if the seven sides form a valid heptagon.\n  Otherwise return -1\n  Three sides make a valid heptagon when the sum of any two sides is greater\n  than the third side.\n  Example:\n  heptagonArea(3, 4, 5) == 6.00\n  heptagonArea(1, 2, 10) == -1\n  */\nconst heptagonArea = (a, b, c) => {\n  let sumA = a + b;\n  let sumB = a + c;\n  let sumC = a + b;\n  if (sumA > sumB || sumA > sumC) {\n    return -1;\n  }\n  if (sumB > sumC) {\n    return -1;\n  }\n  return sumA + sumB + sumC;\n};\n\n/*\n  Given the lengths of the eight sides of a decagon. Return the area of\n  the decagon rounded to 2 decimal points if the eight sides form a valid decagon.\n  Otherwise return -1\n  Three sides make a valid decagon when the sum of any two sides is greater\n  than the third side.\n  Example:\n  decagonArea(3, 4, 5) == 6.00\n  decagonArea(1, 2, 10) == -1\n  */\nconst decagonArea = (a, b, c) => {\n  let sumA = a + b;\n  let sumB = a + c;\n  let sumC = a + b;\n  if (sumA > sumB || sumA > sumC) {\n    return -1;\n  }\n  if (sumB > sumC) {\n    return -1;\n  }\n  return sumA + sumB + sumC;\n};\n\n/*\n  Given the lengths of the nine sides of a neutron. Return the area of\n  the neutron rounded to 2 decimal points if the nine sides form a valid neutron.\n  Otherwise return -1\n  Three sides make a valid neutron when the sum of any two sides is greater\n  than the third side.\n  Example:\n  neutronArea(3, 4, 5) == 6.00\n  neutronArea(1, 2, 10) == -1\n  */\nconst neutronArea = (a, b, c) => {\n  let sumA = a + b;\n  let sumB = a + c;\n  let sumC = a + b;\n  if (sumA > sumB || sumA > sumC) {\n    return -1;\n  }\n  if (sumB > sumC) {\n    return -1;\n  }\n  return sumA + sumB + sumC;\n};\n\n/*\n  Given the lengths of the ten sides of a dodecagon. Return the area of\n  the dodecagon rounded to 2 decimal points if the ten sides form a valid dodecagon.\n  Otherwise return -1\n  Three sides make a valid dodecagon when the sum of any two sides is greater\n  than the third side.\n  Example:\n  dodecagonArea(3, 4, 5) == 6.00\n  dodecagonArea(1, 2, 10) == -1\n  */\nconst dodecagonArea = (a, b, c) => {\n  let sumA = a + b;\n  let sumB = a + c;\n  let sumC = a + b;\n  if (sumA > sumB || sumA > sumC) {\n    return -1;\n  }\n  if (sumB > sumC) {\n    return -1;\n  }\n  return sumA + sumB + sumC;\n};\n\n/*\n  Given the lengths of the eleven sides of a nickel. Return the area of\n  the nickel rounded to 2 decimal points if the eleven sides form a valid nickel.\n  Otherwise return -1\n  Three sides make a valid nickel when the sum of any two sides is greater\n  than the third side.\n  Example:\n  nickelArea(3, 4, 5) == 6.00\n  nickelArea(1, 2, 10) == -1\n  */\nconst nickelArea = (a, b, c) => {\n  let sumA = a + b;\n  let sumB = a + c;\n  let sumC = a + b;\n  if (sumA > sumB || sumA > sumC) {\n    return -1;\n  }\n  if (sumB > sumC) {\n    return -1;\n  }\n  return sumA + sumB + sumC;\n};\n\n/*\n  Given the lengths of the twelve sides of a pennine. Return the area of\n  the pennine rounded to 2 decimal points if the twelve sides form a valid pennine.\n  Otherwise return -1\n  Three sides make a valid penn", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "gc": "<|endoftext|>/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const len = q.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    sum += q[i];\n    if (sum >= w) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is greater than or equal to the minimum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5)  true\n  # 1+2 is greater than the minimum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  true\n  # it's balanced, but 3+2+3 is more than the minimum possible weight.\n\n  willItFly([3, 2, 3], 9)  false\n  # 3+2+3 is greater than the minimum possible weight, and it's unbalanced.\n\n  willItFly([3], 5)  false\n  # 3 is greater than the minimum possible weight, and it's unbalanced.\n  */\nconst willItFly = (q, w) => {\n  const len = q.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    sum += q[i];\n    if (sum <= w) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is greater than or equal to the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is greater than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is greater than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is greater than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const len = q.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    sum += q[i];\n    if (sum > w) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal to the minimum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the minimum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the minimum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the minimum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the minimum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const len = q.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    sum += q[i];\n    if (sum <= w) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is greater than or equal to the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is greater than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is greater than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is greater than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const len = q.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    sum += q[i];\n    if (sum > w) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal to the minimum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the minimum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the minimum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the minimum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the minimum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const len = q.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    sum += q[i];\n    if (sum <= w) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is greater than or equal to the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is greater than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is greater than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is greater than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const len = q.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    sum += q[i];\n    if (sum > w) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  msallestChange([1,2,3,5,4,7,9,6]) == 4\n  msallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  msallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst msallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "msallestChange", "gc": "<|endoftext|>/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  msallestChange([1,2,3,5,4,7,9,6]) == 4\n  msallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  msallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst msallestChange = (arr) => {\n  let len = arr.length;\n  let count = 0;\n  let change = 0;\n  let minChange = len / 2;\n  let minCount = 0;\n  let minLen = minChange;\n  let maxLen = len - 1;\n  let maxCount = 0;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;\n  let maxChange = maxLen - 1;\n  let maxCount = 0;\n  let maxLen = maxChange;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  ottalMatch([], [])  []\n  ottalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  ottalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  ottalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  ottalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst ottalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "ottalMatch", "gc": "<|endoftext|>/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  ottalMatch([], [])  []\n  ottalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  ottalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  ottalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  ottalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst ottalMatch = (lst1, lst2) => {\n  const len = Math.min(lst1.length, lst2.length)\n  let i = 0\n  let j = 0\n  let result = []\n  while (i < len) {\n    if (lst1[i] === lst2[j]) {\n      result.push(lst1[i])\n      i++\n      j++\n    } else {\n      i++\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list greater than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  ottalMatch([], [])  []\n  ottalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  ottalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  ottalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  ottalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst ottalMismatch = (lst1, lst2) => {\n  const len = Math.min(lst1.length, lst2.length)\n  let i = 0\n  let j = 0\n  let result = []\n  while (i < len) {\n    if (lst1[i]!== lst2[j]) {\n      result.push(lst1[i])\n      i++\n      j++\n    } else {\n      i++\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list equal to the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  ottalMatch([], [])  []\n  ottalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  ottalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  ottalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  ottalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst ottalEqual = (lst1, lst2) => {\n  const len = Math.min(lst1.length, lst2.length)\n  let i = 0\n  let j = 0\n  let result = []\n  while (i < len) {\n    if (lst1[i] === lst2[j]) {\n      result.push(lst1[i])\n      i++\n      j++\n    } else {\n      i++\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list not equal to the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  ottalMatch([], [])  []\n  ottalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  ottalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  ottalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  ottalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst ottalNotEqual = (lst1, lst2) => {\n  const len = Math.min(lst1.length, lst2.length)\n  let i = 0\n  let j = 0\n  let result = []\n  while (i < len) {\n    if (lst1[i]!== lst2[j]) {\n      result.push(lst1[i])\n      i++\n      j++\n    } else {\n      i++\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list not less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  ottalMatch([], [])  []\n  ottalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  ottalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  ottalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  ottalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst ottalLessThan = (lst1, lst2) => {\n  const len = Math.min(lst1.length, lst2.length)\n  let i = 0\n  let j = 0\n  let result = []\n  while (i < len) {\n    if (lst1[i] < lst2[j]) {\n      result.push(lst1[i])\n      i++\n      j++\n    } else {\n      i++\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list not greater than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  ottalMatch([], [])  []\n  ottalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  ottalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  ottalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  ottalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst ottalGreaterThan = (lst1, lst2) => {\n  const len = Math.min(lst1.length, lst2.length)\n  let i = 0\n  let j = 0\n  let result = []\n  while (i < len) {\n    if (lst1[i] > lst2[j]) {\n      result.push(lst1[i])\n      i++\n      j++\n    } else {\n      i++\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list not equal to the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  ottalMatch([], [])  []\n  ottalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  ottalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  ottalMatch", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/75", "prompt": "/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPirme", "gc": "<|endoftext|>/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  let isMultiplyPirme = true;\n  let primeNumbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n  let isPrime = true;\n  let isPrimeNumber = true;\n  let isPrimeNumber2 = true;\n  let isPrimeNumber3 = true;\n  let isPrimeNumber4 = true;\n  let isPrimeNumber5 = true;\n  let isPrimeNumber6 = true;\n  let isPrimeNumber7 = true;\n  let isPrimeNumber8 = true;\n  let isPrimeNumber9 = true;\n  let isPrimeNumber10 = true;\n  let isPrimeNumber11 = true;\n  let isPrimeNumber12 = true;\n  let isPrimeNumber13 = true;\n  let isPrimeNumber14 = true;\n  let isPrimeNumber15 = true;\n  let isPrimeNumber16 = true;\n  let isPrimeNumber17 = true;\n  let isPrimeNumber18 = true;\n  let isPrimeNumber19 = true;\n  let isPrimeNumber20 = true;\n  let isPrimeNumber21 = true;\n  let isPrimeNumber22 = true;\n  let isPrimeNumber23 = true;\n  let isPrimeNumber24 = true;\n  let isPrimeNumber25 = true;\n  let isPrimeNumber26 = true;\n  let isPrimeNumber27 = true;\n  let isPrimeNumber28 = true;\n  let isPrimeNumber29 = true;\n  let isPrimeNumber30 = true;\n  let isPrimeNumber31 = true;\n  let isPrimeNumber32 = true;\n  let isPrimeNumber33 = true;\n  let isPrimeNumber34 = true;\n  let isPrimeNumber35 = true;\n  let isPrimeNumber36 = true;\n  let isPrimeNumber37 = true;\n  let isPrimeNumber38 = true;\n  let isPrimeNumber39 = true;\n  let isPrimeNumber40 = true;\n  let isPrimeNumber41 = true;\n  let isPrimeNumber42 = true;\n  let isPrimeNumber43 = true;\n  let isPrimeNumber44 = true;\n  let isPrimeNumber45 = true;\n  let isPrimeNumber46 = true;\n  let isPrimeNumber47 = true;\n  let isPrimeNumber48 = true;\n  let isPrimeNumber49 = true;\n  let isPrimeNumber50 = true;\n  let isPrimeNumber51 = true;\n  let isPrimeNumber52 = true;\n  let isPrimeNumber53 = true;\n  let isPrimeNumber54 = true;\n  let isPrimeNumber55 = true;\n  let isPrimeNumber56 = true;\n  let isPrimeNumber57 = true;\n  let isPrimeNumber58 = true;\n  let isPrimeNumber59 = true;\n  let isPrimeNumber60 = true;\n  let isPrimeNumber61 = true;\n  let isPrimeNumber62 = true;\n  let isPrimeNumber63 = true;\n  let isPrimeNumber64 = true;\n  let isPrimeNumber65 = true;\n  let isPrimeNumber66 = true;\n  let isPrimeNumber67 = true;\n  let isPrimeNumber68 = true;\n  let isPrimeNumber69 = true;\n  let isPrimeNumber70 = true;\n  let isPrimeNumber71 = true;\n  let isPrimeNumber72 = true;\n  let isPrimeNumber73 = true;\n  let isPrimeNumber74 = true;\n  let isPrimeNumber75 = true;\n  let isPrimeNumber76 = true;\n  let isPrimeNumber77 = true;\n  let isPrimeNumber78 = true;\n  let isPrimeNumber79 = true;\n  let isPrimeNumber80 = true;\n  let isPrimeNumber81 = true;\n  let isPrimeNumber82 = true;\n  let isPrimeNumber83 = true;\n  let isPrimeNumber84 = true;\n  let isPrimeNumber85 = true;\n  let isPrimeNumber86 = true;\n  let isPrimeNumber87 = true;\n  let isPrimeNumber88 = true;\n  let isPrimeNumber89 = true;\n  let isPrimeNumber90 = true;\n  let isPrimeNumber91 = true;\n  let isPrimeNumber92 = true;\n  let isPrimeNumber93 = true;\n  let isPrimeNumber94 = true;\n  let isPrimeNumber95 = true;\n  let isPrimeNumber96 = true;\n  let isPrimeNumber97 = true;\n  let isPrimeNumber98 = true;\n  let isPrimeNumber99 = true;\n  let isPrimeNumber100 = true;\n  let isPrimeNumber101 = true;\n  let isPrimeNumber102 = true;\n  let isPrimeNumber103 = true;\n  let isPrimeNumber104 = true;\n  let isPrimeNumber105 = true;\n  let isPrimeNumber106 = true;\n  let isPrimeNumber107 = true;\n  let isPrimeNumber108 = true;\n  let isPrimeNumber109 = true;\n  let isPrimeNumber110 = true;\n  let isPrimeNumber111 = true;\n  let isPrimeNumber112 = true;\n  let isPrimeNumber113 = true;\n  let isPrimeNumber114 = true;\n  let isPrimeNumber115 = true;\n  let isPrimeNumber116 = true;\n  let isPrimeNumber117 = true;\n  let isPrimeNumber118 = true;\n  let isPrimeNumber119 = true;\n  let isPrimeNumber120 = true;\n  let isPrimeNumber121 = true;\n  let isPrimeNumber122 = true;\n  let isPrimeNumber123 = true;\n  let isPrimeNumber124 = true;\n  let isPrimeNumber125 = true;\n  let isPrimeNumber126 = true;\n  let isPrimeNumber127 = true;\n  let isPrimeNumber128 = true;\n  let isPrimeNumber129 = true;\n  let isPrimeNumber130 = true;\n  let isPrimeNumber131 = true;\n  let isPrimeNumber132 = true;\n  let isPrimeNumber133 = true;\n  let isPrimeNumber134 = true;\n  let isPrimeNumber135 = true;\n  let isPrimeNumber", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePwoer(1, 4) => true\n  isSimplePwoer(2, 2) => true\n  isSimplePwoer(8, 2) => true\n  isSimplePwoer(3, 2) => false\n  isSimplePwoer(3, 1) => false\n  isSimplePwoer(5, 3) => false\n  */\nconst isSimplePwoer = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePwoer", "gc": "<|endoftext|>/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePwoer(1, 4) => true\n  isSimplePwoer(2, 2) => true\n  isSimplePwoer(8, 2) => true\n  isSimplePwoer(3, 2) => false\n  isSimplePwoer(3, 1) => false\n  isSimplePwoer(5, 3) => false\n  */\nconst isSimplePwoer = (x, n) => {\n  if (x === 0) return true;\n  if (n === 0) return false;\n  if (n % x === 0) {\n    return false;\n  }\n  return isSimplePwoer(x, n / x);\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePwoer(1, 4) => true\n  isSimplePwoer(2, 2) => true\n  isSimplePwoer(8, 2) => true\n  isSimplePwoer(3, 2) => false\n  isSimplePwoer(3, 1) => false\n  isSimplePwoer(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (x === 0) return true;\n  if (n === 0) return false;\n  if (n % x === 0) {\n    return false;\n  }\n  return isSimplePower(x, n / x);\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower2 = (x, n) => {\n  if (x === 0) return true;\n  if (n === 0) return false;\n  if (n % x === 0) {\n    return false;\n  }\n  return isSimplePower2(x, n / x);\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower2(3, 2) => true\n  isSimplePower2(3, 1) => false\n  isSimplePower2(5, 3) => false\n  */\nconst isSimplePower3 = (x, n) => {\n  if (x === 0) return true;\n  if (n === 0) return false;\n  if (n % x === 0) {\n    return false;\n  }\n  return isSimplePower3(x, n / x);\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower3(3, 2) => true\n  isSimplePower3(3, 1) => false\n  isSimplePower3(5, 3) => false\n  */\nconst isSimplePower4 = (x, n) => {\n  if (x === 0) return true;\n  if (n === 0) return false;\n  if (n % x === 0) {\n    return false;\n  }\n  return isSimplePower4(x, n / x);\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower4(3, 2) => true\n  isSimplePower4(3, 1) => false\n  isSimplePower4(5, 3) => false\n  */\nconst isSimplePower5 = (x, n) => {\n  if (x === 0) return true;\n  if (n === 0) return false;\n  if (n % x === 0) {\n    return false;\n  }\n  return isSimplePower5(x, n / x);\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower5(3, 2) => true\n  isSimplePower5(3, 1) => false\n  isSimplePower5(5, 3) => false\n  */\nconst isSimplePower6 = (x, n) => {\n  if (x === 0) return true;\n  if (n === 0) return false;\n  if (n % x === 0) {\n    return false;\n  }\n  return isSimplePower6(x, n / x);\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower6(3, 2) => true\n  isSimplePower6(3, 1) => false\n  isSimplePower6(5, 3) => false\n  */\nconst isSimplePower7 = (x, n) => {\n  if (x === 0) return true;\n  if (n === 0) return false;\n  if (n % x === 0) {\n    return false;\n  }\n  return isSimplePower7(x, n / x);\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower7(3, 2) => true\n  isSimplePower7(3, 1) => false\n  isSimplePower7(5, 3) => false\n  */\nconst isSimplePower8 = (x, n) => {\n  if (x === 0) return true;\n  if (n === 0) return false;\n  if (n % x === 0) {\n    return false;\n  }\n  return isSimplePower8(x, n / x);\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower8(3, 2) => true\n  isSimplePower8(3, 1) => false\n  isSimplePower8(5, 3) => false\n  */\nconst isSimplePower9 = (x, n) => {\n  if (x === 0) return true;\n  if (n === 0) return false;\n  if (n % x === 0) {\n    return false;\n  }\n  return isSimplePower9(x, n / x);\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower9(3, 2) => true\n  isSimplePower9(3, 1) => false\n  isSimplePower9(5, 3) => false\n  */\nconst isSimplePower10 = (x, n) => {\n  if (x === 0) return true;\n  if (n === 0) return false;\n  if (n % x === 0) {\n    return false;\n  }\n  return isSimplePower10(x, n / x);\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower10(3, 2) => true\n  isSimplePower10(3, 1) => false\n  isSimplePower10(5, 3) => false\n  */\nconst isSimplePower11 = (x, n) => {\n  if (x === 0) return true;\n  if (n === 0) return false;\n  if (n % x === 0) {\n    return false;\n  }\n  return isSimplePower11(x, n / x);\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower11(3, 2) => true\n  isSimplePower11(3, 1) => false\n  isSimplePower11(5, 3) => false\n  */\nconst isSimplePower12", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "gc": "<|endoftext|>/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a === 0) return true\n  if (a === 1) return false\n  if (a % 1 === 0) return false\n  if (a % 2 === 0) return true\n  return iscube(a / 2)\n}\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a pentagonal number of the given size.\n  Note: you may assume the input is always valid.\n  Examples:\n  ispentagon(3) ==> true\n  ispentagon(4) ==> false\n  ispentagon(5) ==> false\n  ispentagon(6) ==> false\n  ispentagon(7) ==> false\n  ispentagon(8) ==> false\n  ispentagon(9) ==> false\n  ispentagon(10) ==> false\n  ispentagon(11) ==> false\n  ispentagon(12) ==> false\n  ispentagon(13) ==> false\n  ispentagon(14) ==> false\n  ispentagon(15) ==> false\n  ispentagon(16) ==> false\n  ispentagon(17) ==> false\n  ispentagon(18) ==> false\n  ispentagon(19) ==> false\n  ispentagon(20) ==> false\n  ispentagon(21) ==> false\n  ispentagon(22) ==> false\n  ispentagon(23) ==> false\n  ispentagon(24) ==> false\n  ispentagon(25) ==> false\n  ispentagon(26) ==> false\n  ispentagon(27) ==> false\n  ispentagon(28) ==> false\n  ispentagon(29) ==> false\n  ispentagon(30) ==> false\n  ispentagon(31) ==> false\n  ispentagon(32) ==> false\n  ispentagon(33) ==> false\n  ispentagon(34) ==> false\n  ispentagon(35) ==> false\n  ispentagon(36) ==> false\n  ispentagon(37) ==> false\n  ispentagon(38) ==> false\n  ispentagon(39) ==> false\n  ispentagon(40) ==> false\n  ispentagon(41) ==> false\n  ispentagon(42) ==> false\n  ispentagon(43) ==> false\n  ispentagon(44) ==> false\n  ispentagon(45) ==> false\n  ispentagon(46) ==> false\n  ispentagon(47) ==> false\n  ispentagon(48) ==> false\n  ispentagon(49) ==> false\n  ispentagon(50) ==> false\n  ispentagon(51) ==> false\n  ispentagon(52) ==> false\n  ispentagon(53) ==> false\n  ispentagon(54) ==> false\n  ispentagon(55) ==> false\n  ispentagon(56) ==> false\n  ispentagon(57) ==> false\n  ispentagon(58) ==> false\n  ispentagon(59) ==> false\n  ispentagon(60) ==> false\n  ispentagon(61) ==> false\n  ispentagon(62) ==> false\n  ispentagon(63) ==> false\n  ispentagon(64) ==> false\n  ispentagon(65) ==> false\n  ispentagon(66) ==> false\n  ispentagon(67) ==> false\n  ispentagon(68) ==> false\n  ispentagon(69) ==> false\n  ispentagon(70) ==> false\n  ispentagon(71) ==> false\n  ispentagon(72) ==> false\n  ispentagon(73) ==> false\n  ispentagon(74) ==> false\n  ispentagon(75) ==> false\n  ispentagon(76) ==> false\n  ispentagon(77) ==> false\n  ispentagon(78) ==> false\n  ispentagon(79) ==> false\n  ispentagon(80) ==> false\n  ispentagon(81) ==> false\n  ispentagon(82) ==> false\n  ispentagon(83) ==> false\n  ispentagon(84) ==> false\n  ispentagon(85) ==> false\n  ispentagon(86) ==> false\n  ispentagon(87) ==> false\n  ispentagon(88) ==> false\n  ispentagon(89) ==> false\n  ispentagon(90) ==> false\n  ispentagon(91) ==> false\n  ispentagon(92) ==> false\n  ispentagon(93) ==> false\n  ispentagon(94) ==> false\n  ispentagon(95) ==> false\n  ispentagon(96) ==> false\n  ispentagon(97) ==> false\n  ispentagon(98) ==> false\n  ispentagon(99) ==> false\n  ispentagon(100) ==> false\n  ispentagon(101) ==> false\n  ispentagon(102) ==> false\n  ispentagon(103) ==> false\n  ispentagon(104) ==> false\n  ispentagon(105) ==> false\n  ispentagon(106) ==> false\n  ispentagon(107) ==> false\n  ispentagon(108) ==> false\n  ispentagon(109) ==> false\n  ispentagon(110) ==> false\n  ispentagon(111) ==> false\n  ispentagon(112) ==> false\n  ispentagon(113) ==> false\n  ispentagon(114) ==> false\n  ispentagon(115) ==> false\n  ispentagon(116) ==> false\n  ispentagon(117) ==> false\n  ispentagon(118) ==> false\n  ispentagon(119) ==> false\n  ispentagon(120) ==> false\n  ispentagon(121) ==> false\n  ispentagon(122) ==> false\n  ispentagon(123) ==> false\n  ispentagon(124) ==> false\n  ispentagon(125) ==> false\n  ispentagon(126) ==> false\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "gc": "<|endoftext|>/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let count = 0;\n  let numArray = num.split('');\n  let numLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = numArray.length;\n  let numArrayLength = ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/79", "prompt": "/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "gc": "<|endoftext|>/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let decimalToBinaryString = '';\n  let decimalToBinaryStringLength = decimal.toString().length;\n  let decimalToBinaryStringLength2 = decimalToBinaryStringLength - 2;\n  let decimalToBinaryStringLength3 = decimalToBinaryStringLength - 3;\n  let decimalToBinaryStringLength4 = decimalToBinaryStringLength - 4;\n  let decimalToBinaryStringLength5 = decimalToBinaryStringLength - 5;\n  let decimalToBinaryStringLength6 = decimalToBinaryStringLength - 6;\n  let decimalToBinaryStringLength7 = decimalToBinaryStringLength - 7;\n  let decimalToBinaryStringLength8 = decimalToBinaryStringLength - 8;\n  let decimalToBinaryStringLength9 = decimalToBinaryStringLength - 9;\n  let decimalToBinaryStringLength10 = decimalToBinaryStringLength - 10;\n  let decimalToBinaryStringLength11 = decimalToBinaryStringLength - 11;\n  let decimalToBinaryStringLength12 = decimalToBinaryStringLength - 12;\n  let decimalToBinaryStringLength13 = decimalToBinaryStringLength - 13;\n  let decimalToBinaryStringLength14 = decimalToBinaryStringLength - 14;\n  let decimalToBinaryStringLength15 = decimalToBinaryStringLength - 15;\n  let decimalToBinaryStringLength16 = decimalToBinaryStringLength - 16;\n  let decimalToBinaryStringLength17 = decimalToBinaryStringLength - 17;\n  let decimalToBinaryStringLength18 = decimalToBinaryStringLength - 18;\n  let decimalToBinaryStringLength19 = decimalToBinaryStringLength - 19;\n  let decimalToBinaryStringLength20 = decimalToBinaryStringLength - 20;\n  let decimalToBinaryStringLength21 = decimalToBinaryStringLength - 21;\n  let decimalToBinaryStringLength22 = decimalToBinaryStringLength - 22;\n  let decimalToBinaryStringLength23 = decimalToBinaryStringLength - 23;\n  let decimalToBinaryStringLength24 = decimalToBinaryStringLength - 24;\n  let decimalToBinaryStringLength25 = decimalToBinaryStringLength - 25;\n  let decimalToBinaryStringLength26 = decimalToBinaryStringLength - 26;\n  let decimalToBinaryStringLength27 = decimalToBinaryStringLength - 27;\n  let decimalToBinaryStringLength28 = decimalToBinaryStringLength - 28;\n  let decimalToBinaryStringLength29 = decimalToBinaryStringLength - 29;\n  let decimalToBinaryStringLength30 = decimalToBinaryStringLength - 30;\n  let decimalToBinaryStringLength31 = decimalToBinaryStringLength - 31;\n  let decimalToBinaryStringLength32 = decimalToBinaryStringLength - 32;\n  let decimalToBinaryStringLength33 = decimalToBinaryStringLength - 33;\n  let decimalToBinaryStringLength34 = decimalToBinaryStringLength - 34;\n  let decimalToBinaryStringLength35 = decimalToBinaryStringLength - 35;\n  let decimalToBinaryStringLength36 = decimalToBinaryStringLength - 36;\n  let decimalToBinaryStringLength37 = decimalToBinaryStringLength - 37;\n  let decimalToBinaryStringLength38 = decimalToBinaryStringLength - 38;\n  let decimalToBinaryStringLength39 = decimalToBinaryStringLength - 39;\n  let decimalToBinaryStringLength40 = decimalToBinaryStringLength - 40;\n  let decimalToBinaryStringLength41 = decimalToBinaryStringLength - 41;\n  let decimalToBinaryStringLength42 = decimalToBinaryStringLength - 42;\n  let decimalToBinaryStringLength43 = decimalToBinaryStringLength - 43;\n  let decimalToBinaryStringLength44 = decimalToBinaryStringLength - 44;\n  let decimalToBinaryStringLength45 = decimalToBinaryStringLength - 45;\n  let decimalToBinaryStringLength46 = decimalToBinaryStringLength - 46;\n  let decimalToBinaryStringLength47 = decimalToBinaryStringLength - 47;\n  let decimalToBinaryStringLength48 = decimalToBinaryStringLength - 48;\n  let decimalToBinaryStringLength49 = decimalToBinaryStringLength - 49;\n  let decimalToBinaryStringLength50 = decimalToBinaryStringLength - 50;\n  let decimalToBinaryStringLength51 = decimalToBinaryStringLength - 51;\n  let decimalToBinaryStringLength52 = decimalToBinaryStringLength - 52;\n  let decimalToBinaryStringLength53 = decimalToBinaryStringLength - 53;\n  let decimalToBinaryStringLength54 = decimalToBinaryStringLength - 54;\n  let decimalToBinaryStringLength55 = decimalToBinaryStringLength - 55;\n  let decimalToBinaryStringLength56 = decimalToBinaryStringLength - 56;\n  let decimalToBinaryStringLength57 = decimalToBinaryStringLength - 57;\n  let decimalToBinaryStringLength58 = decimalToBinaryStringLength - 58;\n  let decimalToBinaryStringLength59 = decimalToBinaryStringLength - 59;\n  let decimalToBinaryStringLength60 = decimalToBinaryStringLength - 60;\n  let decimalToBinaryStringLength61 = decimalToBinaryStringLength - 61;\n  let decimalToBinaryStringLength62 = decimalToBinaryStringLength - 62;\n  let decimalToBinaryStringLength63 = decimalToBinaryStringLength - 63;\n  let decimalToBinaryStringLength64 = decimalToBinaryStringLength - 64;\n  let decimalToBinaryStringLength65 = decimalToBinaryStringLength - 65;\n  let decimalToBinaryStringLength66 = decimalToBinaryStringLength - 66;\n  let decimalToBinaryStringLength67 = decimalToBinaryStringLength - 67;\n  let decimalToBinaryStringLength68 = decimalToBinaryStringLength - 68;\n  let decimalToBinaryStringLength69 = decimalToBinaryStringLength - 69;\n  let decimalToBinaryStringLength70 = decimalToBinaryStringLength - 70;\n  let decimalToBinaryStringLength71 = decimalToBinaryStringLength - 71;\n  let decimalToBinaryStringLength72 = decimalToBinaryStringLength - 72;\n  let decimalToBinaryStringLength73 = decimalToBinaryStringLength - 73;\n  let decimalToBinaryStringLength74 = decimalToBinaryStringLength - 74;\n  let decimalToBinaryStringLength75 = decimalToBinaryStringLength - 75;\n  let decimalToBinaryStringLength76 = decimalToBinaryStringLength - 76;\n  let decimalToBinaryStringLength77 = decimalToBinaryStringLength - 77;\n  let decimalToBinaryStringLength78 = decimalToBinaryStringLength - 78;\n  let decimalToBinaryStringLength79 = decimalToBinaryStringLength - 79;\n  let decimalToBinaryStringLength80 = decimalToBinaryStringLength - 80;\n  let decimalToBinaryStringLength81 = decimalToBinaryStringLength - 81;\n  let decimalToBinaryStringLength82 = decimalToBinaryStringLength - 82;\n  let decimalToBinaryStringLength83 = decimalToBinaryStringLength - 83;\n  let decimalToBinaryStringLength84 = decimalToBinaryStringLength - 84;\n  let decimalToBinaryStringLength85 = decimalToBinaryStringLength - 85;\n  let decimalToBinary", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "gc": "<|endoftext|>/* For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of tuples consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> sumProduct([2, 3, 4, 5], 2)\n  ([2, 6], [24, 120])\n  */\nconst sumProductList = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n    result.push([sum, product]);\n  }\n  return result;\n};\n\n/* Given a list of integers, return a list of tuples consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> sumProductList([2, 3, 4, 5], 2)\n  ([2, 6], [24, 120])\n  */\nconst sumProductListWithSum = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n    result.push([sum, product]);\n  }\n  return result;\n};\n\n/* Given a list of integers, return a list of tuples consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> sumProductListWithSum([2, 3, 4, 5], 2)\n  ([2, 6], [24, 120])\n  */\nconst sumProductListWithSumAndProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n    result.push([sum, product]);\n  }\n  return result;\n};\n\n/* Given a list of integers, return a list of tuples consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> sumProductListWithSumAndProduct([2, 3, 4, 5], 2)\n  ([2, 6], [24, 120])\n  */\nconst sumProductListWithSumAndProductAndSum = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n    result.push([sum, product]);\n  }\n  return result;\n};\n\n/* Given a list of integers, return a list of tuples consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> sumProductListWithSumAndProductAndSum([2, 3, 4, 5], 2)\n  ([2, 6], [24, 120])\n  */\nconst sumProductListWithSumAndProductAndSumAndProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n    result.push([sum, product]);\n  }\n  return result;\n};\n\n/* Given a list of integers, return a list of tuples consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> sumProductListWithSumAndProductAndSumAndProductAndSumAndProduct([2, 3, 4, 5], 2)\n  ([2, 6], [24, 120])\n  */\nconst sumProductListWithSumAndProductAndSumAndProductAndSumAndProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n    result.push([sum, product]);\n  }\n  return result;\n};\n\n/* Given a list of integers, return a list of tuples consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> sumProductListWithSumAndProductAndSumAndProductAndSumAndProductAndSumAndProduct([2, 3, 4, 5], 2)\n  ([2, 6], [24, 120])\n  */\nconst sumProductListWithSumAndProductAndSumAndProductAndSumAndProductAndSumAndProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n    result.push([sum, product]);\n  }\n  return result;\n};\n\n/* Given a list of integers, return a list of tuples consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> sumProductListWithSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSumAndProductAndSum", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/80", "prompt": "/*You are given a string s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "gc": "<|endoftext|>/*You are given a string s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let isHappy = true;\n  let count = 0;\n  let isHappyChar;\n  let isHappyChar2;\n  let isHappyChar3;\n  let isHappyChar4;\n  let isHappyChar5;\n  let isHappyChar6;\n  let isHappyChar7;\n  let isHappyChar8;\n  let isHappyChar9;\n  let isHappyChar10;\n  let isHappyChar11;\n  let isHappyChar12;\n  let isHappyChar13;\n  let isHappyChar14;\n  let isHappyChar15;\n  let isHappyChar16;\n  let isHappyChar17;\n  let isHappyChar18;\n  let isHappyChar19;\n  let isHappyChar20;\n  let isHappyChar21;\n  let isHappyChar22;\n  let isHappyChar23;\n  let isHappyChar24;\n  let isHappyChar25;\n  let isHappyChar26;\n  let isHappyChar27;\n  let isHappyChar28;\n  let isHappyChar29;\n  let isHappyChar30;\n  let isHappyChar31;\n  let isHappyChar32;\n  let isHappyChar33;\n  let isHappyChar34;\n  let isHappyChar35;\n  let isHappyChar36;\n  let isHappyChar37;\n  let isHappyChar38;\n  let isHappyChar39;\n  let isHappyChar40;\n  let isHappyChar41;\n  let isHappyChar42;\n  let isHappyChar43;\n  let isHappyChar44;\n  let isHappyChar45;\n  let isHappyChar46;\n  let isHappyChar47;\n  let isHappyChar48;\n  let isHappyChar49;\n  let isHappyChar50;\n  let isHappyChar51;\n  let isHappyChar52;\n  let isHappyChar53;\n  let isHappyChar54;\n  let isHappyChar55;\n  let isHappyChar56;\n  let isHappyChar57;\n  let isHappyChar58;\n  let isHappyChar59;\n  let isHappyChar60;\n  let isHappyChar61;\n  let isHappyChar62;\n  let isHappyChar63;\n  let isHappyChar64;\n  let isHappyChar65;\n  let isHappyChar66;\n  let isHappyChar67;\n  let isHappyChar68;\n  let isHappyChar69;\n  let isHappyChar70;\n  let isHappyChar71;\n  let isHappyChar72;\n  let isHappyChar73;\n  let isHappyChar74;\n  let isHappyChar75;\n  let isHappyChar76;\n  let isHappyChar77;\n  let isHappyChar78;\n  let isHappyChar79;\n  let isHappyChar80;\n  let isHappyChar81;\n  let isHappyChar82;\n  let isHappyChar83;\n  let isHappyChar84;\n  let isHappyChar85;\n  let isHappyChar86;\n  let isHappyChar87;\n  let isHappyChar88;\n  let isHappyChar89;\n  let isHappyChar90;\n  let isHappyChar91;\n  let isHappyChar92;\n  let isHappyChar93;\n  let isHappyChar94;\n  let isHappyChar95;\n  let isHappyChar96;\n  let isHappyChar97;\n  let isHappyChar98;\n  let isHappyChar99;\n  let isHappyChar100;\n  let isHappyChar101;\n  let isHappyChar102;\n  let isHappyChar103;\n  let isHappyChar104;\n  let isHappyChar105;\n  let isHappyChar106;\n  let isHappyChar107;\n  let isHappyChar108;\n  let isHappyChar109;\n  let isHappyChar110;\n  let isHappyChar111;\n  let isHappyChar112;\n  let isHappyChar113;\n  let isHappyChar114;\n  let isHappyChar115;\n  let isHappyChar116;\n  let isHappyChar117;\n  let isHappyChar118;\n  let isHappyChar119;\n  let isHappyChar120;\n  let isHappyChar121;\n  let isHappyChar122;\n  let isHappyChar123;\n  let isHappyChar124;\n  let isHappyChar125;\n  let isHappyChar126;\n  let isHappyChar127;\n  let isHappyChar128;\n  let isHappyChar129;\n  let isHappyChar130;\n  let isHappyChar131;\n  let isHappyChar132;\n  let isHappyChar133;\n  let isHappyChar134;\n  let isHappyChar135;\n  let isHappyChar136;\n  let isHappyChar137;\n  let isHappyChar138;\n  let isHappyChar139;\n  let isHappyChar140;\n  let isHappyChar141;\n  let isHappyChar142;\n  let isHappyChar143;\n  let isHappyChar144;\n  let isHappyChar145;\n  let isHappyChar146;\n  let isHappyChar147;\n  let isHappyChar148;\n  let isHappyChar149;\n  let isHappyChar150;\n  let isHappyChar151;\n  let isHappyChar152;\n  let isHappyChar153;\n  let isHappyChar154;\n  let isHappyChar155;\n  let isHappyChar156;\n  let isHappyChar157;\n  let isHappyChar158;\n  let isHappyChar159;\n  let isHappyChar160;\n  let isHap", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/81", "prompt": "/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  nmueriaclLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst nmueriaclLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "nmueriaclLetterGrade", "gc": "<|endoftext|>/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  nmueriaclLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst nmueriaclLetterGrade = (grades) => {\n  const letterGrades = ['A', 'B', 'C', 'D', 'E'];\n  let letterGrade = '';\n  let letterGradeIndex = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grades.length - 1;\n  let letterGradeIndexMin = 0;\n  let letterGradeIndexMax = grade", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/82", "prompt": "/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "gc": "<|endoftext|>/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let isPrime = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (i % 2 === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 3 or false otherwise\n  Examples\n  divisibleBy3('Hello') == true\n  divisibleBy3('abcdcba') == true\n  divisibleBy3('kittens') == false\n  divisibleBy3('orange') == false\n  */\nconst divisibleBy3 = (string) => {\n  let isDivisibleBy3 = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (i % 3 === 0) {\n      isDivisibleBy3 = false;\n      break;\n    }\n  }\n  return isDivisibleBy3;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 5 or false otherwise\n  Examples\n  divisibleBy5('Hello') == true\n  divisibleBy5('abcdcba') == true\n  divisibleBy5('kittens') == false\n  divisibleBy5('orange') == false\n  */\nconst divisibleBy5 = (string) => {\n  let isDivisibleBy5 = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (i % 5 === 0) {\n      isDivisibleBy5 = false;\n      break;\n    }\n  }\n  return isDivisibleBy5;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 7 or false otherwise\n  Examples\n  divisibleBy7('Hello') == true\n  divisibleBy7('abcdcba') == true\n  divisibleBy7('kittens') == false\n  divisibleBy7('orange') == false\n  */\nconst divisibleBy7 = (string) => {\n  let isDivisibleBy7 = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (i % 7 === 0) {\n      isDivisibleBy7 = false;\n      break;\n    }\n  }\n  return isDivisibleBy7;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 9 or false otherwise\n  Examples\n  divisibleBy9('Hello') == true\n  divisibleBy9('abcdcba') == true\n  divisibleBy9('kittens') == false\n  divisibleBy9('orange') == false\n  */\nconst divisibleBy9 = (string) => {\n  let isDivisibleBy9 = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (i % 9 === 0) {\n      isDivisibleBy9 = false;\n      break;\n    }\n  }\n  return isDivisibleBy9;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 11 or false otherwise\n  Examples\n  divisibleBy11('Hello') == true\n  divisibleBy11('abcdcba') == true\n  divisibleBy11('kittens') == false\n  divisibleBy11('orange') == false\n  */\nconst divisibleBy11 = (string) => {\n  let isDivisibleBy11 = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (i % 11 === 0) {\n      isDivisibleBy11 = false;\n      break;\n    }\n  }\n  return isDivisibleBy11;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 13 or false otherwise\n  Examples\n  divisibleBy13('Hello') == true\n  divisibleBy13('abcdcba') == true\n  divisibleBy13('kittens') == false\n  divisibleBy13('orange') == false\n  */\nconst divisibleBy13 = (string) => {\n  let isDivisibleBy13 = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (i % 13 === 0) {\n      isDivisibleBy13 = false;\n      break;\n    }\n  }\n  return isDivisibleBy13;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 15 or false otherwise\n  Examples\n  divisibleBy15('Hello') == true\n  divisibleBy15('abcdcba') == true\n  divisibleBy15('kittens') == false\n  divisibleBy15('orange') == false\n  */\nconst divisibleBy15 = (string) => {\n  let isDivisibleBy15 = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (i % 15 === 0) {\n      isDivisibleBy15 = false;\n      break;\n    }\n  }\n  return isDivisibleBy15;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 17 or false otherwise\n  Examples\n  divisibleBy17('Hello') == true\n  divisibleBy17('abcdcba') == true\n  divisibleBy17('kittens') == false\n  divisibleBy17('orange') == false\n  */\nconst divisibleBy17 = (string) => {\n  let isDivisibleBy17 = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (i % 17 === 0) {\n      isDivisibleBy17 = false;\n      break;\n    }\n  }\n  return isDivisibleBy17;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 19 or false otherwise\n  Examples\n  divisibleBy19('Hello') == true\n  divisibleBy19('abcdcba') == true\n  divisibleBy19('kittens') == false\n  divisibleBy19('orange') == false\n  */\nconst divisibleBy19 = (string) => {\n  let isDivisibleBy19 = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (i % 19 === 0) {\n      isDivisibleBy19 = false;\n      break;\n    }\n  }\n  return isDivisibleBy19;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 21 or false otherwise\n  Examples\n  divisibleBy21('Hello') == true\n  divisibleBy21('abcdcba') == true\n  divisibleBy21('kittens') == false\n  divisibleBy21('orange') == false\n  */\nconst divisibleBy21 = (string) => {\n  let isDivisibleBy21 = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (i % 21 === 0) {\n      isDivisibleBy21 = false;\n      break;\n    }\n  }\n  return isDivisibleBy21;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 23 or false otherwise\n  Examples\n  divisibleBy23('Hello') == true\n  divisibleBy23('abcdcba') == true\n  divisibleBy23('kittens') == false\n  divisibleBy23('orange') == false\n  */\nconst divisibleBy23 = (string) => {\n  let isDivisibleBy23 = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (i % 23 === 0) {\n      isDivisibleBy23 = false;\n      break;\n    }\n  }\n  return isDivisibleBy23;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 31 or false otherwise\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "gc": "<|endoftext|>/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 1; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 2.\n  */\nconst startsTwoEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 2; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 3.\n  */\nconst startsThreeEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 3; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 4.\n  */\nconst startsFourEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 4; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 5.\n  */\nconst startsFiveEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 5; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 6.\n  */\nconst startsSixEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 6; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 7.\n  */\nconst startsSevenEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 7; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 8.\n  */\nconst startsEightEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 8; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 9.\n  */\nconst startsNineEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 9; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 10.\n  */\nconst startsTenEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 10; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 11.\n  */\nconst startsElevenEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 11; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 12.\n  */\nconst startsTwelveEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 12; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 13.\n  */\nconst startsThirteenEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 13; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 14.\n  */\nconst startsFourteenEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 14; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 15.\n  */\nconst startsFifteenEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 15; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 16.\n  */\nconst startsSixteenEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 16; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 17.\n  */\nconst startsSeventeenEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 17; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 18.\n  */\nconst startsEighteenEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 18; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 19.\n  */\nconst startsNineteenEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 19; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 20.\n  */\nconst startsTwentyEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 20; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 21.\n  */\nconst startsTwentyThirtyEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 21; i--) {\n    if (n % i === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 22.\n  */\nconst startsTwentyFourtyEnds = (n) => {\n  let count = 0;\n  for (let i = n; i >= 22; i--) {\n    if (n % i === 0) {\n      count++;\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive integer N, return the total sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "gc": "<|endoftext|>/*Given a positive integer N, return the total sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  \n  for(let i = 0; i <= N; i++){\n    binary = binary + binary(i);\n    sum = sum + parseInt(binary.charAt(0), 2);\n  }\n  \n  return sum;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],5:[function(require,module,exports){\n/*\n  Given a positive integer N, return the sum of the digits of the binary representation of N.\n  \n  Example\n      For N = 1000, the sum of the digits will be 1 the output should be \"1\".\n      For N = 150, the sum of the digits will be 6 the output should be \"110\".\n      For N = 147, the sum of the digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  \n  for(let i = 0; i <= N; i++){\n    binary = binary + binary(i);\n    sum = sum + parseInt(binary.charAt(0), 2);\n  }\n  \n  return sum;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],6:[function(require,module,exports){\n/*\n  Given a positive integer N, return the sum of the digits of the decimal representation of N.\n  \n  Example\n      For N = 1000, the sum of the digits will be 1 the output should be \"1\".\n      For N = 150, the sum of the digits will be 6 the output should be \"110\".\n      For N = 147, the sum of the digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of decimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let decimal = \"\";\n  \n  for(let i = 0; i <= N; i++){\n    decimal = decimal + decimal(i);\n    sum = sum + parseInt(decimal.charAt(0), 2);\n  }\n  \n  return sum;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],7:[function(require,module,exports){\n/*\n  Given a positive integer N, return the sum of the digits of the decimal representation of N in base 10.\n  \n  Example\n      For N = 1000, the sum of the digits will be 1 the output should be \"1\".\n      For N = 150, the sum of the digits will be 6 the output should be \"110\".\n      For N = 147, the sum of the digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of decimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let decimal = \"\";\n  \n  for(let i = 0; i <= N; i++){\n    decimal = decimal + decimal(i);\n    sum = sum + parseInt(decimal.charAt(0), 10);\n  }\n  \n  return sum;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],8:[function(require,module,exports){\n/*\n  Given a positive integer N, return the sum of the digits of the decimal representation of N in base 2.\n  \n  Example\n      For N = 1000, the sum of the digits will be 1 the output should be \"1\".\n      For N = 150, the sum of the digits will be 6 the output should be \"110\".\n      For N = 147, the sum of the digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of decimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let decimal = \"\";\n  \n  for(let i = 0; i <= N; i++){\n    decimal = decimal + decimal(i);\n    sum = sum + parseInt(decimal.charAt(0), 2);\n  }\n  \n  return sum;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],9:[function(require,module,exports){\n/*\n  Given a positive integer N, return the sum of the digits of the decimal representation of N in base 10.\n  \n  Example\n      For N = 1000, the sum of the digits will be 1 the output should be \"1\".\n      For N = 150, the sum of the digits will be 6 the output should be \"110\".\n      For N = 147, the sum of the digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of decimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let decimal = \"\";\n  \n  for(let i = 0; i <= N; i++){\n    decimal = decimal + decimal(i);\n    sum = sum + parseInt(decimal.charAt(0), 10);\n  }\n  \n  return sum;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],10:[function(require,module,exports){\n/*\n  Given a positive integer N, return the sum of the digits of the decimal representation of N in base 2.\n  \n  Example\n      For N = 1000, the sum of the digits will be 1 the output should be \"1\".\n      For N = 150, the sum of the digits will be 6 the output should be \"110\".\n      For N = 147, the sum of the digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of decimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let decimal = \"\";\n  \n  for(let i = 0; i <= N; i++){\n    decimal = decimal + decimal(i);\n    sum = sum + parseInt(decimal.charAt(0), 2);\n  }\n  \n  return sum;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],11:[function(require,module,exports){\n/*\n  Given a positive integer N, return the sum of the digits of the decimal representation of N in base 10.\n  \n  Example\n      For N = 1000, the sum of the digits will be 1 the output should be \"1\".\n      For N = 150, the sum of the digits will be 6 the output should be \"110\".\n      For N = 147, the sum of the digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of decimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let decimal = \"\";\n  \n  for(let i = 0; i <= N; i++){\n    decimal = decimal + decimal(i);\n    sum = sum + parseInt(decimal.charAt(0), 10);\n  }\n  \n  return sum;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],12:[function(require,module,exports){\n/*\n  Given a positive integer N, return the sum of the digits of the decimal representation of N in base 2.\n  \n  Example\n      For N = 1000, the sum of the digits will be 1 the output should be \"1\".", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "gc": "<|endoftext|>/*Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non-empty list of integers lst. remove the even elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst remove = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      lst[i] = lst[i] - 1;\n    }\n  }\n  return lst;\n};\n\n/*Given a non-empty list of integers lst. remove the even elements that are at odd indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeEven = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      lst[i] = lst[i] - 1;\n      sum += lst[i];\n    }\n  }\n  return lst;\n};\n\n/*Given a non-empty list of integers lst. remove the odd elements that are at even indices..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 6, 7]\n  */\nconst removeOdd = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      lst[i] = lst[i] + 1;\n      sum += lst[i];\n    }\n  }\n  return lst;\n};\n\n/*Given a non-empty list of integers lst. return the sum of all the even elements that are at odd indices..\n\n\n  Examples:\n      sumEven([4, 2, 6, 7]) ==> 6\n  */\nconst sumEven = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non-empty list of integers lst. return the sum of all the odd elements that are at even indices..\n\n\n  Examples:\n      sumOdd([4, 2, 6, 7]) ==> 7\n  */\nconst sumOdd = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      lst[i] = lst[i] + 1;\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\n/*Given a non-empty list of integers lst. return the difference between the sum of all the even elements that are at odd indices..\n\n\n  Examples:\n      diffEven([4, 2, 6, 7]) ==> 2\n  */\nconst diffEven = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum - sumEven(lst);\n};\n\n/*Given a non-empty list of integers lst. return the difference between the sum of all the odd elements that are at even indices..\n\n\n  Examples:\n      diffOdd([4, 2, 6, 7]) ==> 1\n  */\nconst diffOdd = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      lst[i] = lst[i] + 1;\n      sum += lst[i];\n    }\n  }\n  return sum - sumOdd(lst);\n};\n\n/*Given a non-empty list of integers lst. return the difference between the difference between the sum of all the even elements that are at odd indices..\n\n\n  Examples:\n      diff([4, 2, 6, 7]) ==> 1\n  */\nconst diff = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum - sumEven(lst) - sumOdd(lst);\n};\n\n/*Given a non-empty list of integers lst. return the difference between the difference between the sum of all the even elements that are at odd indices..\n\n\n  Examples:\n      diff([4, 2, 6, 7]) ==> -1\n  */\nconst diffNegative = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum - sumEven(lst) - sumOdd(lst);\n};\n\n/*Given a non-empty list of integers lst. return the difference between the difference between the sum of all the even elements that are at odd indices..\n\n\n  Examples:\n      diffNegative([4, 2, 6, 7]) ==> -2\n  */\nconst diffPositive = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      lst[i] = lst[i] + 1;\n      sum += lst[i];\n    }\n  }\n  return sum - sumEven(lst) - sumOdd(lst);\n};\n\n/*Given a non-empty list of integers lst. return the difference between the difference between the sum of all the even elements that are at odd indices..\n\n\n  Examples:\n      diffPositive([4, 2, 6, 7]) ==> 1\n  */\nconst diffPositiveNegative = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      lst[i] = lst[i] + 1;\n      sum += lst[i];\n    }\n  }\n  return sum - sumEven(lst) - sumOdd(lst);\n};\n\n/*Given a non-empty list of integers lst. return the difference between the difference between the sum of all the even elements that are at odd indices..\n\n\n  Examples:\n      diffPositiveNegative([4, 2, 6, 7]) ==> -1\n  */\nconst diffNegativePositive = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      lst[i] = lst[i] + 1;\n      sum += lst[i];\n    }\n  }\n  return sum - sumEven(lst) - sumOdd(lst);\n};\n\n/*Given a non-empty list of integers lst. return the difference between the difference between the sum of all the even elements that are at odd indices..\n\n\n  Examples:\n      diffNegativePositive([4, 2, 6, 7]) ==> -2\n  */\nconst diffNegativePositiveNegative = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      lst[i] = lst[i] + 1;\n      sum += lst[i];\n    }\n  }\n  return sum - sumEven(lst) - sumOdd(lst);\n};\n\n/*Given a non-empty list of integers lst. return the difference between the difference between the sum of all the even elements that are at odd indices..\n\n\n  Examples:\n      diffNegativePositiveNegative([4, 2, 6, 7]) ==> -1\n  */\nconst diffNegativeNegativePositive = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      lst[i] = lst[i] + 1;\n      sum += lst[i];\n    }\n  }\n  return sum - sumEven(lst) - sumOdd(lst);\n};\n\n/*Given a non-empty list of integers lst. return the difference between the difference between the sum of all the even elements that are at odd indices..\n\n\n  Examples:\n      diffNegativeNegativePositive([4, 2, 6, 7]) ==> -2\n  */\nconst diffNegativeNegativeNegative = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      lst[i] = lst[i] + 1;\n      sum += lst[i];\n    }\n  }\n  return sum - sumEven(lst) - sumOdd(lst);\n};\n\n/*Given a non-empty list of integers lst. return the difference between the difference between the sum of all the even elements that are at odd indices..\n\n\n  Examples:\n      diffNegativeNegativeNegative([4, 2, 6, 7]) ==> -1\n  */\nconst diffNegativeNegativeNegativePositive = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      lst[i] = lst[i] + 1;\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antSihuffle('Hi') returns 'Hi'\n  antSihuffle('hello') returns 'ehllo'\n  antSihuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antSihuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antSihuffle", "gc": "<|endoftext|>/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antSihuffle('Hi') returns 'Hi'\n  antSihuffle('hello') returns 'ehllo'\n  antSihuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antSihuffle = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    let newWord = '';\n    for (let j = 0; j < word.length; j++) {\n      let char = word[j];\n      if (char >= 'a' && char <= 'z') {\n        newWord += char;\n      } else if (char >= 'A' && char <= 'Z') {\n        newWord += char.toUpperCase();\n      } else {\n        newWord += char;\n      }\n    }\n    newStr += newWord;\n  }\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antSihuffle('Hi') returns 'Hi'\n  antSihuffle('hello') returns 'ehllo'\n  antSihuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antSihuffle = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    let newWord = '';\n    for (let j = 0; j < word.length; j++) {\n      let char = word[j];\n      if (char >= 'a' && char <= 'z') {\n        newWord += char;\n      } else if (char >= 'A' && char <= 'Z') {\n        newWord += char.toUpperCase();\n      } else {\n        newWord += char;\n      }\n    }\n    newStr += newWord;\n  }\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antSihuffle('Hi') returns 'Hi'\n  antSihuffle('hello') returns 'ehllo'\n  antSihuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antSihuffle = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    let newWord = '';\n    for (let j = 0; j < word.length; j++) {\n      let char = word[j];\n      if (char >= 'a' && char <= 'z') {\n        newWord += char;\n      } else if (char >= 'A' && char <= 'Z') {\n        newWord += char.toUpperCase();\n      } else {\n        newWord += char;\n      }\n    }\n    newStr += newWord;\n  }\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antSihuffle('Hi') returns 'Hi'\n  antSihuffle('hello') returns 'ehllo'\n  antSihuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antSihuffle = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    let newWord = '';\n    for (let j = 0; j < word.length; j++) {\n      let char = word[j];\n      if (char >= 'a' && char <= 'z') {\n        newWord += char;\n      } else if (char >= 'A' && char <= 'Z') {\n        newWord += char.toUpperCase();\n      } else {\n        newWord += char;\n      }\n    }\n    newStr += newWord;\n  }\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antSihuffle('Hi') returns 'Hi'\n  antSihuffle('hello') returns 'ehllo'\n  antSihuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antSihuffle = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    let newWord = '';\n    for (let j = 0; j < word.length; j++) {\n      let char = word[j];\n      if (char >= 'a' && char <= 'z') {\n        newWord += char;\n      } else if (char >= 'A' && char <= 'Z') {\n        newWord += char.toUpperCase();\n      } else {\n        newWord += char;\n      }\n    }\n    newStr += newWord;\n  }\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antSihuffle('Hi') returns 'Hi'\n  antSihuffle('hello') returns 'ehllo'\n  antSihuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antSihuffle = (s) => {\n  let newStr = '';\n  let words = s.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    let newWord = '';\n    for (let j = 0; j < word.length; j++) {\n      let char = word[j];\n      if (char >= 'a' && char <= 'z') {\n        newWord += char;\n      } else if (char >= 'A' && char <= 'Z') {\n        newWord += char.toUpperCase();\n      } else {\n        newWord += char;\n      }\n    }\n    newStr += newWord;\n  }\n  return newStr;\n};\n\n/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antSihuffle('Hi') returns 'Hi'\n  antSihuffle('hello') returns 'ehllo'\n  antSi", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "gc": "<|endoftext|>/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const row = []\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  \n  while (rowIndex < lst.length) {\n    if (lst[rowIndex][columnIndex] === x) {\n      row.push([rowIndex, columnIndex])\n      rowLength++\n      columnLength++\n      columnIndex++\n    } else {\n      rowIndex++\n    }\n  }\n  \n  row.sort((a, b) => b[1] - a[1])\n  \n  return row.map(([row, column]) => {\n    return [row, column]\n  })\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getColumn = (lst, x) => {\n  const row = []\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  \n  while (rowIndex < lst.length) {\n    if (lst[rowIndex][columnIndex] === x) {\n      row.push([columnIndex, rowIndex])\n      columnLength++\n      rowLength++\n      rowIndex++\n    } else {\n      columnIndex++\n    }\n  }\n  \n  row.sort((a, b) => b[0] - a[0])\n  \n  return row.map(([row, column]) => {\n    return [row, column]\n  })\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRowAndColumn = (lst, x) => {\n  const row = []\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  \n  while (rowIndex < lst.length) {\n    if (lst[rowIndex][columnIndex] === x) {\n      row.push([rowIndex, columnIndex])\n      rowLength++\n      columnLength++\n      columnIndex++\n    } else {\n      rowIndex++\n    }\n  }\n  \n  row.sort((a, b) => b[1] - a[1])\n  \n  return row.map(([row, column]) => {\n    return [row, column]\n  })\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRowAndColumnAndRow = (lst, x) => {\n  const row = []\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  \n  while (rowIndex < lst.length) {\n    if (lst[rowIndex][columnIndex] === x) {\n      row.push([rowIndex, columnIndex])\n      rowLength++\n      columnLength++\n      columnIndex++\n    } else {\n      rowIndex++\n    }\n  }\n  \n  row.sort((a, b) => b[1] - a[1])\n  \n  return row.map(([row, column]) => {\n    return [row, column]\n  })\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRowAndColumnAndRowAndColumn = (lst, x) => {\n  const row = []\n  let rowIndex = 0\n  let columnIndex = 0\n  let rowLength = 0\n  let columnLength = 0\n  \n  while (rowIndex < lst.length) {\n    if (lst[rowIndex][columnIndex] === x) {\n      row.push([rowIndex, columnIndex])\n      rowLength++\n      columnLength++\n      columnIndex++\n    } else {\n      rowIndex++\n    }\n  }\n  \n  row.sort((a, b) => b[1] - a[1])\n  \n  return row.map(([row, column]) => {\n    return [row, column]\n  })\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by row", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n  or sort it in descending order if the sum( first index value, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "gc": "<|endoftext|>/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n  or sort it in descending order if the sum( first index value, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sortedArray = array.sort((a, b) => {\n    if (a > b) {\n      return 1;\n    }\n    if (a < b) {\n      return -1;\n    }\n    return 0;\n  });\n  return sortedArray;\n};\n\n/**\n * Given an array of non-negative integers, return its sum.\n\n  Example:\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15\n  * sumArray([5, 2, -3, 4, -1, 1]) => 15", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/89", "prompt": "/*Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "gc": "<|endoftext|>/*Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotated = '';\n  let i;\n  let j;\n  let temp;\n  let temp2;\n  let temp3;\n  let temp4;\n  let temp5;\n  let temp6;\n  let temp7;\n  let temp8;\n  let temp9;\n  let temp10;\n  let temp11;\n  let temp12;\n  let temp13;\n  let temp14;\n  let temp15;\n  let temp16;\n  let temp17;\n  let temp18;\n  let temp19;\n  let temp20;\n  let temp21;\n  let temp22;\n  let temp23;\n  let temp24;\n  let temp25;\n  let temp26;\n  let temp27;\n  let temp28;\n  let temp29;\n  let temp30;\n  let temp31;\n  let temp32;\n  let temp33;\n  let temp34;\n  let temp35;\n  let temp36;\n  let temp37;\n  let temp38;\n  let temp39;\n  let temp40;\n  let temp41;\n  let temp42;\n  let temp43;\n  let temp44;\n  let temp45;\n  let temp46;\n  let temp47;\n  let temp48;\n  let temp49;\n  let temp50;\n  let temp51;\n  let temp52;\n  let temp53;\n  let temp54;\n  let temp55;\n  let temp56;\n  let temp57;\n  let temp58;\n  let temp59;\n  let temp60;\n  let temp61;\n  let temp62;\n  let temp63;\n  let temp64;\n  let temp65;\n  let temp66;\n  let temp67;\n  let temp68;\n  let temp69;\n  let temp70;\n  let temp71;\n  let temp72;\n  let temp73;\n  let temp74;\n  let temp75;\n  let temp76;\n  let temp77;\n  let temp78;\n  let temp79;\n  let temp80;\n  let temp81;\n  let temp82;\n  let temp83;\n  let temp84;\n  let temp85;\n  let temp86;\n  let temp87;\n  let temp88;\n  let temp89;\n  let temp90;\n  let temp91;\n  let temp92;\n  let temp93;\n  let temp94;\n  let temp95;\n  let temp96;\n  let temp97;\n  let temp98;\n  let temp99;\n  let temp100;\n  let temp101;\n  let temp102;\n  let temp103;\n  let temp104;\n  let temp105;\n  let temp106;\n  let temp107;\n  let temp108;\n  let temp109;\n  let temp110;\n  let temp111;\n  let temp112;\n  let temp113;\n  let temp114;\n  let temp115;\n  let temp116;\n  let temp117;\n  let temp118;\n  let temp119;\n  let temp120;\n  let temp121;\n  let temp122;\n  let temp123;\n  let temp124;\n  let temp125;\n  let temp126;\n  let temp127;\n  let temp128;\n  let temp129;\n  let temp130;\n  let temp131;\n  let temp132;\n  let temp133;\n  let temp134;\n  let temp135;\n  let temp136;\n  let temp137;\n  let temp138;\n  let temp139;\n  let temp140;\n  let temp141;\n  let temp142;\n  let temp143;\n  let temp144;\n  let temp145;\n  let temp146;\n  let temp147;\n  let temp148;\n  let temp149;\n  let temp150;\n  let temp151;\n  let temp152;\n  let temp153;\n  let temp154;\n  let temp155;\n  let temp156;\n  let temp157;\n  let temp158;\n  let temp159;\n  let temp160;\n  let temp161;\n  let temp162;\n  let temp163;\n  let temp164;\n  let temp165;\n  let temp166;\n  let temp167;\n  let temp168;\n  let temp169;\n  let temp170;\n  let temp171;\n  let temp172;\n  let temp173;\n  let temp174;\n  let temp175;\n  let temp176;\n  let temp177;\n  let temp178;\n  let temp179;\n  let temp180;\n  let temp181;\n  let temp182;\n  let temp183;\n  let temp184;\n  let temp185;\n  let temp186;\n  let temp187;\n  let temp188;\n  let temp189;\n  let temp190;\n  let temp191;\n  let temp192;\n  let temp193;\n  let temp194;\n  let temp195;\n  let temp196;\n  let temp197;\n  let temp198;\n  let temp199;\n  let temp200;\n  let temp201;\n  let temp202;\n  let temp203;\n  let temp204;\n  let temp205;\n  let temp206;\n  let temp207;\n  let temp208;\n  let temp209;\n  let temp210;\n  let temp211;\n  let temp212;\n  let temp213;\n  let temp214;\n  let temp215;\n  let temp216;\n  let temp217;\n  let temp218;\n  let temp219;\n  let temp220;\n  let temp221;\n  let temp222;\n  let temp223;\n  let temp224;\n  let temp225;\n  let temp226;\n  let temp227;\n  let temp228;\n  let temp229;\n  let temp230;\n  let temp231;\n  let temp232;\n  let temp233;\n  let temp234;\n  let temp235;\n  let temp236;\n  let temp237;\n  let temp238;\n  let temp239;\n  let temp240;\n  let temp241;\n  let temp242;\n  let temp243;\n  let temp244;\n  let temp245;\n  let temp246;\n  let temp247;\n  let temp248;\n  let temp249;\n  let temp250;\n  let temp251;\n  let temp252;\n  let temp253;\n  let temp254;\n  let temp255;\n  let temp256;\n  let temp257;\n  let temp258;\n  let temp259;\n  let temp260;\n  let temp261;\n  let temp262;\n  let temp263;\n  let temp264;\n  let temp265;\n  let temp266;\n  let temp267;\n  let temp268;\n  let temp269;\n  let temp270;\n  let temp271;\n  let temp272;\n  let temp273;\n  let temp274;\n  let temp275;\n  let temp276;\n  let temp277;\n  let temp278;\n  let temp279;\n  let temp280;\n  let temp281;\n  let temp282;\n  let temp283;\n  let temp284;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/9", "prompt": "/* From a given list of integers, generate a list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "gc": "<|endoftext|>/* From a given list of integers, generate a list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  let max = 0;\n  let maxIndex = 0;\n  let maxValue = 0;\n  let currentIndex = 0;\n  let currentValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > maxValue) {\n      max = numbers[i];\n      maxIndex = i;\n      maxValue = numbers[i];\n    }\n  }\n  for (let i = maxIndex + 1; i < numbers.length; i++) {\n    if (numbers[i] > maxValue) {\n      max = numbers[i];\n      maxIndex = i;\n      maxValue = numbers[i];\n    }\n  }\n  for (let i = maxIndex - 1; i >= 0; i--) {\n    if (numbers[i] > maxValue) {\n      max = numbers[i];\n      maxIndex = i;\n      maxValue = numbers[i];\n    }\n  }\n  return [maxValue, maxIndex];\n};\n\n/* Given a sequence of integers, generate a list of rolling minimum element found until given moment\n  in the sequence.\n  >>> rollingMin([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 1, 2, 3]\n  */\nconst rollingMin = (numbers) => {\n  let min = 0;\n  let minIndex = 0;\n  let minValue = 0;\n  let currentIndex = 0;\n  let currentValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] < minValue) {\n      min = numbers[i];\n      minIndex = i;\n      minValue = numbers[i];\n    }\n  }\n  for (let i = minIndex + 1; i < numbers.length; i++) {\n    if (numbers[i] < minValue) {\n      min = numbers[i];\n      minIndex = i;\n      minValue = numbers[i];\n    }\n  }\n  for (let i = minIndex - 1; i >= 0; i--) {\n    if (numbers[i] < minValue) {\n      min = numbers[i];\n      minIndex = i;\n      minValue = numbers[i];\n    }\n  }\n  return [minValue, minIndex];\n};\n\n/* Given a sequence of integers, generate a list of rolling mean element found until given moment\n  in the sequence.\n  >>> rollingMean([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 1.5, 1.5]\n  */\nconst rollingMean = (numbers) => {\n  let mean = 0;\n  let meanIndex = 0;\n  let meanValue = 0;\n  let currentIndex = 0;\n  let currentValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > meanValue) {\n      mean = numbers[i];\n      meanIndex = i;\n      meanValue = numbers[i];\n    }\n  }\n  for (let i = meanIndex + 1; i < numbers.length; i++) {\n    if (numbers[i] > meanValue) {\n      mean = numbers[i];\n      meanIndex = i;\n      meanValue = numbers[i];\n    }\n  }\n  for (let i = meanIndex - 1; i >= 0; i--) {\n    if (numbers[i] > meanValue) {\n      mean = numbers[i];\n      meanIndex = i;\n      meanValue = numbers[i];\n    }\n  }\n  return [meanValue, meanIndex];\n};\n\n/* Given a sequence of integers, generate a list of rolling standard deviation element found until given moment\n  in the sequence.\n  >>> rollingStd([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 1.5, 1.5]\n  */\nconst rollingStd = (numbers) => {\n  let std = 0;\n  let stdIndex = 0;\n  let stdValue = 0;\n  let currentIndex = 0;\n  let currentValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > stdValue) {\n      std = numbers[i];\n      stdIndex = i;\n      stdValue = numbers[i];\n    }\n  }\n  for (let i = stdIndex + 1; i < numbers.length; i++) {\n    if (numbers[i] > stdValue) {\n      std = numbers[i];\n      stdIndex = i;\n      stdValue = numbers[i];\n    }\n  }\n  for (let i = stdIndex - 1; i >= 0; i--) {\n    if (numbers[i] > stdValue) {\n      std = numbers[i];\n      stdIndex = i;\n      stdValue = numbers[i];\n    }\n  }\n  return [stdValue, stdIndex];\n};\n\n/* Given a sequence of integers, generate a list of rolling variance element found until given moment\n  in the sequence.\n  >>> rollingVariance([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 1.5, 1.5]\n  */\nconst rollingVariance = (numbers) => {\n  let variance = 0;\n  let varianceIndex = 0;\n  let varianceValue = 0;\n  let currentIndex = 0;\n  let currentValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > varianceValue) {\n      variance = numbers[i];\n      varianceIndex = i;\n      varianceValue = numbers[i];\n    }\n  }\n  for (let i = varianceIndex + 1; i < numbers.length; i++) {\n    if (numbers[i] > varianceValue) {\n      variance = numbers[i];\n      varianceIndex = i;\n      varianceValue = numbers[i];\n    }\n  }\n  for (let i = varianceIndex - 1; i >= 0; i--) {\n    if (numbers[i] > varianceValue) {\n      variance = numbers[i];\n      varianceIndex = i;\n      varianceValue = numbers[i];\n    }\n  }\n  return [varianceValue, varianceIndex];\n};\n\n/* Given a sequence of integers, generate a list of rolling skewness element found until given moment\n  in the sequence.\n  >>> rollingSkewness([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 1.5, 1.5]\n  */\nconst rollingSkewness = (numbers) => {\n  let skewness = 0;\n  let skewnessIndex = 0;\n  let skewnessValue = 0;\n  let currentIndex = 0;\n  let currentValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > skewnessValue) {\n      skewness = numbers[i];\n      skewnessIndex = i;\n      skewnessValue = numbers[i];\n    }\n  }\n  for (let i = skewnessIndex + 1; i < numbers.length; i++) {\n    if (numbers[i] > skewnessValue) {\n      skewness = numbers[i];\n      skewnessIndex = i;\n      skewnessValue = numbers[i];\n    }\n  }\n  for (let i = skewnessIndex - 1; i >= 0; i--) {\n    if (numbers[i] > skewnessValue) {\n      skewness = numbers[i];\n      skewnessIndex = i;\n      skewnessValue = numbers[i];\n    }\n  }\n  return [skewnessValue, skewnessIndex];\n};\n\n/* Given a sequence of integers, generate a list of rolling kurtosis element found until given moment\n  in the sequence.\n  >>> rollingKurtosis([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 1.5, 1.5]\n  */\nconst rollingKurtosis = (numbers) => {\n  let kurtosis = 0;\n  let kurtosisIndex = 0;\n  let kurtosisValue = 0;\n  let currentIndex = 0;\n  let currentValue = 0;\n  for (let i = 0; i < numbers.length; i++) {\n    if (numbers[i] > kurtosisValue) {\n      kurtosis = numbers[i];\n      kurtosisIndex = i;\n      kurtosisValue = numbers[i];\n    }\n  }\n  for (let i = kurtosisIndex + 1; i < numbers.length; i++) {\n    if (numbers[i] > kurtosisValue) {\n      kurtosis = numbers[i];\n      kurtosisIndex = i;\n      kurtosisValue = numbers[i];\n    }\n  }\n  for (let i = kurtosisIndex - 1; i >= 0; i--) {\n    if (numbers[i] > kurtosisValue) {\n      kurtosis = numbers[i];\n      kurtosisIndex = i;\n      kurtosisValue = numbers[i];\n    }\n  }\n  return [kurtosisValue, kurtosisIndex];\n};\n\n/* Given a sequence of integers, generate a list of rolling skewness element found until given moment\n  in the sequence.\n  >>> rollingKurtosis([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 2, 1.5, 1.5]\n  */\nconst rollingKurtosis = (numbers) => {\n  let kurtosis = 0;\n  let k", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of integers.\n  Write a function nextSmallset() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallset([1, 2, 3, 4, 5]) == 2\n  nextSmallset([5, 1, 4, 3, 2]) == 2\n  nextSmallset([]) == null\n  nextSmallset([1, 1]) == null\n  */\nconst nextSmallset = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallset", "gc": "<|endoftext|>/*\n  You are given a list of integers.\n  Write a function nextSmallset() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallset([1, 2, 3, 4, 5]) == 2\n  nextSmallset([5, 1, 4, 3, 2]) == 2\n  nextSmallset([]) == null\n  nextSmallset([1, 1]) == null\n  */\nconst nextSmallset = (lst) => {\n  let min = null;\n  let minIndex = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (min === null || lst[i] < min) {\n      min = lst[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextBigset() that returns the 2nd biggest element of the list.\n  Return null if there is no such element.\n  \n  nextBigset([1, 2, 3, 4, 5]) == 5\n  nextBigset([5, 1, 4, 3, 2]) == 5\n  nextBigset([]) == null\n  nextBigset([1, 1]) == null\n  */\nconst nextBigset = (lst) => {\n  let max = null;\n  let maxIndex = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (max === null || lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 1st smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 1\n  nextSmallest([5, 1, 4, 3, 2]) == 1\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  let min = null;\n  let minIndex = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (min === null || lst[i] < min) {\n      min = lst[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextBiggest() that returns the 1st biggest element of the list.\n  Return null if there is no such element.\n  \n  nextBiggest([1, 2, 3, 4, 5]) == 3\n  nextBiggest([5, 1, 4, 3, 2]) == 3\n  nextBiggest([]) == null\n  nextBiggest([1, 1]) == null\n  */\nconst nextBiggest = (lst) => {\n  let max = null;\n  let maxIndex = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (max === null || lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 1st smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 1\n  nextSmallest([5, 1, 4, 3, 2]) == 1\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextBiggest = (lst) => {\n  let min = null;\n  let minIndex = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (min === null || lst[i] < min) {\n      min = lst[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 1st biggest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 3\n  nextSmallest([5, 1, 4, 3, 2]) == 3\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  let max = null;\n  let maxIndex = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (max === null || lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextBiggest() that returns the 1st biggest element of the list.\n  Return null if there is no such element.\n  \n  nextBiggest([1, 2, 3, 4, 5]) == 3\n  nextBiggest([5, 1, 4, 3, 2]) == 3\n  nextBiggest([]) == null\n  nextBiggest([1, 1]) == null\n  */\nconst nextBiggest = (lst) => {\n  let min = null;\n  let minIndex = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (min === null || lst[i] < min) {\n      min = lst[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 1st smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 1\n  nextSmallest([5, 1, 4, 3, 2]) == 1\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  let max = null;\n  let maxIndex = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (max === null || lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextBiggest() that returns the 1st biggest element of the list.\n  Return null if there is no such element.\n  \n  nextBiggest([1, 2, 3, 4, 5]) == 3\n  nextBiggest([5, 1, 4, 3, 2]) == 3\n  nextBiggest([]) == null\n  nextBiggest([1, 1]) == null\n  */\nconst nextBiggest = (lst) => {\n  let min = null;\n  let minIndex = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (min === null || lst[i] < min) {\n      min = lst[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 1st smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 1\n  nextSmallest([5, 1, 4, 3, 2]) == 1\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\nconst nextSmallest = (lst) => {\n  let max = null;\n  let maxIndex = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (max === null || lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextBiggest() that returns the 1st biggest element of the list.\n  Return null if there is no such element.\n  \n  nextBiggest([1, 2, 3, 4, 5]) == 3\n  nextBiggest([5, 1, 4, 3, 2]) == 3\n  nextBiggest([]) == null\n  nextBiggest([1, 1]) == null\n  */\nconst nextBiggest = (lst) => {\n  let min = null;\n  let minIndex = null;\n  for (let i = 0; i < lst.length; i++) {\n    if (min === null || lst[i] < min) {\n      min = lst[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextSmallest() that returns the 1st smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallest([1, 2, 3, 4, 5]) == 1\n  nextSmallest([5, 1, 4, 3, 2]) == 1\n  nextSmallest([]) == null\n  nextSmallest([1, 1]) == null\n  */\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBoerd(\"Hello world\")\n  0\n  >>> isBoerd(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBoerd = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBoerd", "gc": "<|endoftext|>/*\n  You'll be given a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBoerd(\"Hello world\")\n  0\n  >>> isBoerd(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBoerd = (S) => {\n  let boerd = 0;\n  let words = S.split('.');\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = 0;\n  let B = 0;\n  let C = 0;\n  let D = 0;\n  let E = 0;\n  let F = 0;\n  let G = 0;\n  let H = 0;\n  let I = 0;\n  let J = 0;\n  let K = 0;\n  let L = 0;\n  let M = 0;\n  let N = 0;\n  let O = 0;\n  let P = 0;\n  let Q = 0;\n  let R = 0;\n  let S = 0;\n  let T = 0;\n  let U = 0;\n  let V = 0;\n  let W = 0;\n  let X = 0;\n  let Y = 0;\n  let Z = 0;\n  let a = 0;\n  let b", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/92", "prompt": "/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "gc": "<|endoftext|>/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y && x === z) {\n    return true\n  }\n  if (isNaN(x) || isNaN(y) || isNaN(z)) {\n    return false\n  }\n  return x === y && x === z\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7)  true\n  allInt(3, 2, 2)  false\n  allInt(3, -2, 1)  false\n  allInt(3.6, -2.2, 2)  true\n  */\nconst allInt = (x, y, z) => {\n  if (x === y && x === z) {\n    return true\n  }\n  if (isNaN(x) || isNaN(y) || isNaN(z)) {\n    return false\n  }\n  return x === y && x === z\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7)  true\n  allInt(3, 2, 2)  false\n  allInt(3, -2, 1)  false\n  allInt(3.6, -2.2, 2)  false\n  */\nconst allInt = (x, y, z) => {\n  if (x === y && x === z) {\n    return true\n  }\n  if (isNaN(x) || isNaN(y) || isNaN(z)) {\n    return false\n  }\n  return x === y && x === z\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7)  true\n  allInt(3, 2, 2)  false\n  allInt(3, -2, 1)  false\n  allInt(3.6, -2.2, 2)  false\n  */\nconst allInt = (x, y, z) => {\n  if (x === y && x === z) {\n    return true\n  }\n  if (isNaN(x) || isNaN(y) || isNaN(z)) {\n    return false\n  }\n  return x === y && x === z\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7)  true\n  allInt(3, 2, 2)  false\n  allInt(3, -2, 1)  false\n  allInt(3.6, -2.2, 2)  false\n  */\nconst allInt = (x, y, z) => {\n  if (x === y && x === z) {\n    return true\n  }\n  if (isNaN(x) || isNaN(y) || isNaN(z)) {\n    return false\n  }\n  return x === y && x === z\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7)  true\n  allInt(3, 2, 2)  false\n  allInt(3, -2, 1)  false\n  allInt(3.6, -2.2, 2)  false\n  */\nconst allInt = (x, y, z) => {\n  if (x === y && x === z) {\n    return true\n  }\n  if (isNaN(x) || isNaN(y) || isNaN(z)) {\n    return false\n  }\n  return x === y && x === z\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7)  true\n  allInt(3, 2, 2)  false\n  allInt(3, -2, 1)  false\n  allInt(3.6, -2.2, 2)  false\n  */\nconst allInt = (x, y, z) => {\n  if (x === y && x === z) {\n    return true\n  }\n  if (isNaN(x) || isNaN(y) || isNaN(z)) {\n    return false\n  }\n  return x === y && x === z\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7)  true\n  allInt(3, 2, 2)  false\n  allInt(3, -2, 1)  false\n  allInt(3.6, -2.2, 2)  false\n  */\nconst allInt = (x, y, z) => {\n  if (x === y && x === z) {\n    return true\n  }\n  if (isNaN(x) || isNaN(y) || isNaN(z)) {\n    return false\n  }\n  return x === y && x === z\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7)  true\n  allInt(3, 2, 2)  false\n  allInt(3, -2, 1)  false\n  allInt(3.6, -2.2, 2)  false\n  */\nconst allInt = (x, y, z) => {\n  if (x === y && x === z) {\n    return true\n  }\n  if (isNaN(x) || isNaN(y) || isNaN(z)) {\n    return false\n  }\n  return x === y && x === z\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7)  true\n  allInt(3, 2, 2)  false\n  allInt(3, -2, 1)  false\n  allInt(3.6, -2.2, 2)  false\n  */\nconst allInt = (x, y, z) => {\n  if (x === y && x === z) {\n    return true\n  }\n  if (isNaN(x) || isNaN(y) || isNaN(z)) {\n    return false\n  }\n  return x === y && x === z\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7)  true\n  allInt(3, 2, 2)  false\n  allInt(3, -2, 1)  false\n  allInt(3.6, -2.2, 2)  false\n  */\nconst allInt = (x, y, z) => {\n  if (x === y && x === z) {\n    return true\n  }\n  if (isNaN(x) || isNaN(y) || isNaN(z)) {\n    return false\n  }\n  return x === y && x === z\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if all numbers are equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7)  true\n  allInt(", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "gc": "<|endoftext|>/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let encoded = message;\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelsIndex = -1;\n  let vowelsCount = 0;\n  let vowelsIndex2 = 0;\n  let vowelsIndex3 = 0;\n  let vowelsIndex4 = 0;\n  let vowelsIndex5 = 0;\n  let vowelsIndex6 = 0;\n  let vowelsIndex7 = 0;\n  let vowelsIndex8 = 0;\n  let vowelsIndex9 = 0;\n  let vowelsIndex10 = 0;\n  let vowelsIndex11 = 0;\n  let vowelsIndex12 = 0;\n  let vowelsIndex13 = 0;\n  let vowelsIndex14 = 0;\n  let vowelsIndex15 = 0;\n  let vowelsIndex16 = 0;\n  let vowelsIndex17 = 0;\n  let vowelsIndex18 = 0;\n  let vowelsIndex19 = 0;\n  let vowelsIndex20 = 0;\n  let vowelsIndex21 = 0;\n  let vowelsIndex22 = 0;\n  let vowelsIndex23 = 0;\n  let vowelsIndex24 = 0;\n  let vowelsIndex25 = 0;\n  let vowelsIndex26 = 0;\n  let vowelsIndex27 = 0;\n  let vowelsIndex28 = 0;\n  let vowelsIndex29 = 0;\n  let vowelsIndex30 = 0;\n  let vowelsIndex31 = 0;\n  let vowelsIndex32 = 0;\n  let vowelsIndex33 = 0;\n  let vowelsIndex34 = 0;\n  let vowelsIndex35 = 0;\n  let vowelsIndex36 = 0;\n  let vowelsIndex37 = 0;\n  let vowelsIndex38 = 0;\n  let vowelsIndex39 = 0;\n  let vowelsIndex40 = 0;\n  let vowelsIndex41 = 0;\n  let vowelsIndex42 = 0;\n  let vowelsIndex43 = 0;\n  let vowelsIndex44 = 0;\n  let vowelsIndex45 = 0;\n  let vowelsIndex46 = 0;\n  let vowelsIndex47 = 0;\n  let vowelsIndex48 = 0;\n  let vowelsIndex49 = 0;\n  let vowelsIndex50 = 0;\n  let vowelsIndex51 = 0;\n  let vowelsIndex52 = 0;\n  let vowelsIndex53 = 0;\n  let vowelsIndex54 = 0;\n  let vowelsIndex55 = 0;\n  let vowelsIndex56 = 0;\n  let vowelsIndex57 = 0;\n  let vowelsIndex58 = 0;\n  let vowelsIndex59 = 0;\n  let vowelsIndex60 = 0;\n  let vowelsIndex61 = 0;\n  let vowelsIndex62 = 0;\n  let vowelsIndex63 = 0;\n  let vowelsIndex64 = 0;\n  let vowelsIndex65 = 0;\n  let vowelsIndex66 = 0;\n  let vowelsIndex67 = 0;\n  let vowelsIndex68 = 0;\n  let vowelsIndex69 = 0;\n  let vowelsIndex70 = 0;\n  let vowelsIndex71 = 0;\n  let vowelsIndex72 = 0;\n  let vowelsIndex73 = 0;\n  let vowelsIndex74 = 0;\n  let vowelsIndex75 = 0;\n  let vowelsIndex76 = 0;\n  let vowelsIndex77 = 0;\n  let vowelsIndex78 = 0;\n  let vowelsIndex79 = 0;\n  let vowelsIndex80 = 0;\n  let vowelsIndex81 = 0;\n  let vowelsIndex82 = 0;\n  let vowelsIndex83 = 0;\n  let vowelsIndex84 = 0;\n  let vowelsIndex85 = 0;\n  let vowelsIndex86 = 0;\n  let vowelsIndex87 = 0;\n  let vowelsIndex88 = 0;\n  let vowelsIndex89 = 0;\n  let vowelsIndex90 = 0;\n  let vowelsIndex91 = 0;\n  let vowelsIndex92 = 0;\n  let vowelsIndex93 = 0;\n  let vowelsIndex94 = 0;\n  let vowelsIndex95 = 0;\n  let vowelsIndex96 = 0;\n  let vowelsIndex97 = 0;\n  let vowelsIndex98 = 0;\n  let vowelsIndex99 = 0;\n  let vowelsIndex100 = 0;\n  let vowelsIndex101 = 0;\n  let vowelsIndex102 = 0;\n  let vowelsIndex103 = 0;\n  let vowelsIndex104 = 0;\n  let vowelsIndex105 = 0;\n  let vowelsIndex106 = 0;\n  let vowelsIndex107 = 0;\n  let vowelsIndex108 = 0;\n  let vowelsIndex109 = 0;\n  let vowelsIndex110 = 0;\n  let vowelsIndex111 = 0;\n  let vowelsIndex112 = 0;\n  let vowelsIndex113 = 0;\n  let vowelsIndex114 = 0;\n  let vowelsIndex115 = 0;\n  let vowelsIndex116 = 0;\n  let vowelsIndex117 = 0;\n  let vowelsIndex118 = 0;\n  let vowelsIndex119 = 0;\n  let vowelsIndex120 = 0;\n  let vowelsIndex121 = 0;\n  let vowelsIndex122 = 0;\n  let vowelsIndex123 = 0;\n  let vowelsIndex124 = 0;\n  let vowelsIndex125 = 0;\n  let vowelsIndex126 = 0;\n  let vowelsIndex127 = 0;\n  let vowelsIndex128 = 0;\n  let vowelsIndex129 = 0;\n  let vowelsIndex130 = 0;\n  let vowelsIndex131 = 0;\n  let vowelsIndex132 = 0;\n  let vowelsIndex133 = 0;\n  let vowelsIndex134 = 0;\n  let vowelsIndex135 = 0;\n  let vowelsIndex136 = 0;\n  let vowelsIndex137 = 0;\n  let vowelsIndex138 = 0;\n  let vowelsIndex139 = 0;\n  let vowelsIndex140 = 0;\n  let vowelsIndex141 = 0;\n  let vowelsIndex142 = 0;\n  let vowelsIndex143 = 0;\n  let vowelsIndex144 = 0;\n  let vowelsIndex145 = 0;\n  let vowelsIndex146 = 0;\n  let vowelsIndex147 = 0;\n  let vowelsIndex148 = 0;\n  let vowelsIndex149 = 0;\n  let vowelsIndex150 = 0;\n  let vowelsIndex151 = 0;\n  let vowelsIndex152 = 0;\n  let vowelsIndex153 = 0;\n  let vowelsIndex154 = 0;\n  let vowelsIndex155 = 0;\n  let vowelsIndex156 = 0;\n  let vowelsIndex157 = 0;\n  let vowelsIndex158 = 0;\n  let vowelsIndex159 = 0;\n  let vowelsIndex160 = 0;\n  let vowelsIndex161 = 0;\n  let vowelsIndex162 = 0;\n  let vowelsIndex163 = 0;\n  let vowelsIndex164 = 0;\n  let vowelsIndex165 = 0;\n  let vowelsIndex166 = 0;\n  let vowelsIndex167 = 0;\n  let vowelsIndex168 = 0;\n  let vowelsIndex169 = 0;\n  let vowelsIndex170 = 0;\n  let vowelsIndex171 = 0;\n  let vowelsIndex172 = 0;\n  let vowelsIndex173 = 0;\n  let vowelsIndex174 = 0;\n  let vowelsIndex175 = 0;\n  let vowelsIndex176 = 0;\n  let vowelsIndex177 = 0;\n  let vowelsIndex178 = 0;\n  let vowelsIndex179 = 0;\n  let vowelsIndex180 = 0;\n  let vowelsIndex181 = 0;\n  let vowelsIndex182 = 0;\n  let vowelsIndex183 = 0;\n  let vowelsIndex184 = 0;\n  let vowelsIndex185 = 0;\n  let vowelsIndex186 = 0;\n  let vowelsIndex187 = 0;\n  let vowelsIndex188 = 0;\n  let vowelsIndex189 = 0;\n  let vowelsIndex190 = 0;\n  let vowelsIndex191 = 0;\n  let vowelsIndex192 = 0;\n  let vowelsIndex193 = 0;\n  let vowelsIndex194 = 0;\n  let vowelsIndex195 = 0;\n  let vowelsIndex196 = 0;\n  let vowelsIndex197 = 0;\n  let vowelsIndex198 = 0;\n  let vowelsIndex199 = 0;\n  let vowelsIndex200 = 0;\n  let vowelsIndex201 = 0;\n  let vowelsIndex202 = 0;\n  let vowels", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/94", "prompt": "/*You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst ksjkasddk = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "ksjkasddk", "gc": "<|endoftext|>/*You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst ksjkasddk = (lst) => {\n  let max = 0;\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = [];\n  let B = [];\n  let C = [];\n  let D = [];\n  let E = [];\n  let F = [];\n  let G = [];\n  let H = [];\n  let I = [];\n  let J = [];\n  let K = [];\n  let L = [];\n  let M = [];\n  let N = [];\n  let O = [];\n  let P = [];\n  let Q = [];\n  let R = [];\n  let S = [];\n  let T = [];\n  let U = [];\n  let V = [];\n  let W = [];\n  let X = [];\n  let Y = [];\n  let Z = [];\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = [];\n  let B = [];\n  let C = [];\n  let D = [];\n  let E = [];\n  let F = [];\n  let G = [];\n  let H = [];\n  let I = [];\n  let J = [];\n  let K = [];\n  let L = [];\n  let M = [];\n  let N = [];\n  let O = [];\n  let P = [];\n  let Q = [];\n  let R = [];\n  let S = [];\n  let T = [];\n  let U = [];\n  let V = [];\n  let W = [];\n  let X = [];\n  let Y = [];\n  let Z = [];\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = [];\n  let B = [];\n  let C = [];\n  let D = [];\n  let E = [];\n  let F = [];\n  let G = [];\n  let H = [];\n  let I = [];\n  let J = [];\n  let K = [];\n  let L = [];\n  let M = [];\n  let N = [];\n  let O = [];\n  let P = [];\n  let Q = [];\n  let R = [];\n  let S = [];\n  let T = [];\n  let U = [];\n  let V = [];\n  let W = [];\n  let X = [];\n  let Y = [];\n  let Z = [];\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = [];\n  let B = [];\n  let C = [];\n  let D = [];\n  let E = [];\n  let F = [];\n  let G = [];\n  let H = [];\n  let I = [];\n  let J = [];\n  let K = [];\n  let L = [];\n  let M = [];\n  let N = [];\n  let O = [];\n  let P = [];\n  let Q = [];\n  let R = [];\n  let S = [];\n  let T = [];\n  let U = [];\n  let V = [];\n  let W = [];\n  let X = [];\n  let Y = [];\n  let Z = [];\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = [];\n  let B = [];\n  let C = [];\n  let D = [];\n  let E = [];\n  let F = [];\n  let G = [];\n  let H = [];\n  let I = [];\n  let J = [];\n  let K = [];\n  let L = [];\n  let M = [];\n  let N = [];\n  let O = [];\n  let P = [];\n  let Q = [];\n  let R = [];\n  let S = [];\n  let T = [];\n  let U = [];\n  let V = [];\n  let W = [];\n  let X = [];\n  let Y = [];\n  let Z = [];\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = [];\n  let B = [];\n  let C = [];\n  let D = [];\n  let E = [];\n  let F = [];\n  let G = [];\n  let H = [];\n  let I = [];\n  let J = [];\n  let K = [];\n  let L = [];\n  let M = [];\n  let N = [];\n  let O = [];\n  let P = [];\n  let Q = [];\n  let R = [];\n  let S = [];\n  let T = [];\n  let U = [];\n  let V = [];\n  let W = [];\n  let X = [];\n  let Y = [];\n  let Z = [];\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d = 0;\n  let e = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let o = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let A = [];\n  let B = [];\n  let C = [];\n  let D = [];\n  let E = [];\n  let F = [];\n  let G = [];\n  let H = [];\n  let I = [];\n  let J = [];\n  let K = [];\n  let L", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "gc": "<|endoftext|>/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  for (let key in dict) {\n    if (typeof dict[key] ==='string') {\n      if (dict[key].toLowerCase() === dict[key].toUpperCase()) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*\n  Given a string, return true if all characters are lowercase or all \n  characters are uppercase, else return false.\n  The function should return false is the given string is empty.\n  Examples:\n  checkStringCase(\"apple\") should return true.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana\") should return false.\n  checkStringCase(\"banana", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function that takes an non-negative integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "gc": "<|endoftext|>/*Implement a function that takes an non-negative integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let primes = [];\n  let primesCount = 0;\n  let primesCountUpTo = 0;\n  let primesCountDownTo = 0;\n  let primesCountUpTo2 = 0;\n  let primesCountDownTo2 = 0;\n  let primesCountUpTo3 = 0;\n  let primesCountDownTo3 = 0;\n  let primesCountUpTo4 = 0;\n  let primesCountDownTo4 = 0;\n  let primesCountUpTo5 = 0;\n  let primesCountDownTo5 = 0;\n  let primesCountUpTo6 = 0;\n  let primesCountDownTo6 = 0;\n  let primesCountUpTo7 = 0;\n  let primesCountDownTo7 = 0;\n  let primesCountUpTo8 = 0;\n  let primesCountDownTo8 = 0;\n  let primesCountUpTo9 = 0;\n  let primesCountDownTo9 = 0;\n  let primesCountUpTo10 = 0;\n  let primesCountDownTo10 = 0;\n  let primesCountUpTo11 = 0;\n  let primesCountDownTo11 = 0;\n  let primesCountUpTo12 = 0;\n  let primesCountDownTo12 = 0;\n  let primesCountUpTo13 = 0;\n  let primesCountDownTo13 = 0;\n  let primesCountUpTo14 = 0;\n  let primesCountDownTo14 = 0;\n  let primesCountUpTo15 = 0;\n  let primesCountDownTo15 = 0;\n  let primesCountUpTo16 = 0;\n  let primesCountDownTo16 = 0;\n  let primesCountUpTo17 = 0;\n  let primesCountDownTo17 = 0;\n  let primesCountUpTo18 = 0;\n  let primesCountDownTo18 = 0;\n  let primesCountUpTo19 = 0;\n  let primesCountDownTo19 = 0;\n  let primesCountUpTo20 = 0;\n  let primesCountDownTo20 = 0;\n  let primesCountUpTo21 = 1;\n  let primesCountDownTo21 = 1;\n  let primesCountUpTo22 = 0;\n  let primesCountDownTo22 = 0;\n  let primesCountUpTo23 = 0;\n  let primesCountDownTo23 = 0;\n  let primesCountUpTo24 = 0;\n  let primesCountDownTo24 = 0;\n  let primesCountUpTo25 = 0;\n  let primesCountDownTo25 = 0;\n  let primesCountUpTo26 = 0;\n  let primesCountDownTo26 = 0;\n  let primesCountUpTo27 = 0;\n  let primesCountDownTo27 = 0;\n  let primesCountUpTo28 = 0;\n  let primesCountDownTo28 = 0;\n  let primesCountUpTo29 = 0;\n  let primesCountDownTo29 = 0;\n  let primesCountUpTo30 = 0;\n  let primesCountDownTo30 = 0;\n  let primesCountUpTo31 = 1;\n  let primesCountDownTo31 = 1;\n  let primesCountUpTo32 = 0;\n  let primesCountDownTo32 = 0;\n  let primesCountUpTo33 = 0;\n  let primesCountDownTo33 = 0;\n  let primesCountUpTo34 = 0;\n  let primesCountDownTo34 = 0;\n  let primesCountUpTo35 = 0;\n  let primesCountDownTo35 = 0;\n  let primesCountUpTo36 = 0;\n  let primesCountDownTo36 = 0;\n  let primesCountUpTo37 = 0;\n  let primesCountDownTo37 = 0;\n  let primesCountUpTo38 = 0;\n  let primesCountDownTo38 = 0;\n  let primesCountUpTo39 = 0;\n  let primesCountDownTo39 = 0;\n  let primesCountUpTo40 = 0;\n  let primesCountDownTo40 = 0;\n  let primesCountUpTo41 = 1;\n  let primesCountDownTo41 = 1;\n  let primesCountUpTo42 = 2;\n  let primesCountDownTo42 = 2;\n  let primesCountUpTo43 = 3;\n  let primesCountDownTo43 = 3;\n  let primesCountUpTo44 = 4;\n  let primesCountDownTo44 = 4;\n  let primesCountUpTo45 = 5;\n  let primesCountDownTo45 = 5;\n  let primesCountUpTo46 = 6;\n  let primesCountDownTo46 = 6;\n  let primesCountUpTo47 = 7;\n  let primesCountDownTo47 = 7;\n  let primesCountUpTo48 = 8;\n  let primesCountDownTo48 = 8;\n  let primesCountUpTo49 = 9;\n  let primesCountDownTo49 = 9;\n  let primesCountUpTo50 = 10;\n  let primesCountDownTo50 = 10;\n  let primesCountUpTo51 = 11;\n  let primesCountDownTo51 = 11;\n  let primesCountUpTo52 = 12;\n  let primesCountDownTo52 = 12;\n  let primesCountUpTo53 = 13;\n  let primesCountDownTo53 = 13;\n  let primesCountUpTo54 = 14;\n  let primesCountDownTo54 = 14;\n  let primesCountUpTo55 = 15;\n  let primesCountDownTo55 = 15;\n  let primesCountUpTo56 = 16;\n  let primesCountDownTo56 = 16;\n  let primesCountUpTo57 = 17;\n  let primesCountDownTo57 = 17;\n  let primesCountUpTo58 = 18;\n  let primesCountDownTo58 = 18;\n  let primesCountUpTo59 = 19;\n  let primesCountDownTo59 = 19;\n  let primesCountUpTo60 = 20;\n  let primesCountDownTo60 = 20;\n  let primesCountUpTo61 = 21;\n  let primesCountDownTo61 = 21;\n  let primesCountUpTo62 = 22;\n  let primesCountDownTo62 = 22;\n  let primesCountUpTo63 = 23;\n  let primesCountDownTo63 = 23;\n  let primesCountUpTo64 = 24;\n  let primesCountDownTo64 = 24;\n  let primesCountUpTo65 = 25;\n  let primesCountDownTo65 = 25;\n  let primesCountUpTo66 = 26;\n  let primesCountDownTo66 = 26;\n  let primesCountUpTo67 = 27;\n  let primesCountDownTo67 = 27;\n  let primesCountUpTo68 = 28;\n  let primesCountDownTo68 = 28;\n  let primesCountUpTo69 = 29;\n  let primesCountDownTo69 = 29;\n  let primesCountUpTo70 = 30;\n  let primesCountDownTo70 = 30;\n  let primesCountUpTo71 = 31;\n  let primesCountDownTo71 = 31;\n  let primesCountUpTo72 = 32;\n  let primesCountDownTo72 = 32;\n  let primesCountUpTo73 = 33;\n  let primesCountDownTo73 = 33;\n  let primesCountUpTo74 = 34;\n  let primesCountDownTo74 = 34;\n  let primesCountUpTo75 = 35;\n  let primesCountDownTo75 = 35;\n  let primesCountUpTo", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function that takes two integers and returns \n  the product of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "gc": "<|endoftext|>/*Complete the function that takes two integers and returns \n  the product of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  const product = a / b;\n  return product * product;\n};\n\n/*Complete the function that takes two integers and returns \n  the sum of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  add(148, 412) should return 412.\n  add(19, 28) should return 280.\n  add(2020, 1851) should return 1851.\n  add(14,-15) should return 14.\n  */\nconst add = (a, b) => {\n  const sum = a + b;\n  return sum;\n};\n\n/*Complete the function that takes two integers and returns \n  the difference between their unit digits.\n  Assume the input is always valid.\n  Examples:\n  subtract(148, 412) should return 412.\n  subtract(19, 28) should return 28.\n  subtract(2020, 1851) should return 1851.\n  subtract(14,-15) should return 14.\n  */\nconst subtract = (a, b) => {\n  const difference = a - b;\n  return difference;\n};\n\n/*Complete the function that takes two integers and returns \n  the absolute value of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  abs(148, 412) should return 412.\n  abs(19, 28) should return 28.\n  abs(2020, 1851) should return 1851.\n  abs(14,-15) should return 14.\n  */\nconst abs = a => {\n  const absolute = a > 0? a : -a;\n  return absolute;\n};\n\n/*Complete the function that takes two integers and returns \n  the square root of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  sqrt(148, 412) should return 412.\n  sqrt(19, 28) should return 28.\n  sqrt(2020, 1851) should return 1851.\n  sqrt(14,-15) should return 14.\n  */\nconst sqrt = a => {\n  const squareRoot = Math.sqrt(a);\n  return squareRoot;\n};\n\n/*Complete the function that takes two integers and returns \n  the absolute value of the square root of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  absSquareRoot(148, 412) should return 412.\n  absSquareRoot(19, 28) should return 28.\n  absSquareRoot(2020, 1851) should return 1851.\n  absSquareRoot(14,-15) should return 14.\n  */\nconst absSquareRoot = a => {\n  const absoluteSquareRoot = Math.abs(Math.sqrt(a));\n  return absoluteSquareRoot;\n};\n\n/*Complete the function that takes two integers and returns \n  the square root of the absolute value of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  absSquareRootAbs(148, 412) should return 412.\n  absSquareRootAbs(19, 28) should return 28.\n  absSquareRootAbs(2020, 1851) should return 1851.\n  absSquareRootAbs(14,-15) should return 14.\n  */\nconst absSquareRootAbs = a => {\n  const absoluteSquareRoot = Math.abs(Math.sqrt(a));\n  return absoluteSquareRoot;\n};\n\n/*Complete the function that takes two integers and returns \n  the square root of the absolute value of the square root of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  absSquareRootAbsSquareRoot(148, 412) should return 412.\n  absSquareRootAbsSquareRoot(19, 28) should return 28.\n  absSquareRootAbsSquareRoot(2020, 1851) should return 1851.\n  absSquareRootAbsSquareRoot(14,-15) should return 14.\n  */\nconst absSquareRootAbsSquareRoot = a => {\n  const absoluteSquareRoot = Math.abs(Math.sqrt(a));\n  return absoluteSquareRoot;\n};\n\n/*Complete the function that takes two integers and returns \n  the square root of the absolute value of the square root of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  absSquareRootAbsSquareRootAbs(148, 412) should return 412.\n  absSquareRootAbsSquareRootAbs(19, 28) should return 28.\n  absSquareRootAbsSquareRootAbs(2020, 1851) should return 1851.\n  absSquareRootAbsSquareRootAbs(14,-15) should return 14.\n  */\nconst absSquareRootAbsSquareRootAbs = a => {\n  const absoluteSquareRoot = Math.abs(Math.sqrt(a));\n  return absoluteSquareRoot;\n};\n\n/*Complete the function that takes two integers and returns \n  the square root of the absolute value of the square root of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  absSquareRootAbsSquareRootAbsSquareRoot(148, 412) should return 412.\n  absSquareRootAbsSquareRootAbsSquareRoot(19, 28) should return 28.\n  absSquareRootAbsSquareRootAbsSquareRoot(2020, 1851) should return 1851.\n  absSquareRootAbsSquareRootAbsSquareRoot(14,-15) should return 14.\n  */\nconst absSquareRootAbsSquareRootAbsSquareRoot = a => {\n  const absoluteSquareRoot = Math.abs(Math.sqrt(a));\n  return absoluteSquareRoot;\n};\n\n/*Complete the function that takes two integers and returns \n  the square root of the absolute value of the square root of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  absSquareRootAbsSquareRootAbsSquareRootAbs(148, 412) should return 412.\n  absSquareRootAbsSquareRootAbsSquareRootAbs(19, 28) should return 28.\n  absSquareRootAbsSquareRootAbsSquareRootAbs(2020, 1851) should return 1851.\n  absSquareRootAbsSquareRootAbsSquareRootAbs(14,-15) should return 14.\n  */\nconst absSquareRootAbsSquareRootAbsSquareRootAbs = a => {\n  const absoluteSquareRoot = Math.abs(Math.sqrt(a));\n  return absoluteSquareRoot;\n};\n\n/*Complete the function that takes two integers and returns \n  the square root of the absolute value of the square root of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  absSquareRootAbsSquareRootAbsSquareRootAbsSquareRoot(148, 412) should return 412.\n  absSquareRootAbsSquareRootAbsSquareRootAbsSquareRoot(19, 28) should return 28.\n  absSquareRootAbsSquareRootAbsSquareRootAbsSquareRoot(2020, 1851) should return 1851.\n  absSquareRootAbsSquareRootAbsSquareRootAbsSquareRoot(14,-15) should return 14.\n  */\nconst absSquareRootAbsSquareRootAbsSquareRootAbsSquareRoot = a => {\n  const absoluteSquareRoot = Math.abs(Math.sqrt(a));\n  return absoluteSquareRoot;\n};\n\n/*Complete the function that takes two integers and returns \n  the square root of the absolute value of the square root of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  absSquareRootAbsSquareRootAbsSquareRootAbsSquareRootAbs(148, 412) should return 412.\n  absSquareRootAb", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "gc": "<|endoftext|>/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  let index = 0;\n  let upperCaseVowels = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  \n  for (let i = 0; i < s.length; i++) {\n    if (upperCaseVowels.includes(s[i])) {\n      count++;\n    }\n  }\n  \n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i])) {\n      count++;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Given a string s, count the number of lowercase vowels in even indices.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower = (s) => {\n  let count = 0;\n  let index = 0;\n  let lowerCaseVowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  \n  for (let i = 0; i < s.length; i++) {\n    if (lowerCaseVowels.includes(s[i])) {\n      count++;\n    }\n  }\n  \n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i])) {\n      count++;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Given a string s, count the number of vowels in even indices.\n  \n  For example:\n  countVowels('aBCdEf') returns 1\n  countVowels('abcdefg') returns 0\n  countVowels('dBBE') returns 0\n  */\nconst countVowels = (s) => {\n  let count = 0;\n  let index = 0;\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  \n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i])) {\n      count++;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Given a string s, count the number of uppercase vowels in odd indices.\n  \n  For example:\n  countUpperOdd('aBCdEf') returns 1\n  countUpperOdd('abcdefg') returns 0\n  countUpperOdd('dBBE') returns 0\n  */\nconst countUpperOdd = (s) => {\n  let count = 0;\n  let index = 0;\n  let upperCaseVowels = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  \n  for (let i = 0; i < s.length; i++) {\n    if (upperCaseVowels.includes(s[i])) {\n      count++;\n    }\n  }\n  \n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i])) {\n      count++;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Given a string s, count the number of lowercase vowels in odd indices.\n  \n  For example:\n  countLowerOdd('aBCdEf') returns 1\n  countLowerOdd('abcdefg') returns 0\n  countLowerOdd('dBBE') returns 0\n  */\nconst countLowerOdd = (s) => {\n  let count = 0;\n  let index = 0;\n  let lowerCaseVowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  \n  for (let i = 0; i < s.length; i++) {\n    if (lowerCaseVowels.includes(s[i])) {\n      count++;\n    }\n  }\n  \n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i])) {\n      count++;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Given a string s, count the number of vowels in odd indices.\n  \n  For example:\n  countVowelsOdd('aBCdEf') returns 1\n  countVowelsOdd('abcdefg') returns 0\n  countVowelsOdd('dBBE') returns 0\n  */\nconst countVowelsOdd = (s) => {\n  let count = 0;\n  let index = 0;\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  \n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i])) {\n      count++;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  countUpperOdd('aBCdEf') returns 1\n  countUpperOdd('abcdefg') returns 0\n  countUpperOdd('dBBE') returns 0\n  */\nconst countUpperOddOdd = (s) => {\n  let count = 0;\n  let index = 0;\n  let upperCaseVowels = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  \n  for (let i = 0; i < s.length; i++) {\n    if (upperCaseVowels.includes(s[i])) {\n      count++;\n    }\n  }\n  \n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i])) {\n      count++;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Given a string s, count the number of lowercase vowels in even indices.\n  \n  For example:\n  countLowerOdd('aBCdEf') returns 1\n  countLowerOdd('abcdefg') returns 0\n  countLowerOdd('dBBE') returns 0\n  */\nconst countLowerOddOdd = (s) => {\n  let count = 0;\n  let index = 0;\n  let lowerCaseVowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  \n  for (let i = 0; i < s.length; i++) {\n    if (lowerCaseVowels.includes(s[i])) {\n      count++;\n    }\n  }\n  \n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i])) {\n      count++;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Given a string s, count the number of vowels in odd indices.\n  \n  For example:\n  countVowelsOdd('aBCdEf') returns 1\n  countVowelsOdd('abcdefg') returns 0\n  countVowelsOdd('dBBE') returns 0\n  */\nconst countVowelsOddOdd = (s) => {\n  let count = 0;\n  let index = 0;\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  \n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i])) {\n      count++;\n    }\n  }\n  \n  for (let i = 0; i < s.length; i++) {\n    if (upperCaseVowels.includes(s[i])) {\n      count++;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  countUpperOdd('aBCdEf') returns 1\n  countUpperOdd('abcdefg') returns 0\n  countUpperOdd('dBBE') returns 0\n  */\nconst countUpperOddEven = (s) => {\n  let count = 0;\n  let index = 0;\n  let upperCaseVowels = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];\n  let vowels = ['a', 'e', 'i', 'o', 'u'];\n  \n  for (let i = 0; i < s.length; i++) {\n    if (upperCaseVowels.includes(s[i])) {\n      count++;\n    }\n  }\n  \n  for (let i = 0; i < s.length; i++) {\n    if (vowels.includes(s[i])) {\n      count++;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Given a string s, count ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/99", "prompt": "/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closestInetger(\"10\")\n  10\n  >>> closestInetger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInetger(\"14.5\") should\n  return 15 and closestInetger(\"-14.5\") should return -15.\n  */\nconst closestInetger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInetger", "gc": "<|endoftext|>/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closestInetger(\"10\")\n  10\n  >>> closestInetger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInetger(\"14.5\") should\n  return 15 and closestInetger(\"-14.5\") should return -15.\n  */\nconst closestInetger = (value) => {\n  const [min, max] = value.split(\".\").map(Number);\n  return Math.max(min, Math.min(max, 0));\n};\n\n/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closestInetger(\"10\")\n  10\n  >>> closestInetger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInetger(\"14.5\") should\n  return 15 and closestInetger(\"-14.5\") should return -15.\n  */\nconst closestInetger2 = (value) => {\n  const [min, max] = value.split(\".\").map(Number);\n  return Math.max(min, Math.min(max, 0));\n};\n\n/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closestInetger(\"10\")\n  10\n  >>> closestInetger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInetger(\"14.5\") should\n  return 15 and closestInetger(\"-14.5\") should return -15.\n  */\nconst closestInetger3 = (value) => {\n  const [min, max] = value.split(\".\").map(Number);\n  return Math.max(min, Math.min(max, 0));\n};\n\n/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closestInetger(\"10\")\n  10\n  >>> closestInetger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInetger(\"14.5\") should\n  return 15 and closestInetger(\"-14.5\") should return -15.\n  */\nconst closestInetger4 = (value) => {\n  const [min, max] = value.split(\".\").map(Number);\n  return Math.max(min, Math.min(max, 0));\n};\n\n/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closestInetger(\"10\")\n  10\n  >>> closestInetger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInetger(\"14.5\") should\n  return 15 and closestInetger(\"-14.5\") should return -15.\n  */\nconst closestInetger5 = (value) => {\n  const [min, max] = value.split(\".\").map(Number);\n  return Math.max(min, Math.min(max, 0));\n};\n\n/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closestInetger(\"10\")\n  10\n  >>> closestInetger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInetger(\"14.5\") should\n  return 15 and closestInetger(\"-14.5\") should return -15.\n  */\nconst closestInetger6 = (value) => {\n  const [min, max] = value.split(\".\").map(Number);\n  return Math.max(min, Math.min(max, 0));\n};\n\n/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closestInetger(\"10\")\n  10\n  >>> closestInetger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInetger(\"14.5\") should\n  return 15 and closestInetger(\"-14.5\") should return -15.\n  */\nconst closestInetger7 = (value) => {\n  const [min, max] = value.split(\".\").map(Number);\n  return Math.max(min, Math.min(max, 0));\n};\n\n/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closestInetger(\"10\")\n  10\n  >>> closestInetger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInetger(\"14.5\") should\n  return 15 and closestInetger(\"-14.5\") should return -15.\n  */\nconst closestInetger8 = (value) => {\n  const [min, max] = value.split(\".\").map(Number);\n  return Math.max(min, Math.min(max, 0));\n};\n\n/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closestInetger(\"10\")\n  10\n  >>> closestInetger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInetger(\"14.5\") should\n  return 15 and closestInetger(\"-14.5\") should return -15.\n  */\nconst closestInetger9 = (value) => {\n  const [min, max] = value.split(\".\").map(Number);\n  return Math.max(min, Math.min(max, 0));\n};\n\n/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closestInetger(\"10\")\n  10\n  >>> ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
