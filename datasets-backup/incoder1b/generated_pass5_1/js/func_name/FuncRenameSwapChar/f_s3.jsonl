{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> hasCloselEements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloselEements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloselEements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloselEements", "gc": "<|endoftext|>/* Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> hasCloselEements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloselEements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloselEements = (numbers, threshold) => {\n  const len = numbers.length;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/1", "prompt": "/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> separateParenGrousp('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGrousp = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGrousp", "gc": "<|endoftext|>/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> separateParenGrousp('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGrousp = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^)]+)\\)/).map(\n    (group) => group.match(/\\(([^)]+)\\)/)\n  );\n  const paren_group_strings = paren_groups.map(\n    (group) => group[1]\n  );\n  const paren_group_strings_string = paren_group_strings.join('');\n  const paren_group_strings_array = paren_group_strings_string.split(',');\n  const paren_group_strings_array_string = paren_group_strings_array.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array = paren_group_strings_array_string.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array_string = paren_group_strings_array_string_array.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array_string_array = paren_group_strings_array_string_array_string.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array_string_array_string = paren_group_strings_array_string_array_string_array.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array_string_array_string_array = paren_group_strings_array_string_array_string_array_string.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array_string_array_string_array_string = paren_group_strings_array_string_array_string_array_string_array.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string = paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array = paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string = paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string = paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string = paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string = paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string = paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string = paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string = paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string = paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string = paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string = paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string = paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string = paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string = paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string = paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string = paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string = paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string = paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string.map(\n    (group) => group\n  );\n  const paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string = paren_group_strings_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string_array_string.map(", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "gc": "<|endoftext|>/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let longestPalindrome = '';\n  let longestPalindromeLength = 0;\n  let longestPalindromePrefix = '';\n  let longestPalindromeSuffix = '';\n\n  /* Find the longest postfix of supplied string that is a palindrome.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    */\n  for (let i = string.length - 1; i >= 0; i--) {\n    const char = string[i];\n    const reversedChar = string[string.length - i - 1];\n    const isPalindromeChar = isPalindrome(char);\n\n    /* If the palindrome char is a palindrome char, then we know that it\n      is a palindrome and we know that its length is greater than the longest\n      palindrome length, so we know that its prefix and suffix are palindromes.\n      We also know that its prefix and suffix are palindromes because they begin\n      with the same character.\n    */\n    if (isPalindromeChar) {\n      if (longestPalindromeLength > longestPalindromeLength) {\n        longestPalindromeLength = longestPalindromeLength;\n        longestPalindromePrefix = longestPalindromePrefix;\n        longestPalindromeSuffix = longestPalindromeSuffix;\n      }\n\n      if (isPalindromeChar == reversedChar) {\n        longestPalindromeLength++;\n        longestPalindromePrefix = longestPalindromePrefix + char;\n        longestPalindromeSuffix = longestPalindromeSuffix + reversedChar;\n      }\n    }\n  }\n\n  /* If the palindrome length is greater than the longest palindrome length, then\n    we know that its prefix and suffix are palindromes.\n    We also know that its prefix and suffix are palindromes because they begin\n    with the same character.\n  */\n  if (longestPalindromeLength > longestPalindromeLength) {\n    longestPalindromeLength = longestPalindromeLength;\n    longestPalindromePrefix = longestPalindromePrefix;\n    longestPalindromeSuffix = longestPalindromeSuffix;\n  }\n\n  /* If the palindrome prefix and suffix are palindromes, then we know that\n    its prefix and suffix are palindromes.\n    We also know that its prefix and suffix are palindromes because they begin\n    with the same character.\n  */\n  if (longestPalindromePrefix.length == longestPalindromeSuffix.length) {\n    if (longestPalindromePrefix.length == longestPalindromeSuffix.length) {\n      return longestPalindromePrefix + longestPalindromeSuffix;\n    }\n    return longestPalindromePrefix + longestPalindromeSuffix + longestPalindromePrefix;\n  }\n\n  /* If the palindrome prefix and suffix are NOT palindromes, then we know that\n    its prefix and suffix are NOT palindromes.\n    We also know that its prefix and suffix are NOT palindromes because they begin\n    with the same character.\n  */\n  return longestPalindromePrefix + longestPalindromeSuffix + longestPalindromePrefix + longestPalindromeSuffix;\n}\n\n/* Given a string, return true if it is a palindrome and false otherwise.\n  >>> isPalindrome('cat')\n  true\n  >>> isPalindrome('cata')\n  false\n  >>> isPalindrome('catac')\n  false\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cats')\n  false\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cats')\n  false\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cats')\n  false\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cats')\n  false\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cats')\n  false\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cats')\n  false\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cats')\n  false\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cats')\n  false\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cats')\n  false\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cats')\n  false\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cats')\n  false\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cats')\n  false\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cats')\n  false\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cats')\n  false\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cats')\n  false\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cats')\n  false\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cats')\n  false\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cats')\n  false\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cats')\n  false\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cats')\n  false\n  >>> isPalindrome('cat')\n  false\n  >>> isPalindrome('cats')\n  false\n  >>> isPalindrome('cat')\n  false\n  >>> isP", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "gc": "<|endoftext|>/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [[]];\n  let level = 0;\n  let levelNum = 1;\n  let num = 1;\n  while (num < n) {\n    if (num % 2 === 0) {\n      levels[level].push(num);\n      num++;\n      levelNum++;\n    } else {\n      levelNum++;\n    }\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [[]];\n  let level = 0;\n  let levelNum = 1;\n  let num = 1;\n  while (num < n) {\n    if (num % 2 === 0) {\n      levels[level].push(num);\n      num++;\n      levelNum++;\n    } else {\n      levelNum++;\n    }\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [[]];\n  let level = 0;\n  let levelNum = 1;\n  let num = 1;\n  while (num < n) {\n    if (num % 2 === 0) {\n      levels[level].push(num);\n      num++;\n      levelNum++;\n    } else {\n      levelNum++;\n    }\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [[]];\n  let level = 0;\n  let levelNum = 1;\n  let num = 1;\n  while (num < n) {\n    if (num % 2 === 0) {\n      levels[level].push(num);\n      num++;\n      levelNum++;\n    } else {\n      levelNum++;\n    }\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [[]];\n  let level = 0;\n  let levelNum = 1;\n  let num = 1;\n  while (num < n) {\n    if (num % 2 === 0) {\n      levels[level].push(num);\n      num++;\n      levelNum++;\n    } else {\n      levelNum++;\n    }\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [[]];\n  let level = 0;\n  let levelNum = 1;\n  let num = 1;\n  while (num < n) {\n    if (num % 2 === 0) {\n      levels[level].push(num);\n      num++;\n      levelNum++;\n    } else {\n      levelNum++;\n    }\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [[]];\n  let level = 0;\n  let levelNum = 1;\n  let num = 1;\n  while (num < n) {\n    if (num % 2 === 0) {\n      levels[level].push(num);\n      num++;\n      levelNum++;\n    } else {\n      levelNum++;\n    }\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [[]];\n  let level = 0;\n  let levelNum = 1;\n  let num = 1;\n  while (num < n) {\n    if (num % 2 === 0) {\n      levels[level].push(num);\n      num++;\n      levelNum++;\n    } else {\n      levelNum++;\n    }\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [[]];\n  let level = 0;\n  let levelNum = 1;\n  let num = 1;\n  while (num < n) {\n    if (num % 2 === 0) {\n      levels[level].push(num);\n      num++;\n      levelNum++;\n    } else {\n      levelNum++;\n    }\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n ", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 3, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "gc": "<|endoftext|>/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/[, ]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsArray = (s) => {\n  const words = s.split(/[, ]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsArray2 = (s) => {\n  const words = s.split(/[, ]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsArray3 = (s) => {\n  const words = s.split(/[, ]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsArray4 = (s) => {\n  const words = s.split(/[, ]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsArray5 = (s) => {\n  const words = s.split(/[, ]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsArray6 = (s) => {\n  const words = s.split(/[, ]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsArray7 = (s) => {\n  const words = s.split(/[, ]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsArray8 = (s) => {\n  const words = s.split(/[, ]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsArray9 = (s) => {\n  const words = s.split(/[, ]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsArray10 = (s) => {\n  const words = s.split(/[, ]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsArray11 = (s) => {\n  const words = s.split(/[, ]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsArray12 = (s) => {\n  const words = s.split(/[, ]+/);\n  return words;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task\n  is to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, fi", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "gc": "<|endoftext|>/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x > y || y === 0) return -1;\n  let temp = Math.floor((x + y) / 2);\n  if (temp % 2 === 0) return temp;\n  return chooseNum(temp, y);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest odd integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x > y || y === 0) return -1;\n  let temp = Math.floor((x + y) / 2);\n  if (temp % 2 === 1) return temp;\n  return chooseNum(temp, y);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x > y || y === 0) return -1;\n  let temp = Math.floor((x + y) / 2);\n  if (temp % 2 === 0) return temp;\n  return chooseNum(temp, y);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x > y || y === 0) return -1;\n  let temp = Math.floor((x + y) / 2);\n  if (temp % 2 === 1) return temp;\n  return chooseNum(temp, y);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x > y || y === 0) return -1;\n  let temp = Math.floor((x + y) / 2);\n  if (temp % 2 === 0) return temp;\n  return chooseNum(temp, y);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x > y || y === 0) return -1;\n  let temp = Math.floor((x + y) / 2);\n  if (temp % 2 === 1) return temp;\n  return chooseNum(temp, y);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x > y || y === 0) return -1;\n  let temp = Math.floor((x + y) / 2);\n  if (temp % 2 === 0) return temp;\n  return chooseNum(temp, y);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x > y || y === 0) return -1;\n  let temp = Math.floor((x + y) / 2);\n  if (temp % 2 === 1) return temp;\n  return chooseNum(temp, y);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x > y || y === 0) return -1;\n  let temp = Math.floor((x + y) / 2);\n  if (temp % 2 === 0) return temp;\n  return chooseNum(temp, y);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x > y || y === 0) return -1;\n  let temp = Math.floor((x + y) / 2);\n  if (temp % 2 === 1) return temp;\n  return chooseNum(temp, y);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x > y || y === 0) return -1;\n  let temp = Math.floor((x + y) / 2);\n  if (temp % 2 === 0) return temp;\n  return chooseNum(temp, y);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x > y || y === 0) return -1;\n  let temp = Math.floor((x + y) / 2);\n  if (temp % 2 === 1) return temp;\n  return chooseNum(temp, y);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x > y || y === 0) return -1;\n  let temp = Math.floor((x + y) / 2);\n  if (temp % 2 === 0) return temp;\n  return chooseNum(temp, y);\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 15\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x > y || y === 0) return -1;\n  let temp = Math.floor((x + y) / 2);\n  if (temp % 2 === 1) return temp;\n  return chooseNum(temp, y);\n};\n\n/*This function takes two positive numbers x and ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/103", "prompt": "/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "gc": "<|endoftext|>/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  let count = 0;\n  let binary = \"\";\n  let binCount = 0;\n  let binSum = 0;\n  let binCount2 = 0;\n  let binSum2 = 0;\n  let binCount3 = 0;\n  let binSum3 = 0;\n  let binCount4 = 0;\n  let binSum4 = 0;\n  let binCount5 = 0;\n  let binSum5 = 0;\n  let binCount6 = 0;\n  let binSum6 = 0;\n  let binCount7 = 0;\n  let binSum7 = 0;\n  let binCount8 = 0;\n  let binSum8 = 0;\n  let binCount9 = 0;\n  let binSum9 = 0;\n  let binCount10 = 0;\n  let binSum10 = 0;\n  let binCount11 = 0;\n  let binSum11 = 0;\n  let binCount12 = 0;\n  let binSum12 = 0;\n  let binCount13 = 0;\n  let binSum13 = 0;\n  let binCount14 = 0;\n  let binSum14 = 0;\n  let binCount15 = 0;\n  let binSum15 = 0;\n  let binCount16 = 0;\n  let binSum16 = 0;\n  let binCount17 = 0;\n  let binSum17 = 0;\n  let binCount18 = 0;\n  let binSum18 = 0;\n  let binCount19 = 0;\n  let binSum19 = 0;\n  let binCount20 = 0;\n  let binSum20 = 0;\n  let binCount21 = 0;\n  let binSum21 = 0;\n  let binCount22 = 0;\n  let binSum22 = 0;\n  let binCount23 = 0;\n  let binSum23 = 0;\n  let binCount24 = 0;\n  let binSum24 = 0;\n  let binCount25 = 0;\n  let binSum25 = 0;\n  let binCount26 = 0;\n  let binSum26 = 0;\n  let binCount27 = 0;\n  let binSum27 = 0;\n  let binCount28 = 0;\n  let binSum28 = 0;\n  let binCount29 = 0;\n  let binSum29 = 0;\n  let binCount30 = 0;\n  let binSum30 = 0;\n  let binCount31 = 0;\n  let binSum31 = 0;\n  let binCount32 = 0;\n  let binSum32 = 0;\n  let binCount33 = 0;\n  let binSum33 = 0;\n  let binCount34 = 0;\n  let binSum34 = 0;\n  let binCount35 = 0;\n  let binSum35 = 0;\n  let binCount36 = 0;\n  let binSum36 = 0;\n  let binCount37 = 0;\n  let binSum37 = 0;\n  let binCount38 = 0;\n  let binSum38 = 0;\n  let binCount39 = 0;\n  let binSum39 = 0;\n  let binCount40 = 0;\n  let binSum40 = 0;\n  let binCount41 = 0;\n  let binSum41 = 0;\n  let binCount42 = 0;\n  let binSum42 = 0;\n  let binCount43 = 0;\n  let binSum43 = 0;\n  let binCount44 = 0;\n  let binSum44 = 0;\n  let binCount45 = 0;\n  let binSum45 = 0;\n  let binCount46 = 0;\n  let binSum46 = 0;\n  let binCount47 = 0;\n  let binSum47 = 0;\n  let binCount48 = 0;\n  let binSum48 = 0;\n  let binCount49 = 0;\n  let binSum49 = 0;\n  let binCount50 = 0;\n  let binSum50 = 0;\n  let binCount51 = 0;\n  let binSum51 = 0;\n  let binCount52 = 0;\n  let binSum52 = 0;\n  let binCount53 = 0;\n  let binSum53 = 0;\n  let binCount54 = 0;\n  let binSum54 = 0;\n  let binCount55 = 0;\n  let binSum55 = 0;\n  let binCount56 = 0;\n  let binSum56 = 0;\n  let binCount57 = 0;\n  let binSum57 = 0;\n  let binCount58 = 0;\n  let binSum58 = 0;\n  let binCount59 = 0;\n  let binSum59 = 0;\n  let binCount60 = 0;\n  let binSum60 = 0;\n  let binCount61 = 0;\n  let binSum61 = 0;\n  let binCount62 = 0;\n  let binSum62 = 0;\n  let binCount63 = 0;\n  let binSum63 = 0;\n  let binCount64 = 0;\n  let binSum64 = 0;\n  let binCount65 = 0;\n  let binSum65 = 0;\n  let binCount66 = 0;\n  let binSum66 = 0;\n  let binCount67 = 0;\n  let binSum67 = 0;\n  let binCount68 = 0;\n  let binSum68 = 0;\n  let binCount69 = 0;\n  let binSum69 = 0;\n  let binCount70 = 0;\n  let binSum70 = 0;\n  let binCount71 = 0;\n  let binSum71 = 0;\n  let binCount72 = 0;\n  let binSum72 = 0;\n  let binCount73 = 0;\n  let binSum73 = 0;\n  let binCount74 = 0;\n  let binSum74 = 0;\n  let binCount75 = 0;\n  let binSum75 = 0;\n  let binCount76 = 0;\n  let binSum76 = 0;\n  let binCount77 = 0;\n  let binSum77 = 0;\n  let binCount78 = 0;\n  let binSum78 = 0;\n  let binCount79 = 0;\n  let binSum79 = 0;\n  let binCount80 = 0;\n  let binSum80 = 0;\n  let binCount81 = 0;\n  let binSum81 = 0;\n  let binCount82 = 0;\n  let binSum82 = 0;\n  let binCount83 = 0;\n  let binSum83 = 0;\n  let binCount84 = 0;\n  let binSum84 = 0;\n  let binCount85 = 0;\n  let binSum85 = 0;\n  let binCount86 = 0;\n  let binSum86 = 0;\n  let binCount87 = 0;\n  let binSum87 = 0;\n  let binCount88 = 0;\n  let binSum88 = 0;\n  let binCount89 = 0;\n  let binSum89 = 0;\n  let binCount90 = 0;\n  let binSum90 = 0;\n  let binCount91 = 0;\n  let binSum91 = 0;\n  let binCount92 = 0;\n  let binSum92 = 0;\n  let binCount93 = 0;\n  let binSum93 = 0;\n  let binCount94 = 0;\n  let binSum94 = 0;\n  let binCount95 = 0;\n  let binSum95 = 0;\n  let binCount96 = 0;\n  let binSum96 = 0;\n  let binCount97 = 0;\n  let binSum97 = 0;\n  let binCount98 = 0;\n  let binSum98 = 0;\n  let binCount99 = 0;\n  let binSum99 = 0;\n  let binCount100 = 0;\n  let binSum100 = 0;\n  let binCount101 = 0;\n  let binSum101 = 0;\n  let binCount102 = 0;\n  let binSum102 = 0;\n  let binCount103 = 0;\n  let binSum103 = 0;\n  let binCount104 = 0;\n  let binSum104 = 0;\n  let binCount105 = 0;\n  let binSum105 = 0;\n  let binCount106 = 0;\n  let binSum106 = 0;\n  let binCount107 = 0;\n  let binSum107 = 0;\n  let binCount108 = 0;\n  let binSum108 = 0;\n  let binCount109 = 0;\n  let binSum109 = 0;\n  let binCount110 = 0;\n  let binSum110 = 0;\n  let binCount111 = 0;\n  let binSum111 = 0;\n  let binCount112 = 0;\n  let binSum112 = 0;\n  let binCount113 = 0;\n  let binSum113 = 0;\n  let binCount114 = 0;\n  let binSum114 = 0;\n  let binCount115 = 0;\n  let binSum115 = 0;\n  let binCount116 = 0;\n  let binSum116 = 0;\n  let binCount117 = 0;\n  let binSum117 = 0;\n  let binCount118 = 0;\n  let binSum118 = 0;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueDigtis([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigtis([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigtis = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigtis", "gc": "<|endoftext|>/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueDigtis([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigtis([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigtis = (x) => {\n  const digits = x.filter(x => x % 2 === 0).map(x => parseInt(x, 10));\n  return digits.filter(x => x!== 0).sort((a, b) => a - b);\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any odd digit.\n\n  Note: Returned list should be sorted in decreasing order.\n  \n  For example:\n  >>> uniqueDigtis([15, 33, 1422, 1])\n  [1422, 1, 15]\n  >>> uniqueDigtis([152, 323, 1422, 10])\n  [10, 1422, 152]\n  */\nconst uniqueOddDigtis = (x) => {\n  const digits = x.filter(x => x % 2!== 0).map(x => parseInt(x, 10));\n  return digits.filter(x => x!== 0).sort((a, b) => b - a);\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueOddDigtis([15, 33, 1422, 1])\n  [1422, 1, 15]\n  >>> uniqueOddDigtis([152, 323, 1422, 10])\n  [10, 1422, 152]\n  */\nconst uniqueEvenDigtis = (x) => {\n  const digits = x.filter(x => x % 2 === 0).map(x => parseInt(x, 10));\n  return digits.filter(x => x!== 0).sort((a, b) => a - b);\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any odd or even digit.\n\n  Note: Returned list should be sorted in decreasing order.\n  \n  For example:\n  >>> uniqueEvenDigtis([15, 33, 1422, 1])\n  [1422, 1, 15]\n  >>> uniqueEvenDigtis([152, 323, 1422, 10])\n  [10, 1422, 152]\n  */\nconst uniqueOddEvenDigtis = (x) => {\n  const digits = x.filter(x => x % 2!== 0).map(x => parseInt(x, 10));\n  return digits.filter(x => x!== 0).sort((a, b) => b - a);\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any odd or even digit.\n\n  Note: Returned list should be sorted in decreasing order.\n  \n  For example:\n  >>> uniqueOddEvenDigtis([15, 33, 1422, 1])\n  [1422, 1, 15]\n  >>> uniqueOddEvenDigtis([152, 323, 1422, 10])\n  [10, 1422, 152]\n  */\nconst uniqueEvenOddDigtis = (x) => {\n  const digits = x.filter(x => x % 2 === 0).map(x => parseInt(x, 10));\n  return digits.filter(x => x!== 0).sort((a, b) => b - a);\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any odd or even digit.\n\n  Note: Returned list should be sorted in decreasing order.\n  \n  For example:\n  >>> uniqueEvenOddDigtis([15, 33, 1422, 1])\n  [1422, 1, 15]\n  >>> uniqueEvenOddDigtis([152, 323, 1422, 10])\n  [10, 1422, 152]\n  */\nconst uniqueOddEvenOddDigtis = (x) => {\n  const digits = x.filter(x => x % 2!== 0).map(x => parseInt(x, 10));\n  return digits.filter(x => x!== 0).sort((a, b) => b - a);\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any odd or even digit.\n\n  Note: Returned list should be sorted in decreasing order.\n  \n  For example:\n  >>> uniqueOddEvenOddDigtis([15, 33, 1422, 1])\n  [1422, 1, 15]\n  >>> uniqueOddEvenOddDigtis([152, 323, 1422, 10])\n  [10, 1422, 152]\n  */\nconst uniqueEvenOddEvenOddDigtis = (x) => {\n  const digits = x.filter(x => x % 2!== 0).map(x => parseInt(x, 10));\n  return digits.filter(x => x!== 0).sort((a, b) => b - a);\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any odd or even digit.\n\n  Note: Returned list should be sorted in decreasing order.\n  \n  For example:\n  >>> uniqueEvenOddEvenOddDigtis([15, 33, 1422, 1])\n  [1422, 1, 15]\n  >>> uniqueEvenOddEvenOddDigtis([152, 323, 1422, 10])\n  [10, 1422, 152]\n  */\nconst uniqueEvenOddOddEvenDigtis = (x) => {\n  const digits = x.filter(x => x % 2!== 0).map(x => parseInt(x, 10));\n  return digits.filter(x => x!== 0).sort((a, b) => b - a);\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any odd or even digit.\n\n  Note: Returned list should be sorted in decreasing order.\n  \n  For example:\n  >>> uniqueEvenOddOddEvenDigtis([15, 33, 1422, 1])\n  [1422, 1, 15]\n  >>> uniqueEvenOddOddEvenDigtis([152, 323, 1422, 10])\n  [10, 1422, 152]\n  */\nconst uniqueEvenOddOddOddEvenDigtis = (x) => {\n  const digits = x.filter(x => x % 2!== 0).map(x => parseInt(x, 10));\n  return digits.filter(x => x!== 0).sort((a, b) => b - a);\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any odd or even digit.\n\n  Note: Returned list should be sorted in decreasing order.\n  \n  For example:\n  >>> uniqueEvenOddOddOddEvenDigtis([15, 33, 1422, 1])\n  [1422, 1, 15]\n  >>> uniqueEvenOddOddOddEvenDigtis([152, 323, 1422, 10])\n  [10, 1422, 152]\n  */\nconst uniqueEvenOddOddOddOddEvenDigtis = (x) => {\n  const digits = x.filter(x => x % 2!== 0).map(x => parseInt(x, 10));\n  return digits.filter(x => x!== 0).sort((a, b) => b - a);\n};\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has any odd or even digit.\n\n  Note: Returned list should be sorted in decreasing order.\n  \n  For example:\n  >>> uniqueEvenOddOddOddOddEvenDigtis([15, 33, 1422, 1])\n  [1422, 1, 15]\n  >>> uniqueEvenOddOddOddOddEvenDigtis([152, 323, 1422, 10])\n  [10, 1422, 152]\n  */\nconst uniqueEvenOddOddOddOddOddEvenDigtis = (x) => {\n  const digits = x.filter(x => x % 2!== 0).map(x => parseInt(x, 10));\n  return digits.filter(", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst ybLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "ybLength", "gc": "<|endoftext|>/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst ybLength = (arr) => {\n  let result = [];\n  let len = arr.length;\n  let i = 0;\n  while (i < len) {\n    if (arr[i] >= 1 && arr[i] <= 9) {\n      result.push(arr[i]);\n      i++;\n    }\n  }\n  return result;\n};\n\n/**\n * Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n * reverse the resulting array, and then replace each digit by its corresponding name from\n * \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst ybReverse = (arr) => {\n  let result = [];\n  let len = arr.length;\n  let i = 0;\n  while (i < len) {\n    if (arr[i] >= 1 && arr[i] <= 9) {\n      result.push(arr[i]);\n      i++;\n    }\n  }\n  return result.sort().reverse();\n};\n\n/**\n * Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n * reverse the resulting array, and then replace each digit by its corresponding name from\n * \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst ybReverse2 = arr => {\n  let result = [];\n  let len = arr.length;\n  let i = 0;\n  while (i < len) {\n    if (arr[i] >= 1 && arr[i] <= 9) {\n      result.push(arr[i]);\n      i++;\n    }\n  }\n  return result.sort().reverse();\n};\n\n/**\n * Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n * reverse the resulting array, and then replace each digit by its corresponding name from\n * \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst ybReverse3 = arr => {\n  let result = [];\n  let len = arr.length;\n  let i = 0;\n  while (i < len) {\n    if (arr[i] >= 1 && arr[i] <= 9) {\n      result.push(arr[i]);\n      i++;\n    }\n  }\n  return result.sort().reverse();\n};\n\n/**\n * Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n * reverse the resulting array, and then replace each digit by its corresponding name from\n * \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst ybReverse4 = arr => {\n  let result = [];\n  let len = arr.length;\n  let i = 0;\n  while (i < len) {\n    if (arr[i] >= 1 && arr[i] <= 9) {\n      result.push(arr[i]);\n      i++;\n    }\n  }\n  return result.sort().reverse();\n};\n\n/**\n * Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n * reverse the resulting array, and then replace each digit by its corresponding name from\n * \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst ybReverse5 = arr => {\n  let result = [];\n  let len = arr.length;\n  let i = 0;\n  while (i < len) {\n    if (arr[i] >= 1 && arr[i] <= 9) {\n      result.push(arr[i]);\n      i++;\n    }\n  }\n  return result.sort().reverse();\n};\n\n/**\n * Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n * reverse the resulting array, and then replace each digit by its corresponding name from\n * \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, ", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 3, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/106", "prompt": "/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "gc": "<|endoftext|>/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(factorial(i));\n    }\n  }\n  return result;\n};\n\n/* Implement the function factorial that takes one parameter, n, and returns the factorial of n.\n  Example:\n  factorial(5) == 120\n  */\nconst factorial = (n) => {\n  if (n <= 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n};\n\n/* Implement the function factorial2 that takes two parameters,\n  a and b, and returns the product of a * b (a * b *... * b).\n  Example:\n  factorial2(5, 3) == 120\n  */\nconst factorial2 = (a, b) => {\n  if (a <= 0 || b <= 0) {\n    return 0;\n  }\n  return a * factorial2(b - 1, a * b);\n};\n\n/* Implement the function factorial3 that takes three parameters,\n  a, b, c, and returns the product of a * b * c (a * b * c *... * c).\n  Example:\n  factorial3(5, 3, 3) == 120\n  */\nconst factorial3 = (a, b, c) => {\n  if (a <= 0 || b <= 0 || c <= 0) {\n    return 0;\n  }\n  return a * factorial3(b - 1, c, a * c) * factorial3(b - 1, c, a * c);\n};\n\n/* Implement the function factorial4 that takes four parameters,\n  a, b, c, d, and returns the product of a * b * c * d (a * b * c * d *... * d).\n  Example:\n  factorial4(5, 3, 3, 4, 3) == 120\n  */\nconst factorial4 = (a, b, c, d) => {\n  if (a <= 0 || b <= 0 || c <= 0 || d <= 0) {\n    return 0;\n  }\n  return a * factorial4(b - 1, c, d, a * c) * factorial4(b - 1, c, d, a * d) * factorial4(b - 1, c, d, a * c);\n};\n\n/* Implement the function factorial5 that takes five parameters,\n  a, b, c, d, e, and returns the product of a * b * c * d * e (a * b * c * d * e *... * e).\n  Example:\n  factorial5(5, 3, 3, 4, 3, 3) == 120\n  */\nconst factorial5 = (a, b, c, d, e) => {\n  if (a <= 0 || b <= 0 || c <= 0 || d <= 0 || e <= 0) {\n    return 0;\n  }\n  return a * factorial5(b - 1, c, d, e, a * c) * factorial5(b - 1, c, d, e, a * d) * factorial5(b - 1, c, d, e, a * e);\n};\n\n/* Implement the function factorial6 that takes six parameters,\n  a, b, c, d, e, f, and returns the product of a * b * c * d * e (a * b * c * d * e *... * e) * f (a * b * c * d * e *... * f).\n  Example:\n  factorial6(5, 3, 3, 4, 3, 3, 4, 3) == 120\n  */\nconst factorial6 = (a, b, c, d, e, f) => {\n  if (a <= 0 || b <= 0 || c <= 0 || d <= 0 || e <= 0 || f <= 0) {\n    return 0;\n  }\n  return a * factorial6(b - 1, c, d, e, f, a * c) * factorial6(b - 1, c, d, e, f, a * d) * factorial6(b - 1, c, d, e, f, a * e);\n};\n\n/* Implement the function factorial7 that takes seven parameters,\n  a, b, c, d, e, f, g, and returns the product of a * b * c * d * e (a * b * c * d * e *... * e) * f (a * b * c * d * e *... * f) * g (a * b * c * d * e *... * g).\n  Example:\n  factorial7(5, 3, 3, 4, 3, 3, 4, 3, 3, 4, 3) == 120\n  */\nconst factorial7 = (a, b, c, d, e, f, g) => {\n  if (a <= 0 || b <= 0 || c <= 0 || d <= 0 || e <= 0 || f <= 0 || g <= 0) {\n    return 0;\n  }\n  return a * factorial7(b - 1, c, d, e, f, g, a * c) * factorial7(b - 1, c, d, e, f, g, a * d) * factorial7(b - 1, c, d, e, f, g, a * e);\n};\n\n/* Implement the function factorial8 that takes eight parameters,\n  a, b, c, d, e, f, g, h, and returns the product of a * b * c * d * e (a * b * c * d * e *... * e) * f (a * b * c * d * e *... * f) * g (a * b * c * d * e *... * g) * h (a * b * c * d * e *... * h).\n  Example:\n  factorial8(5, 3, 3, 4, 3, 3, 4, 3, 3, 4, 3, 3, 4, 3) == 120\n  */\nconst factorial8 = (a, b, c, d, e, f, g, h) => {\n  if (a <= 0 || b <= 0 || c <= 0 || d <= 0 || e <= 0 || f <= 0 || g <= 0 || h <= 0) {\n    return 0;\n  }\n  return a * factorial8(b - 1, c, d, e, f, g, h, a * c) * factorial8(b - 1, c, d, e, f, g, h, a * d) * factorial8(b - 1, c, d, e, f, g, h, a * e);\n};\n\n/* Implement the function factorial9 that takes nine parameters,\n  a, b, c, d, e, f, g, h, i, and returns the product of a * b * c * d * e (a * b * c * d * e *... * e) * f (a * b * c * d * e *... * f) * g (a * b * c * d * e *... * g) * h (a * b * c * d * e *... * h) * i (a * b * c * d * e *... * i).\n  Example:\n  factorial9(5, 3, 3, 4, 3, 3, 4, 3, 3, 4, 3, 3, 4, 3, 3, 4, 3) == 120\n  */\nconst factorial9 = (a, b, c, d, e, f, g, h, i) => {\n  if (a <= 0 || b <= 0 || c <= 0 || d <= 0 || e <= 0 || f <= 0 || g <= 0 || h <= 0 || i <= 0) {\n    return 0;\n  }\n  return a * factorial9(b - 1, c, d, e, f, g, h, i, a * c) * factorial9(b - 1, c, d, e, f, g, h, i, a * d) * factorial9(b - 1, c, d, e, f, g, h, i, a * e);\n};\n\n/* Implement the function factorial10 that takes ten parameters,\n  a, b, c, d, e, f, g, h, i, j, k, and returns the product of a * b * c * d * e (a * b * c * d * e *... * e) * f (a * b * c * d * e *... * f) * g (a * b * c * d * e *... * g) * h (a * b * c * d * e *... * h) * i (a * b * c * d * e *... * i) * j (a * b * c * d * e *... * j) * k (a * b * c * d * e *... * k).\n  Example:\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "gc": "<|endoftext|>/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const oddPalindromes = Array.from({ length: n }, (_, i) => i * 2);\n  const evenPalindromes = Array.from({ length: n }, (_, i) => i * 2 + 1);\n\n  const evenPalindromeCounts = evenPalindromes.reduce((acc, curr, i) => {\n    if (i % 2 === 0) {\n      acc[curr] = acc[curr] + 1;\n    }\n    return acc;\n  }, {});\n\n  const oddPalindromeCounts = oddPalindromes.reduce((acc, curr, i) => {\n    if (i % 2 === 0) {\n      acc[curr] = acc[curr] + 1;\n    }\n    return acc;\n  }, {});\n\n  return [...oddPalindromeCounts,...evenPalindromeCounts];\n};\n\n// Given a positive integer n, return an integer that has the number of even and odd integer palindromes that fall within the range(1, n), inclusive.\n// Example 1:\n// Input: 3\n// Output: 1\n// Explanation:\n// Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n// Example 2:\n// Input: 12\n// Output: 4\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1 <= n <= 10^3\n// Example 3:\n// Input: 9\n// Output: 3\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1 <= n <= 10^3\n// Example 4:\n// Input: 10\n// Output: 1\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1 <= n <= 10^3\n// Example 5:\n// Input: 11\n// Output: 1\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1 <= n <= 10^3\n// Example 6:\n// Input: 12\n// Output: 4\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1 <= n <= 10^3\n// Example 7:\n// Input: 13\n// Output: 3\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1 <= n <= 10^3\n// Example 8:\n// Input: 14\n// Output: 1\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1 <= n <= 10^3\n// Example 9:\n// Input: 15\n// Output: 1\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1 <= n <= 10^3\n// Example 10:\n// Input: 16\n// Output: 1\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1 <= n <= 10^3\n// Example 11:\n// Input: 17\n// Output: 1\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1 <= n <= 10^3\n// Example 12:\n// Input: 18\n// Output: 1\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1 <= n <= 10^3\n// Example 13:\n// Input: 19\n// Output: 1\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1 <= n <= 10^3\n// Example 14:\n// Input: 20\n// Output: 1\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1 <= n <= 10^3\n// Example 15:\n// Input: 21\n// Output: 1\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1 <= n <= 10^3\n// Example 16:\n// Input: 22\n// Output: 1\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1 <= n <= 10^3\n// Example 17:\n// Input: 23\n// Output: 1\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1 <= n <= 10^3\n// Example 18:\n// Input: 24\n// Output: 1\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1 <= n <= 10^3\n// Example 19:\n// Input: 25\n// Output: 1\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1 <= n <= 10^3\n// Example 20:\n// Input: 26\n// Output: 1\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1 <= n <= 10^3\n// Example 21:\n// Input: 27\n// Output: 1\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n// Note:\n// 1 <= n <= 10^3\n// Example 22:\n// Input: 28\n// Output: 1\n// Explanation:\n// Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNmus", "gc": "<|endoftext|>/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    const digit = arr[i];\n    if (digit >= 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    const digit = arr[i];\n    if (digit >= 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    const digit = arr[i];\n    if (digit >= 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    const digit = arr[i];\n    if (digit >= 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    const digit = arr[i];\n    if (digit >= 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    const digit = arr[i];\n    if (digit >= 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    const digit = arr[i];\n    if (digit >= 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    const digit = arr[i];\n    if (digit >= 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    const digit = arr[i];\n    if (digit >= 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    const digit = arr[i];\n    if (digit >= 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    const digit = arr[i];\n    if (digit >= 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    const digit = arr[i];\n    if (digit >= 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "gc": "<|endoftext|>/*We have an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  let sortedArr = [];\n  let num = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let temp;\n  let temp2;\n  let temp3;\n  let temp4;\n  let temp5;\n  let temp6;\n  let temp7;\n  let temp8;\n  let temp9;\n  let temp10;\n  let temp11;\n  let temp12;\n  let temp13;\n  let temp14;\n  let temp15;\n  let temp16;\n  let temp17;\n  let temp18;\n  let temp19;\n  let temp20;\n  let temp21;\n  let temp22;\n  let temp23;\n  let temp24;\n  let temp25;\n  let temp26;\n  let temp27;\n  let temp28;\n  let temp29;\n  let temp30;\n  let temp31;\n  let temp32;\n  let temp33;\n  let temp34;\n  let temp35;\n  let temp36;\n  let temp37;\n  let temp38;\n  let temp39;\n  let temp40;\n  let temp41;\n  let temp42;\n  let temp43;\n  let temp44;\n  let temp45;\n  let temp46;\n  let temp47;\n  let temp48;\n  let temp49;\n  let temp50;\n  let temp51;\n  let temp52;\n  let temp53;\n  let temp54;\n  let temp55;\n  let temp56;\n  let temp57;\n  let temp58;\n  let temp59;\n  let temp60;\n  let temp61;\n  let temp62;\n  let temp63;\n  let temp64;\n  let temp65;\n  let temp66;\n  let temp67;\n  let temp68;\n  let temp69;\n  let temp70;\n  let temp71;\n  let temp72;\n  let temp73;\n  let temp74;\n  let temp75;\n  let temp76;\n  let temp77;\n  let temp78;\n  let temp79;\n  let temp80;\n  let temp81;\n  let temp82;\n  let temp83;\n  let temp84;\n  let temp85;\n  let temp86;\n  let temp87;\n  let temp88;\n  let temp89;\n  let temp90;\n  let temp91;\n  let temp92;\n  let temp93;\n  let temp94;\n  let temp95;\n  let temp96;\n  let temp97;\n  let temp98;\n  let temp99;\n  let temp100;\n  let temp101;\n  let temp102;\n  let temp103;\n  let temp104;\n  let temp105;\n  let temp106;\n  let temp107;\n  let temp108;\n  let temp109;\n  let temp110;\n  let temp111;\n  let temp112;\n  let temp113;\n  let temp114;\n  let temp115;\n  let temp116;\n  let temp117;\n  let temp118;\n  let temp119;\n  let temp120;\n  let temp121;\n  let temp122;\n  let temp123;\n  let temp124;\n  let temp125;\n  let temp126;\n  let temp127;\n  let temp128;\n  let temp129;\n  let temp130;\n  let temp131;\n  let temp132;\n  let temp133;\n  let temp134;\n  let temp135;\n  let temp136;\n  let temp137;\n  let temp138;\n  let temp139;\n  let temp140;\n  let temp141;\n  let temp142;\n  let temp143;\n  let temp144;\n  let temp145;\n  let temp146;\n  let temp147;\n  let temp148;\n  let temp149;\n  let temp150;\n  let temp151;\n  let temp152;\n  let temp153;\n  let temp154;\n  let temp155;\n  let temp156;\n  let temp157;\n  let temp158;\n  let temp159;\n  let temp160;\n  let temp161;\n  let temp162;\n  let temp163;\n  let temp164;\n  let temp165;\n  let temp166;\n  let temp167;\n  let temp168;\n  let temp169;\n  let temp170;\n  let temp171;\n  let temp172;\n  let temp173;\n  let temp174;\n  let temp175;\n  let temp176;\n  let temp177;\n  let temp178;\n  let temp179;\n  let temp180;\n  let temp181;\n  let temp182;\n  let temp183;\n  let temp184;\n  let temp185;\n  let temp186;\n  let temp187;\n  let temp188;\n  let temp189;\n  let temp190;\n  let temp191;\n  let temp192;\n  let temp193;\n  let temp194;\n  let temp195;\n  let temp196;\n  let temp197;\n  let temp198;\n  let temp199;\n  let temp200;\n  let temp201;\n  let temp202;\n  let temp203;\n  let temp204;\n  let temp205;\n  let temp206;\n  let temp207;\n  let temp208;\n  let temp209;\n  let temp210;\n  let temp211;\n  let temp212;\n  let temp213;\n  let temp214;\n  let temp215;\n  let temp216;\n  let temp217;\n  let temp218;\n  let temp219;\n  let temp220;\n  let temp221;\n  let temp222;\n  let temp223;\n  let temp224;\n  let temp225;\n  let temp226;\n  let temp227;\n  let temp228;\n  let temp229;\n  let temp230;\n  let temp231;\n  let temp232;\n  let temp233;\n  let temp234;\n  let temp235;\n  let temp236;\n  let temp237;\n  let temp238;\n  let temp239;\n  let temp240;\n  let temp241;\n  let temp242;\n  let temp243;\n  let temp244;\n  let temp245;\n  let temp246;\n  let temp247;\n  let temp248;\n  let temp249;\n  let temp250;\n  let temp251;\n  let temp252;\n  let temp253;\n  let temp254;\n  let temp255;\n  let temp256;\n  let temp257;\n  let temp258;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/11", "prompt": "/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> strinXgor('010', '110')\n  '100'\n  */\nconst strinXgor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "strinXgor", "gc": "<|endoftext|>/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> strinXgor('010', '110')\n  '100'\n  */\nconst strinXgor = (a, b) => {\n  let result = ''\n  for (let i = 0; i < a.length; i++) {\n    let c = a.charCodeAt(i)\n    let d = b.charCodeAt(i)\n    result += String.fromCharCode((c ^ d).toString(2))\n  }\n  return result\n}\n\n/**\n  Convert a string to binary (base 2) representation.\n  >>> bin2str('0b10')\n  '1010'\n  */\nconst bin2str = (n) => {\n  let result = ''\n  for (let i = 0; i < n.length; i++) {\n    let c = n.charAt(i)\n    result += String.fromCharCode((c === '1')? 1 : 0)\n  }\n  return result\n}\n\n/**\n  Convert binary (base 2) representation to string.\n  >>> bin2str('1010')\n  '0b10'\n  */\nconst bin2str2 = (n) => {\n  let result = ''\n  for (let i = 0; i < n.length; i++) {\n    let c = n.charAt(i)\n    result += String.fromCharCode((c === '1')? 0 : 1)\n  }\n  return result\n}\n\n/**\n  Convert a string to hexadecimal (base 16) representation.\n  >>> hex2str('0x10')\n  '0x10'\n  */\nconst hex2str = (n) => {\n  let result = ''\n  for (let i = 0; i < n.length; i++) {\n    let c = n.charAt(i)\n    result += String.fromCharCode((c === 'x')? 16 : 0)\n  }\n  return result\n}\n\n/**\n  Convert hexadecimal (base 16) representation to string.\n  >>> hex2str('0x10')\n  '0x10'\n  */\nconst hex2str2 = (n) => {\n  let result = ''\n  for (let i = 0; i < n.length; i++) {\n    let c = n.charAt(i)\n    result += String.fromCharCode((c === 'x')? 0 : 16)\n  }\n  return result\n}\n\n/**\n  Convert a string to octal (base 8) representation.\n  >>> oct2str('0o10')\n  '0o10'\n  */\nconst oct2str = (n) => {\n  let result = ''\n  for (let i = 0; i < n.length; i++) {\n    let c = n.charAt(i)\n    result += String.fromCharCode((c === '0')? 8 : 0)\n  }\n  return result\n}\n\n/**\n  Convert octal (base 8) representation to string.\n  >>> oct2str('0o10')\n  '0o10'\n  */\nconst oct2str2 = (n) => {\n  let result = ''\n  for (let i = 0; i < n.length; i++) {\n    let c = n.charAt(i)\n    result += String.fromCharCode((c === '0')? 0 : 8)\n  }\n  return result\n}\n\n/**\n  Convert a string to decimal (base 10) representation.\n  >>> dec2str('0o10')\n  '10'\n  */\nconst dec2str = (n) => {\n  let result = ''\n  for (let i = 0; i < n.length; i++) {\n    let c = n.charAt(i)\n    result += String.fromCharCode((c === '0')? 10 : 0)\n  }\n  return result\n}\n\n/**\n  Convert decimal (base 10) representation to string.\n  >>> dec2str('10')\n  '10'\n  */\nconst dec2str2 = (n) => {\n  let result = ''\n  for (let i = 0; i < n.length; i++) {\n    let c = n.charAt(i)\n    result += String.fromCharCode((c === '0')? 0 : 10)\n  }\n  return result\n}\n\n/**\n  Convert a string to hexadecimal (base 16) representation.\n  >>> hex2dec('0x10')\n  10\n  */\nconst hex2dec = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    let c = n.charAt(i)\n    result += parseInt(c, 16)\n  }\n  return result\n}\n\n/**\n  Convert hexadecimal (base 16) representation to decimal (base 10) representation.\n  >>> hex2dec('0x10')\n  10\n  */\nconst hex2dec2 = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    let c = n.charAt(i)\n    result += parseInt(c, 16)\n  }\n  return result\n}\n\n/**\n  Convert a string to octal (base 8) representation.\n  >>> dec2oct('0o10')\n  8\n  */\nconst dec2oct = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    let c = n.charAt(i)\n    result += parseInt(c, 8)\n  }\n  return result\n}\n\n/**\n  Convert octal (base 8) representation to decimal (base 10) representation.\n  >>> dec2oct('0o10')\n  8\n  */\nconst dec2oct2 = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    let c = n.charAt(i)\n    result += parseInt(c, 8)\n  }\n  return result\n}\n\n/**\n  Convert a string to decimal (base 10) representation.\n  >>> dec2dec('10')\n  10\n  */\nconst dec2dec = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    let c = n.charAt(i)\n    result += parseInt(c, 10)\n  }\n  return result\n}\n\n/**\n  Convert decimal (base 10) representation to hexadecimal (base 16) representation.\n  >>> hex2dec('10')\n  10\n  */\nconst hex2hex = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    let c = n.charAt(i)\n    result += parseInt(c, 16)\n  }\n  return result\n}\n\n/**\n  Convert hexadecimal (base 16) representation to decimal (base 10) representation.\n  >>> hex2hex('10')\n  10\n  */\nconst hex2hex2 = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    let c = n.charAt(i)\n    result += parseInt(c, 16)\n  }\n  return result\n}\n\n/**\n  Convert a string to hexadecimal (base 16) representation.\n  >>> hex2oct('0x10')\n  16\n  */\nconst hex2oct = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    let c = n.charAt(i)\n    result += parseInt(c, 16)\n  }\n  return result\n}\n\n/**\n  Convert octal (base 16) representation to hexadecimal (base 10) representation.\n  >>> hex2oct('0x10')\n  16\n  */\nconst hex2oct2 = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    let c = n.charAt(i)\n    result += parseInt(c, 16)\n  }\n  return result\n}\n\n/**\n  Convert a string to decimal (base 10) representation.\n  >>> dec2hex('10')\n  16\n  */\nconst dec2hex = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    let c = n.charAt(i)\n    result += parseInt(c, 16)\n  }\n  return result\n}\n\n/**\n  Convert hexadecimal (base 16) representation to decimal (base 10) representation.\n  >>> dec2hex('10')\n  16\n  */\nconst dec2hex2 = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    let c = n.charAt(i)\n    result += parseInt(c, 16)\n  }\n  return result\n}\n\n/**\n  Convert a string to decimal (base 10) representation.\n  >>> hex2dec('0x10')\n  16\n  */\nconst hex2dec = (n) => {\n  let result = 0\n  for (let i = 0; i < n.length; i++) {\n    let c = n.charAt(i)\n    result += parseInt(c, 16)\n  }\n  return result\n}\n\n/**\n  Convert hexadecimal (base 16) ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an xechange of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of xechanged elements between lst1 and lst2.\n  If it is possible to xechange elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  xechange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  xechange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst xechange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "xechange", "gc": "<|endoftext|>/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an xechange of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of xechanged elements between lst1 and lst2.\n  If it is possible to xechange elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  xechange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  xechange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst xechange = (lst1, lst2) => {\n  let isXechanged = false;\n  let isEven = true;\n  let i = 0;\n  let j = 0;\n  while (i < lst1.length && j < lst2.length) {\n    if (lst1[i] % 2 === lst2[j] % 2) {\n      isXechanged = true;\n      isEven = false;\n      i++;\n      j++;\n    } else {\n      isXechanged = false;\n      isEven = true;\n      i++;\n      j++;\n    }\n  }\n  return isXechanged && isEven;\n};\n\n/*\n  Given two sorted arrays, return true if they are equal.\n  Two sorted arrays are equal if they have the same length and each of\n  them contains only unique elements.\n  For example:\n  equalArrays([2, 3], [2, 3]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 2]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => true\n  equalArrays([2, 3], [2, 1]) => false\n  equalArrays([2, 3], [2, 1]) => ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/111", "prompt": "/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "gc": "<|endoftext|>/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  letters.forEach((letter) => {\n    counts[letter] = counts[letter] || 0;\n    counts[letter]++;\n  });\n  return counts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  letters.forEach((letter) => {\n    counts[letter] = counts[letter] || 0;\n    counts[letter]++;\n  });\n  return counts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  letters.forEach((letter) => {\n    counts[letter] = counts[letter] || 0;\n    counts[letter]++;\n  });\n  return counts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  letters.forEach((letter) => {\n    counts[letter] = counts[letter] || 0;\n    counts[letter]++;\n  });\n  return counts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  letters.forEach((letter) => {\n    counts[letter] = counts[letter] || 0;\n    counts[letter]++;\n  });\n  return counts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  letters.forEach((letter) => {\n    counts[letter] = counts[letter] || 0;\n    counts[letter]++;\n  });\n  return counts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  letters.forEach((letter) => {\n    counts[letter] = counts[letter] || 0;\n    counts[letter]++;\n  });\n  return counts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  letters.forEach((letter) => {\n    counts[letter] = counts[letter] || 0;\n    counts[letter]++;\n  });\n  return counts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  letters.forEach((letter) => {\n    counts[letter] = counts[letter] || 0;\n    counts[letter]++;\n  });\n  return counts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a'", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reveresDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reveresDelete", "gc": "<|endoftext|>/*Task\n  We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reveresDelete = (s, c) => {\n  let res = [];\n  let rev = s.split(\"\").reverse().join(\"\");\n  let len = c.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let flag = false;\n  while (i < len) {\n    if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      j++;\n      i++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.push(rev[i]);\n      flag = true;\n      i++;\n      j++;\n    } else if (rev[i] === c[j]) {\n      res.", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "gc": "<|endoftext|>/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  const oddCounts = []\n  for (let i = 0; i < lst.length; i++) {\n    const oddCount = (lst[i].replace(/\\D/g, '')) % 2 === 0\n    oddCounts.push(oddCount)\n  }\n  return oddCounts\n}\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  const evenCounts = []\n  for (let i = 0; i < lst.length; i++) {\n    const evenCount = (lst[i].replace(/\\D/g, '')) % 2!== 0\n    evenCounts.push(evenCount)\n  }\n  return evenCounts\n}\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of pairs of adjacent digits in\n  the string i of the input.\" where all the i's should be replaced by the number\n  of pairs of adjacent digits in the i'th string of the input.\n\n  >>> pairCount(['1234567'])\n  [\"the number of pairs of adjacent digits 4n the str4ng 4 of the 4nput.\"]\n  >>> pairCount(['3',\"11111111\"])\n  [\"the number of pairs of adjacent digits 1n the str1ng 1 of the 1nput.\",\n   \"the number of pairs of adjacent digits 8n the str8ng 8 of the 8nput.\"]\n  */\nconst pairCount = (lst) => {\n  const pairCounts = []\n  for (let i = 0; i < lst.length; i++) {\n    const pairCount = (lst[i].replace(/\\D/g, '')) % 2 === 0\n    pairCounts.push(pairCount)\n  }\n  return pairCounts\n}\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of triples of adjacent digits in\n  the string i of the input.\" where all the i's should be replaced by the number\n  of triples of adjacent digits in the i'th string of the input.\n\n  >>> tripleCount(['1234567'])\n  [\"the number of triples of adjacent digits 4n the str4ng 4 of the 4nput.\"]\n  >>> tripleCount(['3',\"11111111\"])\n  [\"the number of triples of adjacent digits 1n the str1ng 1 of the 1nput.\",\n   \"the number of triples of adjacent digits 8n the str8ng 8 of the 8nput.\"]\n  */\nconst tripleCount = (lst) => {\n  const tripleCounts = []\n  for (let i = 0; i < lst.length; i++) {\n    const tripleCount = (lst[i].replace(/\\D/g, '')) % 2!== 0\n    tripleCounts.push(tripleCount)\n  }\n  return tripleCounts\n}\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of quads of adjacent digits in\n  the string i of the input.\" where all the i's should be replaced by the number\n  of quads of adjacent digits in the i'th string of the input.\n\n  >>> quadCount(['1234567'])\n  [\"the number of quads of adjacent digits 4n the str4ng 4 of the 4nput.\"]\n  >>> quadCount(['3',\"11111111\"])\n  [\"the number of quads of adjacent digits 1n the str1ng 1 of the 1nput.\",\n   \"the number of quads of adjacent digits 8n the str8ng 8 of the 8nput.\"]\n  */\nconst quadCount = (lst) => {\n  const quadCounts = []\n  for (let i = 0; i < lst.length; i++) {\n    const quadCount = (lst[i].replace(/\\D/g, '')) % 2 === 0\n    quadCounts.push(quadCount)\n  }\n  return quadCounts\n}\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of quins of adjacent digits in\n  the string i of the input.\" where all the i's should be replaced by the number\n  of quins of adjacent digits in the i'th string of the input.\n\n  >>> quinCount(['1234567'])\n  [\"the number of quins of adjacent digits 4n the str4ng 4 of the 4nput.\"]\n  >>> quinCount(['3',\"11111111\"])\n  [\"the number of quins of adjacent digits 1n the str1ng 1 of the 1nput.\",\n   \"the number of quins of adjacent digits 8n the str8ng 8 of the 8nput.\"]\n  */\nconst quinCount = (lst) => {\n  const quinCounts = []\n  for (let i = 0; i < lst.length; i++) {\n    const quinCount = (lst[i].replace(/\\D/g, '')) % 2!== 0\n    quinCounts.push(quinCount)\n  }\n  return quinCounts\n}\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of nicks of adjacent digits in\n  the string i of the input.\" where all the i's should be replaced by the number\n  of nicks of adjacent digits in the i'th string of the input.\n\n  >>> nickCount(['1234567'])\n  [\"the number of nicks of adjacent digits 4n the str4ng 4 of the 4nput.\"]\n  >>> nickCount(['3',\"11111111\"])\n  [\"the number of nicks of adjacent digits 1n the str1ng 1 of the 1nput.\",\n   \"the number of nicks of adjacent digits 8n the str8ng 8 of the 8nput.\"]\n  */\nconst nickCount = (lst) => {\n  const nickCounts = []\n  for (let i = 0; i < lst.length; i++) {\n    const nickCount = (lst[i].replace(/\\D/g, '')) % 2 === 0\n    nickCounts.push(nickCount)\n  }\n  return nickCounts\n}\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of penns of adjacent digits in\n  the string i of the input.\" where all the i's should be replaced by the number\n  of penns of adjacent digits in the i'th string of the input.\n\n  >>> pennCount(['1234567'])\n  [\"the number of penns of adjacent digits 4n the str4ng 4 of the 4nput.\"]\n  >>> pennCount(['3',\"11111111\"])\n  [\"the number of penns of adjacent digits 1n the str1ng 1 of the 1nput.\",\n   \"the number of penns of adjacent digits 8n the str8ng 8 of the 8nput.\"]", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "gc": "<|endoftext|>/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\nmodule.exports = minSubArraySum;\n\n},{}],3:[function(require,module,exports){\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\nmodule.exports = maxSubArraySum;\n\n},{}],4:[function(require,module,exports){\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\nmodule.exports = maxSubArraySum;\n\n},{}],5:[function(require,module,exports){\n/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\nmodule.exports = minSubArraySum;\n\n},{}],6:[function(require,module,exports){\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\nmodule.exports = maxSubArraySum;\n\n},{}],7:[function(require,module,exports){\n/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\nmodule.exports = minSubArraySum;\n\n},{}],8:[function(require,module,exports){\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\nmodule.exports = maxSubArraySum;\n\n},{}],9:[function(require,module,exports){\n/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\nmodule.exports = minSubArraySum;\n\n},{}],10:[function(require,module,exports){\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\nmodule.exports = maxSubArraySum;\n\n},{}],11:[function(require,module,exports){\n/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\nmodule.exports = minSubArraySum;\n\n},{}],12:[function(require,module,exports){\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\nmodule.exports = maxSubArraySum;\n\n},{}],13:[function(require,module,exports){\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == -3\n  */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "gc": "<|endoftext|>/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = 0;\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(grid[i][j] === 1) {\n                const bucket = grid[i][j];\n                const bucketCapacity = capacity - bucket;\n                if(bucketCapacity > 0) {\n                    result += (bucketCapacity * bucketCapacity);\n                }\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Your MaxFill function will be called as follows:\n *\n * let grid = [[0,0,1,0], [0,1,0,0], [1,1,1,1]];\n * let capacity = 1;\n * maxFill(grid, capacity);\n */\nconst maxFill2 = grid => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = 0;\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(grid[i][j] === 1) {\n                const bucket = grid[i][j];\n                const bucketCapacity = capacity - bucket;\n                if(bucketCapacity > 0) {\n                    result += (bucketCapacity * bucketCapacity);\n                }\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Your MaxFill function will be called as follows:\n *\n * let grid = [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]];\n * let capacity = 5;\n * maxFill(grid, capacity);\n */\nconst maxFill3 = grid => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = 0;\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(grid[i][j] === 1) {\n                const bucket = grid[i][j];\n                const bucketCapacity = capacity - bucket;\n                if(bucketCapacity > 0) {\n                    result += (bucketCapacity * bucketCapacity);\n                }\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Your MaxFill function will be called as follows:\n *\n * let grid = [[0,0,0], [0,0,0]];\n * let capacity = 5;\n * maxFill(grid, capacity);\n */\nconst maxFill4 = grid => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = 0;\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(grid[i][j] === 1) {\n                const bucket = grid[i][j];\n                const bucketCapacity = capacity - bucket;\n                if(bucketCapacity > 0) {\n                    result += (bucketCapacity * bucketCapacity);\n                }\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Your MaxFill function will be called as follows:\n *\n * let grid = [[0,0,0], [0,0,0]];\n * let capacity = 5;\n * maxFill(grid, capacity);\n */\nconst maxFill5 = grid => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = 0;\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(grid[i][j] === 1) {\n                const bucket = grid[i][j];\n                const bucketCapacity = capacity - bucket;\n                if(bucketCapacity > 0) {\n                    result += (bucketCapacity * bucketCapacity);\n                }\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Your MaxFill function will be called as follows:\n *\n * let grid = [[0,0,0], [0,0,0]];\n * let capacity = 5;\n * maxFill(grid, capacity);\n */\nconst maxFill6 = grid => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = 0;\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(grid[i][j] === 1) {\n                const bucket = grid[i][j];\n                const bucketCapacity = capacity - bucket;\n                if(bucketCapacity > 0) {\n                    result += (bucketCapacity * bucketCapacity);\n                }\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Your MaxFill function will be called as follows:\n *\n * let grid = [[0,0,0], [0,0,0]];\n * let capacity = 5;\n * maxFill(grid, capacity);\n */\nconst maxFill7 = grid => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = 0;\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(grid[i][j] === 1) {\n                const bucket = grid[i][j];\n                const bucketCapacity = capacity - bucket;\n                if(bucketCapacity > 0) {\n                    result += (bucketCapacity * bucketCapacity);\n                }\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Your MaxFill function will be called as follows:\n *\n * let grid = [[0,0,0], [0,0,0]];\n * let capacity = 5;\n * maxFill(grid, capacity);\n */\nconst maxFill8 = grid => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = 0;\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(grid[i][j] === 1) {\n                const bucket = grid[i][j];\n                const bucketCapacity = capacity - bucket;\n                if(bucketCapacity > 0) {\n                    result += (bucketCapacity * bucketCapacity);\n                }\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Your MaxFill function will be called as follows:\n *\n * let grid = [[0,0,0], [0,0,0]];\n * let capacity = 5;\n * maxFill(grid, capacity);\n */\nconst maxFill9 = grid => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = 0;\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(grid[i][j] === 1) {\n                const bucket = grid[i][j];\n                const bucketCapacity = capacity - bucket;\n                if(bucketCapacity > 0) {\n                    result += (bucketCapacity * bucketCapacity);\n                }\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Your MaxFill function will be called as follows:\n *\n * let grid = [[0,0,0], [0,0,0]];\n * let capacity = 5;\n * maxFill(grid, capacity);\n */\nconst maxFill10 = grid => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = 0;\n    for(let i = 0; i < n; i++) {\n        for(let j = 0; j < m; j++) {\n            if(grid[i][j] === 1) {\n                const bucket = grid[i][j];\n                const bucketCapacity = capacity - bucket;\n                if(bucketCapacity > 0) {\n                    result += (bucketCapacity * bucketCapacity);\n                }\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Your MaxFill function will be called as follows:\n *\n * let grid = [[0,0,0], [0,0,0]];\n * let capacity = 5;\n * maxFill(grid, capacity);\n */\nconst maxFill11 = grid => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "gc": "<|endoftext|>/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const sorted = arr.sort((a, b) => a - b);\n  return sorted.map((num) => num.toString());\n};\n\n// Given an array of integers, return a new array where each element is the sum\n// of the elements in the original array divided by its length.\nconst divideArray = (arr) => {\n  const len = arr.length;\n  const result = [];\n  for (let i = 0; i < len; i++) {\n    result[i] = arr[i] / len;\n  }\n  return result;\n};\n\n// Given an array of integers, return a new array where each element is the sum\n// of the elements in the original array multiplied by its length.\nconst multiplyArray = (arr) => {\n  const len = arr.length;\n  const result = [];\n  for (let i = 0; i < len; i++) {\n    result[i] = arr[i] * len;\n  }\n  return result;\n};\n\n// Given an array of integers, return a new array where each element is the sum\n// of the elements in the original array modulo its length.\nconst moduloArray = (arr) => {\n  const len = arr.length;\n  const result = [];\n  for (let i = 0; i < len; i++) {\n    result[i] = arr[i] % len;\n  }\n  return result;\n};\n\n// Given an array of integers, return a new array where each element is the sum\n// of the elements in the original array multiplied by its length and modulo\n// its length.\nconst multiplyAndModuloArray = (arr) => {\n  const len = arr.length;\n  const result = [];\n  for (let i = 0; i < len; i++) {\n    result[i] = arr[i] * len + arr[i] % len;\n  }\n  return result;\n};\n\n// Given an array of integers, return a new array where each element is the sum\n// of the elements in the original array multiplied by its length and modulo\n// its length and divided by its length.\nconst multiplyAndModuloAndDivideArray = (arr) => {\n  const len = arr.length;\n  const result = [];\n  for (let i = 0; i < len; i++) {\n    result[i] = arr[i] * len + arr[i] % len / len;\n  }\n  return result;\n};\n\n// Given an array of integers, return a new array where each element is the sum\n// of the elements in the original array multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length.\nconst multiplyAndModuloAndDivideAndDivideArray = (arr) => {\n  const len = arr.length;\n  const result = [];\n  for (let i = 0; i < len; i++) {\n    result[i] = arr[i] * len + arr[i] % len / len / len;\n  }\n  return result;\n};\n\n// Given an array of integers, return a new array where each element is the sum\n// of the elements in the original array multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and multiplied by its length and modulo\n// its length and divided by its length and multiplied by its length and modulo\n// its length and ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selectWdors(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWdors(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWdors(\"simple white space\", 2) ==> []\n  selectWdors(\"Hello world\", 4) ==> [\"world\"]\n  selectWdors(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWdors = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWdors", "gc": "<|endoftext|>/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selectWdors(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWdors(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWdors(\"simple white space\", 2) ==> []\n  selectWdors(\"Hello world\", 4) ==> [\"world\"]\n  selectWdors(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWdors = (s, n) => {\n  let words = []\n  let word = ''\n  let wordLen = 0\n  let wordCount = 0\n  let wordCountMax = s.length\n  let wordCountMin = 1\n  let wordCountMaxMin = wordCountMax - wordCountMin\n  let wordCountMaxMax = wordCountMax - wordCountMax - 1\n  let wordCountMaxMin = wordCountMax - wordCountMin - 1\n  let wordCountMaxMax = wordCountMax - wordCountMax - 2\n  let wordCountMaxMin = wordCountMax - wordCountMin - 2\n  let wordCountMaxMax = wordCountMax - wordCountMax - 3\n  let wordCountMaxMin = wordCountMax - wordCountMin - 3\n  let wordCountMaxMax = wordCountMax - wordCountMax - 4\n  let wordCountMaxMin = wordCountMax - wordCountMin - 4\n  let wordCountMaxMax = wordCountMax - wordCountMax - 5\n  let wordCountMaxMin = wordCountMax - wordCountMin - 5\n  let wordCountMaxMax = wordCountMax - wordCountMax - 6\n  let wordCountMaxMin = wordCountMax - wordCountMin - 6\n  let wordCountMaxMax = wordCountMax - wordCountMax - 7\n  let wordCountMaxMin = wordCountMax - wordCountMin - 7\n  let wordCountMaxMax = wordCountMax - wordCountMax - 8\n  let wordCountMaxMin = wordCountMax - wordCountMin - 8\n  let wordCountMaxMax = wordCountMax - wordCountMax - 9\n  let wordCountMaxMin = wordCountMax - wordCountMin - 9\n  let wordCountMaxMax = wordCountMax - wordCountMax - 10\n  let wordCountMaxMin = wordCountMax - wordCountMin - 10\n  let wordCountMaxMax = wordCountMax - wordCountMax - 11\n  let wordCountMaxMin = wordCountMax - wordCountMin - 11\n  let wordCountMaxMax = wordCountMax - wordCountMax - 12\n  let wordCountMaxMin = wordCountMax - wordCountMin - 12\n  let wordCountMaxMax = wordCountMax - wordCountMax - 13\n  let wordCountMaxMin = wordCountMax - wordCountMin - 13\n  let wordCountMaxMax = wordCountMax - wordCountMax - 14\n  let wordCountMaxMin = wordCountMax - wordCountMin - 14\n  let wordCountMaxMax = wordCountMax - wordCountMax - 15\n  let wordCountMaxMin = wordCountMax - wordCountMin - 15\n  let wordCountMaxMax = wordCountMax - wordCountMax - 16\n  let wordCountMaxMin = wordCountMax - wordCountMin - 16\n  let wordCountMaxMax = wordCountMax - wordCountMax - 17\n  let wordCountMaxMin = wordCountMax - wordCountMin - 17\n  let wordCountMaxMax = wordCountMax - wordCountMax - 18\n  let wordCountMaxMin = wordCountMax - wordCountMin - 18\n  let wordCountMaxMax = wordCountMax - wordCountMax - 19\n  let wordCountMaxMin = wordCountMax - wordCountMin - 19\n  let wordCountMaxMax = wordCountMax - wordCountMax - 20\n  let wordCountMaxMin = wordCountMax - wordCountMin - 20\n  let wordCountMaxMax = wordCountMax - wordCountMax - 21\n  let wordCountMaxMin = wordCountMax - wordCountMin - 21\n  let wordCountMaxMax = wordCountMax - wordCountMax - 22\n  let wordCountMaxMin = wordCountMax - wordCountMin - 22\n  let wordCountMaxMax = wordCountMax - wordCountMax - 23\n  let wordCountMaxMin = wordCountMax - wordCountMin - 23\n  let wordCountMaxMax = wordCountMax - wordCountMax - 24\n  let wordCountMaxMin = wordCountMax - wordCountMin - 24\n  let wordCountMaxMax = wordCountMax - wordCountMax - 25\n  let wordCountMaxMin = wordCountMax - wordCountMin - 25\n  let wordCountMaxMax = wordCountMax - wordCountMax - 26\n  let wordCountMaxMin = wordCountMax - wordCountMin - 26\n  let wordCountMaxMax = wordCountMax - wordCountMax - 27\n  let wordCountMaxMin = wordCountMax - wordCountMin - 27\n  let wordCountMaxMax = wordCountMax - wordCountMax - 28\n  let wordCountMaxMin = wordCountMax - wordCountMin - 28\n  let wordCountMaxMax = wordCountMax - wordCountMax - 29\n  let wordCountMaxMin = wordCountMax - wordCountMin - 29\n  let wordCountMaxMax = wordCountMax - wordCountMax - 30\n  let wordCountMaxMin = wordCountMax - wordCountMin - 30\n  let wordCountMaxMax = wordCountMax - wordCountMax - 31\n  let wordCountMaxMin = wordCountMax - wordCountMin - 31\n  let wordCountMaxMax = wordCountMax - wordCountMax - 32\n  let wordCountMaxMin = wordCountMax - wordCountMin - 32\n  let wordCountMaxMax = wordCountMax - wordCountMax - 33\n  let wordCountMaxMin = wordCountMax - wordCountMin - 33\n  let wordCountMaxMax = wordCountMax - wordCountMax - 34\n  let wordCountMaxMin = wordCountMax - wordCountMin - 34\n  let wordCountMaxMax = wordCountMax - wordCountMax - 35\n  let wordCountMaxMin = wordCountMax - wordCountMin - 35\n  let wordCountMaxMax = wordCountMax - wordCountMax - 36\n  let wordCountMaxMin = wordCountMax - wordCountMin - 36\n  let wordCountMaxMax = wordCountMax - wordCountMax - 37\n  let wordCountMaxMin = wordCountMax - wordCountMin - 37\n  let wordCountMaxMax = wordCountMax - wordCountMax - 38\n  let wordCountMaxMin = wordCountMax - wordCountMin - 38\n  let wordCountMaxMax = wordCountMax - wordCountMax - 39\n  let wordCountMaxMin = wordCountMax - wordCountMin - 39\n  let wordCountMaxMax = wordCountMax - wordCountMax - 40\n  let wordCountMaxMin = wordCountMax - wordCountMin - 40\n  let wordCountMaxMax = wordCountMax - wordCountMax - 41\n  let wordCountMaxMin = wordCountMax - wordCountMin - 41\n  let wordCountMaxMax = wordCountMax - wordCount", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/118", "prompt": "/*You are given a word. Your task is to find the closest vowel that stands between \n  two consonants from the right side of the word (case sensitive).\n  \n  Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contains English letter only.\n\n  Example:\n  getClossetVowel(\"yogurt\") ==> \"u\"\n  getClossetVowel(\"FULL\") ==> \"U\"\n  getClossetVowel(\"quick\") ==> \"\"\n  getClossetVowel(\"ab\") ==> \"\"\n  */\nconst getClossetVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClossetVowel", "gc": "<|endoftext|>/*You are given a word. Your task is to find the closest vowel that stands between \n  two consonants from the right side of the word (case sensitive).\n  \n  Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contains English letter only.\n\n  Example:\n  getClossetVowel(\"yogurt\") ==> \"u\"\n  getClossetVowel(\"FULL\") ==> \"U\"\n  getClossetVowel(\"quick\") ==> \"\"\n  getClossetVowel(\"ab\") ==> \"\"\n  */\nconst getClossetVowel = (word) => {\n  let vowels = vowels.split('');\n  let vowelsLength = vowels.length;\n  let vowelsArray = [];\n  let vowelsArrayLength = 0;\n  let vowelsArrayIndex = 0;\n  let vowelsArrayValue = 0;\n  let vowelsArrayValueLength = 0;\n  let vowelsArrayValueIndex = 0;\n  let vowelsArrayValueValue = 0;\n  let vowelsArrayValueValueLength = 0;\n  let vowelsArrayValueValueIndex = 0;\n  let vowelsArrayValueValueValue = 0;\n  let vowelsArrayValueValueValueLength = 0;\n  let vowelsArrayValueValueValueIndex = 0;\n  let vowelsArrayValueValueValueValue = 0;\n  let vowelsArrayValueValueValueValueLength = 0;\n  let vowelsArrayValueValueValueValueIndex = 0;\n  let vowelsArrayValueValueValueValueValue = 0;\n  let vowelsArrayValueValueValueValueValueLength = 0;\n  let vowelsArrayValueValueValueValueValueIndex = 0;\n  let vowelsArrayValueValueValueValueValueValue = 0;\n  let vowelsArrayValueValueValueValueValueValueLength = 0;\n  let vowelsArrayValueValueValueValueValueValueIndex = 0;\n  let vowelsArrayValueValueValueValueValueValueValue = 0;\n  let vowelsArrayValueValueValueValueValueValueValueLength = 0;\n  let vowelsArrayValueValueValueValueValueValueValueIndex = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValue = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueLength = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueIndex = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValue = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueLength = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueIndex = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValue = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueLength = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueIndex = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValue = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueLength = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueIndex = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValueValue = 0;\n  let vowelsArrayValueValueValueValueValueValueValueValueValueValueValue", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of two strings, both strings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible to concatenate the two strings in\n  some order, that the resulting string will be good.\n  A string S is considered to be good if and only if all parentheses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "gc": "<|endoftext|>/* You are given a list of two strings, both strings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible to concatenate the two strings in\n  some order, that the resulting string will be good.\n  A string S is considered to be good if and only if all parentheses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let res = '';\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let balance = 0;\n  let openParens = 0;\n  let closeParens = 0;\n  let openParensCount = 0;\n  let closeParensCount = 0;\n  let openParensCount2 = 0;\n  let closeParensCount2 = 0;\n  let openParensCount3 = 0;\n  let closeParensCount3 = 0;\n  let openParensCount4 = 0;\n  let closeParensCount4 = 0;\n  let openParensCount5 = 0;\n  let closeParensCount5 = 0;\n  let openParensCount6 = 0;\n  let closeParensCount6 = 0;\n  let openParensCount7 = 0;\n  let closeParensCount7 = 0;\n  let openParensCount8 = 0;\n  let closeParensCount8 = 0;\n  let openParensCount9 = 0;\n  let closeParensCount9 = 0;\n  let openParensCount10 = 0;\n  let closeParensCount10 = 0;\n  let openParensCount11 = 0;\n  let closeParensCount11 = 0;\n  let openParensCount12 = 0;\n  let closeParensCount12 = 0;\n  let openParensCount13 = 0;\n  let closeParensCount13 = 0;\n  let openParensCount14 = 0;\n  let closeParensCount14 = 0;\n  let openParensCount15 = 0;\n  let closeParensCount15 = 0;\n  let openParensCount16 = 0;\n  let closeParensCount16 = 0;\n  let openParensCount17 = 0;\n  let closeParensCount17 = 0;\n  let openParensCount18 = 0;\n  let closeParensCount18 = 0;\n  let openParensCount19 = 0;\n  let closeParensCount19 = 0;\n  let openParensCount20 = 0;\n  let closeParensCount20 = 0;\n  let openParensCount21 = 0;\n  let closeParensCount21 = 0;\n  let openParensCount22 = 0;\n  let closeParensCount22 = 0;\n  let openParensCount23 = 0;\n  let closeParensCount23 = 0;\n  let openParensCount24 = 0;\n  let closeParensCount24 = 0;\n  let openParensCount25 = 0;\n  let closeParensCount25 = 0;\n  let openParensCount26 = 0;\n  let closeParensCount26 = 0;\n  let openParensCount27 = 0;\n  let closeParensCount27 = 0;\n  let openParensCount28 = 0;\n  let closeParensCount28 = 0;\n  let openParensCount29 = 0;\n  let closeParensCount29 = 0;\n  let openParensCount30 = 0;\n  let closeParensCount30 = 0;\n  let openParensCount31 = 0;\n  let closeParensCount31 = 0;\n  let openParensCount32 = 0;\n  let closeParensCount32 = 0;\n  let openParensCount33 = 0;\n  let closeParensCount33 = 0;\n  let openParensCount34 = 0;\n  let closeParensCount34 = 0;\n  let openParensCount35 = 0;\n  let closeParensCount35 = 0;\n  let openParensCount36 = 0;\n  let closeParensCount36 = 0;\n  let openParensCount37 = 0;\n  let closeParensCount37 = 0;\n  let openParensCount38 = 0;\n  let closeParensCount38 = 0;\n  let openParensCount39 = 0;\n  let closeParensCount39 = 0;\n  let openParensCount40 = 0;\n  let closeParensCount40 = 0;\n  let openParensCount41 = 0;\n  let closeParensCount41 = 0;\n  let openParensCount42 = 0;\n  let closeParensCount42 = 0;\n  let openParensCount43 = 0;\n  let closeParensCount43 = 0;\n  let openParensCount44 = 0;\n  let closeParensCount44 = 0;\n  let openParensCount45 = 0;\n  let closeParensCount45 = 0;\n  let openParensCount46 = 0;\n  let closeParensCount46 = 0;\n  let openParensCount47 = 0;\n  let closeParensCount47 = 0;\n  let openParensCount48 = 0;\n  let closeParensCount48 = 0;\n  let openParensCount49 = 0;\n  let closeParensCount49 = 0;\n  let openParensCount50 = 0;\n  let closeParensCount50 = 0;\n  let openParensCount51 = 0;\n  let closeParensCount51 = 0;\n  let openParensCount52 = 0;\n  let closeParensCount52 = 0;\n  let openParensCount53 = 0;\n  let closeParensCount53 = 0;\n  let openParensCount54 = 0;\n  let closeParensCount54 = 0;\n  let openParensCount55 = 0;\n  let closeParensCount55 = 0;\n  let openParensCount56 = 0;\n  let closeParensCount56 = 0;\n  let openParensCount57 = 0;\n  let closeParensCount57 = 0;\n  let openParensCount58 = 0;\n  let closeParensCount58 = 0;\n  let openParensCount59 = 0;\n  let closeParensCount59 = 0;\n  let openParensCount60 = 0;\n  let closeParensCount60 = 0;\n  let openParensCount61 = 0;\n  let closeParensCount61 = 0;\n  let openParensCount62 = 0;\n  let closeParensCount62 = 0;\n  let openParensCount63 = 0;\n  let closeParensCount63 = 0;\n  let openParensCount64 = 0;\n  let closeParensCount64 = 0;\n  let openParensCount65 = 0;\n  let closeParensCount65 = 0;\n  let openParensCount66 = 0;\n  let closeParensCount66 = 0;\n  let openParensCount67 = 0;\n  let closeParensCount67 = 0;\n  let openParensCount68 = 0;\n  let closeParensCount68 = 0;\n  let openParensCount69 = 0;\n  let closeParensCount69 = 0;\n  let openParensCount70 = 0;\n  let closeParensCount70 = 0;\n  let openParensCount71 = 0;\n  let closeParensCount71 = 0;\n  let openParensCount72 = 0;\n  let closeParensCount72 = 0;\n  let openParensCount73 = 0;\n  let closeParensCount73 = 0;\n  let openParensCount74 = 0;\n  let closeParensCount74 = 0;\n  let openParensCount75 = 0;\n  let closeParensCount75 = 0;\n  let openParensCount76 = 0;\n  let closeParensCount76 = 0;\n  let openParensCount77 = 0;\n  let closeParensCount77 = 0;\n  let openParensCount78 = 0;\n  let closeParensCount78 = 0;\n  let openParensCount79 = 0;\n  let closeParensCount79 = 0;\n  let openParensCount80 = 0;\n  let closeParensCount80 = 0;\n  let openParensCount81 = 0;\n  let closeParensCount81 = 0;\n  let openParensCount82 = 0;\n  let closeParensCount82 = 0;\n  let openParensCount83 = 0;\n  let closeParensCount83 = 0;\n  let openParensCount84 = 0;\n  let closeParensCount84 = 0;\n  let openParensCount85 = 0;\n  let closeParensCount85 = 0;\n  let openParensCount86 = 0;\n  let closeParensCount86 = 0;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "gc": "<|endoftext|>/* Out of list of strings, return the longest one. Return the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (!strings || strings.length === 0) {\n    return null\n  }\n\n  const longestLength = 0\n  let longestString = ''\n  for (let i = 0; i < strings.length; i++) {\n    const string = strings[i]\n    if (string.length > longestLength) {\n      longestString = string\n      longestLength = string.length\n    }\n  }\n  return longestString\n}\n\nmodule.exports = longest\n\n},{}],17:[function(require,module,exports){\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  const hash = createHash('sha256')\n  hash.update(string)\n  return hash.digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":10}],18:[function(require,module,exports){\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  const hash = createHash('sha256')\n  hash.update(string)\n  return hash.digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":10}],19:[function(require,module,exports){\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  const hash = createHash('sha256')\n  hash.update(string)\n  return hash.digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":10}],20:[function(require,module,exports){\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  const hash = createHash('sha256')\n  hash.update(string)\n  return hash.digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":10}],21:[function(require,module,exports){\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  const hash = createHash('sha256')\n  hash.update(string)\n  return hash.digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":10}],22:[function(require,module,exports){\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  const hash = createHash('sha256')\n  hash.update(string)\n  return hash.digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":10}],23:[function(require,module,exports){\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  const hash = createHash('sha256')\n  hash.update(string)\n  return hash.digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":10}],24:[function(require,module,exports){\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  const hash = createHash('sha256')\n  hash.update(string)\n  return hash.digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":10}],25:[function(require,module,exports){\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  const hash = createHash('sha256')\n  hash.update(string)\n  return hash.digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":10}],26:[function(require,module,exports){\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  const hash = createHash('sha256')\n  hash.update(string)\n  return hash.digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":10}],27:[function(require,module,exports){\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  const hash = createHash('sha256')\n  hash.update(string)\n  return hash.digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":10}],28:[function(require,module,exports){\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  const hash = createHash('sha256')\n  hash.update(string)\n  return hash.digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":10}],29:[function(require,module,exports){\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  const hash = createHash('sha256')\n  hash.update(string)\n  return hash.digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":10}],30:[function(require,module,exports){\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  const hash = createHash('sha256')\n  hash.update(string)\n  return hash.digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":10}],31:[function(require,module,exports){\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  const hash = createHash('sha256')\n  hash.update(string)\n  return hash.digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":10}],32:[function(require,module,exports){\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  const hash = createHash('sha256')\n  hash.update(string)\n  return hash.digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":10}],33:[function(require,module,exports){\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  const hash = createHash('sha256')\n  hash.update(string)\n  return hash.digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":10}],34:[function(require,module,exports){\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  const hash = createHash('sha256')\n  hash.update(string)\n  return hash.digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":10}],35:[function(require,module,exports){\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  const hash = createHash('sha256')\n  hash.update(string)\n  return hash.digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":10}],36:[function(require,module,exports){\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  const hash = createHash('sha256')\n  hash.update(string)\n  return hash.digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":10}],37:[function(require,module,exports){\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  const hash = createHash('sha256')\n  hash.update(string)\n  return hash.digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":10}],38:[function(require,module,exports){\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  const hash = createHash('sha256')\n  hash.update(string)\n  return hash.digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":10}],39:[function(require,module,exports){\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  const hash = createHash('sha256')\n  hash.update(string)\n  return hash.digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":10}],40:[function(require,module,exports){\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  const hash = createHash('sha256')\n  hash.update(string)\n  return hash.digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":10}],41:[function(require,module,exports){\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  const hash = createHash('sha256')\n  hash.update(string)\n  return hash.digest('hex')\n}\n\nmodule.exports = hash\n\n},", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n  of length k with the maxmium k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maxmium = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maxmium", "gc": "<|endoftext|>/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n  of length k with the maxmium k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maxmium = (arr, k) => {\n  const len = arr.length;\n  const result = [];\n  let max = 0;\n  let min = 0;\n  let i = 1;\n  while (i < len) {\n    if (arr[i] > max) {\n      max = arr[i];\n      min = i;\n    }\n    i++;\n  }\n  while (i < len) {\n    if (arr[i] < min) {\n      min = arr[i];\n      max = i;\n    }\n    i++;\n  }\n  result.push(max);\n  result.push(min);\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-a-given-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {number[]}\n */\nvar findMaxSubArraySum = function(head, k) {\n  const result = [];\n  let curr = head;\n  let sum = 0;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  result.push(sum);\n  result.push(sum - k);\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-a-given-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {number[]}\n */\nvar findMaxSubArraySum = function(head, k) {\n  const result = [];\n  let curr = head;\n  let sum = 0;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  result.push(sum);\n  result.push(sum - k);\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-a-given-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {number[]}\n */\nvar findMaxSubArraySum = function(head, k) {\n  const result = [];\n  let curr = head;\n  let sum = 0;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  result.push(sum);\n  result.push(sum - k);\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-a-given-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {number[]}\n */\nvar findMaxSubArraySum = function(head, k) {\n  const result = [];\n  let curr = head;\n  let sum = 0;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  result.push(sum);\n  result.push(sum - k);\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-a-given-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {number[]}\n */\nvar findMaxSubArraySum = function(head, k) {\n  const result = [];\n  let curr = head;\n  let sum = 0;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  result.push(sum);\n  result.push(sum - k);\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-a-given-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {number[]}\n */\nvar findMaxSubArraySum = function(head, k) {\n  const result = [];\n  let curr = head;\n  let sum = 0;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  result.push(sum);\n  result.push(sum - k);\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-a-given-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {number[]}\n */\nvar findMaxSubArraySum = function(head, k) {\n  const result = [];\n  let curr = head;\n  let sum = 0;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  result.push(sum);\n  result.push(sum - k);\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-a-given-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {number[]}\n */\nvar findMaxSubArraySum = function(head, k) {\n  const result = [];\n  let curr = head;\n  let sum = 0;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  result.push(sum);\n  result.push(sum - k);\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-a-given-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {number[]}\n */\nvar findMaxSubArraySum = function(head, k) {\n  const result = [];\n  let curr = head;\n  let sum = 0;\n  while (curr) {\n    sum += curr.val;\n    curr = curr.next;\n  }\n  result.push(sum);\n  result.push(sum - k);\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-from-a-given-array/\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/121", "prompt": "/*Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "gc": "<|endoftext|>/*Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],4:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],5:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],6:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],7:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],8:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],9:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],10:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],11:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],12:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],13:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],14:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],15:[function(require,module,exports){\n/*\n  Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "gc": "<|endoftext|>/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let count = 0;\n  while (i < arr.length) {\n    if (arr[i] >= 10) {\n      sum += arr[i];\n      i++;\n    } else {\n      count++;\n      if (count >= k) {\n        sum++;\n        count = 0;\n      }\n    }\n  }\n  return sum;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the number of distinct elements with at most two digits from the first k elements of arr.\n\n * Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 4 # number of distinct elements with at most 2 digits from the first 4 elements of arr\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst countDistinctElements = (arr, k) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let count = 0;\n  while (i < arr.length) {\n    if (arr[i] >= 10) {\n      count++;\n    } else {\n      if (count >= k) {\n        count++;\n        count = 0;\n      }\n      i++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the maximum element with at most two digits from the first k elements of arr.\n\n * Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 9 # maximum element with at most 2 digits from the first 4 elements of arr\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst maxElement = (arr, k) => {\n  let max = 0;\n  let i = 0;\n  let j = 0;\n  let count = 0;\n  while (i < arr.length) {\n    if (arr[i] >= 10) {\n      count++;\n    } else {\n      if (count >= k) {\n        max = arr[i];\n        count = 0;\n      }\n      i++;\n    }\n  }\n  return max;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the minimum element with at most two digits from the first k elements of arr.\n\n * Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 5 # minimum element with at most 2 digits from the first 4 elements of arr\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst minElement = (arr, k) => {\n  let min = 0;\n  let i = 0;\n  let j = 0;\n  let count = 0;\n  while (i < arr.length) {\n    if (arr[i] >= 10) {\n      count++;\n    } else {\n      if (count >= k) {\n        min = arr[i];\n        count = 0;\n      }\n      i++;\n    }\n  }\n  return min;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the sum of all elements with at most two digits from the first k elements of arr.\n\n * Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst sumElements = (arr, k) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let count = 0;\n  while (i < arr.length) {\n    if (arr[i] >= 10) {\n      sum += arr[i];\n      i++;\n    } else {\n      count++;\n      if (count >= k) {\n        sum++;\n        count = 0;\n      }\n    }\n  }\n  return sum;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the sum of all distinct elements with at most two digits from the first k elements of arr.\n\n * Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 4 # sum of distinct elements with at most 2 digits from the first 4 elements of arr\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst countDistinctElements = (arr, k) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let count = 0;\n  while (i < arr.length) {\n    if (arr[i] >= 10) {\n      count++;\n    } else {\n      if (count >= k) {\n        count++;\n        count = 0;\n      }\n      i++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the maximum element with at most two digits from the first k elements of arr.\n\n * Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 9 # maximum element with at most 2 digits from the first 4 elements of arr\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst maxElement = (arr, k) => {\n  let max = 0;\n  let i = 0;\n  let j = 0;\n  let count = 0;\n  while (i < arr.length) {\n    if (arr[i] >= 10) {\n      count++;\n    } else {\n      if (count >= k) {\n        max = arr[i];\n        count = 0;\n      }\n      i++;\n    }\n  }\n  return max;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the minimum element with at most two digits from the first k elements of arr.\n\n * Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 5 # minimum element with at most 2 digits from the first 4 elements of arr\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst minElement = (arr, k) => {\n  let min = 0;\n  let i = 0;\n  let j = 0;\n  let count = 0;\n  while (i < arr.length) {\n    if (arr[i] >= 10) {\n      count++;\n    } else {\n      if (count >= k) {\n        min = arr[i];\n        count = 0;\n      }\n      i++;\n    }\n  }\n  return min;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the sum of all elements with at most two digits from the first k elements of arr.\n\n * Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst sumElements = (arr, k) => {\n  let sum = 0;\n  let i = 0;\n  let j = 0;\n  let count = 0;\n  while (i < arr.length) {\n    if (arr[i] >= 10) {\n      sum += arr[i];\n      i++;\n    } else {\n      count++;\n      if (count >= k) {\n        sum++;\n        count = 0;\n      }\n    }\n  }\n  return sum;\n};\n\n/**\n * Given a non-empty array of integers arr and an integer k, return\n * the sum of all distinct elements with at most two digits from the first k elements of arr.\n\n * Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 4 # sum of distinct elements with at most 2 digits from the first 4 elements of arr\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst countDistin", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 3, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "gc": "<|endoftext|>/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let collatz = [];\n  let num = 1;\n  let prev = 1;\n  while (num < n) {\n    if (num % 2 === 0) {\n      collatz.push(num);\n      num += prev;\n      prev = num;\n    } else {\n      num += prev;\n      prev = num;\n    }\n  }\n  collatz.push(num);\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the even numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5, 3] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the even numbers are 1, 5, and 3.\n  */\nconst getEvenCollatz = (n) => {\n  let collatz = [];\n  let num = 1;\n  let prev = 1;\n  while (num < n) {\n    if (num % 2 === 0) {\n      collatz.push(num);\n      num += prev;\n      prev = num;\n    } else {\n      num += prev;\n      prev = num;\n    }\n  }\n  collatz.push(num);\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 3, 5, 7, 9] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the prime numbers are 1, 3, 5, 7, and 9.\n  */\nconst getPrimeCollatz = (n) => {\n  let collatz = [];\n  let num = 1;\n  let prev = 1;\n  while (num < n) {\n    if (num % 2 === 0) {\n      collatz.push(num);\n      num += prev;\n      prev = num;\n    } else {\n      num += prev;\n      prev = num;\n    }\n  }\n  collatz.push(num);\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 3, 5, 7, 9] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the prime numbers are 1, 3, 5, 7, and 9.\n  */\nconst getPrimeCollatz = (n) => {\n  let collatz = [];\n  let num = 1;\n  let prev = 1;\n  while (num < n) {\n    if (num % 2 === 0) {\n      collatz.push(num);\n      num += prev;\n      prev = num;\n    } else {\n      num += prev;\n      prev = num;\n    }\n  }\n  collatz.push(num);\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 3, 5, 7, 9] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the prime numbers are 1, 3, 5, 7, and 9.\n  */\nconst getPrimeCollatz = (n) => {\n  let collatz = [];\n  let num = 1;\n  let prev = 1;\n  while (num < n) {\n    if (num % 2 === 0) {\n      collatz.push(num);\n      num += prev;\n      prev = num;\n    } else {\n      num += prev;\n      prev = num;\n    }\n  }\n  collatz.push(num);\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 3, 5, 7, 9] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the prime numbers are 1, 3, 5, 7, and 9.\n  */\nconst getPrimeCollatz = (n) => {\n  let collatz = [];\n  let num = 1;\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/124", "prompt": "/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "gc": "<|endoftext|>/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const dateArray = date.split('-');\n  const dateString = dateArray.join('-');\n  const date = new Date(dateString);\n  const isValid = dateArray.length === 3 && dateArray[0].length === 2 && dateArray[1].length === 2 && dateArray[0] >= 1 && dateArray[1] <= 31 && dateArray[0] >= 4 && dateArray[1] <= 29 && dateArray[0] >= 6 && dateArray[1] <= 11;\n  return isValid;\n};\n\n/*\n  Given a date string and a month number, returns the date string of the next month.\n  If the month number is greater than 12, returns the date string of the previous month.\n  If the month number is less than 1, returns the date string of the next year.\n  If the month number is less than 1, returns the date string of the previous year.\n  If the month number is less than 1, returns the date string of the next decade.\n  If the month number is less than 1, returns the date string of the previous decade.\n  If the month number is less than 1, returns the date string of the next century.\n  If the month number is less than 1, returns the date string of the previous century.\n  If the month number is less than 1, returns the date string of the next millennium.\n  If the month number is less than 1, returns the date string of the previous millennium.\n  If the month number is less than 1, returns the date string of the next century millennium.\n  If the month number is less than 1, returns the date string of the previous century millennium.\n  If the month number is less than 1, returns the date string of the next millennium century.\n  If the month number is less than 1, returns the date string of the previous millennium century.\n  If the month number is less than 1, returns the date string of the next century millennium century.\n  If the month number is less than 1, returns the date string of the previous century millennium century.\n  If the month number is less than 1, returns the date string of the next century millennium millennium.\n  If the month number is less than 1, returns the date string of the previous century millennium millennium.\n  If the month number is less than 1, returns the date string of the next millennium millennium millennium.\n  If the month number is less than 1, returns the date string of the previous millennium millennium millennium.\n  If the month number is less than 1, returns the date string of the next century millennium millennium century.\n  If the month number is less than 1, returns the date string of the previous century millennium millennium century.\n  If the month number is less than 1, returns the date string of the next century millennium millennium millennium.\n  If the month number is less than 1, returns the date string of the previous century millennium millennium millennium.\n  If the month number is less than 1, returns the date string of the next century millennium millennium millennium century.\n  If the month number is less than 1, returns the date string of the previous century millennium millennium millennium century.\n  If the month number is less than 1, returns the date string of the next century millennium millennium millennium millennium.\n  If the month number is less than 1, returns the date string of the previous century millennium millennium millennium millennium.\n  If the month number is less than 1, returns the date string of the next century millennium millennium millennium millennium century.\n  If the month number is less than 1, returns the date string of the previous century millennium millennium millennium millennium century.\n  If the month number is less than 1, returns the date string of the next century millennium millennium millennium millennium millennium.\n  If the month number is less than 1, returns the date string of the previous century millennium millennium millennium millennium millennium.\n  If the month number is less than 1, returns the date string of the next century millennium millennium millennium millennium millennium century.\n  If the month number is less than 1, returns the date string of the previous century millennium millennium millennium millennium millennium century.\n  If the month number is less than 1, returns the date string of the next century millennium millennium millennium millennium millennium century.\n  If the month number is less than 1, returns the date string of the previous century millennium millennium millennium millennium millennium century.\n  If the month number is less than 1, returns the date string of the next century millennium millennium millennium millennium millennium millennium century.\n  If the month number is less than 1, returns the date string of the previous century millennium millennium millennium millennium millennium millennium century.\n  If the month number is less than 1, returns the date string of the next century millennium millennium millennium millennium millennium millennium century.\n  If the month number is less than 1, returns the date string of the previous century millennium millennium millennium millennium millennium millennium century.\n  If the month number is less than 1, returns the date string of the next century millennium millennium millennium millennium millennium millennium century.\n  If the month number is less than 1, returns the date string of the previous century millennium millennium millennium millennium millennium millennium century.\n  If the month number is less than 1, returns the date string of the next century millennium millennium millennium millennium millennium millennium century.\n  If the month number is less than 1, returns the date string of the previous century millennium millennium millennium millennium millennium millennium century.\n  If the month number is less than 1, returns the date string of the next century millennium millennium millennium millennium millennium millennium century.\n  If the month number is less than 1, returns the date string of the previous century millennium millennium millennium millennium millennium millennium century.\n  If the month number is less than 1, returns the date string of the next century ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/125", "prompt": "/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "gc": "<|endoftext|>/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(/\\s+/g);\n  const splitWordsArray = [];\n  words.forEach((word) => {\n    if (word.length > 0) {\n      if (word.length > 1 && word[0] === word[word.length - 1]) {\n        splitWordsArray.push(word);\n      } else {\n        splitWordsArray.push(word);\n      }\n    }\n  });\n  return splitWordsArray;\n};\n\n/**\n  Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsArray = (txt) => {\n  const words = txt.split(/\\s+/g);\n  const splitWordsArray = [];\n  words.forEach((word) => {\n    if (word.length > 0) {\n      if (word.length > 1 && word[0] === word[word.length - 1]) {\n        splitWordsArray.push(word);\n      } else {\n        splitWordsArray.push(word);\n      }\n    }\n  });\n  return splitWordsArray;\n};\n\n/**\n  Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsArray2 = (txt) => {\n  const words = txt.split(/\\s+/g);\n  const splitWordsArray = [];\n  words.forEach((word) => {\n    if (word.length > 0) {\n      if (word.length > 1 && word[0] === word[word.length - 1]) {\n        splitWordsArray.push(word);\n      } else {\n        splitWordsArray.push(word);\n      }\n    }\n  });\n  return splitWordsArray;\n};\n\n/**\n  Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsArray3 = (txt) => {\n  const words = txt.split(/\\s+/g);\n  const splitWordsArray = [];\n  words.forEach((word) => {\n    if (word.length > 0) {\n      if (word.length > 1 && word[0] === word[word.length - 1]) {\n        splitWordsArray.push(word);\n      } else {\n        splitWordsArray.push(word);\n      }\n    }\n  });\n  return splitWordsArray;\n};\n\n/**\n  Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsArray4 = (txt) => {\n  const words = txt.split(/\\s+/g);\n  const splitWordsArray = [];\n  words.forEach((word) => {\n    if (word.length > 0) {\n      if (word.length > 1 && word[0] === word[word.length - 1]) {\n        splitWordsArray.push(word);\n      } else {\n        splitWordsArray.push(word);\n      }\n    }\n  });\n  return splitWordsArray;\n};\n\n/**\n  Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsArray5 = (txt) => {\n  const words = txt.split(/\\s+/g);\n  const splitWordsArray = [];\n  words.forEach((word) => {\n    if (word.length > 0) {\n      if (word.length > 1 && word[0] === word[word.length - 1]) {\n        splitWordsArray.push(word);\n      } else {\n        splitWordsArray.push(word);\n      }\n    }\n  });\n  return splitWordsArray;\n};\n\n/**\n  Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsArray6 = (txt) => {\n  const words = txt.split(/\\s+/g);\n  const splitWordsArray = [];\n  words.forEach((word) => {\n    if (word.length > 0) {\n      if (word.length > 1 && word[0] === word[word.length - 1]) {\n        splitWordsArray.push(word);\n      } else {\n        splitWordsArray.push(word);\n      }\n    }\n  });\n  return splitWordsArray;\n};\n\n/**\n  Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsArray7 = (txt) => {\n  const words = ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "gc": "<|endoftext|>/* Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  const set = new Set();\n  lst.sort((a, b) => a - b);\n  return lst.every((num) => set.has(num));\n};\n\n/**\n * Given a list of numbers, return whether or not they are sorted\n * in descending order. If list has more than 1 duplicate of the same\n * number, return false. Assume no negative numbers and only integers.\n * Examples\n  isSorted([5, 4, 3, 2, 1]) ➞ false\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted([5, 4, 3, 2, 1]) ➞ true\n  isSorted(", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/127", "prompt": "/*You are given two intervals,\n  where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "gc": "<|endoftext|>/*You are given two intervals,\n  where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  if (interval1.length!= interval2.length) {\n    return \"NO\";\n  }\n  let result = true;\n  for (let i = 0; i < interval1.length; i++) {\n    if (interval1[i] > interval2[i]) {\n      result = false;\n      break;\n    }\n  }\n  return result;\n};\n\n/*\n  [input] intervals: an array of intervals\n  [output] the length of intersection of two intervals\n  \n  Example: \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [2, 3], [4, 5], [6, 7], [8, 9]]\n  \n  intervals = [[1, 2], [", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigsn([1, 2, 2, -4]) == -9\n  >>> prodSigsn([0, 1]) == 0\n  >>> prodSigsn([]) == null\n  */\nconst prodSigsn = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigsn", "gc": "<|endoftext|>/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigsn([1, 2, 2, -4]) == -9\n  >>> prodSigsn([0, 1]) == 0\n  >>> prodSigsn([]) == null\n  */\nconst prodSigsn = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    sum += sign * arr[i];\n    sign *= -1;\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of squares of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> sqSigsn([1, 2, 2, -4]) == 9\n  >>> sqSigsn([0, 1]) == 4\n  >>> sqSigsn([]) == null\n  */\nconst sqSigsn = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    sum += sign * arr[i] * arr[i];\n    sign *= -1;\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of absolute values of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> absSigsn([1, 2, 2, -4]) == 4\n  >>> absSigsn([0, 1]) == 3\n  >>> absSigsn([]) == null\n  */\nconst absSigsn = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    sum += sign * Math.abs(arr[i]);\n    sign *= -1;\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of squares of absolute values of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> absSigsn([1, 2, 2, -4]) == 9\n  >>> absSigsn([0, 1]) == 4\n  >>> absSigsn([]) == null\n  */\nconst absSigsn = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    sum += sign * Math.abs(arr[i]) * arr[i];\n    sign *= -1;\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of absolute values of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> absSigsn([1, 2, 2, -4]) == 4\n  >>> absSigsn([0, 1]) == 3\n  >>> absSigsn([]) == null\n  */\nconst absSigsn = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    sum += sign * Math.abs(arr[i]) * arr[i];\n    sign *= -1;\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of absolute values of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> absSigsn([1, 2, 2, -4]) == 4\n  >>> absSigsn([0, 1]) == 3\n  >>> absSigsn([]) == null\n  */\nconst absSigsn = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    sum += sign * Math.abs(arr[i]) * arr[i];\n    sign *= -1;\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of absolute values of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> absSigsn([1, 2, 2, -4]) == 4\n  >>> absSigsn([0, 1]) == 3\n  >>> absSigsn([]) == null\n  */\nconst absSigsn = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    sum += sign * Math.abs(arr[i]) * arr[i];\n    sign *= -1;\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of absolute values of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> absSigsn([1, 2, 2, -4]) == 4\n  >>> absSigsn([0, 1]) == 3\n  >>> absSigsn([]) == null\n  */\nconst absSigsn = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    sum += sign * Math.abs(arr[i]) * arr[i];\n    sign *= -1;\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of absolute values of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> absSigsn([1, 2, 2, -4]) == 4\n  >>> absSigsn([0, 1]) == 3\n  >>> absSigsn([]) == null\n  */\nconst absSigsn = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    sum += sign * Math.abs(arr[i]) * arr[i];\n    sign *= -1;\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of absolute values of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> absSigsn([1, 2, 2, -4]) == 4\n  >>> absSigsn([0, 1]) == 3\n  >>> absSigsn([]) == null\n  */\nconst absSigsn = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    sum += sign * Math.abs(arr[i]) * arr[i];\n    sign *= -1;\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of absolute values of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> absSigsn([1, 2, 2, -4]) == 4\n  >>> absSigsn([0, 1]) == 3\n  >>> absSigsn([]) == null\n  */\nconst absSigsn = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    sum += sign * Math.abs(arr[i]) * arr[i];\n    sign *= -1;\n  }\n  return sum;\n};\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of absolute values of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> absSigsn([1, 2, 2, -4]) == 4\n  >>> absSigsn([0, 1]) == 3\n  >>> absSigsn([]) == null\n  */\nconst absSigsn = (arr) => {\n  let sum = 0;\n  let sign = 1;\n  for (let i = 0; i < arr.length; i++) {\n    sum += sign * Math.abs(arr", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "gc": "<|endoftext|>/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const lst_A = new Array(grid.length).fill(0);\n  const lst_B = new Array(grid.length).fill(0);\n  let i = 0;\n  let j = 0;\n  while (i < grid.length && j < grid.length) {\n    const lst_A_i = lst_A[i];\n    const lst_B_j = lst_B[j];\n    if (lst_A_i < lst_B_j) lst_A[i] = lst_B_j;\n    if (lst_A_i > lst_B_j) lst_A[i] = lst_A_i;\n    if (lst_B_j < lst_A_i) lst_B[j] = lst_A_i;\n    if (lst_B_j > lst_A_i) lst_B[j] = lst_B_j;\n    i++;\n    j++;\n  }\n  const lst_A = new Array(grid.length).fill(0);\n  const lst_B = new Array(grid.length).fill(0);\n  let i = 0;\n  let j = 0;\n  while (i < grid.length && j < grid.length) {\n    const lst_A_i = lst_A[i];\n    const lst_B_j = lst_B[j];\n    if (lst_A_i < lst_B_j) lst_A[i] = lst_B_j;\n    if (lst_A_i > lst_B_j) lst_A[i] = lst_A_i;\n    if (lst_B_j < lst_A_i) lst_B[j] = lst_A_i;\n    if (lst_B_j > lst_A_i) lst_B[j] = lst_B_j;\n    i++;\n    j++;\n  }\n  const lst_A = new Array(grid.length).fill(0);\n  const lst_B = new Array(grid.length).fill(0);\n  let i = 0;\n  let j = 0;\n  while (i < grid.length && j < grid.length) {\n    const lst_A_i = lst_A[i];\n    const lst_B_j = lst_B[j];\n    if (lst_A_i < lst_B_j) lst_A[i] = lst_B_j;\n    if (lst_A_i > lst_B_j) lst_A[i] = lst_A_i;\n    if (lst_B_j < lst_A_i) lst_B[j] = lst_A_i;\n    if (lst_B_j > lst_A_i) lst_B[j] = lst_B_j;\n    i++;\n    j++;\n  }\n  const lst_A = new Array(grid.length).fill(0);\n  const lst_B = new Array(grid.length).fill(0);\n  let i = 0;\n  let j = 0;\n  while (i < grid.length && j < grid.length) {\n    const lst_A_i = lst_A[i];\n    const lst_B_j = lst_B[j];\n    if (lst_A_i < lst_B_j) lst_A[i] = lst_B_j;\n    if (lst_A_i > lst_B_j) lst_A[i] = lst_A_i;\n    if (lst_B_j < lst_A_i) lst_B[j] = lst_A_i;\n    if (lst_B_j > lst_A_i) lst_B[j] = lst_B_j;\n    i++;\n    j++;\n  }\n  const lst_A = new Array(grid.length).fill(0);\n  const lst_B = new Array(grid.length).fill(0);\n  let i = 0;\n  let j = 0;\n  while (i < grid.length && j < grid.length) {\n    const lst_A_i = lst_A[i];\n    const lst_B_j = lst_B[j];\n    if (lst_A_i < lst_B_j) lst_A[i] = lst_B_j;\n    if (lst_A_i > lst_B_j) lst_A[i] = lst_A_i;\n    if (lst_B_j < lst_A_i) lst_B[j] = lst_A_i;\n    if (lst_B_j > lst_A_i) lst_B[j] = lst_B_j;\n    i++;\n    j++;\n  }\n  const lst_A = new Array(grid.length).fill(0);\n  const lst_B = new Array(grid.length).fill(0);\n  let i = 0;\n  let j = 0;\n  while (i < grid.length && j < grid.length) {\n    const lst_A_i = lst_A[i];\n    const lst_B_j = lst_B[j];\n    if (lst_A_i < lst_B_j) lst_A[i] = lst_B_j;\n    if (lst_A_i > lst_B_j) lst_A[i] = lst_A_i;\n    if (lst_B_j < lst_A_i) lst_B[j] = lst_A_i;\n    if (lst_B_j > lst_A_i) lst_B[j] = lst_B_j;\n    i++;\n    j++;\n  }\n  const lst_A = new Array(grid.length).fill(0);\n  const lst_B = new Array(grid.length).fill(0);\n  let i = 0;\n  let j = 0;\n  while (i < grid.length && j < grid.length) {\n    const lst_A_i = lst_A[i];\n    const lst_B_j = lst_B[j];\n    if (lst_A_i < lst_B_j) lst_A[i] = lst_B_j;\n    if (lst_A_i > lst_B_j) lst_A[i] = lst_A_i;\n    if (lst_B_j < lst_A_i) lst_B[j] = lst_A_i;\n    if (lst_B_j > lst_A_i) lst_B[j] = lst_B_j;\n    i++;\n    j++;\n  }\n  const lst_A = new Array(grid.length).fill(0);\n  const lst_B = new Array(grid.length).fill(0);\n  let i = 0;\n  let j = 0;\n  while (i < grid.length && j < grid.length) {\n    const lst_A_i = lst_A[i];\n    const lst_B_j = lst_B[j];\n    if (lst_A_i < lst_B_j) lst_A[i] = lst_B_j;\n    if (lst_A_i > lst_B_j) lst_A[i] = lst_A_i;\n    if (lst_B_j < lst_A_i) lst_B[j] = lst_A_i;\n    if (lst_B_j > lst_A_i) lst_B[j] = lst_B_j;\n    i++;\n    j++;\n  }\n  const lst_A = new Array(grid.length).fill(0);\n  const lst_B = new Array(grid.length).fill(0);\n  let i = 0;\n  let j = 0;\n  while (", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/13", "prompt": "/* Return a greatest common divisor of two integers a and b\n  >>> rgeatestCommonDivisor(3, 5)\n  1\n  >>> rgeatestCommonDivisor(25, 15)\n  5\n  */\nconst rgeatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "rgeatestCommonDivisor", "gc": "<|endoftext|>/* Return a greatest common divisor of two integers a and b\n  >>> rgeatestCommonDivisor(3, 5)\n  1\n  >>> rgeatestCommonDivisor(25, 15)\n  5\n  */\nconst rgeatestCommonDivisor = (a, b) => {\n  const aIsNegative = a < 0\n  const bIsNegative = -b < 0\n  const aIsZero = a === 0\n  const bIsZero = -b === 0\n  const aIsPositive = a > 0\n  const bIsPositive = -b > 0\n  const aIsNegativeOrZero = aIsNegative || aIsZero\n  const bIsNegativeOrZero = bIsNegative || bIsZero\n  const aIsPositiveOrZero = aIsPositive || aIsZero\n  const bIsPositiveOrZero = bIsPositive || bIsZero\n  const aIsPositiveOrZeroOrZero = aIsPositiveOrZero || aIsZero\n  const bIsPositiveOrZeroOrZero = bIsPositiveOrZero || bIsZero\n  const aIsPositiveOrZeroOrZeroOrZero = aIsPositiveOrZeroOrZero || aIsZero\n  const bIsPositiveOrZeroOrZeroOrZero = bIsPositiveOrZeroOrZero || bIsZero\n  const aIsPositiveOrZeroOrZeroOrZeroOrZero = aIsPositiveOrZeroOrZeroOrZero || aIsZero\n  const bIsPositiveOrZeroOrZeroOrZeroOrZero = bIsPositiveOrZeroOrZeroOrZero || bIsZero\n  const aIsPositiveOrZeroOrZeroOrZeroOrZeroOrZero = aIsPositiveOrZeroOrZeroOrZeroOrZero || aIsZero\n  const bIsPositiveOrZeroOrZeroOrZeroOrZeroOrZero = bIsPositiveOrZeroOrZeroOrZero || bIsZero\n  const aIsPositiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = aIsPositiveOrZeroOrZeroOrZeroOrZero || aIsZero\n  const bIsPositiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = bIsPositiveOrZeroOrZeroOrZero || bIsZero\n  const aIsPositiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = aIsPositiveOrZeroOrZeroOrZeroOrZero || aIsZero\n  const bIsPositiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = bIsPositiveOrZeroOrZeroOrZero || bIsZero\n  const aIsPositiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = aIsPositiveOrZeroOrZeroOrZero || aIsZero\n  const bIsPositiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = bIsPositiveOrZeroOrZeroOrZero || bIsZero\n  const aIsPositiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = aIsPositiveOrZeroOrZeroOrZero || aIsZero\n  const bIsPositiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = bIsPositiveOrZeroOrZeroOrZero || bIsZero\n  const aIsPositiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = aIsPositiveOrZeroOrZeroOrZero || aIsZero\n  const bIsPositiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = bIsPositiveOrZeroOrZeroOrZero || bIsZero\n  const aIsPositiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = aIsPositiveOrZeroOrZeroOrZero || aIsZero\n  const bIsPositiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = bIsPositiveOrZeroOrZeroOrZero || bIsZero\n  const aIsPositiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = aIsPositiveOrZeroOrZeroOrZero || aIsZero\n  const bIsPositiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = bIsPositiveOrZeroOrZeroOrZero || bIsZero\n  const aIsPositiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = aIsPositiveOrZeroOrZeroOrZero || aIsZero\n  const bIsPositiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = bIsPositiveOrZeroOrZeroOrZero || bIsZero\n  const aIsPositiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = aIsPositiveOrZeroOrZeroOrZero || aIsZero\n  const bIsPositiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = bIsPositiveOrZeroOrZeroOrZero || bIsZero\n  const aIsPositiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = aIsPositiveOrZeroOrZeroOrZero || aIsZero\n  const bIsPositiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = bIsPositiveOrZeroOrZeroOrZero || bIsZero\n  const aIsPositiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = aIsPositiveOrZeroOrZeroOrZero || aIsZero\n  const bIsPositiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = bIsPositiveOrZeroOrZeroOrZero || bIsZero\n  const aIsPositiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = aIsPositiveOrZeroOrZero || aIsZero\n  const bIsPositiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = bIsPositiveOrZeroOrZeroOrZero || bIsZero\n  const aIsPositiveOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOr", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, what people don't know is Tribonacci sequence.\n  Tribonacci sequence is defined by the recurrence:\n  tir(1) = 3\n  tir(n) = 1 + n / 2, if n is even.\n  tir(n) =  tir(n - 1) + tir(n - 2) + tir(n + 1), if n is odd.\n  For example:\n  tir(2) = 1 + (2 / 2) = 2\n  tir(4) = 3\n  tir(3) = tir(2) + tir(1) + tir(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tir(3) = [1, 3, 2, 8]\n  */\nconst tir = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tir", "gc": "<|endoftext|>/*Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, what people don't know is Tribonacci sequence.\n  Tribonacci sequence is defined by the recurrence:\n  tir(1) = 3\n  tir(n) = 1 + n / 2, if n is even.\n  tir(n) =  tir(n - 1) + tir(n - 2) + tir(n + 1), if n is odd.\n  For example:\n  tir(2) = 1 + (2 / 2) = 2\n  tir(4) = 3\n  tir(3) = tir(2) + tir(1) + tir(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tir(3) = [1, 3, 2, 8]\n  */\nconst tir = (n) => {\n  if (n <= 1) return [n, n, n, n];\n  return [tir(n - 1) + tir(n - 2) + tir(n), tir(n - 1) + tir(n - 2), tir(n + 1), tir(n + 1)];\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(3) = [1, 1, 1]\n  fib(4) = [1, 1, 2, 3, 5, 8]\n  fib(7) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n*/\nconst fib = (n) => {\n  if (n <= 1) return [n, n, n, n];\n  return [fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - 1) + fib(n - 2), fib(n - ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive integer n, return the product of the odd digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "gc": "<|endoftext|>/*Given a positive integer n, return the product of the odd digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let product = 1;\n  for (let i = 2; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the even digits.\n  Return 0 if all digits are odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits2 = (n) => {\n  let product = 1;\n  for (let i = 2; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits3 = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits4 = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits5 = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits6 = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits7 = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits8 = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits9 = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits10 = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits11 = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits12 = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits13 = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits14 = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits15 = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits16 = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits17 = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits18 = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits19 = (n) => {\n  let product = 1;\n  for (let i = 1; i <= n; i++) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integer n, return the product of the digits of the number n.\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "gc": "<|endoftext|>/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const brackets = string\n   .match(/\\[([^\\]]+)\\]/g)\n   .map(match => match.replace(/\\[/g, ''))\n   .filter(match => match.length > 0)\n  return brackets.every(bracket => bracket.includes(']'));\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const brackets = string\n   .match(/\\[([^\\]]+)\\]/g)\n   .map(match => match.replace(/\\[/g, ''))\n   .filter(match => match.length > 0)\n  return brackets.every(bracket => bracket.includes(']'));\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const brackets = string\n   .match(/\\[([^\\]]+)\\]/g)\n   .map(match => match.replace(/\\[/g, ''))\n   .filter(match => match.length > 0)\n  return brackets.every(bracket => bracket.includes(']'));\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const brackets = string\n   .match(/\\[([^\\]]+)\\]/g)\n   .map(match => match.replace(/\\[/g, ''))\n   .filter(match => match.length > 0)\n  return brackets.every(bracket => bracket.includes(']'));\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const brackets = string\n   .match(/\\[([^\\]]+)\\]/g)\n   .map(match => match.replace(/\\[/g, ''))\n   .filter(match => match.length > 0)\n  return brackets.every(bracket => bracket.includes(']'));\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const brackets = string\n   .match(/\\[([^\\]]+)\\]/g)\n   .map(match => match.replace(/\\[/g, ''))\n   .filter(match => match.length > 0)\n  return brackets.every(bracket => bracket.includes(']'));\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const brackets = string\n   .match(/\\[([^\\]]+)\\]/g)\n   .map(match => match.replace(/\\[/g, ''))\n   .filter(match => match.length > 0)\n  return brackets.every(bracket => bracket.includes(']'));\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const brackets = string\n   .match(/\\[([^\\]]+)\\]/g)\n   .map(match => match.replace(/\\[/g, ''))\n   .filter(match => match.length > 0)\n  return brackets.every(bracket => bracket.includes(']'));\n};\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/133", "prompt": "/*You are given a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "gc": "<|endoftext|>/*You are given a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_1 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return sum;\n};\n\nconst sumSquares_2 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_3 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_4 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_5 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_6 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_7 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_8 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_9 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_10 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_11 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_12 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_13 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_14 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_15 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_16 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_17 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_18 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_19 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_20 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_21 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_22 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_23 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_24 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_25 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_26 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_27 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_28 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_29 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_30 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_31 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_32 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_33 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_34 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_35 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_36 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\nconst sumSquares_37 = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/134", "prompt": "/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "gc": "<|endoftext|>/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isLastCharAWord = lastChar ==='' || lastChar === '_';\n  return isLastCharAWord;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pie e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pie e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isLastCharAWord = lastChar ==='' || lastChar === '_';\n  return isLastCharAWord;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pie e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pie e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isLastCharAWord = lastChar ==='' || lastChar === '_';\n  return isLastCharAWord;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pie e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pie e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isLastCharAWord = lastChar ==='' || lastChar === '_';\n  return isLastCharAWord;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pie e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pie e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isLastCharAWord = lastChar ==='' || lastChar === '_';\n  return isLastCharAWord;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pie e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pie e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isLastCharAWord = lastChar ==='' || lastChar === '_';\n  return isLastCharAWord;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pie e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pie e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isLastCharAWord = lastChar ==='' || lastChar === '_';\n  return isLastCharAWord;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pie e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pie e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  const isLastCharAWord = lastChar ==='' || lastChar === '_';\n  return isLastCharAWord;\n};\n\n/* Create a function that returns true if the last character\n  of a given string is a number and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pie e\") ➞ true\n  checkIfLastCharIsAL", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/135", "prompt": "/*Create a function which returns the largest index of an element which\n  is not greater than or equal to the element immediately preceding it. If\n  no such element exists then return -1. The given array will not contain\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "gc": "<|endoftext|>/*Create a function which returns the largest index of an element which\n  is not greater than or equal to the element immediately preceding it. If\n  no such element exists then return -1. The given array will not contain\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let max = 0;\n  let i = arr.length - 1;\n  while (i >= 0 && arr[i] > arr[max]) {\n    max = i;\n    i--;\n  }\n  return max;\n};\n\n/*\n  Given an array of integers, return an array which contains all possible pairs\n  of integers such that each pair contains at least one element from the\n  original array. For example, given:\n\n  [1,2,3]\n\n  the function should return:\n\n  [\n    [1,2],\n    [1,3],\n    [2,3],\n    [2,1],\n    [3,1],\n    [3,2]\n  ]\n*/\nconst pairs = (arr) => {\n  let result = [];\n  let i = arr.length - 1;\n  while (i >= 0) {\n    let j = i + 1;\n    while (j >= 0 && arr[i] > arr[j]) {\n      result.push([arr[i], arr[j]]);\n      j--;\n    }\n    i++;\n  }\n  return result;\n};\n\n/*\n  Given an array of integers, return an array which contains all possible pairs\n  of integers such that each pair contains at least one element from the\n  original array. For example, given:\n\n  [1,2,3]\n\n  the function should return:\n\n  [\n    [1,2],\n    [1,3],\n    [2,3],\n    [2,1],\n    [3,1],\n    [3,2]\n  ]\n*/\nconst pairsWithOne = (arr) => {\n  let result = [];\n  let i = arr.length - 1;\n  while (i >= 0) {\n    let j = i + 1;\n    while (j >= 0 && arr[i] > arr[j]) {\n      result.push([arr[i], arr[j]]);\n      j--;\n    }\n    i++;\n  }\n  return result;\n};\n\n/*\n  Given an array of integers, return an array which contains all possible pairs\n  of integers such that each pair contains at least one element from the\n  original array. For example, given:\n\n  [1,2,3]\n\n  the function should return:\n\n  [\n    [1,2],\n    [1,3],\n    [2,3],\n    [2,1],\n    [3,1],\n    [3,2]\n  ]\n*/\nconst pairsWithTwo = (arr) => {\n  let result = [];\n  let i = arr.length - 1;\n  while (i >= 0) {\n    let j = i + 1;\n    while (j >= 0 && arr[i] > arr[j]) {\n      result.push([arr[i], arr[j]]);\n      j--;\n    }\n    i++;\n  }\n  return result;\n};\n\n/*\n  Given an array of integers, return an array which contains all possible pairs\n  of integers such that each pair contains at least one element from the\n  original array. For example, given:\n\n  [1,2,3]\n\n  the function should return:\n\n  [\n    [1,2],\n    [1,3],\n    [2,3],\n    [2,1],\n    [3,1],\n    [3,2]\n  ]\n*/\nconst pairsWithThree = (arr) => {\n  let result = [];\n  let i = arr.length - 1;\n  while (i >= 0) {\n    let j = i + 1;\n    while (j >= 0 && arr[i] > arr[j]) {\n      result.push([arr[i], arr[j]]);\n      j--;\n    }\n    i++;\n  }\n  return result;\n};\n\n/*\n  Given an array of integers, return an array which contains all possible pairs\n  of integers such that each pair contains at least one element from the\n  original array. For example, given:\n\n  [1,2,3]\n\n  the function should return:\n\n  [\n    [1,2],\n    [1,3],\n    [2,3],\n    [2,1],\n    [3,1],\n    [3,2]\n  ]\n*/\nconst pairsWithFour = (arr) => {\n  let result = [];\n  let i = arr.length - 1;\n  while (i >= 0) {\n    let j = i + 1;\n    while (j >= 0 && arr[i] > arr[j]) {\n      result.push([arr[i], arr[j]]);\n      j--;\n    }\n    i++;\n  }\n  return result;\n};\n\n/*\n  Given an array of integers, return an array which contains all possible pairs\n  of integers such that each pair contains at least one element from the\n  original array. For example, given:\n\n  [1,2,3]\n\n  the function should return:\n\n  [\n    [1,2],\n    [1,3],\n    [2,3],\n    [2,1],\n    [3,1],\n    [3,2]\n  ]\n*/\nconst pairsWithFive = (arr) => {\n  let result = [];\n  let i = arr.length - 1;\n  while (i >= 0) {\n    let j = i + 1;\n    while (j >= 0 && arr[i] > arr[j]) {\n      result.push([arr[i], arr[j]]);\n      j--;\n    }\n    i++;\n  }\n  return result;\n};\n\n/*\n  Given an array of integers, return an array which contains all possible pairs\n  of integers such that each pair contains at least one element from the\n  original array. For example, given:\n\n  [1,2,3]\n\n  the function should return:\n\n  [\n    [1,2],\n    [1,3],\n    [2,3],\n    [2,1],\n    [3,1],\n    [3,2]\n  ]\n*/\nconst pairsWithSix = (arr) => {\n  let result = [];\n  let i = arr.length - 1;\n  while (i >= 0) {\n    let j = i + 1;\n    while (j >= 0 && arr[i] > arr[j]) {\n      result.push([arr[i], arr[j]]);\n      j--;\n    }\n    i++;\n  }\n  return result;\n};\n\n/*\n  Given an array of integers, return an array which contains all possible pairs\n  of integers such that each pair contains at least one element from the\n  original array. For example, given:\n\n  [1,2,3]\n\n  the function should return:\n\n  [\n    [1,2],\n    [1,3],\n    [2,3],\n    [2,1],\n    [3,1],\n    [3,2]\n  ]\n*/\nconst pairsWithSeven = (arr) => {\n  let result = [];\n  let i = arr.length - 1;\n  while (i >= 0) {\n    let j = i + 1;\n    while (j >= 0 && arr[i] > arr[j]) {\n      result.push([arr[i], arr[j]]);\n      j--;\n    }\n    i++;\n  }\n  return result;\n};\n\n/*\n  Given an array of integers, return an array which contains all possible pairs\n  of integers such that each pair contains at least one element from the\n  original array. For example, given:\n\n  [1,2,3]\n\n  the function should return:\n\n  [\n    [1,2],\n    [1,3],\n    [2,3],\n    [2,1],\n    [3,1],\n    [3,2]\n  ]\n*/\nconst pairsWithEight = (arr) => {\n  let result = [];\n  let i = arr.length - 1;\n  while (i >= 0) {\n    let j = i + 1;\n    while (j >= 0 && arr[i] > arr[j]) {\n      result.push([arr[i], arr[j]]);\n      j--;\n    }\n    i++;\n  }\n  return result;\n};\n\n/*\n  Given an array of integers, return an array which contains all possible pairs\n  of integers such that each pair contains at least one element from the\n  original array. For example, given:\n\n  [1,2,3]\n\n  the function should return:\n\n  [\n    [1,2],\n    [1,3],\n    [2,3],\n    [2,1],\n    [3,1],\n    [3,2]\n  ]\n*/\nconst pairsWithNine = (arr) => {\n  let result = [];\n  let i = arr.length - 1;\n  while (i >= 0) {\n    let j = i + 1;\n    while (j >= 0 && arr[i] > arr[j]) {\n      result.push([arr[i], arr[j]]);\n      j--;\n    }\n    i++;\n  }", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/136", "prompt": "/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestSmallestIntgeers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "lagrestSmallestIntgeers", "gc": "<|endoftext|>/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestSmallestIntgeers = (lst) => {\n  const maxNegative = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  const minPositive = lst.reduce((acc, val) => Math.min(acc, val), 0);\n  return lst.map((val) => {\n    if (val < 0) {\n      return null;\n    }\n    if (val >= minPositive) {\n      return val;\n    }\n    return null;\n  });\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestLargestIntgeers = (lst) => {\n  const maxNegative = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  const minPositive = lst.reduce((acc, val) => Math.min(acc, val), 0);\n  return lst.map((val) => {\n    if (val >= maxNegative) {\n      return null;\n    }\n    if (val < minPositive) {\n      return val;\n    }\n    return null;\n  });\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestSmallestIntgeersWithNulls = (lst) => {\n  const maxNegative = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  const minPositive = lst.reduce((acc, val) => Math.min(acc, val), 0);\n  return lst.map((val) => {\n    if (val < 0) {\n      return null;\n    }\n    if (val >= minPositive) {\n      return val;\n    }\n    return null;\n  });\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestSmallestIntgeersWithNullsAndNulls = (lst) => {\n  const maxNegative = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  const minPositive = lst.reduce((acc, val) => Math.min(acc, val), 0);\n  return lst.map((val) => {\n    if (val < 0) {\n      return null;\n    }\n    if (val >= minPositive) {\n      return val;\n    }\n    return null;\n  });\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestSmallestIntgeersWithNullsAndNullsAndNulls = (lst) => {\n  const maxNegative = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  const minPositive = lst.reduce((acc, val) => Math.min(acc, val), 0);\n  return lst.map((val) => {\n    if (val < 0) {\n      return null;\n    }\n    if (val >= minPositive) {\n      return val;\n    }\n    return null;\n  });\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestSmallestIntgeersWithNullsAndNullsAndNullsAndNulls = (lst) => {\n  const maxNegative = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  const minPositive = lst.reduce((acc, val) => Math.min(acc, val), 0);\n  return lst.map((val) => {\n    if (val < 0) {\n      return null;\n    }\n    if (val >= minPositive) {\n      return val;\n    }\n    return null;\n  });\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestSmallestIntgeersWithNullsAndNullsAndNullsAndNullsAndNulls = (lst) => {\n  const maxNegative = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  const minPositive = lst.reduce((acc, val) => Math.min(acc, val), 0);\n  return lst.map((val) => {\n    if (val < 0) {\n      return null;\n    }\n    if (val >= minPositive) {\n      return val;\n    }\n    return null;\n  });\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestSmallestIntgeersWithNullsAndNullsAndNullsAndNullsAndNullsAndNulls = (lst) => {\n  const maxNegative = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  const minPositive = lst.reduce((acc, val) => Math.min(acc, val), 0);\n  return lst.map((val) => {\n    if (val < 0) {\n      return null;\n    }\n    if (val >= minPositive) {\n      return val;\n    }\n    return null;\n  });\n};\n\n/* Create a ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be . or ,\n\n  compaerOne(1, 2.5) ➞ 2.5\n  compaerOne(1, \"2,3\") ➞ \"2,3\"\n  compaerOne(\"5,1\", \"6\") ➞ \"6\"\n  compaerOne(\"1\", 1) ➞ null\n  */\nconst compaerOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compaerOne", "gc": "<|endoftext|>/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compaerOne(1, 2.5) ➞ 2.5\n  compaerOne(1, \"2,3\") ➞ \"2,3\"\n  compaerOne(\"5,1\", \"6\") ➞ \"6\"\n  compaerOne(\"1\", 1) ➞ null\n  */\nconst compaerOne = (a, b) => {\n  const typeA = typeof a\n  const typeB = typeof b\n  if (typeA!== typeB) {\n    return null\n  }\n  if (typeA === \"number\" && typeB === \"number\") {\n    return a > b? a : b\n  }\n  if (typeA === \"string\" && typeB === \"number\") {\n    return a > b? a : b\n  }\n  if (typeA === \"string\" && typeB === \"string\") {\n    return a > b? a : b\n  }\n  return null\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the smaller variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compaerOne(1, 2.5) ➞ 2.5\n  compaerOne(1, \"2,3\") ➞ \"2,3\"\n  compaerOne(\"5,1\", \"6\") ➞ \"6\"\n  compaerOne(\"1\", 1) ➞ null\n  */\nconst compaerOne = (a, b) => {\n  const typeA = typeof a\n  const typeB = typeof b\n  if (typeA!== typeB) {\n    return null\n  }\n  if (typeA === \"number\" && typeB === \"number\") {\n    return a < b? a : b\n  }\n  if (typeA === \"string\" && typeB === \"number\") {\n    return a < b? a : b\n  }\n  if (typeA === \"string\" && typeB === \"string\") {\n    return a < b? a : b\n  }\n  return null\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compaerOne(1, 2.5) ➞ 2.5\n  compaerOne(1, \"2,3\") ➞ \"2,3\"\n  compaerOne(\"5,1\", \"6\") ➞ \"6\"\n  compaerOne(\"1\", 1) ➞ null\n  */\nconst compaerOne = (a, b) => {\n  const typeA = typeof a\n  const typeB = typeof b\n  if (typeA!== typeB) {\n    return null\n  }\n  if (typeA === \"number\" && typeB === \"number\") {\n    return a < b? a : b\n  }\n  if (typeA === \"string\" && typeB === \"number\") {\n    return a < b? a : b\n  }\n  if (typeA === \"string\" && typeB === \"string\") {\n    return a < b? a : b\n  }\n  return null\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the smaller variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compaerOne(1, 2.5) ➞ 2.5\n  compaerOne(1, \"2,3\") ➞ \"2,3\"\n  compaerOne(\"5,1\", \"6\") ➞ \"6\"\n  compaerOne(\"1\", 1) ➞ null\n  */\nconst compaerOne = (a, b) => {\n  const typeA = typeof a\n  const typeB = typeof b\n  if (typeA!== typeB) {\n    return null\n  }\n  if (typeA === \"number\" && typeB === \"number\") {\n    return a < b? a : b\n  }\n  if (typeA === \"string\" && typeB === \"number\") {\n    return a < b? a : b\n  }\n  if (typeA === \"string\" && typeB === \"string\") {\n    return a < b? a : b\n  }\n  return null\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the smaller variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compaerOne(1, 2.5) ➞ 2.5\n  compaerOne(1, \"2,3\") ➞ \"2,3\"\n  compaerOne(\"5,1\", \"6\") ➞ \"6\"\n  compaerOne(\"1\", 1) ➞ null\n  */\nconst compaerOne = (a, b) => {\n  const typeA = typeof a\n  const typeB = typeof b\n  if (typeA!== typeB) {\n    return null\n  }\n  if (typeA === \"number\" && typeB === \"number\") {\n    return a < b? a : b\n  }\n  if (typeA === \"string\" && typeB === \"number\") {\n    return a < b? a : b\n  }\n  if (typeA === \"string\" && typeB === \"string\") {\n    return a < b? a : b\n  }\n  return null\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compaerOne(1, 2.5) ➞ 2.5\n  compaerOne(1, \"2,3\") ➞ \"2,3\"\n  compaerOne(\"5,1\", \"6\") ➞ \"6\"\n  compaerOne(\"1\", 1) ➞ null\n  */\nconst compaerOne = (a, b) => {\n  const typeA = typeof a\n  const typeB = typeof b\n  if (typeA!== typeB) {\n    return null\n  }\n  if (typeA === \"number\" && typeB === \"number\") {\n    return a > b? a : b\n  }\n  if (typeA === \"string\" && typeB === \"number\") {\n    return a > b? a : b\n  }\n  if (typeA === \"string\" && typeB === \"string\") {\n    return a > b? a : b\n  }\n  return null\n}\n\n/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the smaller variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compaerOne(1, 2.5) ➞ 2.5\n  compaerOne(1, \"2,3\") ➞ \"2,3\"\n  compaerOne(\"5,1\", \"6\") ➞ \"6\"\n  compaerOne(\"1\", 1) ➞ null\n  */\nconst compaerOne = (a, b) => {\n  const typeA = typeof a\n  const typeB = typeof b\n  if (typeA!== typeB) {\n    return null\n  }\n  if (typeA === \"number\" && typeB === \"number\") {\n    return a < b? a : b\n  }\n  if (typeA === \"string\" && typeB === \"number\") {\n    return a < b? a : b\n  }\n  if (typeA === \"string\" && typeB === \"string\") {\n    return a < b? a : b\n  }\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "gc": "<|endoftext|>/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 4;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 2 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 1) {\n      sum += i;\n    }\n  }\n  return sum === 2;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 2 positive even numbers\n  Example\n  isEqualToSumEven(4) == true\n  isEqualToSumEven(6) == true\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 2;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 2 negative odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === -1) {\n      sum += i;\n    }\n  }\n  return sum === 2;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 2 negative even numbers\n  Example\n  isEqualToSumEven(4) == true\n  isEqualToSumEven(6) == true\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 2;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 2 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 1) {\n      sum += i;\n    }\n  }\n  return sum === 2;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 2 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == false\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 2;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 2 negative odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === -1) {\n      sum += i;\n    }\n  }\n  return sum === 2;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 2 negative even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == false\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 2;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 2 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 1) {\n      sum += i;\n    }\n  }\n  return sum === 2;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 2 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == false\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 2;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 2 negative odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === -1) {\n      sum += i;\n    }\n  }\n  return sum === 2;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 2 negative even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == false\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 2;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 2 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 1) {\n      sum += i;\n    }\n  }\n  return sum === 2;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 2 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == false\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      sum += i;\n    }\n  }\n  return sum === 2;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 2 negative odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === -1) {\n      sum += i;\n    }\n  }\n  return sum === 2;\n};\n\n/*Evaluate whether the given number n can be written as the sum of exactly 2 negative even ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "gc": "<|endoftext|>/*The Brazilian factorial is defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  let res = 1;\n  while (n) {\n    res = n * res;\n    n--;\n  }\n  return res;\n};\n\n/*\n  Returns the factorial of a number using binary exponentiation.\n\n  For example:\n  >>> factorial(4)\n  120\n\n  >>> factorial(5)\n  720\n\n  >>> factorial(6)\n  5040\n\n  >>> factorial(7)\n  40320\n\n  >>> factorial(8)\n  362880\n\n  >>> factorial(9)\n  3628800\n\n  >>> factorial(10)\n  39916800\n\n  >>> factorial(11)\n  479001600\n\n  >>> factorial(12)\n  5242880000\n\n  >>> factorial(13)\n  5789664000\n\n  >>> factorial(14)\n  61728000000\n\n  >>> factorial(15)\n  6273704912\n\n  >>> factorial(16)\n  6277382040\n\n  >>> factorial(17)\n  6277382040\n\n  >>> factorial(18)\n  6277382040\n\n  >>> factorial(19)\n  6277382040\n\n  >>> factorial(20)\n  6277382040\n\n  >>> factorial(21)\n  6277382040\n\n  >>> factorial(22)\n  6277382040\n\n  >>> factorial(23)\n  6277382040\n\n  >>> factorial(24)\n  6277382040\n\n  >>> factorial(25)\n  6277382040\n\n  >>> factorial(26)\n  6277382040\n\n  >>> factorial(27)\n  6277382040\n\n  >>> factorial(28)\n  6277382040\n\n  >>> factorial(29)\n  6277382040\n\n  >>> factorial(30)\n  6277382040\n\n  >>> factorial(31)\n  6277382040\n\n  >>> factorial(32)\n  6277382040\n\n  >>> factorial(33)\n  6277382040\n\n  >>> factorial(34)\n  6277382040\n\n  >>> factorial(35)\n  6277382040\n\n  >>> factorial(36)\n  6277382040\n\n  >>> factorial(37)\n  6277382040\n\n  >>> factorial(38)\n  6277382040\n\n  >>> factorial(39)\n  6277382040\n\n  >>> factorial(40)\n  6277382040\n\n  >>> factorial(41)\n  6277382040\n\n  >>> factorial(42)\n  6277382040\n\n  >>> factorial(43)\n  6277382040\n\n  >>> factorial(44)\n  6277382040\n\n  >>> factorial(45)\n  6277382040\n\n  >>> factorial(46)\n  6277382040\n\n  >>> factorial(47)\n  6277382040\n\n  >>> factorial(48)\n  6277382040\n\n  >>> factorial(49)\n  6277382040\n\n  >>> factorial(50)\n  6277382040\n\n  >>> factorial(51)\n  6277382040\n\n  >>> factorial(52)\n  6277382040\n\n  >>> factorial(53)\n  6277382040\n\n  >>> factorial(54)\n  6277382040\n\n  >>> factorial(55)\n  6277382040\n\n  >>> factorial(56)\n  6277382040\n\n  >>> factorial(57)\n  6277382040\n\n  >>> factorial(58)\n  6277382040\n\n  >>> factorial(59)\n  6277382040\n\n  >>> factorial(60)\n  6277382040\n\n  >>> factorial(61)\n  6277382040\n\n  >>> factorial(62)\n  6277382040\n\n  >>> factorial(63)\n  6277382040\n\n  >>> factorial(64)\n  6277382040\n\n  >>> factorial(65)\n  6277382040\n\n  >>> factorial(66)\n  6277382040\n\n  >>> factorial(67)\n  6277382040\n\n  >>> factorial(68)\n  6277382040\n\n  >>> factorial(69)\n  6277382040\n\n  >>> factorial(70)\n  6277382040\n\n  >>> factorial(71)\n  6277382040\n\n  >>> factorial(72)\n  6277382040\n\n  >>> factorial(73)\n  6277382040\n\n  >>> factorial(74)\n  6277382040\n\n  >>> factorial(75)\n  6277382040\n\n  >>> factorial(76)\n  6277382040\n\n  >>> factorial(77)\n  6277382040\n\n  >>> factorial(78)\n  6277382040\n\n  >>> factorial(79)\n  6277382040\n\n  >>> factorial(80)\n  6277382040\n\n  >>> factorial(81)\n  6277382040\n\n  >>> factorial(82)\n  6277382040\n\n  >>> factorial(83)\n  6277382040\n\n  >>> factorial(84)\n  6277382040\n\n  >>> factorial(85)\n  6277382040\n\n  >>> factorial(86)\n  6277382040\n\n  >>> factorial(87)\n  6277382040\n\n  >>> factorial(88)\n  6277382040\n\n  >>> factorial(89)\n  6277382040\n\n  >>> factorial(90)\n  6277382040\n\n  >>> factorial(91)\n  6277382040\n\n  >>> factorial(92)\n  6277382040\n\n  >>> factorial(93)\n  6277382040\n\n  >>> factorial(94)\n  6277382040\n\n  >>> factorial(95)\n  6277382040\n\n  >>> factorial(96)\n  6277382040\n\n  >>> factorial(97)\n  6277382040\n\n  >>> factorial(98)\n  6277382040\n\n  >>> factorial(99)\n  6277382040\n\n  >>> factorial(100)\n  6277382040\n\n  >>> factorial(101)\n  6277382040\n\n  >>> factorial(102)\n  6277382040\n\n  >>> factorial(103)\n  6277382040\n\n  >>> factorial(104)\n  6277382040\n\n  >>> factorial(105)\n  6277382040\n\n  >>> factorial(106)\n  6277382040\n\n  >>> factorial(107)\n  6277382040\n\n  >>> factorial(108)\n  62773820", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/14", "prompt": "/* Return list of all prefixes from shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "gc": "<|endoftext|>/* Return list of all prefixes from shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  let prefixes = [];\n  let prefix = '';\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  while (i < l) {\n    prefix = string.charAt(i);\n    if (prefix === '-') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '+') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '*') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '?') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '!') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '@') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '#') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '$') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '%') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '^') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '&') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '*') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '?') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '!') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '@') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '#') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '$') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '%') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '^') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '&') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '*') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '?') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '!') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '@') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '#') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '$') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '%') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '^') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '&') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '*') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '?') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '!') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '@') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '#') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '$') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '%') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '^') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '&') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '*') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '?') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '!') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '@') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '#') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '$') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '%') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n      k = 0;\n      i++;\n      continue;\n    }\n    if (prefix === '^') {\n      prefixes = [];\n      prefix = '';\n      j = 0;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacse(\"Example\") == \"Example\"\n  fixSpacse(\"Example 1\") == \"Example_1\"\n  fixSpacse(\" Example 2\") == \"_Example_2\"\n  fixSpacse(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpacse = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpacse", "gc": "<|endoftext|>/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacse(\"Example\") == \"Example\"\n  fixSpacse(\"Example 1\") == \"Example_1\"\n  fixSpacse(\" Example 2\") == \"_Example_2\"\n  fixSpacse(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpacse = (text) => {\n  return text.replace(/\\s+/g, '_').replace(/  +/g, '_')\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacse(\"Example\") == \"Example\"\n  fixSpacse(\"Example 1\") == \"Example_1\"\n  fixSpacse(\" Example 2\") == \"_Example_2\"\n  fixSpacse(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpacesInWords = (text) => {\n  return text.replace(/\\s+/g, '_').replace(/  +/g, '_')\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacesInWords(\"Example\") == \"Example\"\n  fixSpacesInWords(\"Example 1\") == \"Example_1\"\n  fixSpacesInWords(\" Example 2\") == \"_Example_2\"\n  fixSpacesInWords(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpacesInWordsNoSpaces = (text) => {\n  return text.replace(/\\s+/g, '_').replace(/  +/g, '_')\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacesInWords(\"Example\") == \"Example\"\n  fixSpacesInWords(\"Example 1\") == \"Example_1\"\n  fixSpacesInWords(\" Example 2\") == \"_Example_2\"\n  fixSpacesInWords(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpacesInWordsNoSpacesAndSpaces = (text) => {\n  return text.replace(/\\s+/g, '_').replace(/  +/g, '_')\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacesInWords(\"Example\") == \"Example\"\n  fixSpacesInWords(\"Example 1\") == \"Example_1\"\n  fixSpacesInWords(\" Example 2\") == \"_Example_2\"\n  fixSpacesInWords(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpacesInWordsNoSpacesAndSpacesAndSpaces = (text) => {\n  return text.replace(/\\s+/g, '_').replace(/  +/g, '_')\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacesInWords(\"Example\") == \"Example\"\n  fixSpacesInWords(\"Example 1\") == \"Example_1\"\n  fixSpacesInWords(\" Example 2\") == \"_Example_2\"\n  fixSpacesInWords(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpacesInWordsNoSpacesAndSpacesAndSpacesAndSpaces = (text) => {\n  return text.replace(/\\s+/g, '_').replace(/  +/g, '_')\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacesInWords(\"Example\") == \"Example\"\n  fixSpacesInWords(\"Example 1\") == \"Example_1\"\n  fixSpacesInWords(\" Example 2\") == \"_Example_2\"\n  fixSpacesInWords(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpacesInWordsNoSpacesAndSpacesAndSpacesAndSpacesAndSpaces = (text) => {\n  return text.replace(/\\s+/g, '_').replace(/  +/g, '_')\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacesInWords(\"Example\") == \"Example\"\n  fixSpacesInWords(\"Example 1\") == \"Example_1\"\n  fixSpacesInWords(\" Example 2\") == \"_Example_2\"\n  fixSpacesInWords(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpacesInWordsNoSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpaces = (text) => {\n  return text.replace(/\\s+/g, '_').replace(/  +/g, '_')\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacesInWords(\"Example\") == \"Example\"\n  fixSpacesInWords(\"Example 1\") == \"Example_1\"\n  fixSpacesInWords(\" Example 2\") == \"_Example_2\"\n  fixSpacesInWords(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpacesInWordsNoSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpaces = (text) => {\n  return text.replace(/\\s+/g, '_').replace(/  +/g, '_')\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacesInWords(\"Example\") == \"Example\"\n  fixSpacesInWords(\"Example 1\") == \"Example_1\"\n  fixSpacesInWords(\" Example 2\") == \"_Example_2\"\n  fixSpacesInWords(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpacesInWordsNoSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpaces = (text) => {\n  return text.replace(/\\s+/g, '_').replace(/  +/g, '_')\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacesInWords(\"Example\") == \"Example\"\n  fixSpacesInWords(\"Example 1\") == \"Example_1\"\n  fixSpacesInWords(\" Example 2\") == \"_Example_2\"\n  fixSpacesInWords(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpacesInWordsNoSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpacesAndSpaces = (text) => {\n  return text.replace(/\\s+/g, '_').replace(/  +/g, '_')\n}\n\n/*\n  Given a string text, replace all spaces in it with under", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "gc": "<|endoftext|>/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^(.*)(\\.txt|\\.exe|\\.dll)$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^(.*)(\\.txt|\\.exe|\\.dll)$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^(.*)(\\.txt|\\.exe|\\.dll)$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^(.*)(\\.txt|\\.exe|\\.dll)$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^(.*)(\\.txt|\\.exe|\\.dll)$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^(.*)(\\.txt|\\.exe|\\.dll)$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^(.*)(\\.txt|\\.exe|\\.dll)$/;\n  return re.test(file_name);\n};\n\n/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The sub", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "gc": "<|endoftext|>/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function \n  shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubes = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function \n  shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubes = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function \n  shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubesNoChange = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function \n  shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubesNoChangeNoChange = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function \n  shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubesNoChangeNoChangeNoChangeNoChange = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its index is a multiple of 4. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function \n  shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubesNoChangeNoChangeNoChangeNoChangeNoChange = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This function will take a list of integers. For all entries in the list, the function shall cube the integer entry if its index is a multiple of 3 and will \n  square the integer entry if its ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wrodsInSentenec = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wrodsInSentenec", "gc": "<|endoftext|>/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wrodsInSentenec = (sentence) => {\n  let words = [];\n  let wordsInSentence = [];\n  let wordsInSentenceLength = [];\n  let wordsInSentenceOrder = [];\n  let wordsInSentenceLengthLength = [];\n  let wordsInSentenceOrderLength = [];\n  let wordsInSentenceLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsInSentenceLengthLengthLengthLengthLength = [];\n  let wordsInSentenceOrderLengthLengthLengthLength = [];\n  let wordsIn", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function that will simpilfy the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simpilfy(\"1/5\", \"5/1\") = true\n  simpilfy(\"1/6\", \"2/1\") = false\n  simpilfy(\"7/10\", \"10/2\") = false\n  */\nconst simpilfy = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simpilfy", "gc": "<|endoftext|>/*Your task is to implement a function that will simpilfy the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simpilfy(\"1/5\", \"5/1\") = true\n  simpilfy(\"1/6\", \"2/1\") = false\n  simpilfy(\"7/10\", \"10/2\") = false\n  */\nconst simpilfy = (x, n) => {\n  const [num, denom] = x.split('/').map(Number);\n  return num === 0 && denom === 0;\n};\n\n/*\n  Your task is to implement a function that will convert a fraction to its simplified form. For example,\n  1/2 would become 1/3 and 2/3 would become 2/3. Both 1/2 and 2/3 are valid fractions, and do not have\n  zero as denominator. Simply put, 1/2 -> 1/3 and 2/3 -> 2/3.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  convertFraction(\"1/2\", \"1/3\") = \"1/3\"\n  convertFraction(\"1/2\", \"2/3\") = \"2/3\"\n  convertFraction(\"2/3\", \"1/2\") = \"1/2\"\n  convertFraction(\"2/3\", \"2/3\") = \"2/3\"\n  convertFraction(\"2/3\", \"2/3\") = \"2/3\"\n  convertFraction(\"2/3\", \"2/3\") = \"2/3\"\n  */\nconst convertFraction = (x, n) => {\n  const [num, denom] = x.split('/').map(Number);\n  return num === 0 && denom === 0;\n};\n\n/*\n  Your task is to implement a function that will convert a fraction to its simplified form using the\n  following rules:\n\n  1. If x is 0, return 0.\n  2. If x is 1, return 1.\n  3. If x is 1/2, return 1/3.\n  4. If x is 1/3, return 1/3.\n  5. If x is 2/3, return 2/3.\n  6. If x is 2/3, return 2/3.\n  7. If x is 2/3, return 2/3.\n  8. If x is 2/3, return 2/3.\n  9. If x is 2/3, return 2/3.\n  10. If x is 2/3, return 2/3.\n  11. If x is 2/3, return 2/3.\n  12. If x is 2/3, return 2/3.\n  13. If x is 2/3, return 2/3.\n  14. If x is 2/3, return 2/3.\n  15. If x is 2/3, return 2/3.\n  16. If x is 2/3, return 2/3.\n  17. If x is 2/3, return 2/3.\n  18. If x is 2/3, return 2/3.\n  19. If x is 2/3, return 2/3.\n  20. If x is 2/3, return 2/3.\n  21. If x is 2/3, return 2/3.\n  22. If x is 2/3, return 2/3.\n  23. If x is 2/3, return 2/3.\n  24. If x is 2/3, return 2/3.\n  25. If x is 2/3, return 2/3.\n  26. If x is 2/3, return 2/3.\n  27. If x is 2/3, return 2/3.\n  28. If x is 2/3, return 2/3.\n  29. If x is 2/3, return 2/3.\n  30. If x is 2/3, return 2/3.\n  31. If x is 2/3, return 2/3.\n  32. If x is 2/3, return 2/3.\n  33. If x is 2/3, return 2/3.\n  34. If x is 2/3, return 2/3.\n  35. If x is 2/3, return 2/3.\n  36. If x is 2/3, return 2/3.\n  37. If x is 2/3, return 2/3.\n  38. If x is 2/3, return 2/3.\n  39. If x is 2/3, return 2/3.\n  40. If x is 2/3, return 2/3.\n  41. If x is 2/3, return 2/3.\n  42. If x is 2/3, return 2/3.\n  43. If x is 2/3, return 2/3.\n  44. If x is 2/3, return 2/3.\n  45. If x is 2/3, return 2/3.\n  46. If x is 2/3, return 2/3.\n  47. If x is 2/3, return 2/3.\n  48. If x is 2/3, return 2/3.\n  49. If x is 2/3, return 2/3.\n  50. If x is 2/3, return 2/3.\n  51. If x is 2/3, return 2/3.\n  52. If x is 2/3, return 2/3.\n  53. If x is 2/3, return 2/3.\n  54. If x is 2/3, return 2/3.\n  55. If x is 2/3, return 2/3.\n  56. If x is 2/3, return 2/3.\n  57. If x is 2/3, return 2/3.\n  58. If x is 2/3, return 2/3.\n  59. If x is 2/3, return 2/3.\n  60. If x is 2/3, return 2/3.\n  61. If x is 2/3, return 2/3.\n  62. If x is 2/3, return 2/3.\n  63. If x is 2/3, return 2/3.\n  64. If x is 2/3, return 2/3.\n  65. If x is 2/3, return 2/3.\n  66. If x is 2/3, return 2/3.\n  67. If x is 2/3, return 2/3.\n  68. If x is 2/3, return 2/3.\n  69. If x is 2/3, return 2/3.\n  70. If x is 2/3, return 2/3.\n  71. If x is 2/3, return 2/3.\n  72. If x is 2/3, return 2/3.\n  73. If x is 2/3, return 2/3.\n  74. If x is 2/3, return 2/3.\n  75. If x is 2/3, return 2/3.\n  76. If x is 2/3, return 2/3.\n  77. If x is 2/3, return 2/3.\n  78. If x is 2/3, return 2/3.\n  79. If x is 2/3, return 2/3.\n  80. If x is 2/3, return 2/3.\n  81. If x is 2/3, return 2/3.\n  82. If x is 2/3, return 2/3.\n  83. If x is 2/3, return 2/3.\n  84. If x is 2/3, return 2/3.\n  85. If x is 2/3, return 2/3.\n  86. If x is 2/3, return 2/3.\n  87. If x is 2/3, return 2/3.\n  88. If x is 2/3, return 2/3.\n  89. If x is 2/3, return 2/3.\n  90. If x is 2/3, return 2/3.\n  91. If x is 2/3, return 2/3.\n  92. If x is 2/3, return 2/3.\n  93. If x is 2/3, return 2/3.\n  94. If x is 2/3, return 2/3.\n  95. If x is 2/3, return 2/3.\n  96. If x is 2/3, return 2/3.\n  97. If x is 2/3, return 2/3.\n  98. If x is 2/3, return 2/3.\n  99. If x is 2/3, return 2/3.\n  100. If x is 2/3, return 2/3.\n  101. If x is 2/3, return 2/3.\n  102. If x is 2/3, return 2/3.\n  103. If x is 2/3, return 2/3.\n  104. If x is 2/3, return 2/3.\n  105. If x is 2/3, return 2/3.\n  106. If x is 2/3, return 2/3.\n  107. If x ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> roderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> roderByPoints([]) == []\n  */\nconst roderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "roderByPoints", "gc": "<|endoftext|>/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> roderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> roderByPoints([]) == []\n  */\nconst roderByPoints = (nums) => {\n  const sortedNums = nums.sort((a, b) => a - b);\n  const sums = sortedNums.reduce((acc, num) => acc + num, 0);\n  const sortedSums = sortedNums.map((num) => num * 10);\n  const sortedSumsReversed = sortedSums.reverse();\n  const sortedSumsReversedReversed = sortedSumsReversed.reverse();\n  const sortedSumsReversedReversedReversed = sortedSumsReversedReversed.reverse();\n  return sortedSumsReversedReversedReversed.map((num) => num / 10);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> roderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> roderByPoints([]) == []\n  */\nconst roderByPointsReversed = (nums) => {\n  const sortedNums = nums.sort((a, b) => a - b);\n  const sums = sortedNums.reduce((acc, num) => acc + num, 0);\n  const sortedSums = sortedNums.map((num) => num * 10);\n  const sortedSumsReversed = sortedSums.reverse();\n  const sortedSumsReversedReversed = sortedSumsReversed.reverse();\n  const sortedSumsReversedReversedReversed = sortedSumsReversedReversed.reverse();\n  return sortedSumsReversedReversedReversed.map((num) => num / 10);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> roderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> roderByPoints([]) == []\n  */\nconst roderByPointsReversedReversed = (nums) => {\n  const sortedNums = nums.sort((a, b) => a - b);\n  const sums = sortedNums.reduce((acc, num) => acc + num, 0);\n  const sortedSums = sortedNums.map((num) => num * 10);\n  const sortedSumsReversed = sortedSums.reverse();\n  const sortedSumsReversedReversed = sortedSumsReversed.reverse();\n  const sortedSumsReversedReversedReversed = sortedSumsReversedReversed.reverse();\n  return sortedSumsReversedReversedReversed.map((num) => num / 10);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> roderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> roderByPoints([]) == []\n  */\nconst roderByPointsReversedReversedReversed = (nums) => {\n  const sortedNums = nums.sort((a, b) => a - b);\n  const sums = sortedNums.reduce((acc, num) => acc + num, 0);\n  const sortedSums = sortedNums.map((num) => num * 10);\n  const sortedSumsReversed = sortedSums.reverse();\n  const sortedSumsReversedReversed = sortedSumsReversed.reverse();\n  const sortedSumsReversedReversedReversed = sortedSumsReversedReversed.reverse();\n  return sortedSumsReversedReversedReversedReversed.map((num) => num / 10);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> roderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> roderByPoints([]) == []\n  */\nconst roderByPointsReversedReversedReversedReversed = (nums) => {\n  const sortedNums = nums.sort((a, b) => a - b);\n  const sums = sortedNums.reduce((acc, num) => acc + num, 0);\n  const sortedSums = sortedNums.map((num) => num * 10);\n  const sortedSumsReversed = sortedSums.reverse();\n  const sortedSumsReversedReversed = sortedSumsReversed.reverse();\n  const sortedSumsReversedReversedReversed = sortedSumsReversedReversed.reverse();\n  return sortedSumsReversedReversedReversedReversed.map((num) => num / 10);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> roderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> roderByPoints([]) == []\n  */\nconst roderByPointsReversedReversedReversedReversedReversed = (nums) => {\n  const sortedNums = nums.sort((a, b) => a - b);\n  const sums = sortedNums.reduce((acc, num) => acc + num, 0);\n  const sortedSums = sortedNums.map((num) => num * 10);\n  const sortedSumsReversed = sortedSums.reverse();\n  const sortedSumsReversedReversed = sortedSumsReversed.reverse();\n  const sortedSumsReversedReversedReversed = sortedSumsReversedReversed.reverse();\n  return sortedSumsReversedReversedReversedReversed.map((num) => num / 10);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> roderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> roderByPoints([]) == []\n  */\nconst roderByPointsReversedReversedReversedReversedReversedReversed = (nums) => {\n  const sortedNums = nums.sort((a, b) => a - b);\n  const sums = sortedNums.reduce((acc, num) => acc + num, 0);\n  const sortedSums = sortedNums.map((num) => num * 10);\n  const sortedSumsReversed = sortedSums.reverse();\n  const sortedSumsReversedReversed = sortedSumsReversed.reverse();\n  const sortedSumsReversedReversedReversed = sortedSumsReversedReversed.reverse();\n  return sortedSumsReversedReversedReversedReversedReversed.map((num) => num / 10);\n};\n\n/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/146", "prompt": "/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "gc": "<|endoftext|>/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      if (firstDigit % 2 === 1 && lastDigit % 2 === 1) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      if (firstDigit % 2 === 1 && lastDigit % 2 === 1) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      if (firstDigit % 2 === 1 && lastDigit % 2 === 1) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      if (firstDigit % 2 === 1 && lastDigit % 2 === 1) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      if (firstDigit % 2 === 1 && lastDigit % 2 === 1) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      if (firstDigit % 2 === 1 && lastDigit % 2 === 1) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      if (firstDigit % 2 === 1 && lastDigit % 2 === 1) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      if (firstDigit % 2 === 1 && lastDigit % 2 === 1) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      if (firstDigit % 2 === 1 && lastDigit % 2 === 1) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let firstDigit = 0;\n  let lastDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] >= 10) {\n      firstDigit = nums[i];\n      lastDigit = nums[i + 1];\n      if (firstDigit % 2 === 1 && lastDigit % 2 === 1) {\n        count++;\n      }\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of element", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTrpiles = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTrpiles", "gc": "<|endoftext|>/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTrpiles = (n) => {\n  const a = [...Array(n - 1).keys()].map(() => 0);\n  for (let i = 1; i <= n; i++) {\n    const j = i - 1;\n    const k = i + 1;\n    a[i] = a[j] + a[k];\n    a[j] = a[j] + a[k];\n    a[k] = a[j] + a[k];\n  }\n  return a.filter((v, i, a) => i % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 2\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = [...Array(n - 1).keys()].map(() => 0);\n  for (let i = 1; i <= n; i++) {\n    const j = i - 1;\n    const k = i + 1;\n    a[i] = a[j] + a[k];\n    a[j] = a[j] + a[k];\n    a[k] = a[j] + a[k];\n  }\n  return a.filter((v, i, a) => i % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 3\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriplesWithTriples = (n) => {\n  const a = [...Array(n - 1).keys()].map(() => 0);\n  for (let i = 1; i <= n; i++) {\n    const j = i - 1;\n    const k = i + 1;\n    a[i] = a[j] + a[k];\n    a[j] = a[j] + a[k];\n    a[k] = a[j] + a[k];\n  }\n  return a.filter((v, i, a) => i % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 4\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriplesWithTriplesWithTriples = (n) => {\n  const a = [...Array(n - 1).keys()].map(() => 0);\n  for (let i = 1; i <= n; i++) {\n    const j = i - 1;\n    const k = i + 1;\n    a[i] = a[j] + a[k];\n    a[j] = a[j] + a[k];\n    a[k] = a[j] + a[k];\n  }\n  return a.filter((v, i, a) => i % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 5\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriplesWithTriplesWithTriplesWithTriples = (n) => {\n  const a = [...Array(n - 1).keys()].map(() => 0);\n  for (let i = 1; i <= n; i++) {\n    const j = i - 1;\n    const k = i + 1;\n    a[i] = a[j] + a[k];\n    a[j] = a[j] + a[k];\n    a[k] = a[j] + a[k];\n  }\n  return a.filter((v, i, a) => i % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 6\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriplesWithTriplesWithTriplesWithTriplesWithTriples = (n) => {\n  const a = [...Array(n - 1).keys()].map(() => 0);\n  for (let i = 1; i <= n; i++) {\n    const j = i - 1;\n    const k = i + 1;\n    a[i] = a[j] + a[k];\n    a[j] = a[j] + a[k];\n    a[k] = a[j] + a[k];\n  }\n  return a.filter((v, i, a) => i % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 7\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriplesWithTriplesWithTriplesWithTriplesWithTriplesWithTriples = (n) => {\n  const a = [...Array(n - 1).keys()].map(() => 0);\n  for (let i = 1; i <= n; i++) {\n    const j = i - 1;\n    const k = i + 1;\n    a[i] = a[j] + a[k];\n    a[j] = a[j] + a[k];\n    a[k] = a[j] + a[k];\n  }\n  return a.filter((v, i, a) => i % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "gc": "<|endoftext|>/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planet1Orbit = orbit(planet1);\n  const planet2Orbit = orbit(planet2);\n  const planet1Orbits = planet1Orbit.orbits;\n  const planet2Orbits = planet2Orbit.orbits;\n  const planet1Orbits2 = planet1Orbits.filter(orbit => orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.orbit.", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "gc": "<|endoftext|>/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return [...new Set(sum)];\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the string with all the letters converted to uppercase.\n  For example:\n  assert upperCase(\"Hello World!\") == \"HELLO WORLD!\"\n  */\nconst upperCase = (str) => {\n  return str.replace(/\\w\\S*/g, txt => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase());\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the string with all the letters converted to lowercase.\n  For example:\n  assert lowerCase(\"Hello World!\") == \"hello world!\"\n  */\nconst lowerCase = (str) => {\n  return str.replace(/\\w\\S*/g, txt => txt.charAt(0).toLowerCase() + txt.substr(1).toLowerCase());\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the string with all the letters converted to uppercase and lowercase.\n  For example:\n  assert upperCaseAndLowerCase(\"Hello World!\") == \"hello world!\"\n  */\nconst upperCaseAndLowerCase = (str) => {\n  return str.replace(/\\w\\S*/g, txt => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase() + txt.substr(1).toLowerCase());\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the string with all the letters converted to uppercase and lowercase and spaces removed.\n  For example:\n  assert upperCaseAndLowerCaseSpaces(\" Hello World!\") == \"hello world!\"\n  */\nconst upperCaseAndLowerCaseSpaces = (str) => {\n  return str.replace(/\\w\\S*/g, txt => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase() + txt.substr(1).toLowerCase().replace(/ /g, \"\"));\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the string with all the letters converted to uppercase and lowercase and spaces removed.\n  For example:\n  assert upperCaseAndLowerCaseSpaces(\" Hello World!\") == \"hello world!\"\n  */\nconst lowerCaseAndUpperCaseSpaces = (str) => {\n  return str.replace(/\\w\\S*/g, txt => txt.charAt(0).toLowerCase() + txt.substr(1).toLowerCase() + txt.substr(1).toLowerCase().replace(/ /g, \"\"));\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the string with all the letters converted to uppercase and lowercase and spaces removed.\n  For example:\n  assert upperCaseAndLowerCaseSpaces(\" Hello World!\") == \"hello world!\"\n  */\nconst lowerCaseAndUpperCaseSpaces = (str) => {\n  return str.replace(/\\w\\S*/g, txt => txt.charAt(0).toLowerCase() + txt.substr(1).toLowerCase() + txt.substr(1).toLowerCase().replace(/ /g, \"\"));\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the string with all the letters converted to uppercase and lowercase and spaces removed.\n  For example:\n  assert upperCaseAndLowerCaseSpaces(\" Hello World!\") == \"hello world!\"\n  */\nconst upperCaseAndLowerCaseSpaces = (str) => {\n  return str.replace(/\\w\\S*/g, txt => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase() + txt.substr(1).toLowerCase().replace(/ /g, \"\"));\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the string with all the letters converted to uppercase and lowercase and spaces removed.\n  For example:\n  assert upperCaseAndLowerCaseSpaces(\" Hello World!\") == \"hello world!\"\n  */\nconst lowerCaseAndUpperCaseSpaces = (str) => {\n  return str.replace(/\\w\\S*/g, txt => txt.charAt(0).toLowerCase() + txt.substr(1).toLowerCase() + txt.substr(1).toLowerCase().replace(/ /g, \"\"));\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the string with all the letters converted to uppercase and lowercase and spaces removed.\n  For example:\n  assert upperCaseAndLowerCaseSpaces(\" Hello World!\") == \"hello world!\"\n  */\nconst lowerCaseAndUpperCaseSpaces = (str) => {\n  return str.replace(/\\w\\S*/g, txt => txt.charAt(0).toLowerCase() + txt.substr(1).toLowerCase() + txt.substr(1).toLowerCase().replace(/ /g, \"\"));\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the string with all the letters converted to uppercase and lowercase and spaces removed.\n  For example:\n  assert upperCaseAndLowerCaseSpaces(\" Hello World!\") == \"hello world!\"\n  */\nconst upperCaseAndLowerCaseSpaces = (str) => {\n  return str.replace(/\\w\\S*/g, txt => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase() + txt.substr(1).toLowerCase().replace(/ /g, \"\"));\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the string with all the letters converted to uppercase and lowercase and spaces removed.\n  For example:\n  assert upperCaseAndLowerCaseSpaces(\" Hello World!\") == \"hello world!\"\n  */\nconst lowerCaseAndUpperCaseSpaces = (str) => {\n  return str.replace(/\\w\\S*/g, txt => txt.charAt(0).toLowerCase() + txt.substr(1).toLowerCase() + txt.substr(1).toLowerCase().replace(/ /g, \"\"));\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the string with all the letters converted to uppercase and lowercase and spaces removed.\n  For example:\n  assert upperCaseAndLowerCaseSpaces(\" Hello World!\") == \"hello world!\"\n  */\nconst lowerCaseAndUpperCaseSpaces = (str) => {\n  return str.replace(/\\w\\S*/g, txt => txt.charAt(0).toLowerCase() + txt.substr(1).toLowerCase() + txt.substr(1).toLowerCase().replace(/ /g, \"\"));\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the string with all the letters converted to uppercase and lowercase and spaces removed.\n  For example:\n  assert upperCaseAndLowerCaseSpaces(\" Hello World!\") == \"hello world!\"\n  */\nconst upperCaseAndLowerCaseSpaces = (str) => {\n  return str.replace(/\\w\\S*/g, txt => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase() + txt.substr(1).toLowerCase().replace(/ /g, \"\"));\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the string with all the letters converted to uppercase and lowercase and spaces removed.\n  For example:\n  assert upperCaseAndLowerCaseSpaces(\" Hello World!\") == \"hello world!\"\n  */\nconst lowerCaseAndUpperCaseSpaces = (str) => {\n  return str.replace(/\\w\\S*/g, txt => txt.charAt(0).toLowerCase() + txt.substr(1).toLowerCase() + txt.", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/15", "prompt": "/* Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "gc": "<|endoftext|>/* Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += i;\n    if (i!== n - 1) {\n      s +='';\n    }\n  }\n  return s;\n};\n\n/**\n  Returns a string containing space-delimited numbers starting from n inclusive.\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceFrom = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += i;\n    if (i!== n - 1) {\n      s +='';\n    }\n  }\n  return s;\n};\n\n/**\n  Returns a string containing space-delimited numbers starting from n inclusive.\n  >>> stringSequenceFrom(0)\n  '0'\n  */\nconst stringSequenceFromZero = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += i;\n    if (i!== n - 1) {\n      s +='';\n    }\n  }\n  return s;\n};\n\n/**\n  Returns a string containing space-delimited numbers starting from n inclusive.\n  >>> stringSequenceFromZero(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceFromZeroTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += i;\n    if (i!== n - 1) {\n      s +='';\n    }\n  }\n  return s;\n};\n\n/**\n  Returns a string containing space-delimited numbers starting from n inclusive.\n  >>> stringSequenceFromZeroTo(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceFromZeroToZero = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += i;\n    if (i!== n - 1) {\n      s +='';\n    }\n  }\n  return s;\n};\n\n/**\n  Returns a string containing space-delimited numbers starting from n inclusive.\n  >>> stringSequenceFromZeroToZero(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceFromZeroToZeroTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += i;\n    if (i!== n - 1) {\n      s +='';\n    }\n  }\n  return s;\n};\n\n/**\n  Returns a string containing space-delimited numbers starting from n inclusive.\n  >>> stringSequenceFromZeroToZeroTo(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceFromZeroToZeroToZero = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += i;\n    if (i!== n - 1) {\n      s +='';\n    }\n  }\n  return s;\n};\n\n/**\n  Returns a string containing space-delimited numbers starting from n inclusive.\n  >>> stringSequenceFromZeroToZeroToZeroTo(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceFromZeroToZeroToZeroTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += i;\n    if (i!== n - 1) {\n      s +='';\n    }\n  }\n  return s;\n};\n\n/**\n  Returns a string containing space-delimited numbers starting from n inclusive.\n  >>> stringSequenceFromZeroToZeroToZeroToZeroTo(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceFromZeroToZeroToZeroToZeroTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += i;\n    if (i!== n - 1) {\n      s +='';\n    }\n  }\n  return s;\n};\n\n/**\n  Returns a string containing space-delimited numbers starting from n inclusive.\n  >>> stringSequenceFromZeroToZeroToZeroToZeroToZeroTo(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceFromZeroToZeroToZeroToZeroToZeroTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += i;\n    if (i!== n - 1) {\n      s +='';\n    }\n  }\n  return s;\n};\n\n/**\n  Returns a string containing space-delimited numbers starting from n inclusive.\n  >>> stringSequenceFromZeroToZeroToZeroToZeroToZeroToZeroTo(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceFromZeroToZeroToZeroToZeroToZeroToZeroTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += i;\n    if (i!== n - 1) {\n      s +='';\n    }\n  }\n  return s;\n};\n\n/**\n  Returns a string containing space-delimited numbers starting from n inclusive.\n  >>> stringSequenceFromZeroToZeroToZeroToZeroToZeroToZeroToZeroTo(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceFromZeroToZeroToZeroToZeroToZeroToZeroToZeroTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += i;\n    if (i!== n - 1) {\n      s +='';\n    }\n  }\n  return s;\n};\n\n/**\n  Returns a string containing space-delimited numbers starting from n inclusive.\n  >>> stringSequenceFromZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroTo(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceFromZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += i;\n    if (i!== n - 1) {\n      s +='';\n    }\n  }\n  return s;\n};\n\n/**\n  Returns a string containing space-delimited numbers starting from n inclusive.\n  >>> stringSequenceFromZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroTo(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequenceFromZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroTo = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += i;\n    if (i!== n - 1) {\n      s +='';\n    }\n  }\n  return s;\n};\n\n/**\n  Returns a string containing space-delimited numbers starting from n inclusive.\n  >>> stringSequenceFromZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroToZeroTo", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/150", "prompt": "/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "gc": "<|endoftext|>/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrY(n / y, y, x);\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrY(n / y, y, x);\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrY(n / y, y, x);\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrY(n / y, y, x);\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrY(n / y, y, x);\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrY(n / y, y, x);\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrY(n / y, y, x);\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrY(n / y, y, x);\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrY(n / y, y, x);\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrY(n / y, y, x);\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrY(n / y, y, x);\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrY(n / y, y, x);\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrY(n / y, y, x);\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrY(n / y, y, x);\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrY(n / y, y, x);\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 0 || n >= y) {\n    return y;\n  }\n  if (n % y === 0) {\n    return x;\n  }\n  return xOrY(n / y, y, x);\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doublehTeDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doublehTeDifference([-1, -2, 0]) == 0\n  doublehTeDifference([9, -2]) == 81\n  doublehTeDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doublehTeDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doublehTeDifference", "gc": "<|endoftext|>/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doublehTeDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doublehTeDifference([-1, -2, 0]) == 0\n  doublehTeDifference([9, -2]) == 81\n  doublehTeDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doublehTeDifference = (lst) => {\n  if (lst == null || lst.length == 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are even. Ignore numbers that are negative or not integers.\n  doublehTeEvenDifference([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 10\n  doublehTeEvenDifference([-1, -2, 0]) == -1\n  doublehTeEvenDifference([9, -2]) == 81\n  doublehTeEvenDifference([0]) == -1\n  If the input list is empty, return 0.\n  */\nconst doublehTeEvenDifference = (lst) => {\n  if (lst == null || lst.length == 0) {\n    return 0;\n  }\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the difference between the sum of the squares of the numbers\n  in the list that are odd and sum of the squares of the numbers in the list that are even.\n  doublehTeDifferenceAndEvenDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 + 0 = 10\n  doublehTeDifferenceAndEvenDifference([-1, -2, 0]) == -1\n  doublehTeDifferenceAndEvenDifference([9, -2]) == 81\n  doublehTeDifferenceAndEvenDifference([0]) == -1\n  If the input list is empty, return 0.\n  */\nconst doublehTeDifferenceAndEvenDifference = (lst) => {\n  if (lst == null || lst.length == 0) {\n    return 0;\n  }\n  let sum = 0;\n  let sum2 = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i] * lst[i];\n      sum2 += lst[i] * lst[i];\n    }\n  }\n  return sum - sum2;\n};\n\n/* Given a list of numbers, return the difference between the sum of the squares of the numbers\n  in the list that are odd and sum of the squares of the numbers in the list that are even.\n  doublehTeDifferenceAndEvenDifference([]) == 0 + 0 + 0 + 0 = 10\n  doublehTeDifferenceAndEvenDifference([1]) == 0 + 0 + 0 + 0 = 10\n  doublehTeDifferenceAndEvenDifference([-1]) == 0 + 0 + 0 + 0 = 10\n  doublehTeDifferenceAndEvenDifference([9]) == 0 + 0 + 0 + 0 = 10\n  doublehTeDifferenceAndEvenDifference([0]) == 0 + 0 + 0 + 0 = 10\n  If the input list is empty, return 0.\n  */\nconst doublehTeDifferenceAndEvenDifference = (lst) => {\n  if (lst == null || lst.length == 0) {\n    return 0;\n  }\n  let sum = 0;\n  let sum2 = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i] * lst[i];\n      sum2 += lst[i] * lst[i];\n    }\n  }\n  return sum - sum2;\n};\n\n/* Given a list of numbers, return the difference between the sum of the squares of the numbers\n  in the list that are odd and sum of the squares of the numbers in the list that are even.\n  doublehTeDifferenceAndEvenDifference([]) == 0 + 0 + 0 + 0 = 10\n  doublehTeDifferenceAndEvenDifference([1]) == 0 + 0 + 0 + 0 = 10\n  doublehTeDifferenceAndEvenDifference([-1]) == 0 + 0 + 0 + 0 = 10\n  doublehTeDifferenceAndEvenDifference([9]) == 0 + 0 + 0 + 0 = 10\n  doublehTeDifferenceAndEvenDifference([0]) == 0 + 0 + 0 + 0 = 10\n  If the input list is empty, return 0.\n  */\nconst doublehTeDifferenceAndEvenDifference = (lst) => {\n  if (lst == null || lst.length == 0) {\n    return 0;\n  }\n  let sum = 0;\n  let sum2 = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i] * lst[i];\n      sum2 += lst[i] * lst[i];\n    }\n  }\n  return sum - sum2;\n};\n\n/* Given a list of numbers, return the difference between the sum of the squares of the numbers\n  in the list that are odd and sum of the squares of the numbers in the list that are even.\n  doublehTeDifferenceAndEvenDifference([]) == 0 + 0 + 0 + 0 = 10\n  doublehTeDifferenceAndEvenDifference([1]) == 0 + 0 + 0 + 0 = 10\n  doublehTeDifferenceAndEvenDifference([-1]) == 0 + 0 + 0 + 0 = 10\n  doublehTeDifferenceAndEvenDifference([9]) == 0 + 0 + 0 + 0 = 10\n  doublehTeDifferenceAndEvenDifference([0]) == 0 + 0 + 0 + 0 = 10\n  If the input list is empty, return 0.\n  */\nconst doublehTeDifferenceAndEvenDifference = (lst) => {\n  if (lst == null || lst.length == 0) {\n    return 0;\n  }\n  let sum = 0;\n  let sum2 = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i] * lst[i];\n      sum2 += lst[i] * lst[i];\n    }\n  }\n  return sum - sum2;\n};\n\n/* Given a list of numbers, return the difference between the sum of the squares of the numbers\n  in the list that are odd and sum of the squares of the numbers in the list that are even.\n  doublehTeDifferenceAndEvenDifference([]) == 0 + 0 + 0 + 0 = 10\n  doublehTeDifferenceAndEvenDifference([1]) == 0 + 0 + 0 + 0 = 10\n  doublehTeDifferenceAndEvenDifference([-1]) == 0 + 0 + 0 + 0 = 10\n  doublehTeDifferenceAndEvenDifference([9]) == 0 + 0 + 0 + 0 = 10\n  doublehTeDifferenceAndEvenDifference([0]) == 0 + 0 + 0 + 0 = 10\n  If the input list is empty, return 0.\n  */\nconst doublehTeDifferenceAndEvenDifference = (lst) => {\n  if (lst == null || lst.length == 0) {\n    return 0;\n  }\n  let sum = 0;\n  let sum2 = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i] * lst[i];\n      sum2 += lst[i] * lst[i];\n    }\n  }\n  return sum - sum2;\n};\n\n/* Given a list of numbers, return the difference between the sum of the squares of the numbers\n  in the list that are odd and sum of the squares of the numbers in the list that are even.\n  doublehTeDifferenceAndEvenDifference([]) == 0 + 0 + 0 + 0 = 10\n  doublehTeDifferenceAndEvenDifference([1]) == 0 + 0 + 0 + 0 = 10\n  doublehTeDifferenceAndEvenDifference([-1]) == 0 + 0 + 0 + 0 = 10\n  doublehTeDifferenceAndEvenDifference([9]) == 0 + 0 + 0 + 0 = 10\n  doublehTeDifferenceAndEvenDifference([0]) == 0 + 0 + 0 + 0 = 10\n  If the input list is empty, return 0.\n  */\nconst doublehTeDifferenceAndEvenDifference = (lst) => {\n  if (lst == null || lst.length == 0) {\n    return 0;\n  }\n  let sum = 0;\n  let sum2 = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i] * lst[i];\n      sum2 += lst[i] * lst[i];\n    }\n  }\n  return sum - sum2;\n};\n\n/* Given a list of numbers, return the difference between the sum of the squares of the numbers\n  in the list that are odd and sum of the squares of the numbers in the list that are even.\n  doublehTeDifferenceAndEvenDifference([]) == 0 + 0 + 0 + 0 = 10\n  doublehTeDifferenceAndEvenDifference([1]) == 0 + 0 + 0 + ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "gc": "<|endoftext|>/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const scores = [...game];\n  const guesses = [...guess];\n  const results = [];\n  \n  guesses.forEach((guess, i) => {\n    const score = scores[i];\n    const guessedScore = guesses[i];\n    const diff = score - guessedScore;\n    results.push(Math.abs(diff));\n  });\n  \n  return results;\n};\n\n/*\n  Given an array of numbers, return an array of the same length denoting how far off each number was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the number.\n  \n  \n  example:\n\n  diff([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  diff([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst diff = (game, guess) => {\n  const scores = [...game];\n  const guesses = [...guess];\n  const results = [];\n  \n  guesses.forEach((guess, i) => {\n    const score = scores[i];\n    const guessedScore = guesses[i];\n    const diff = score - guessedScore;\n    results.push(Math.abs(diff));\n  });\n  \n  return results;\n};\n\n/*\n  Given an array of numbers, return an array of the same length denoting how far off each number was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the number.\n  \n  \n  example:\n\n  diff([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  diff([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst diff2 = (game, guess) => {\n  const scores = [...game];\n  const guesses = [...guess];\n  const results = [];\n  \n  guesses.forEach((guess, i) => {\n    const score = scores[i];\n    const guessedScore = guesses[i];\n    const diff = score - guessedScore;\n    results.push(Math.abs(diff));\n  });\n  \n  return results;\n};\n\n/*\n  Given an array of numbers, return an array of the same length denoting how far off each number was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the number.\n  \n  \n  example:\n\n  diff3([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  diff3([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst diff3 = (game, guess) => {\n  const scores = [...game];\n  const guesses = [...guess];\n  const results = [];\n  \n  guesses.forEach((guess, i) => {\n    const score = scores[i];\n    const guessedScore = guesses[i];\n    const diff = score - guessedScore;\n    results.push(Math.abs(diff));\n  });\n  \n  return results;\n};\n\n/*\n  Given an array of numbers, return an array of the same length denoting how far off each number was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the number.\n  \n  \n  example:\n\n  diff4([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  diff4([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst diff4 = (game, guess) => {\n  const scores = [...game];\n  const guesses = [...guess];\n  const results = [];\n  \n  guesses.forEach((guess, i) => {\n    const score = scores[i];\n    const guessedScore = guesses[i];\n    const diff = score - guessedScore;\n    results.push(Math.abs(diff));\n  });\n  \n  return results;\n};\n\n/*\n  Given an array of numbers, return an array of the same length denoting how far off each number was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the number.\n  \n  \n  example:\n\n  diff5([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  diff5([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst diff5 = (game, guess) => {\n  const scores = [...game];\n  const guesses = [...guess];\n  const results = [];\n  \n  guesses.forEach((guess, i) => {\n    const score = scores[i];\n    const guessedScore = guesses[i];\n    const diff = score - guessedScore;\n    results.push(Math.abs(diff));\n  });\n  \n  return results;\n};\n\n/*\n  Given an array of numbers, return an array of the same length denoting how far off each number was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the number.\n  \n  \n  example:\n\n  diff6([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  diff6([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst diff6 = (game, guess) => {\n  const scores = [...game];\n  const guesses = [...guess];\n  const results = [];\n  \n  guesses.forEach((guess, i) => {\n    const score = scores[i];\n    const guessedScore = guesses[i];\n    const diff = score - guessedScore;\n    results.push(Math.abs(diff));\n  });\n  \n  return results;\n};\n\n/*\n  Given an array of numbers, return an array of the same length denoting how far off each number was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the number.\n  \n  \n  example:\n\n  diff7([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  diff7([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst diff7 = (game, guess) => {\n  const scores = [...game];\n  const guesses = [...guess];\n  const results = [];\n  \n  guesses.forEach((guess, i) => {\n    const score = scores[i];\n    const guessedScore = guesses[i];\n    const diff = score - guessedScore;\n    results.push(Math.abs(diff));\n  });\n  \n  return results;\n};\n\n/*\n  Given an array of numbers, return an array of the same length denoting how far off each number was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the number.\n  \n  \n  example:\n\n  diff8([1,2,3,4,5,1],[1,2,3,4,2,", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/153", "prompt": "/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "gc": "<|endoftext|>/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_strongest = null;\n  for (let extension of extensions) {\n    let extension_strength_str = extension.split('_').map(x => x.toUpperCase()).join('');\n    if (extension_strength_str === class_name) {\n      extension_strength = extension.split('_').map(x => x.toLowerCase()).join('');\n    }\n  }\n  if (extension_strength > extension_strength_str.length) {\n    extension_strongest = extension_strength_str;\n  }\n  return extension_strongest;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name that\n  has the highest extension's strength.\n  Example:\n  Given the class \"my_class\" and extensions: ['AA', 'Be', 'CC'], you\n  should return \"my_class\".\n  Note:\n  You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst highestExtension = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_strongest = null;\n  for (let extension of extensions) {\n    let extension_strength_str = extension.split('_').map(x => x.toUpperCase()).join('');\n    if (extension_strength_str === class_name) {\n      extension_strength = extension.split('_').map(x => x.toLowerCase()).join('');\n    }\n  }\n  if (extension_strength > extension_strength_str.length) {\n    extension_strongest = extension_strength_str;\n  }\n  return extension_strongest;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name that\n  has the lowest extension's strength.\n  Example:\n  Given the class \"my_class\" and extensions: ['AA', 'Be', 'CC'], you\n  should return \"my_class\".\n  Note:\n  You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst lowestExtension = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_strongest = null;\n  for (let extension of extensions) {\n    let extension_strength_str = extension.split('_').map(x => x.toUpperCase()).join('');\n    if (extension_strength_str === class_name) {\n      extension_strength = extension.split('_').map(x => x.toLowerCase()).join('');\n    }\n  }\n  if (extension_strength > extension_strength_str.length) {\n    extension_strongest = extension_strength_str;\n  }\n  return extension_strongest;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name that\n  has the highest extension's strength and lowest extension's strength.\n  Example:\n  Given the class \"my_class\" and extensions: ['AA', 'Be', 'CC'], you\n  should return \"my_class\".\n  Note:\n  You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst highestAndLowestExtension = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_strongest = null;\n  for (let extension of extensions) {\n    let extension_strength_str = extension.split('_').map(x => x.toUpperCase()).join('');\n    if (extension_strength_str === class_name) {\n      extension_strength = extension.split('_').map(x => x.toLowerCase()).join('');\n    }\n  }\n  if (extension_strength > extension_strength_str.length) {\n    extension_strongest = extension_strength_str;\n  }\n  return extension_strongest;\n};\n\n/*\n  Given a class name and a list of extensions, return the class name ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/154", "prompt": "/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  ccypatternChekc(\"abcd\",\"abd\") => false\n  ccypatternChekc(\"hello\",\"ell\") => true\n  ccypatternChekc(\"whassup\",\"psus\") => false\n  ccypatternChekc(\"abab\",\"baa\") => true\n  ccypatternChekc(\"efef\",\"eeff\") => false\n  ccypatternChekc(\"himenss\",\"simen\") => true\n  */\nconst ccypatternChekc = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "ccypatternChekc", "gc": "<|endoftext|>/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  ccypatternChekc(\"abcd\",\"abd\") => false\n  ccypatternChekc(\"hello\",\"ell\") => true\n  ccypatternChekc(\"whassup\",\"psus\") => false\n  ccypatternChekc(\"abab\",\"baa\") => true\n  ccypatternChekc(\"efef\",\"eeff\") => false\n  ccypatternChekc(\"himenss\",\"simen\") => true\n  */\nconst ccypatternChekc = (a, b) => {\n  let firstWord = a.split('')\n  let secondWord = b.split('')\n  let firstWordLength = firstWord.length\n  let secondWordLength = secondWord.length\n  let firstWordRotation = firstWord.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let secondWordRotation = secondWord.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let firstWordRotation = firstWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let secondWordRotation = secondWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let firstWordRotation = firstWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let secondWordRotation = secondWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let firstWordRotation = firstWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let secondWordRotation = secondWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let firstWordRotation = firstWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let secondWordRotation = secondWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let firstWordRotation = firstWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let secondWordRotation = secondWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let firstWordRotation = firstWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let secondWordRotation = secondWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let firstWordRotation = firstWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let secondWordRotation = secondWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let firstWordRotation = firstWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let secondWordRotation = secondWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let firstWordRotation = firstWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let secondWordRotation = secondWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let firstWordRotation = firstWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let secondWordRotation = secondWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let firstWordRotation = firstWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let secondWordRotation = secondWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let firstWordRotation = firstWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let secondWordRotation = secondWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let firstWordRotation = firstWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let secondWordRotation = secondWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let firstWordRotation = firstWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let secondWordRotation = secondWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let firstWordRotation = firstWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let secondWordRotation = secondWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let firstWordRotation = firstWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let secondWordRotation = secondWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let firstWordRotation = firstWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let secondWordRotation = secondWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let firstWordRotation = firstWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let secondWordRotation = secondWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let firstWordRotation = firstWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let secondWordRotation = secondWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let firstWordRotation = firstWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let secondWordRotation = secondWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let firstWordRotation = firstWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let secondWordRotation = secondWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let firstWordRotation = firstWordRotation.map(x => x.split('').map(y => y.split('')).map(z => z[0]).join(''))\n  let secondWordRotation = secondWordRotation.map(x => x.split('').map(y => y.split('')).", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "gc": "<|endoftext|>/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  let digitCount = 0;\n  let digitCount2 = 0;\n  let digitCount3 = 0;\n  let digitCount4 = 0;\n  let digitCount5 = 0;\n  let digitCount6 = 0;\n  let digitCount7 = 0;\n  let digitCount8 = 0;\n  let digitCount9 = 0;\n  let digitCount10 = 0;\n  let digitCount11 = 0;\n  let digitCount12 = 0;\n  let digitCount13 = 0;\n  let digitCount14 = 0;\n  let digitCount15 = 0;\n  let digitCount16 = 0;\n  let digitCount17 = 0;\n  let digitCount18 = 0;\n  let digitCount19 = 0;\n  let digitCount20 = 0;\n  let digitCount21 = 0;\n  let digitCount22 = 0;\n  let digitCount23 = 0;\n  let digitCount24 = 0;\n  let digitCount25 = 0;\n  let digitCount26 = 0;\n  let digitCount27 = 0;\n  let digitCount28 = 0;\n  let digitCount29 = 0;\n  let digitCount30 = 0;\n  let digitCount31 = 0;\n  let digitCount32 = 0;\n  let digitCount33 = 0;\n  let digitCount34 = 0;\n  let digitCount35 = 0;\n  let digitCount36 = 0;\n  let digitCount37 = 0;\n  let digitCount38 = 0;\n  let digitCount39 = 0;\n  let digitCount40 = 0;\n  let digitCount41 = 0;\n  let digitCount42 = 0;\n  let digitCount43 = 0;\n  let digitCount44 = 0;\n  let digitCount45 = 0;\n  let digitCount46 = 0;\n  let digitCount47 = 0;\n  let digitCount48 = 0;\n  let digitCount49 = 0;\n  let digitCount50 = 0;\n  let digitCount51 = 0;\n  let digitCount52 = 0;\n  let digitCount53 = 0;\n  let digitCount54 = 0;\n  let digitCount55 = 0;\n  let digitCount56 = 0;\n  let digitCount57 = 0;\n  let digitCount58 = 0;\n  let digitCount59 = 0;\n  let digitCount60 = 0;\n  let digitCount61 = 0;\n  let digitCount62 = 0;\n  let digitCount63 = 0;\n  let digitCount64 = 0;\n  let digitCount65 = 0;\n  let digitCount66 = 0;\n  let digitCount67 = 0;\n  let digitCount68 = 0;\n  let digitCount69 = 0;\n  let digitCount70 = 0;\n  let digitCount71 = 0;\n  let digitCount72 = 0;\n  let digitCount73 = 0;\n  let digitCount74 = 0;\n  let digitCount75 = 0;\n  let digitCount76 = 0;\n  let digitCount77 = 0;\n  let digitCount78 = 0;\n  let digitCount79 = 0;\n  let digitCount80 = 0;\n  let digitCount81 = 0;\n  let digitCount82 = 0;\n  let digitCount83 = 0;\n  let digitCount84 = 0;\n  let digitCount85 = 0;\n  let digitCount86 = 0;\n  let digitCount87 = 0;\n  let digitCount88 = 0;\n  let digitCount89 = 0;\n  let digitCount90 = 0;\n  let digitCount91 = 0;\n  let digitCount92 = 0;\n  let digitCount93 = 0;\n  let digitCount94 = 0;\n  let digitCount95 = 0;\n  let digitCount96 = 0;\n  let digitCount97 = 0;\n  let digitCount98 = 0;\n  let digitCount99 = 0;\n  let digitCount100 = 0;\n  let digitCount101 = 0;\n  let digitCount102 = 0;\n  let digitCount103 = 0;\n  let digitCount104 = 0;\n  let digitCount105 = 0;\n  let digitCount106 = 0;\n  let digitCount107 = 0;\n  let digitCount108 = 0;\n  let digitCount109 = 0;\n  let digitCount110 = 0;\n  let digitCount111 = 0;\n  let digitCount112 = 0;\n  let digitCount113 = 0;\n  let digitCount114 = 0;\n  let digitCount115 = 0;\n  let digitCount116 = 0;\n  let digitCount117 = 0;\n  let digitCount118 = 0;\n  let digitCount119 = 0;\n  let digitCount120 = 0;\n  let digitCount121 = 0;\n  let digitCount122 = 0;\n  let digitCount123 = 0;\n  let digitCount124 = 0;\n  let digitCount125 = 0;\n  let digitCount126 = 0;\n  let digitCount127 = 0;\n  let digitCount128 = 0;\n  let digitCount129 = 0;\n  let digitCount130 = 0;\n  let digitCount131 = 0;\n  let digitCount132 = 0;\n  let digitCount133 = 0;\n  let digitCount134 = 0;\n  let digitCount135 = 0;\n  let digitCount136 = 0;\n  let digitCount137 = 0;\n  let digitCount138 = 0;\n  let digitCount139 = 0;\n  let digitCount140 = 0;\n  let digitCount141 = 0;\n  let digitCount142 = 0;\n  let digitCount143 = 0;\n  let digitCount144 = 0;\n  let digitCount145 = 0;\n  let digitCount146 = 0;\n  let digitCount147 = 0;\n  let digitCount148 = 0;\n  let digitCount149 = 0;\n  let digitCount150 = 0;\n  let digitCount151 = 0;\n  let digitCount152 = 0;\n  let digitCount153 = 0;\n  let digitCount154 = 0;\n  let digitCount155 = 0;\n  let digitCount156 = 0;\n  let digitCount157 = 0;\n  let digitCount158 = 0;\n  let digitCount159 = 0;\n  let digitCount160 = 0;\n  let digitCount161 = 0;\n  let digitCount162 = 0;\n  let digitCount163 = 0;\n  let digitCount164 = 0;\n  let digitCount165 = 0;\n  let digitCount166 = 0;\n  let digitCount167 = 0;\n  let digitCount168 = 0;\n  let digitCount169 = 0;\n  let digitCount170 = 0;\n  let digitCount171 = 0;\n  let digitCount172 = 0;\n  let digitCount173 = 0;\n  let digitCount174 = 0;\n  let digitCount175 = 0;\n  let digitCount176 = 0;\n  let digitCount177 = 0;\n  let digitCount178 = 0;\n  let digitCount179 = 0;\n  let digitCount180 = 0;\n  let digitCount181 = 0;\n  let digitCount182 = 0;\n  let digitCount183 = 0;\n  let digitCount184 = 0;\n  let digitCount185 = 0;\n  let digitCount186 = 0;\n  let digitCount187 = 0;\n  let digitCount188 = 0;\n  let digitCount189 = 0;\n  let digitCount190 = 0;\n  let digitCount191 = 0;\n  let digitCount192 = 0;\n  let digitCount193 = 0;\n  let digitCount194 = 0;\n  let digitCount195 = 0;\n  let digitCount196 = 0;\n  let digitCount197 = 0;\n  let digitCount198 = 0;\n  let digitCount199 = 0;\n  let digitCount200 = 0;\n  let digitCount201 = 0;\n  let digitCount202 = 0;\n  let digitCount203 = 0;\n  let digitCount204 = 0;\n  let digitCount205 = 0;\n  let digitCount206 = 0;\n  let digitCount207 = 0;\n  let digitCount208 = 0;\n  let digitCount209 = 0;\n  let digitCount210 = 0;\n  let digitCount211 = 0;\n  let digitCount212 = 0;\n  let digitCount213 = 0;\n  let digitCount214 = 0;\n  let digitCount215 = 0;\n  let digitCount216 = 0;\n  let digitCount217 = 0;\n  let digitCount218 = 0;\n  let digitCount219 = 0;\n  let digitCount220 = 0;\n  let digitCount221 = 0;\n  let digitCount222 = 0;\n  let digitCount223 = 0;\n  let digitCount224 = 0;\n  let digitCount225 = 0;\n  let digitCount226 = 0;\n  let digitCount227 = 0;\n  let digitCount228 = 0;\n  let digitCount229 = 0;\n  let digitCount230 = 0;\n  let digitCount231 = 0;\n  let digitCount232 = 0;\n  let digitCount233 = 0;\n  let digitCount234 = 0;\n  let digitCount235 = 0;\n  let digitCount236 = 0;\n  let digitCount237 = 0;\n  let digitCount238 = 0;\n  let digitCount239 = 0;\n  let digitCount240 = 0;\n  let digitCount241 = 0;\n  let digitCount242 = 0;\n  let digitCount243 = 0;\n  let digitCount244 = 0;\n  let digitCount245 = 0;\n  let digitCount246 = 0;\n  let digit", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMinRioman(19) == 'xix'\n  >>> intToMinRioman(152) == 'clii'\n  >>> intToMinRioman(426) == 'cdxxvi'\n  */\nconst intToMinRioman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMinRioman", "gc": "<|endoftext|>/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMinRioman(19) == 'xix'\n  >>> intToMinRioman(152) == 'clii'\n  >>> intToMinRioman(426) == 'cdxxvi'\n  */\nconst intToMinRioman = (number) => {\n  const numStr = number.toString()\n  const numStrArr = numStr.split('')\n  const numStrArrLen = numStrArr.length\n  let numStrArrLenMinusOne = numStrArrLen - 1\n  let numStrArrLenPlusOne = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusOne = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusOne = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusTwo = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusTwo = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusThree = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusThree = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusFour = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusFour = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusFive = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusFive = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusSix = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusSix = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusSeven = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusSeven = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusEight = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusEight = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusNine = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusNine = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusTen = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusTen = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusEleven = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusEleven = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusTwelve = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusTwelve = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusThirteen = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusThirteen = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusFourteen = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusFourteen = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusFifteen = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusFifteen = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusSixteen = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusSixteen = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusSeventeen = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusSeventeen = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusEighteen = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusEighteen = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusNineteen = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusNineteen = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusTwenty = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusTwenty = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusThirty = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusThirty = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusFourty = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusFourty = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusFifty = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusFifty = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusSixty = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusSixty = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusSeventy = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusSeventy = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusEighty = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusEighty = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusNinety = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusNinety = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusTwentyOne = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusTwentyOne = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusTwentyTwo = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusTwentyTwo = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusTwentyThree = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusTwentyThree = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusTwentyFour = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusTwentyFour = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusTwentyFive = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusTwentyFive = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusTwentySix = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusTwentySix = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusTwentySeven = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusTwentySeven = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusTwentyEight = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusTwentyEight = numStrArrLen + 1\n  let numStrArrLenMinusOneMinusTwentyNine = numStrArrLen - 1\n  let numStrArrLenPlusOneMinusTwentyNine = numStrArrLen + 1\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled triangle is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngelTriangle(3, 4, 5) == true\n  rightAngelTriangle(1, 2, 3) == false\n  */\nconst rightAngelTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngelTriangle", "gc": "<|endoftext|>/*\n Given the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled triangle is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngelTriangle(3, 4, 5) == true\n  rightAngelTriangle(1, 2, 3) == false\n  */\nconst rightAngelTriangle = (a, b, c) => {\n  const a1 = Math.cos(a * Math.PI / 180);\n  const a2 = Math.sin(a * Math.PI / 180);\n  const b1 = Math.cos(b * Math.PI / 180);\n  const b2 = Math.sin(b * Math.PI / 180);\n  const c1 = Math.cos(c * Math.PI / 180);\n  const c2 = Math.sin(c * Math.PI / 180);\n  const denom = a1 * b2 - a2 * b1;\n  const numer = a1 * c2 - a2 * c1;\n  const denom2 = a1 * b1 * b2 - a2 * b1 * b1;\n  const numer = a1 * c1 * c2 - a2 * c1 * c1;\n  return denom === 0 && numer === 0 && denom2 === 0 && numer === denom2;\n};\n\nconst rightAngelTriangle2 = (a, b, c) => {\n  const a1 = Math.cos(a * Math.PI / 180);\n  const a2 = Math.sin(a * Math.PI / 180);\n  const b1 = Math.cos(b * Math.PI / 180);\n  const b2 = Math.sin(b * Math.PI / 180);\n  const c1 = Math.cos(c * Math.PI / 180);\n  const c2 = Math.sin(c * Math.PI / 180);\n  const denom = a1 * b2 - a2 * b1;\n  const numer = a1 * c2 - a2 * c1;\n  const denom2 = a1 * b1 * b2 - a2 * b1 * b1;\n  const numer = a1 * c1 * c2 - a2 * c1 * c1;\n  return denom === 0 && numer === 0 && denom2 === 0 && numer === denom2;\n};\n\nconst rightAngelTriangle3 = (a, b, c) => {\n  const a1 = Math.cos(a * Math.PI / 180);\n  const a2 = Math.sin(a * Math.PI / 180);\n  const b1 = Math.cos(b * Math.PI / 180);\n  const b2 = Math.sin(b * Math.PI / 180);\n  const c1 = Math.cos(c * Math.PI / 180);\n  const c2 = Math.sin(c * Math.PI / 180);\n  const denom = a1 * b2 - a2 * b1;\n  const numer = a1 * c2 - a2 * c1;\n  const denom2 = a1 * b1 * b2 - a2 * b1 * b1;\n  const numer = a1 * c1 * c2 - a2 * c1 * c1;\n  return denom === 0 && numer === 0 && denom2 === 0 && numer === denom2;\n};\n\nconst rightAngelTriangle4 = (a, b, c) => {\n  const a1 = Math.cos(a * Math.PI / 180);\n  const a2 = Math.sin(a * Math.PI / 180);\n  const b1 = Math.cos(b * Math.PI / 180);\n  const b2 = Math.sin(b * Math.PI / 180);\n  const c1 = Math.cos(c * Math.PI / 180);\n  const c2 = Math.sin(c * Math.PI / 180);\n  const denom = a1 * b2 - a2 * b1;\n  const numer = a1 * c2 - a2 * c1;\n  const denom2 = a1 * b1 * b2 - a2 * b1 * b1;\n  const numer = a1 * c1 * c2 - a2 * c1 * c1;\n  return denom === 0 && numer === 0 && denom2 === 0 && numer === denom2;\n};\n\nconst rightAngelTriangle5 = (a, b, c) => {\n  const a1 = Math.cos(a * Math.PI / 180);\n  const a2 = Math.sin(a * Math.PI / 180);\n  const b1 = Math.cos(b * Math.PI / 180);\n  const b2 = Math.sin(b * Math.PI / 180);\n  const c1 = Math.cos(c * Math.PI / 180);\n  const c2 = Math.sin(c * Math.PI / 180);\n  const denom = a1 * b2 - a2 * b1;\n  const numer = a1 * c2 - a2 * c1;\n  const denom2 = a1 * b1 * b2 - a2 * b1 * b1;\n  const numer = a1 * c1 * c2 - a2 * c1 * c1;\n  return denom === 0 && numer === 0 && denom2 === 0 && numer === denom2;\n};\n\nconst rightAngelTriangle6 = (a, b, c) => {\n  const a1 = Math.cos(a * Math.PI / 180);\n  const a2 = Math.sin(a * Math.PI / 180);\n  const b1 = Math.cos(b * Math.PI / 180);\n  const b2 = Math.sin(b * Math.PI / 180);\n  const c1 = Math.cos(c * Math.PI / 180);\n  const c2 = Math.sin(c * Math.PI / 180);\n  const denom = a1 * b2 - a2 * b1;\n  const numer = a1 * c2 - a2 * c1;\n  const denom2 = a1 * b1 * b2 - a2 * b1 * b1;\n  const numer = a1 * c1 * c2 - a2 * c1 * c1;\n  return denom === 0 && numer === 0 && denom2 === 0 && numer === denom2;\n};\n\nconst rightAngelTriangle7 = (a, b, c) => {\n  const a1 = Math.cos(a * Math.PI / 180);\n  const a2 = Math.sin(a * Math.PI / 180);\n  const b1 = Math.cos(b * Math.PI / 180);\n  const b2 = Math.sin(b * Math.PI / 180);\n  const c1 = Math.cos(c * Math.PI / 180);\n  const c2 = Math.sin(c * Math.PI / 180);\n  const denom = a1 * b2 - a2 * b1;\n  const numer = a1 * c2 - a2 * c1;\n  const denom2 = a1 * b1 * b2 - a2 * b1 * b1;\n  const numer = a1 * c1 * c2 - a2 * c1 * c1;\n  return denom === 0 && numer === 0 && denom2 === 0 && numer === denom2;\n};\n\nconst rightAngelTriangle8 = (a, b, c) => {\n  const a1 = Math.cos(a * Math.PI / 180);\n  const a2 = Math.sin(a * Math.PI / 180);\n  const b1 = Math.cos(b * Math.PI / 180);\n  const b2 = Math.sin(b * Math.PI / 180);\n  const c1 = Math.cos(c * Math.PI / 180);\n  const c2 = Math.sin(c * Math.PI / 180);\n  const denom = a1 * b2 - a2 * b1;\n  const numer = a1 * c2 - a2 * c1;\n  const denom2 = a1 * b1 * b2 - a2 * b1 * b1;\n  const numer = a1 * c1 * c2 - a2 * c1 * c1;\n  return denom === 0 && numer === 0 && denom2 === 0 && numer === denom2;\n};\n\nconst rightAngelTriangle9 = (a, b, c) => {\n  const a1 = Math.cos(a * Math.PI / 180);\n  const a2 = Math.sin(a * Math.PI / 180);\n  const b1 = Math.cos(b * Math.PI / 180);\n  const b2 = Math.sin(b * Math.PI / 180);\n  const c1 = Math.cos(c * Math.PI / 180);\n  const c2 = Math.sin", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "gc": "<|endoftext|>/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  let max = 0;\n  let maxWord = '';\n  let maxChar = 0;\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const chars = word.length;\n    if (chars > maxChar) {\n      maxChar = chars;\n      maxWord = word;\n    }\n    if (chars === maxChar) {\n      max++;\n    }\n  }\n  return maxWord;\n};\n\n/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMin = (words) => {\n  let min = 0;\n  let minWord = '';\n  let minChar = 0;\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const chars = word.length;\n    if (chars < minChar) {\n      minChar = chars;\n      minWord = word;\n    }\n    if (chars === minChar) {\n      min++;\n    }\n  }\n  return minWord;\n};\n\n/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with minimum number\n  of unique characters. If multiple strings have minimum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMin([\"name\", \"of\", \"string\"]) === \"string\"\n  findMin([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMin([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMinMax = (words) => {\n  let min = 0;\n  let max = 0;\n  let minWord = '';\n  let maxWord = '';\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const chars = word.length;\n    if (chars < min) {\n      min = chars;\n      minWord = word;\n    }\n    if (chars > max) {\n      max = chars;\n      maxWord = word;\n    }\n  }\n  return maxWord;\n};\n\n/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with minimum number\n  of unique characters. If multiple strings have minimum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMinMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMinMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMinMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMinMaxMin = (words) => {\n  let min = 0;\n  let max = 0;\n  let minWord = '';\n  let maxWord = '';\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const chars = word.length;\n    if (chars < min) {\n      min = chars;\n      minWord = word;\n    }\n    if (chars > max) {\n      max = chars;\n      maxWord = word;\n    }\n  }\n  return minWord;\n};\n\n/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMinMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMinMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMinMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMinMaxMax = (words) => {\n  let min = 0;\n  let max = 0;\n  let minWord = '';\n  let maxWord = '';\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const chars = word.length;\n    if (chars < min) {\n      min = chars;\n      minWord = word;\n    }\n    if (chars > max) {\n      max = chars;\n      maxWord = word;\n    }\n  }\n  return maxWord;\n};\n\n/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with minimum number\n  of unique characters. If multiple strings have minimum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMinMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMinMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMinMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMinMaxMinMax = (words) => {\n  let min = 0;\n  let max = 0;\n  let minWord = '';\n  let maxWord = '';\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const chars = word.length;\n    if (chars < min) {\n      min = chars;\n      minWord = word;\n    }\n    if (chars > max) {\n      max = chars;\n      maxWord = word;\n    }\n  }\n  return minWord;\n};\n\n/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMinMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMinMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMinMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMinMaxMaxMinMax = (words) => {\n  let min = 0;\n  let max = 0;\n  let minWord = '';\n  let maxWord = '';\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const chars = word.length;\n    if (chars < min) {\n      min = chars;\n      minWord = word;\n    }\n    if (chars > max) {\n      max = chars;\n      maxWord = word;\n    }\n  }\n  return maxWord;\n};\n\n/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with minimum number\n  of unique characters. If multiple strings have minimum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMinMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMinMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMinMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMinMaxMinMaxMinMax = (words) => {\n  let min = 0;\n  let max = 0;\n  let minWord = '';\n  let maxWord = '';\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const chars = word.length;\n    if (chars < min) {\n      min = chars;\n      minWord = word;\n    }\n    if (chars > max) {\n      max = chars;\n      maxWord = word;\n    }\n  }\n  return minWord;\n};\n\n/*Write a ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "gc": "<|endoftext|>/*\n  You're a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  let result = [];\n  let remaining = Math.min(remaining, need);\n  let remainder = Math.floor(remaining / number);\n  let remainderRemaining = remaining % number;\n  let remainderRemainderRemaining = remainderRemaining % number;\n  let remainderRemainderRemainderRemaining = remainderRemainderRemainderRemaining % number;\n  let remainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder % number;\n  let remainderRemainderRemainderRemainderRemainderRemainderRemainderRemainder = remain", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/16", "prompt": "/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "gc": "<|endoftext|>/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    count += chars[i].length;\n  }\n  return count;\n};\n\n/**\n * Given a string, find the longest common subsequence (LCS) of a given string.\n * https://leetcode.com/problems/longest-common-subsequence/\n * Given two strings s and t, find the longest common subsequence (LCS) where s[i] == t[j].\n * https://leetcode.com/problems/longest-common-subsequence/discuss/434/LCS-problem\n * Given two strings s and t, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * https://leetcode.com/problems/longest-common-subsequence/discuss/434/LCS-problem\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * https://leetcode.com/problems/longest-common-subsequence/discuss/434/LCS-problem\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * https://leetcode.com/problems/longest-common-subsequence/discuss/434/LCS-problem\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * https://leetcode.com/problems/longest-common-subsequence/discuss/434/LCS-problem\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * https://leetcode.com/problems/longest-common-subsequence/discuss/434/LCS-problem\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * https://leetcode.com/problems/longest-common-subsequence/discuss/434/LCS-problem\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * https://leetcode.com/problems/longest-common-subsequence/discuss/434/LCS-problem\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * https://leetcode.com/problems/longest-common-subsequence/discuss/434/LCS-problem\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * https://leetcode.com/problems/longest-common-subsequence/discuss/434/LCS-problem\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * https://leetcode.com/problems/longest-common-subsequence/discuss/434/LCS-problem\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * https://leetcode.com/problems/longest-common-subsequence/discuss/434/LCS-problem\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * https://leetcode.com/problems/longest-common-subsequence/discuss/434/LCS-problem\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * https://leetcode.com/problems/longest-common-subsequence/discuss/434/LCS-problem\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * https://leetcode.com/problems/longest-common-subsequence/discuss/434/LCS-problem\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * https://leetcode.com/problems/longest-common-subsequence/discuss/434/LCS-problem\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * https://leetcode.com/problems/longest-common-subsequence/discuss/434/LCS-problem\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * https://leetcode.com/problems/longest-common-subsequence/discuss/434/LCS-problem\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * Given a string s, find the longest common subsequence (LCS) where s[i] == t[j] and s[i] == t[k] and s[i] == t[l].\n * Given ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "gc": "<|endoftext|>/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('+')\n  const result = []\n  for (let i = 0; i < operatorList.length; i++) {\n    const operator = operatorList[i]\n    const operand = operandList[i]\n    const operatorIndex = operatorList.indexOf(operator)\n    const operandIndex = operandList.indexOf(operand)\n    if (operatorIndex === -1 || operandIndex === -1) {\n      result.push(`Invalid operator: ${operator}`)\n    } else {\n      result.push(operatorList[operatorIndex] + operandList[operandIndex])\n    }\n  }\n  return result.join('+')\n}\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('+')\n  const result = []\n  for (let i = 0; i < operatorList.length; i++) {\n    const operator = operatorList[i]\n    const operand = operandList[i]\n    const operatorIndex = operatorList.indexOf(operator)\n    const operandIndex = operandList.indexOf(operand)\n    if (operatorIndex === -1 || operandIndex === -1) {\n      result.push(`Invalid operator: ${operator}`)\n    } else {\n      result.push(operatorList[operatorIndex] + operandList[operandIndex])\n    }\n  }\n  return result.join('+')\n}\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('+')\n  const result = []\n  for (let i = 0; i < operatorList.length; i++) {\n    const operator = operatorList[i]\n    const operand = operandList[i]\n    const operatorIndex = operatorList.indexOf(operator)\n    const operandIndex = operandList.indexOf(operand)\n    if (operatorIndex === -1 || operandIndex === -1) {\n      result.push(`Invalid operator: ${operator}`)\n    } else {\n      result.push(operatorList[operatorIndex] + operandList[operandIndex])\n    }\n  }\n  return result.join('+')\n}\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('+')\n  const result = []\n  for (let i = 0; i < operatorList.length; i++) {\n    const operator = operatorList[i]\n    const operand = operandList[i]\n    const operatorIndex = operatorList.indexOf(operator)\n    const operandIndex = operandList.indexOf(operand)\n    if (operatorIndex === -1 || operandIndex === -1) {\n      result.push(`Invalid operator: ${operator}`)\n    } else {\n      result.push(operatorList[operatorIndex] + operandList[operandIndex])\n    }\n  }\n  return result.join('+')\n}\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('+')\n  const result = []\n  for (let i = 0; i < operatorList.length; i++) {\n    const operator = operatorList[i]\n    const operand = operandList[i]\n    const operatorIndex = operatorList.indexOf(operator)\n    const operandIndex = operandList.indexOf(operand)\n    if (operatorIndex === -1 || operandIndex === -1) {\n      result.push(`Invalid operator: ${operator}`)\n    } else {\n      result.push(operatorList[operatorIndex] + operandList[operandIndex])\n    }\n  }\n  return result.join('+')\n}\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/161", "prompt": "/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "gc": "<|endoftext|>/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let result = '';\n  let len = s.length;\n  let i = 0;\n  let j = 0;\n  let temp = '';\n  \n  while(i < len) {\n    if(s[i] >= 'a' && s[i] <= 'z') {\n      temp = s[i];\n      s[i] = s[i] - 'a' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= 'A' && s[i] <= 'Z') {\n      temp = s[i];\n      s[i] = s[i] - 'A' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '0' && s[i] <= '9') {\n      temp = s[i];\n      s[i] = s[i] - '0' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '!' && s[i] <= '@') {\n      temp = s[i];\n      s[i] = s[i] - '!' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '#' && s[i] <= '$') {\n      temp = s[i];\n      s[i] = s[i] - '#' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '$' && s[i] <= '&') {\n      temp = s[i];\n      s[i] = s[i] - '$' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '&' && s[i] <= '^') {\n      temp = s[i];\n      s[i] = s[i] - '&' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '^' && s[i] <= '`') {\n      temp = s[i];\n      s[i] = s[i] - '^' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '`' && s[i] <= '~') {\n      temp = s[i];\n      s[i] = s[i] - '`' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '~' && s[i] <= '[') {\n      temp = s[i];\n      s[i] = s[i] - '~' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '[' && s[i] <= ']') {\n      temp = s[i];\n      s[i] = s[i] - '[';\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= ']' && s[i] <= '^') {\n      temp = s[i];\n      s[i] = s[i] - ']' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '^' && s[i] <= '`') {\n      temp = s[i];\n      s[i] = s[i] - '^' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '`' && s[i] <= '~') {\n      temp = s[i];\n      s[i] = s[i] - '`' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '~' && s[i] <= '[') {\n      temp = s[i];\n      s[i] = s[i] - '~' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '[' && s[i] <= ']') {\n      temp = s[i];\n      s[i] = s[i] - '[';\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= ']' && s[i] <= '^') {\n      temp = s[i];\n      s[i] = s[i] - ']' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '^' && s[i] <= '`') {\n      temp = s[i];\n      s[i] = s[i] - '^' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '`' && s[i] <= '~') {\n      temp = s[i];\n      s[i] = s[i] - '`' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '~' && s[i] <= '[') {\n      temp = s[i];\n      s[i] = s[i] - '~' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '[' && s[i] <= ']') {\n      temp = s[i];\n      s[i] = s[i] - '[';\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= ']' && s[i] <= '^') {\n      temp = s[i];\n      s[i] = s[i] - ']' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '^' && s[i] <= '`') {\n      temp = s[i];\n      s[i] = s[i] - '^' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '`' && s[i] <= '~') {\n      temp = s[i];\n      s[i] = s[i] - '`' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '~' && s[i] <= '[') {\n      temp = s[i];\n      s[i] = s[i] - '~' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '[' && s[i] <= ']') {\n      temp = s[i];\n      s[i] = s[i] - '[';\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= ']' && s[i] <= '^') {\n      temp = s[i];\n      s[i] = s[i] - ']' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '^' && s[i] <= '`') {\n      temp = s[i];\n      s[i] = s[i] - '^' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '`' && s[i] <= '~') {\n      temp = s[i];\n      s[i] = s[i] - '`' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '~' && s[i] <= '[') {\n      temp = s[i];\n      s[i] = s[i] - '~' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '[' && s[i] <= ']') {\n      temp = s[i];\n      s[i] = s[i] - '[';\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= ']' && s[i] <= '^') {\n      temp = s[i];\n      s[i] = s[i] - ']' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '^' && s[i] <= '`') {\n      temp = s[i];\n      s[i] = s[i] - '^' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '`' && s[i] <= '~') {\n      temp = s[i];\n      s[i] = s[i] - '`' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '~' && s[i] <= '[') {\n      temp = s[i];\n      s[i] = s[i] - '~' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '[' && s[i] <= ']') {\n      temp = s[i];\n      s[i] = s[i] - '[';\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= ']' && s[i] <= '^') {\n      temp = s[i];\n      s[i] = s[i] - ']' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '^' && s[i] <= '`') {\n      temp = s[i];\n      s[i] = s[i] - '^' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '`' && s[i] <= '~') {\n      temp = s[i];\n      s[i] = s[i] - '`' + 1;\n      s[i + 1] = temp;\n    }\n    \n    if(s[i] >= '~' && s[i] <= '[') {\n      temp = s[i];\n      s[i] = s[i] - '~' + 1;\n      s[i + 1] = temp;\n    }\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "gc": "<|endoftext|>/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5Hex = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5B64 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('base64');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5HexB64 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5B64Hex = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('base64');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5HexB64Hex = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5B64B64 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('base64');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5HexB64B64 = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5B64B64Hex = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('base64');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5HexB64HexHex = (text) => {\n  if (!text) {\n    return null;\n  }\n  const md5Hash = crypto.createHash('md5');\n  md5Hash.update(text);\n  return md5Hash.digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64B64", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two positive integers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "gc": "<|endoftext|>/*\n  Given two positive integers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const result = [];\n  let i = a;\n  let j = b;\n  while (i || j) {\n    if (i && j) {\n      result.push(i);\n      i = Math.floor(i / 10);\n      j = Math.floor(j / 10);\n    } else if (i) {\n      result.push(i);\n      i = Math.floor(i / 10);\n    } else if (j) {\n      result.push(j);\n      j = Math.floor(j / 10);\n    }\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest power of 10 greater than or equal to n.\n */\nconst getLargestPowerOfTen = n => {\n  let result = 1;\n  while (n > 0) {\n    result = result * 10;\n    n = Math.floor(n / 10);\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the smallest power of 10 less than or equal to n.\n */\nconst getSmallestPowerOfTen = n => {\n  let result = 1;\n  while (n > 0) {\n    result = result / 10;\n    n = Math.floor(n / 10);\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest power of 2 greater than or equal to n.\n */\nconst getLargestPowerOfTwo = n => {\n  let result = 1;\n  while (n > 0) {\n    result = result * 2;\n    n = Math.floor(n / 2);\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the smallest power of 2 less than or equal to n.\n */\nconst getSmallestPowerOfTwo = n => {\n  let result = 1;\n  while (n > 0) {\n    result = result / 2;\n    n = Math.floor(n / 2);\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest power of 2 greater than or equal to n.\n */\nconst getLargestPowerOfTwoWithFactor = n => {\n  let result = 1;\n  while (n > 0) {\n    result = result * 2;\n    n = Math.floor(n / 2);\n    if (n % 2 === 0) {\n      result = result / 2;\n    }\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the smallest power of 2 less than or equal to n.\n */\nconst getSmallestPowerOfTwoWithFactor = n => {\n  let result = 1;\n  while (n > 0) {\n    result = result / 2;\n    n = Math.floor(n / 2);\n    if (n % 2 === 0) {\n      result = result / 2;\n    }\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest power of 2 greater than or equal to n.\n */\nconst getLargestPowerOfTwoWithFactorAndFactor = n => {\n  let result = 1;\n  while (n > 0) {\n    result = result * 2;\n    n = Math.floor(n / 2);\n    if (n % 2 === 0) {\n      result = result / 2;\n    }\n    if (n % 3 === 0) {\n      result = result / 3;\n    }\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the smallest power of 2 less than or equal to n.\n */\nconst getSmallestPowerOfTwoWithFactorAndFactor = n => {\n  let result = 1;\n  while (n > 0) {\n    result = result / 2;\n    n = Math.floor(n / 2);\n    if (n % 2 === 0) {\n      result = result / 2;\n    }\n    if (n % 3 === 0) {\n      result = result / 3;\n    }\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest power of 2 greater than or equal to n.\n */\nconst getLargestPowerOfTwoWithFactorAndFactorAndFactor = n => {\n  let result = 1;\n  while (n > 0) {\n    result = result * 2;\n    n = Math.floor(n / 2);\n    if (n % 2 === 0) {\n      result = result / 2;\n    }\n    if (n % 3 === 0) {\n      result = result / 3;\n    }\n    if (n % 5 === 0) {\n      result = result / 5;\n    }\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the smallest power of 2 less than or equal to n.\n */\nconst getSmallestPowerOfTwoWithFactorAndFactorAndFactor = n => {\n  let result = 1;\n  while (n > 0) {\n    result = result / 2;\n    n = Math.floor(n / 2);\n    if (n % 2 === 0) {\n      result = result / 2;\n    }\n    if (n % 3 === 0) {\n      result = result / 3;\n    }\n    if (n % 5 === 0) {\n      result = result / 5;\n    }\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest power of 2 greater than or equal to n.\n */\nconst getLargestPowerOfTwoWithFactorAndFactorAndFactorAndFactor = n => {\n  let result = 1;\n  while (n > 0) {\n    result = result * 2;\n    n = Math.floor(n / 2);\n    if (n % 2 === 0) {\n      result = result / 2;\n    }\n    if (n % 3 === 0) {\n      result = result / 3;\n    }\n    if (n % 5 === 0) {\n      result = result / 5;\n    }\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the smallest power of 2 less than or equal to n.\n */\nconst getSmallestPowerOfTwoWithFactorAndFactorAndFactorAndFactor = n => {\n  let result = 1;\n  while (n > 0) {\n    result = result / 2;\n    n = Math.floor(n / 2);\n    if (n % 2 === 0) {\n      result = result / 2;\n    }\n    if (n % 3 === 0) {\n      result = result / 3;\n    }\n    if (n % 5 === 0) {\n      result = result / 5;\n    }\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest power of 2 greater than or equal to n.\n */\nconst getLargestPowerOfTwoWithFactorAndFactorAndFactorAndFactorAndFactor = n => {\n  let result = 1;\n  while (n > 0) {\n    result = result * 2;\n    n = Math.floor(n / 2);\n    if (n % 2 === 0) {\n      result = result / 2;\n    }\n    if (n % 3 === 0) {\n      result = result / 3;\n    }\n    if (n % 5 === 0) {\n      result = result / 5;\n    }\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the smallest power of 2 less than or equal to n.\n */\nconst getSmallestPowerOfTwoWithFactorAndFactorAndFactorAndFactorAndFactor = n => {\n  let result = 1;\n  while (n > 0) {\n    result = result / 2;\n    n = Math.floor(n / 2);\n    if (n % 2 === 0) {\n      result = result / 2;\n    }\n    if (n % 3 === 0) {\n      result = result / 3;\n    }\n    if (n % 5 === 0) {\n      result = result / 5;\n    }\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the largest power of 2 greater than or equal to n.\n */\nconst getLargestPowerOfTwoWithFactorAndFactorAndFactorAndFactorAndFactorAndFactorAndFactor = n => {\n  let result = 1;\n  while (n > 0) {\n    result = result * 2;\n    n = Math.floor(n / 2);\n    if (n % 2 === 0) {\n      result = result / 2;\n    }\n    if (n % 3 === 0) {\n      result = result / 3;\n    }\n    if (n % 5 === 0) {\n      result = result / 5;\n    }\n  }\n  return result;\n};\n\n/**\n * Given a positive integer n, return the smallest power of 2 less than or equal to n.\n */\nconst getSmallestPowerOfTwoWithFactorAndFactorAndFactorAndFactorAndFactorAndFactorAndFactorAnd = n => {\n  let result = 1;\n  while (n > 0) {\n    result = result / 2;\n    n = Math.floor(n / 2);\n    if (n % 2 === 0) {\n      result = result / 2;\n    }\n    if (n % 3 === 0) {\n      result = result / 3;\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/17", "prompt": "/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "gc": "<|endoftext|>/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = music_string.split('|');\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split(' ');\n    const note_is_last = note.length === 1;\n    if (note_is_last) {\n      result.push(4);\n    } else {\n      result.push(note.length);\n    }\n  }\n  return result;\n};\n\n/**\n  Given a string, return a list of integers representing how many beats does each note last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseNotes('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes = (notes_string) => {\n  const notes = notes_string.split(' ');\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const note_is_last = note.length === 1;\n    if (note_is_last) {\n      result.push(4);\n    } else {\n      result.push(note.length);\n    }\n  }\n  return result;\n};\n\n/**\n  Given a string, return a list of integers representing how many beats does each note last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseNotes('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_no_bend = (notes_string) => {\n  const notes = notes_string.split(' ');\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const note_is_last = note.length === 1;\n    if (note_is_last) {\n      result.push(4);\n    } else {\n      result.push(note.length);\n    }\n  }\n  return result;\n};\n\n/**\n  Given a string, return a list of integers representing how many beats does each note last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseNotes('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_no_bend_no_bend = (notes_string) => {\n  const notes = notes_string.split(' ');\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const note_is_last = note.length === 1;\n    if (note_is_last) {\n      result.push(4);\n    } else {\n      result.push(note.length);\n    }\n  }\n  return result;\n};\n\n/**\n  Given a string, return a list of integers representing how many beats does each note last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseNotes('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_no_bend_no_bend_no_bend = (notes_string) => {\n  const notes = notes_string.split(' ');\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const note_is_last = note.length === 1;\n    if (note_is_last) {\n      result.push(4);\n    } else {\n      result.push(note.length);\n    }\n  }\n  return result;\n};\n\n/**\n  Given a string, return a list of integers representing how many beats does each note last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseNotes('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_no_bend_no_bend_no_bend_no_bend = (notes_string) => {\n  const notes = notes_string.split(' ');\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const note_is_last = note.length === 1;\n    if (note_is_last) {\n      result.push(4);\n    } else {\n      result.push(note.length);\n    }\n  }\n  return result;\n};\n\n/**\n  Given a string, return a list of integers representing how many beats does each note last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseNotes('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_no_bend_no_bend_no_bend_no_bend_no_bend = (notes_string) => {\n  const notes = notes_string.split(' ');\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const note_is_last = note.length === 1;\n    if (note_is_last) {\n      result.push(4);\n    } else {\n      result.push(note.length);\n    }\n  }\n  return result;\n};\n\n/**\n  Given a string, return a list of integers representing how many beats does each note last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseNotes('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_no_bend_no_bend_no_bend_no_bend_no_bend_no_bend = (notes_string) => {\n  const notes = notes_string.split(' ');\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i].split('|');\n    const note_is_last = note.length === 1;\n    if (note_is_last) {\n      result.push(4);\n    } else {\n      result.push(note.length);\n    }\n  }\n  return result;\n};\n\n/**\n  Given a string, return a list of integers representing how many beats does each note last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/18", "prompt": "/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "gc": "<|endoftext|>/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = string.length;\n  let m = substring? substring.split('') : [];\n  while (i < l && j < m) {\n    if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(i) === substring.charAt(j)) {\n      count++;\n      i++;\n      j++;\n    } else if (string.charAt(", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "gc": "<|endoftext|>/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  let sortedNumbers = numbers.split(' ').sort((a, b) => a - b);\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/2", "prompt": "/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNubmer(3.5)\n  0.5\n  */\nconst truncateNubmer = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNubmer", "gc": "<|endoftext|>/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNubmer(3.5)\n  0.5\n  */\nconst truncateNubmer = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNubmer(3.5)\n  3\n  */\nconst truncateNubmerInt = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part (decimal part).\n  >>> truncateNubmerInt(3.5)\n  3\n  */\nconst truncateNubmerIntDec = number => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part (integer part).\n  >>> truncateNubmerIntDec(3.5)\n  3.5\n  */\nconst truncateNubmerIntDec = number => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part (integer part).\n  >>> truncateNubmerIntDec(3.5)\n  3.5\n  */\nconst truncateNubmerIntDec = number => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part (decimal part).\n  >>> truncateNubmerIntDec(3.5)\n  3.5\n  */\nconst truncateNubmerIntDec = number => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part (decimal part).\n  >>> truncateNubmerIntDec(3.5)\n  3.5\n  */\nconst truncateNubmerIntDec = number => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part (decimal part).\n  >>> truncateNubmerIntDec(3.5)\n  3.5\n  */\nconst truncateNubmerIntDec = number => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part (decimal part).\n  >>> truncateNubmerIntDec(3.5)\n  3.5\n  */\nconst truncateNubmerIntDec = number => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part (decimal part).\n  >>> truncateNubmerIntDec(3.5)\n  3.5\n  */\nconst truncateNubmerIntDec = number => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part (decimal part).\n  >>> truncateNubmerIntDec(3.5)\n  3.5\n  */\nconst truncateNubmerIntDec = number => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part (decimal part).\n  >>> truncateNubmerIntDec(3.5)\n  3.5\n  */\nconst truncateNubmerIntDec = number => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part (decimal part).\n  >>> truncateNubmerIntDec(3.5)\n  3.5\n  */\nconst truncateNubmerIntDec = number => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part (decimal part).\n  >>> truncateNubmerIntDec(3.5)\n  3.5\n  */\nconst truncateNubmerIntDec = number => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part (decimal part).\n  >>> truncateNubmerIntDec(3.5)\n  3.5\n  */\nconst truncateNubmerIntDec = number => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n  other and return them in order (smaller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "gc": "<|endoftext|>/* From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n  other and return them in order (smaller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  let minDistance = Number.MAX_VALUE;\n  let minDistanceIndex = -1;\n  let minDistanceElement = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    const distance = numbers[i] - minDistanceElement;\n    if (distance < minDistance) {\n      minDistance = distance;\n      minDistanceIndex = i;\n      minDistanceElement = numbers[i];\n    }\n  }\n  return [minDistanceElement, minDistanceIndex];\n};\n\n/**\n  Given a number and a list containing numbers, return the number that is the closest to that number.\n  >>> findClosestNumber([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  2.0\n  >>> findClosestNumber([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  2.0\n  */\nconst findClosestNumber = (numbers) => {\n  let minDistance = Number.MAX_VALUE;\n  let minDistanceIndex = -1;\n  let minDistanceElement = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    const distance = numbers[i] - minDistanceElement;\n    if (distance < minDistance) {\n      minDistance = distance;\n      minDistanceIndex = i;\n      minDistanceElement = numbers[i];\n    }\n  }\n  return minDistanceElement;\n};\n\n/**\n  Given a number and a list containing numbers, return the number that is the closest to that number.\n  >>> findClosestNumbers([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  [2.0, 2.2]\n  >>> findClosestNumbers([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  [2.0, 2.0]\n  */\nconst findClosestNumbers = (numbers) => {\n  let minDistance = Number.MAX_VALUE;\n  let minDistanceIndex = -1;\n  let minDistanceElement = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    const distance = numbers[i] - minDistanceElement;\n    if (distance < minDistance) {\n      minDistance = distance;\n      minDistanceIndex = i;\n      minDistanceElement = numbers[i];\n    }\n  }\n  return [minDistanceElement, minDistanceIndex];\n};\n\n/**\n  Given a number and a list containing numbers, return the number that is the closest to that number.\n  >>> findClosestNumbers([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  [2.0, 2.2]\n  >>> findClosestNumbers([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  [2.0, 2.0]\n  */\nconst findClosestNumbersOrNull = (numbers) => {\n  let minDistance = Number.MAX_VALUE;\n  let minDistanceIndex = -1;\n  let minDistanceElement = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    const distance = numbers[i] - minDistanceElement;\n    if (distance < minDistance) {\n      minDistance = distance;\n      minDistanceIndex = i;\n      minDistanceElement = numbers[i];\n    }\n  }\n  return [minDistanceElement, minDistanceIndex];\n};\n\n/**\n  Given a number and a list containing numbers, return the number that is the closest to that number.\n  >>> findClosestNumbersOrNull([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  [2.0, 2.2]\n  >>> findClosestNumbersOrNull([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  [2.0, 2.0]\n  */\nconst findClosestNumbersOrNullOrNull = (numbers) => {\n  let minDistance = Number.MAX_VALUE;\n  let minDistanceIndex = -1;\n  let minDistanceElement = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    const distance = numbers[i] - minDistanceElement;\n    if (distance < minDistance) {\n      minDistance = distance;\n      minDistanceIndex = i;\n      minDistanceElement = numbers[i];\n    }\n  }\n  return [minDistanceElement, minDistanceIndex];\n};\n\n/**\n  Given a number and a list containing numbers, return the number that is the closest to that number.\n  >>> findClosestNumbersOrNullOrNull([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  [2.0, 2.2]\n  >>> findClosestNumbersOrNullOrNull([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  [2.0, 2.0]\n  */\nconst findClosestNumbersOrNullOrNullOrNull = (numbers) => {\n  let minDistance = Number.MAX_VALUE;\n  let minDistanceIndex = -1;\n  let minDistanceElement = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    const distance = numbers[i] - minDistanceElement;\n    if (distance < minDistance) {\n      minDistance = distance;\n      minDistanceIndex = i;\n      minDistanceElement = numbers[i];\n    }\n  }\n  return [minDistanceElement, minDistanceIndex];\n};\n\n/**\n  Given a number and a list containing numbers, return the number that is the closest to that number.\n  >>> findClosestNumbersOrNullOrNullOrNull([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  [2.0, 2.2]\n  >>> findClosestNumbersOrNullOrNullOrNullOrNull([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  [2.0, 2.0]\n  */\nconst findClosestNumbersOrNullOrNullOrNullOrNull = (numbers) => {\n  let minDistance = Number.MAX_VALUE;\n  let minDistanceIndex = -1;\n  let minDistanceElement = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    const distance = numbers[i] - minDistanceElement;\n    if (distance < minDistance) {\n      minDistance = distance;\n      minDistanceIndex = i;\n      minDistanceElement = numbers[i];\n    }\n  }\n  return [minDistanceElement, minDistanceIndex];\n};\n\n/**\n  Given a number and a list containing numbers, return the number that is the closest to that number.\n  >>> findClosestNumbersOrNullOrNullOrNullOrNull([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  [2.0, 2.2]\n  >>> findClosestNumbersOrNullOrNullOrNullOrNullOrNull([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  [2.0, 2.0]\n  */\nconst findClosestNumbersOrNullOrNullOrNullOrNullOrNull = (numbers) => {\n  let minDistance = Number.MAX_VALUE;\n  let minDistanceIndex = -1;\n  let minDistanceElement = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    const distance = numbers[i] - minDistanceElement;\n    if (distance < minDistance) {\n      minDistance = distance;\n      minDistanceIndex = i;\n      minDistanceElement = numbers[i];\n    }\n  }\n  return [minDistanceElement, minDistanceIndex];\n};\n\n/**\n  Given a number and a list containing numbers, return the number that is the closest to that number.\n  >>> findClosestNumbersOrNullOrNullOrNullOrNullOrNull([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  [2.0, 2.2]\n  >>> findClosestNumbersOrNullOrNullOrNullOrNullOrNull([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  [2.0, 2.0]\n  */\nconst findClosestNumbersOrNullOrNullOrNullOrNullOrNullOrNull = (numbers) => {\n  let minDistance = Number.MAX_VALUE;\n  let minDistanceIndex = -1;\n  let minDistanceElement = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    const distance = numbers[i] - minDistanceElement;\n    if (distance < minDistance) {\n      minDistance = distance;\n      minDistanceIndex = i;\n      minDistanceElement = numbers[i];\n    }\n  }", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleTonUit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleTonUit", "gc": "<|endoftext|>/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleTonUit = (numbers) => {\n  const [min, max] = numbers.map((n) => Math.min(n, 1))\n  return numbers.map((n) => n * min / max)\n}\n\n// Given a list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 2)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 3)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 4)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 5)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 6)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 7)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 8)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 9)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 10)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 11)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 12)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 13)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 14)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 15)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 16)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 17)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 18)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 19)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 20)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 21)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 22)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 23)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 24)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 25)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 26)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 27)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 28)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 29)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 30)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 31)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 32)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 33)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 34)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 35)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 36)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 37)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 38)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 39)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 40)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 41)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 42)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 43)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 44)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 45)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 46)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 47)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 48)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 49)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 50)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 51)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0], 52)\n// [0.0, 0.25, 0.5, 0.75, 1.0]\n// >>> rescal", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of any python values only for integers\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filetrItnegers", "gc": "<|endoftext|>/* Filter given list of any python values only for integers\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegers = (values) => {\n  return values.filter(value => typeof value === 'number' &&!isNaN(value))\n}\n\n/* Filter given list of any python values only for floats\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersFloats = (values) => {\n  return values.filter(value => typeof value === 'number' && isFinite(value))\n}\n\n/* Filter given list of any python values only for strings\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersStrings = (values) => {\n  return values.filter(value => typeof value ==='string')\n}\n\n/* Filter given list of any python values only for booleans\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersBools = (values) => {\n  return values.filter(value => typeof value === 'boolean')\n}\n\n/* Filter given list of any python values only for None\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersNones = (values) => {\n  return values.filter(value => value === null)\n}\n\n/* Filter given list of any python values only for empty lists\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyLists = (values) => {\n  return values.filter(value => Array.isArray(value) && value.length === 0)\n}\n\n/* Filter given list of any python values only for empty dictionaries\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyDicts = (values) => {\n  return values.filter(value => typeof value === 'object' &&!Object.keys(value).length)\n}\n\n/* Filter given list of any python values only for empty strings\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyStrings = (values) => {\n  return values.filter(value => typeof value ==='string' && value.length === 0)\n}\n\n/* Filter given list of any python values only for empty booleans\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyBools = (values) => {\n  return values.filter(value => typeof value === 'boolean' && value.length === 0)\n}\n\n/* Filter given list of any python values only for empty None\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyNones = (values) => {\n  return values.filter(value => value === null)\n}\n\n/* Filter given list of any python values only for empty lists\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyListsNones = (values) => {\n  return values.filter(value => Array.isArray(value) && value.length === 0)\n}\n\n/* Filter given list of any python values only for empty dictionaries\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyDictsNones = (values) => {\n  return values.filter(value => typeof value === 'object' &&!Object.keys(value).length)\n}\n\n/* Filter given list of any python values only for empty strings\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyStringsNones = (values) => {\n  return values.filter(value => typeof value ==='string' && value.length === 0)\n}\n\n/* Filter given list of any python values only for empty booleans\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyBoolsNones = (values) => {\n  return values.filter(value => typeof value === 'boolean' && value.length === 0)\n}\n\n/* Filter given list of any python values only for empty None\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyNonesNones = (values) => {\n  return values.filter(value => value === null)\n}\n\n/* Filter given list of any python values only for empty lists\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyListsEmptyLists = (values) => {\n  return values.filter(value => Array.isArray(value) && value.length === 0)\n}\n\n/* Filter given list of any python values only for empty dictionaries\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyDictsEmptyDicts = (values) => {\n  return values.filter(value => typeof value === 'object' &&!Object.keys(value).length)\n}\n\n/* Filter given list of any python values only for empty strings\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyStringsEmptyStrings = (values) => {\n  return values.filter(value => typeof value ==='string' && value.length === 0)\n}\n\n/* Filter given list of any python values only for empty booleans\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyBoolsEmptyBools = (values) => {\n  return values.filter(value => typeof value === 'boolean' && value.length === 0)\n}\n\n/* Filter given list of any python values only for empty None\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegers", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/23", "prompt": "/* Return length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "gc": "<|endoftext|>/* Return length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length\n}\n\n// Return true if given string starts with given prefix\nconst startsWith = (string, prefix) => {\n  return string.slice(0, prefix.length) === prefix\n}\n\n// Return true if given string ends with given suffix\nconst endsWith = (string, suffix) => {\n  return string.slice(string.length - suffix.length) === suffix\n}\n\n// Return true if given string contains given substring\nconst contains = (string, substring) => {\n  return string.indexOf(substring)!== -1\n}\n\n// Return true if given string starts with given substring\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring)\n}\n\n// Return true if given string ends with given substring\nconst endsWith = (string, substring) => {\n  return string.endsWith(substring)\n}\n\n// Return true if given string contains given substring\nconst contains = (string, substring) => {\n  return string.includes(substring)\n}\n\n// Return true if given string starts with given substring\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring)\n}\n\n// Return true if given string ends with given substring\nconst endsWith = (string, substring) => {\n  return string.endsWith(substring)\n}\n\n// Return true if given string contains given substring\nconst contains = (string, substring) => {\n  return string.includes(substring)\n}\n\n// Return true if given string starts with given substring\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring)\n}\n\n// Return true if given string ends with given substring\nconst endsWith = (string, substring) => {\n  return string.endsWith(substring)\n}\n\n// Return true if given string contains given substring\nconst contains = (string, substring) => {\n  return string.includes(substring)\n}\n\n// Return true if given string starts with given substring\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring)\n}\n\n// Return true if given string ends with given substring\nconst endsWith = (string, substring) => {\n  return string.endsWith(substring)\n}\n\n// Return true if given string contains given substring\nconst contains = (string, substring) => {\n  return string.includes(substring)\n}\n\n// Return true if given string starts with given substring\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring)\n}\n\n// Return true if given string ends with given substring\nconst endsWith = (string, substring) => {\n  return string.endsWith(substring)\n}\n\n// Return true if given string contains given substring\nconst contains = (string, substring) => {\n  return string.includes(substring)\n}\n\n// Return true if given string starts with given substring\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring)\n}\n\n// Return true if given string ends with given substring\nconst endsWith = (string, substring) => {\n  return string.endsWith(substring)\n}\n\n// Return true if given string contains given substring\nconst contains = (string, substring) => {\n  return string.includes(substring)\n}\n\n// Return true if given string starts with given substring\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring)\n}\n\n// Return true if given string ends with given substring\nconst endsWith = (string, substring) => {\n  return string.endsWith(substring)\n}\n\n// Return true if given string contains given substring\nconst contains = (string, substring) => {\n  return string.includes(substring)\n}\n\n// Return true if given string starts with given substring\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring)\n}\n\n// Return true if given string ends with given substring\nconst endsWith = (string, substring) => {\n  return string.endsWith(substring)\n}\n\n// Return true if given string contains given substring\nconst contains = (string, substring) => {\n  return string.includes(substring)\n}\n\n// Return true if given string starts with given substring\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring)\n}\n\n// Return true if given string ends with given substring\nconst endsWith = (string, substring) => {\n  return string.endsWith(substring)\n}\n\n// Return true if given string contains given substring\nconst contains = (string, substring) => {\n  return string.includes(substring)\n}\n\n// Return true if given string starts with given substring\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring)\n}\n\n// Return true if given string ends with given substring\nconst endsWith = (string, substring) => {\n  return string.endsWith(substring)\n}\n\n// Return true if given string contains given substring\nconst contains = (string, substring) => {\n  return string.includes(substring)\n}\n\n// Return true if given string starts with given substring\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring)\n}\n\n// Return true if given string ends with given substring\nconst endsWith = (string, substring) => {\n  return string.endsWith(substring)\n}\n\n// Return true if given string contains given substring\nconst contains = (string, substring) => {\n  return string.includes(substring)\n}\n\n// Return true if given string starts with given substring\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring)\n}\n\n// Return true if given string ends with given substring\nconst endsWith = (string, substring) => {\n  return string.endsWith(substring)\n}\n\n// Return true if given string contains given substring\nconst contains = (string, substring) => {\n  return string.includes(substring)\n}\n\n// Return true if given string starts with given substring\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring)\n}\n\n// Return true if given string ends with given substring\nconst endsWith = (string, substring) => {\n  return string.endsWith(substring)\n}\n\n// Return true if given string contains given substring\nconst contains = (string, substring) => {\n  return string.includes(substring)\n}\n\n// Return true if given string starts with given substring\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring)\n}\n\n// Return true if given string ends with given substring\nconst endsWith = (string, substring) => {\n  return string.endsWith(substring)\n}\n\n// Return true if given string contains given substring\nconst contains = (string, substring) => {\n  return string.includes(substring)\n}\n\n// Return true if given string starts with given substring\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring)\n}\n\n// Return true if given string ends with given substring\nconst endsWith = (string, substring) => {\n  return string.endsWith(substring)\n}\n\n// Return true if given string contains given substring\nconst contains = (string, substring) => {\n  return string.includes(substring)\n}\n\n// Return true if given string starts with given substring\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring)\n}\n\n// Return true if given string ends with given substring\nconst endsWith = (string, substring) => {\n  return string.endsWith(substring)\n}\n\n// Return true if given string contains given substring\nconst contains = (string, substring) => {\n  return string.includes(substring)\n}\n\n// Return true if given string starts with given substring\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring)\n}\n\n// Return true if given string ends with given substring\nconst endsWith = (string, substring) => {\n  return string.endsWith(substring)\n}\n\n// Return true if given string contains given substring\nconst contains = (string, substring) => {\n  return string.includes(substring)\n}\n\n// Return true if given string starts with given substring\nconst startsWith = (string, substring) => {\n  return string.startsWith(substring)\n}\n\n// Return true if given string end", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/24", "prompt": "/* For a given number n, find the largest number that divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "gc": "<|endoftext|>/* For a given number n, find the largest number that divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor += 1;\n  }\n  return divisor;\n};\n\n// Given a number n, find the largest number that divides n evenly, larger than n\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> largestDivisor(15)\n// 15\n// >>> ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/25", "prompt": "/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "gc": "<|endoftext|>/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let primeFactors = [];\n  let primeFactor = 1;\n  let primeFactorCount = 0;\n  while (primeFactorCount < n) {\n    primeFactorCount++;\n    if (n % primeFactor === 0) {\n      primeFactors.push(primeFactor);\n      primeFactor = 1;\n      i++;\n      j++;\n    } else {\n      primeFactor = primeFactor * primeFactor;\n    }\n    if (primeFactorCount > 100) {\n      primeFactors = [];\n      primeFactor = 1;\n      i++;\n      j++;\n    }\n  }\n  while (j < i) {\n    factors.push(factor);\n    factor = 1;\n    j++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize2 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let primeFactors = [];\n  let primeFactor = 1;\n  let primeFactorCount = 0;\n  let primeFactors = [];\n  while (primeFactorCount < n) {\n    primeFactorCount++;\n    if (n % primeFactor === 0) {\n      primeFactors.push(primeFactor);\n      primeFactor = 1;\n      i++;\n      j++;\n    } else {\n      primeFactor = primeFactor * primeFactor;\n    }\n    if (primeFactorCount > 100) {\n      primeFactors = [];\n      primeFactor = 1;\n      i++;\n      j++;\n    }\n  }\n  while (j < i) {\n    factors.push(factor);\n    factor = 1;\n    j++;\n  }\n  return primeFactors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize3 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let primeFactors = [];\n  let primeFactor = 1;\n  let primeFactorCount = 0;\n  let primeFactors = [];\n  while (primeFactorCount < n) {\n    primeFactorCount++;\n    if (n % primeFactor === 0) {\n      primeFactors.push(primeFactor);\n      primeFactor = 1;\n      i++;\n      j++;\n    } else {\n      primeFactor = primeFactor * primeFactor;\n    }\n    if (primeFactorCount > 100) {\n      primeFactors = [];\n      primeFactor = 1;\n      i++;\n      j++;\n    }\n  }\n  while (j < i) {\n    factors.push(factor);\n    factor = 1;\n    j++;\n  }\n  return primeFactors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize4 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let primeFactors = [];\n  let primeFactor = 1;\n  let primeFactorCount = 0;\n  let primeFactors = [];\n  while (primeFactorCount < n) {\n    primeFactorCount++;\n    if (n % primeFactor === 0) {\n      primeFactors.push(primeFactor);\n      primeFactor = 1;\n      i++;\n      j++;\n    } else {\n      primeFactor = primeFactor * primeFactor;\n    }\n    if (primeFactorCount > 100) {\n      primeFactors = [];\n      primeFactor = 1;\n      i++;\n      j++;\n    }\n  }\n  while (j < i) {\n    factors.push(factor);\n    factor = 1;\n    j++;\n  }\n  return primeFactors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize5 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let primeFactors = [];\n  let primeFactor = 1;\n  let primeFactorCount = 0;\n  let primeFactors = [];\n  while (primeFactorCount < n) {\n    primeFactorCount++;\n    if (n % primeFactor === 0) {\n      primeFactors.push(primeFactor);\n      primeFactor = 1;\n      i++;\n      j++;\n    } else {\n      primeFactor = primeFactor * primeFactor;\n    }\n    if (primeFactorCount > 100) {\n      primeFactors = [];\n      primeFactor = 1;\n      i++;\n      j++;\n    }\n  }\n  while (j < i) {\n    factors.push(factor);\n    factor = 1;\n    j++;\n  }\n  return primeFactors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize6 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let primeFactors = [];\n  let primeFactor = 1;\n  let primeFactorCount = 0;\n  let primeFactors = [];\n  while (primeFactorCount < n) {\n    primeFactorCount++;\n    if (n % primeFactor === 0) {\n      primeFactors.push(primeFactor);\n      primeFactor = 1;\n      i++;\n      j++;\n    } else {\n      primeFactor = primeFactor * primeFactor;\n    }\n    if (primeFactorCount > 100) {\n      primeFactors = [];\n      primeFactor = 1;\n      i++;\n      j++;\n    }\n  }\n  while (j < i) {\n    factors.push(factor);\n    factor = 1;\n    j++;\n  }\n  return primeFactors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize7 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 1;\n  let j = 1;\n", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers, remove all elements that occur more than once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "gc": "<|endoftext|>/* From a list of integers, remove all elements that occur more than once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    const number = numbers[i];\n    if (seen.has(number)) {\n      continue;\n    }\n    seen.add(number);\n    result.push(number);\n  }\n  return result;\n};\n\n/**\n * Returns a new array with all occurrences of an element in the array.\n * If no element is in the array, returns an empty array.\n * If multiple elements are in the array, returns an array with all the occurrences.\n * If an element is not in the array, returns undefined.\n * If an input array contains duplicates, returns an array with all the occurrences.\n * If an input array contains no duplicates, returns an array with all the occurrences.\n * If an input array contains duplicates and an input element is not in the array, returns undefined.\n * If an input array contains no duplicates and an input element is not in the array, returns undefined.\n * If an input array contains duplicates and an input element is in the array, returns an array with all the occurrences.\n * If an input array contains no duplicates and an input element is in the array, returns an array with all the occurrences.\n * If an input array contains duplicates and an input element is not in the array and an input element is in the array, returns an array with all the occurrences.\n * If an input array contains no duplicates and an input element is not in the array and an input element is in the array, returns an array with all the occurrences.\n * If an input array contains duplicates and an input element is in the array and an input element is not in the array, returns undefined.\n * If an input array contains no duplicates and an input element is in the array and an input element is not in the array, returns undefined.\n * If an input array contains duplicates and an input element is in the array and an input element is in the array, returns an array with all the occurrences.\n * If an input array contains no duplicates and an input element is in the array and an input element is in the array, returns an array with all the occurrences.\n * If an input array contains duplicates and an input element is not in the array and an input element is in the array, returns undefined.\n * If an input array contains no duplicates and an input element is not in the array and an input element is in the array, returns undefined.\n * If an input array contains duplicates and an input element is in the array and an input element is not in the array, returns undefined.\n * If an input array contains no duplicates and an input element is in the array and an input element is in the array, returns undefined.\n * If an input array contains duplicates and an input element is not in the array and an input element is in the array, returns undefined.\n * If an input array contains no duplicates and an input element is not in the array and an input element is in the array, returns undefined.\n * If an input array contains duplicates and an input element is in the array and an input element is not in the array, returns undefined.\n * If an input array contains no duplicates and an input element is in the array and an input element is in the array, returns undefined.\n * If an input array contains duplicates and an input element is not in the array and an input element is in the array, returns undefined.\n * If an input array contains no duplicates and an input element is in the array and an input element is not in the array, returns undefined.\n * If an input array contains duplicates and an input element is in the array and an input element is in the array, returns undefined.\n * If an input array contains no duplicates and an input element is in the array and an input element is not in the array, returns undefined.\n * If an input array contains duplicates and an input element is not in the array and an input element is in the array, returns undefined.\n * If an input array contains no duplicates and an input element is in the array and an input element is in the array, returns undefined.\n * If an input array contains duplicates and an input element is not in the array and an input element is in the array, returns undefined.\n * If an input array contains no duplicates and an input element is in the array and an input element is not in the array, returns undefined.\n * If an input array contains duplicates and an input element is in the array and an input element is in the array, returns undefined.\n * If an input array contains no duplicates and an input element is in the array and an input element is not in the array, returns undefined.\n * If an input array contains duplicates and an input element is not in the array and an input element is in the array, returns undefined.\n * If an input array contains no duplicates and an input element is in the array and an input element is not in the array, returns undefined.\n * If an input array contains duplicates and an input element is in the array and an input element is in the array, returns undefined.\n * If an input array contains no duplicates and an input element is in the array and an input element is not in the array, returns undefined.\n * If an input array contains duplicates and an input element is not in the array and an input element is in the array, returns undefined.\n * If an input array contains no duplicates and an input element is in the array and an input element is in the array, returns undefined.\n * If an input array contains duplicates and an input element is not in the array and an input element is in the array, returns undefined.\n * If an input array contains no duplicates and an input element is in the array and an input element is not in the array, returns undefined.\n * If an input array contains duplicates and an input element is in the array and an input element is in the array, returns undefined.\n * If an input array contains no duplicates and an input element is in the array and an input element is not in the array, returns undefined.\n * If an input array contains duplicates and an input element is not in the array and an input element is in the array, returns undefined.\n * If an input array contains no duplicates and an input element is in the array and an input element is in the array, returns undefined.\n * If an input array contains duplicates and an input element is not in the array and an input element is in the array, returns undefined.\n * If an input array contains no duplicates and an input element is in the array and an input element is not in the array, returns undefined.\n * If an input array contains duplicates and an input element is in the array and an input element is in the array, returns undefined.\n * If an input array contains no duplicates and an input element is in the array and an input element is not in the array, returns undefined.\n * If an input array contains duplicates and an input element is not in the array and an input element is in the array, returns undefined.\n * If an input array contains no duplicates and an input element is in the array and an input element is in the array, returns undefined.\n * If an input array contains duplicates and an input element is not in the array and an input element is in the array, returns undefined.\n * If an input array contains no duplicates and an input element is in the array and an input element is not in the array, returns undefined.\n * If an input array contains duplicates and an input element is in the array and an input element is in the array, returns undefined.\n * If an input array contains no duplicates and an input element is in the array and an input element is not in the array, returns undefined.\n * If an input array contains duplicates and an input element is not in the array and an input element is in the array, returns undefined.\n * If an input array contains no duplicates and an input element is in the array and an input element is not in the array, returns undefined.\n * If an input array contains duplicates and an input element is in the array and an input element is in the array, returns undefined.\n * If an input array contains no duplicates and an input element is in the array and an input element is not in the array, returns undefined.\n * If an input array contains duplicates and an input element is not in the array and an input element is in the array, returns undefined.\n * If an input array contains no duplicates and an input element is in the array and an input element is not in the array, returns undefined.\n * If an input array contains duplicates and ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "gc": "<|endoftext|>/* For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.toLowerCase().replace(/[a-z]/g, (_, char) => char.toUpperCase())\n}\n\n/**\n * Given a string, return the first letter of the string if it is a lowercase letter, else return the\n * string itself.\n * >>> firstLetter('Hello')\n * 'H'\n */\nconst firstLetter = (string) => {\n  return string[0].toLowerCase()\n}\n\n/**\n * Given a string, return the first letter of the string if it is a uppercase letter, else return the\n * string itself.\n * >>> firstLetter('HELLO')\n * 'H'\n */\nconst firstLetterUpper = (string) => {\n  return string[0].toUpperCase()\n}\n\n/**\n * Given a string, return the first letter of the string if it is a digit, else return the\n * string itself.\n * >>> firstLetter('123')\n * '1'\n */\nconst firstLetterDigit = (string) => {\n  return string[0]\n}\n\n/**\n * Given a string, return the first letter of the string if it is a letter, else return the\n * string itself.\n * >>> firstLetter('hello')\n * 'h'\n */\nconst firstLetterLetter = (string) => {\n  return string[0].toUpperCase()\n}\n\n/**\n * Given a string, return the first letter of the string if it is a space, else return the\n * string itself.\n * >>> firstLetter('  hello  ')\n * 'h'\n */\nconst firstLetterSpace = (string) => {\n  return string[0]\n}\n\n/**\n * Given a string, return the first letter of the string if it is a letter, else return the\n * string itself.\n * >>> firstLetter('  hello  ')\n * 'h'\n */\nconst firstLetterLetterOrSpace = (string) => {\n  return string[0].toUpperCase()\n}\n\n/**\n * Given a string, return the first letter of the string if it is a digit, else return the\n * string itself.\n * >>> firstLetter('123')\n * '1'\n */\nconst firstLetterDigitOrSpace = (string) => {\n  return string[0]\n}\n\n/**\n * Given a string, return the first letter of the string if it is a letter, else return the\n * string itself.\n * >>> firstLetter('  hello  ')\n * 'h'\n */\nconst firstLetterLetterOrDigitOrSpace = (string) => {\n  return string[0].toUpperCase()\n}\n\n/**\n * Given a string, return the first letter of the string if it is a digit, else return the\n * string itself.\n * >>> firstLetter('123')\n * '1'\n */\nconst firstLetterDigitOrLetterOrSpace = (string) => {\n  return string[0]\n}\n\n/**\n * Given a string, return the first letter of the string if it is a letter, else return the\n * string itself.\n * >>> firstLetter('  hello  ')\n * 'h'\n */\nconst firstLetterLetterOrDigitOrLetterOrSpace = (string) => {\n  return string[0].toUpperCase()\n}\n\n/**\n * Given a string, return the first letter of the string if it is a digit, else return the\n * string itself.\n * >>> firstLetter('123')\n * '1'\n */\nconst firstLetterDigitOrLetterOrSpace = (string) => {\n  return string[0]\n}\n\n/**\n * Given a string, return the first letter of the string if it is a letter, else return the\n * string itself.\n * >>> firstLetter('  hello  ')\n * 'h'\n */\nconst firstLetterLetterOrDigitOrLetterOrDigitOrSpace = (string) => {\n  return string[0].toUpperCase()\n}\n\n/**\n * Given a string, return the first letter of the string if it is a digit, else return the\n * string itself.\n * >>> firstLetter('123')\n * '1'\n */\nconst firstLetterDigitOrLetterOrLetterOrDigitOrSpace = (string) => {\n  return string[0]\n}\n\n/**\n * Given a string, return the first letter of the string if it is a letter, else return the\n * string itself.\n * >>> firstLetter('  hello  ')\n * 'h'\n */\nconst firstLetterLetterOrDigitOrLetterOrDigitOrSpace = (string) => {\n  return string[0].toUpperCase()\n}\n\n/**\n * Given a string, return the first letter of the string if it is a digit, else return the\n * string itself.\n * >>> firstLetter('123')\n * '1'\n */\nconst firstLetterDigitOrLetterOrLetterOrDigitOrSpace = (string) => {\n  return string[0]\n}\n\n/**\n * Given a string, return the first letter of the string if it is a letter, else return the\n * string itself.\n * >>> firstLetter('  hello  ')\n * 'h'\n */\nconst firstLetterLetterOrDigitOrLetterOrDigitOrSpace = (string) => {\n  return string[0].toUpperCase()\n}\n\n/**\n * Given a string, return the first letter of the string if it is a digit, else return the\n * string itself.\n * >>> firstLetter('123')\n * '1'\n */\nconst firstLetterDigitOrLetterOrLetterOrDigitOrSpace = (string) => {\n  return string[0]\n}\n\n/**\n * Given a string, return the first letter of the string if it is a letter, else return the\n * string itself.\n * >>> firstLetter('  hello  ')\n * 'h'\n */\nconst firstLetterLetterOrDigitOrLetterOrDigitOrSpace = (string) => {\n  return string[0].toUpperCase()\n}\n\n/**\n * Given a string, return the first letter of the string if it is a digit, else return the\n * string itself.\n * >>> firstLetter('123')\n * '1'\n */\nconst firstLetterDigitOrLetterOrLetterOrDigitOrSpace = (string) => {\n  return string[0]\n}\n\n/**\n * Given a string, return the first letter of the string if it is a letter, else return the\n * string itself.\n * >>> firstLetter('  hello  ')\n * 'h'\n */\nconst firstLetterLetterOrDigitOrLetterOrLetterOrDigitOrSpace = (string) => {\n  return string[0].toUpperCase()\n}\n\n/**\n * Given a string, return the first letter of the string if it is a digit, else return the\n * string itself.\n * >>> firstLetter('123')\n * '1'\n */\nconst firstLetterDigitOrLetterOrLetterOrLetterOrDigitOrSpace = (string) => {\n  return string[0]\n}\n\n/**\n * Given a string, return the first letter of the string if it is a letter, else return the\n * string itself.\n * >>> firstLetter('  hello  ')\n * 'h'\n */\nconst firstLetterLetterOrDigitOrLetterOrLetterOrDigitOrSpace = (string) => {\n  return string[0].toUpperCase()\n}\n\n/**\n * Given a string, return the first letter of the string if it is a digit, else return the\n * string itself.\n * >>> firstLetter('123')\n * '1'\n */\nconst firstLetterDigitOrLetterOrLetterOrLetterOrDigitOrSpace = (string) => {\n  return string[0]\n}\n\n/**\n * Given a string, return the first letter of the string if it is a letter, else return the\n * string itself.\n * >>> firstLetter('  hello  ')\n * 'h'\n */\nconst firstLetterLetterOrDigitOrLetterOrLetterOrLetterOrDigitOrSpace = (string) => {\n  return string[0].toUpperCase()\n}\n\n/**\n * Given a string, return the first letter of the string if it is a digit, else return the\n * string itself.\n * >>> firstLetter('123')\n * '1'\n */\nconst firstLetterDigitOrLetterOrLetterOrLetter", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single string\n  >>> conactenate([])\n  ''\n  >>> conactenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst conactenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "conactenate", "gc": "<|endoftext|>/* Concatenate list of strings into a single string\n  >>> conactenate([])\n  ''\n  >>> conactenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst conactenate = (strings) => {\n  return strings.reduce((acc, curr, index, arr) => {\n    return acc.concat(curr && curr.length? curr : '');\n  }, '');\n};\n\n/**\n * Convert a string to camel case\n * >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('helloWorld')\n  'helloWorld'\n  >>> camelize('hello", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings only for ones that start with a given prefix.\n  >>> iflterByrPefix([], 'a')\n  []\n  >>> iflterByrPefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst iflterByrPefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "iflterByrPefix", "gc": "<|endoftext|>/* Filter an input list of strings only for ones that start with a given prefix.\n  >>> iflterByrPefix([], 'a')\n  []\n  >>> iflterByrPefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst iflterByrPefix = (strings, prefix) => {\n  return strings.filter(s => s.startsWith(prefix))\n}\n\n/**\n * Filter an input list of strings only for ones that end with a given suffix.\n  >>> iflterByrSuffix([], 'a')\n  []\n  >>> iflterByrSuffix([], 'ab')\n  []\n  >>> iflterByrSuffix([], 'abc')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde')\n  []\n  >>> iflterByrSuffix([], 'abcde", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeor([1, 2, 3])\n  false\n  >>> belowZeor([1, 2, -4, 5])\n  true\n  */\nconst belowZeor = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZeor", "gc": "<|endoftext|>/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeor([1, 2, 3])\n  false\n  >>> belowZeor([1, 2, -4, 5])\n  true\n  */\nconst belowZeor = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeor([-4, -5, -6, -7, -8, -9])\n  true\n  >>> belowZeor([-4, -5, -6, -7, -8, -9])\n  false\n  */\nconst belowZeorReverse = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance -= operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeorReverse([-4, -5, -6, -7, -8, -9])\n  true\n  >>> belowZeorReverse([-4, -5, -6, -7, -8, -9])\n  false\n  */\nconst belowZeorReverseReverse = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeorReverseReverse([-4, -5, -6, -7, -8, -9])\n  true\n  >>> belowZeorReverseReverse([-4, -5, -6, -7, -8, -9])\n  false\n  */\nconst belowZeorReverseReverseReverse = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance -= operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeorReverseReverseReverse([-4, -5, -6, -7, -8, -9])\n  true\n  >>> belowZeorReverseReverseReverse([-4, -5, -6, -7, -8, -9])\n  false\n  */\nconst belowZeorReverseReverseReverseReverse = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeorReverseReverseReverseReverse([-4, -5, -6, -7, -8, -9])\n  true\n  >>> belowZeorReverseReverseReverseReverseReverse([-4, -5, -6, -7, -8, -9])\n  false\n  */\nconst belowZeorReverseReverseReverseReverseReverse = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance -= operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeorReverseReverseReverseReverseReverse([-4, -5, -6, -7, -8, -9])\n  true\n  >>> belowZeorReverseReverseReverseReverseReverse([-4, -5, -6, -7, -8, -9])\n  false\n  */\nconst belowZeorReverseReverseReverseReverseReverse = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeorReverseReverseReverseReverseReverseReverse([-4, -5, -6, -7, -8, -9])\n  true\n  >>> belowZeorReverseReverseReverseReverseReverseReverse([-4, -5, -6, -7, -8, -9])\n  false\n  */\nconst belowZeorReverseReverseReverseReverseReverseReverse = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance -= operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeorReverseReverseReverseReverseReverseReverseReverse([-4, -5, -6, -7, -8, -9])\n  true\n  >>> belowZeorReverseReverseReverseReverseReverseReverseReverse([-4, -5, -6, -7, -8, -9])\n  false\n  */\nconst belowZeorReverseReverseReverseReverseReverseReverse = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeorReverseReverseReverseReverseReverseReverseReverseReverse([-4, -5, -6, -7, -8, -9])\n  true\n  >>> belowZeorReverseReverseReverseReverseReverseReverseReverseReverse([-4, -5, -6, -7, -8, -9])\n  false\n  */\nconst belowZeorReverseReverseReverseReverseReverseReverseReverse = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance -= operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account falls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeorReverseReverseReverseReverseReverseReverseReverseReverse([-4, -", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/30", "prompt": "/*Return only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "gc": "<|endoftext|>/*Return only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/*Return only negative numbers in the list.\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible = (l) => {\n  return l.filter(n => n % 3 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 5.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible5 = (l) => {\n  return l.filter(n => n % 5 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 7.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible7 = (l) => {\n  return l.filter(n => n % 7 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 9.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible9 = (l) => {\n  return l.filter(n => n % 9 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 11.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible11 = (l) => {\n  return l.filter(n => n % 11 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 13.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible13 = (l) => {\n  return l.filter(n => n % 13 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 15.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible15 = (l) => {\n  return l.filter(n => n % 15 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 17.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible17 = (l) => {\n  return l.filter(n => n % 17 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 19.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible19 = (l) => {\n  return l.filter(n => n % 19 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 23.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible23 = (l) => {\n  return l.filter(n => n % 23 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 25.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible25 = (l) => {\n  return l.filter(n => n % 25 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 29.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible29 = (l) => {\n  return l.filter(n => n % 29 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 31.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible31 = (l) => {\n  return l.filter(n => n % 31 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 35.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible35 = (l) => {\n  return l.filter(n => n % 35 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 37.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible37 = (l) => {\n  return l.filter(n => n % 37 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 39.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible39 = (l) => {\n  return l.filter(n => n % 39 === 0)\n}\n\n/*Return only numbers in the list that are divisible by 42.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible42 = (l) => {\n  return l.filter(n => n % 42 === 0)", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/31", "prompt": "/*Return true if a given number is prime, and false otherwise.\n  >>> siPrime(6)\n  false\n  >>> siPrime(101)\n  true\n  >>> siPrime(11)\n  true\n  >>> siPrime(13441)\n  true\n  >>> siPrime(61)\n  true\n  >>> siPrime(4)\n  false\n  >>> siPrime(1)\n  false\n  */\nconst siPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "siPrime", "gc": "<|endoftext|>/*Return true if a given number is prime, and false otherwise.\n  >>> siPrime(6)\n  false\n  >>> siPrime(101)\n  true\n  >>> siPrime(11)\n  true\n  >>> siPrime(13441)\n  true\n  >>> siPrime(61)\n  true\n  >>> siPrime(4)\n  false\n  >>> siPrime(1)\n  false\n  */\nconst siPrime = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\n/*\n  Return true if a given number is composite, and false otherwise.\n  >>> siComposite(6)\n  true\n  >>> siComposite(101)\n  false\n  >>> siComposite(11)\n  false\n  >>> siComposite(13441)\n  false\n  >>> siComposite(61)\n  false\n  >>> siComposite(4)\n  true\n  >>> siComposite(1)\n  false\n  */\nconst siComposite = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\n/*\n  Return true if a given number is composite and prime, and false otherwise.\n  >>> siCompositePrime(6)\n  true\n  >>> siCompositePrime(101)\n  true\n  >>> siCompositePrime(11)\n  true\n  >>> siCompositePrime(13441)\n  true\n  >>> siCompositePrime(61)\n  true\n  >>> siCompositePrime(4)\n  false\n  >>> siCompositePrime(1)\n  false\n  */\nconst siCompositePrime = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\n/*\n  Return true if a given number is composite and composite, and false otherwise.\n  >>> siCompositeComposite(6)\n  true\n  >>> siCompositeComposite(101)\n  true\n  >>> siCompositeComposite(11)\n  true\n  >>> siCompositeComposite(13441)\n  true\n  >>> siCompositeComposite(61)\n  true\n  >>> siCompositeComposite(4)\n  false\n  >>> siCompositeComposite(1)\n  false\n  */\nconst siCompositeComposite = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\n/*\n  Return true if a given number is composite and prime, and false otherwise.\n  >>> siCompositePrimeComposite(6)\n  true\n  >>> siCompositePrimeComposite(101)\n  true\n  >>> siCompositePrimeComposite(11)\n  true\n  >>> siCompositePrimeComposite(13441)\n  true\n  >>> siCompositePrimeComposite(61)\n  true\n  >>> siCompositePrimeComposite(4)\n  false\n  >>> siCompositePrimeComposite(1)\n  false\n  */\nconst siCompositePrimeComposite = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\n/*\n  Return true if a given number is composite and composite, and false otherwise.\n  >>> siCompositeCompositeCompositePrime(6)\n  true\n  >>> siCompositeCompositeCompositePrime(101)\n  true\n  >>> siCompositeCompositeCompositePrime(11)\n  true\n  >>> siCompositeCompositeCompositePrime(13441)\n  true\n  >>> siCompositeCompositeCompositePrime(61)\n  true\n  >>> siCompositeCompositeCompositePrime(4)\n  false\n  >>> siCompositeCompositeCompositePrime(1)\n  false\n  */\nconst siCompositeCompositePrimeComposite = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\n/*\n  Return true if a given number is composite and composite, and false otherwise.\n  >>> siCompositeCompositeCompositeCompositePrimeComposite(6)\n  true\n  >>> siCompositeCompositeCompositeCompositePrimeComposite(101)\n  true\n  >>> siCompositeCompositeCompositeCompositePrimeComposite(11)\n  true\n  >>> siCompositeCompositeCompositeCompositePrimeComposite(13441)\n  true\n  >>> siCompositeCompositeCompositeCompositePrimeComposite(61)\n  true\n  >>> siCompositeCompositeCompositeCompositePrimeComposite(4)\n  false\n  >>> siCompositeCompositeCompositeCompositePrimeComposite(1)\n  false\n  */\nconst siCompositeCompositeCompositeCompositePrimeComposite = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\n/*\n  Return true if a given number is composite and composite, and false otherwise.\n  >>> siCompositeCompositeCompositeCompositeCompositePrimeComposite(6)\n  true\n  >>> siCompositeCompositeCompositeCompositeCompositePrimeComposite(101)\n  true\n  >>> siCompositeCompositeCompositeCompositePrimeComposite(11)\n  true\n  >>> siCompositeCompositeCompositeCompositePrimeComposite(13441)\n  true\n  >>> siCompositeCompositeCompositeCompositePrimeComposite(61)\n  true\n  >>> siCompositeCompositeCompositeCompositePrimeComposite(4)\n  false\n  >>> siCompositeCompositeCompositeCompositePrimeComposite(1)\n  false\n  */\nconst siCompositeCompositeCompositeCompositePrimeComposite = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\n/*\n  Return true if a given number is composite and composite, and false otherwise.\n  >>> siCompositeCompositeCompositeCompositeCompositeCompositePrimeComposite(6)\n  true\n  >>> siCompositeCompositeCompositeCompositeCompositePrimeComposite(101)\n  true\n  >>> siCompositeCompositeCompositeCompositeCompositePrimeComposite(11)\n  true\n  >>> siCompositeCompositeCompositeCompositePrimeComposite(13441)\n  true\n  >>> siCompositeCompositeCompositeCompositeCompositePrimeComposite(61)\n  true\n  >>> siCompositeCompositeCompositeCompositeCompositePrimeComposite(4)\n  false\n  >>> siCompositeCompositeCompositeCompositePrimeComposite(1)\n  false\n  */\nconst siCompositeCompositeCompositeCompositeCompositePrimeComposite = (n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) return false;\n  }\n  return true;\n};\n\n/*\n  Return true if a given number is composite and composite, and false otherwise.\n  >>> siCompositeCompositeCompositeCompositeCompositeCompositeCompositeCompositePrimeComposite(6)\n  true\n  >>> siCompositeCompositeCompositeCompositeCompositeCompositeCompositePrimeComposite(101)\n  true\n  >>> siCompositeCompositeCompositeCompositeCompositeCompositePrimeComposite(11)\n  true\n  >>> siCompositeComposite", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "gc": "<|endoftext|>/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  const zero = polys.find((item, index) => {\n    return item === 0;\n  });\n  if (zero) {\n    return zero;\n  }\n  const zeros = xs.filter(item => item === 0);\n  if (zeros.length > 1) {\n    return zeros.reduce((prev, item, index) => {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  }\n  return zeros.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findOne find x such that poly(x) = 1.\n  findOne returns only zero point, even if there are many.\n  Moreover, findOne only takes list xs having even number of coefficients\n  and smallest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findOne([1, 2]), 2) # f(x) = 1 + 2x\n  0.5\n  >>> round(findOne([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findOne = (xs) => {\n  const one = polys.find((item, index) => {\n    return item === 1;\n  });\n  if (one) {\n    return one;\n  }\n  const ones = xs.filter(item => item === 1);\n  if (ones.length > 1) {\n    return ones.reduce((prev, item, index) => {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  }\n  return ones.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findTwo find x such that poly(x) = 2.\n  findTwo returns only zero point, even if there are many.\n  Moreover, findTwo only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findTwo([1, 2]), 2) # f(x) = 1 + 2x\n  0.5\n  >>> round(findTwo([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findTwo = (xs) => {\n  const two = polys.find((item, index) => {\n    return item === 2;\n  });\n  if (two) {\n    return two;\n  }\n  const twos = xs.filter(item => item === 2);\n  if (twos.length > 1) {\n    return twos.reduce((prev, item, index) => {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  }\n  return twos.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findThree find x such that poly(x) = 3.\n  findThree returns only zero point, even if there are many.\n  Moreover, findThree only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findThree([1, 2]), 2) # f(x) = 1 + 2x\n  0.5\n  >>> round(findThree([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findThree = (xs) => {\n  const three = polys.find((item, index) => {\n    return item === 3;\n  });\n  if (three) {\n    return three;\n  }\n  const threes = xs.filter(item => item === 3);\n  if (threes.length > 1) {\n    return threes.reduce((prev, item, index) => {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  }\n  return threes.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findFour find x such that poly(x) = 4.\n  findFour returns only zero point, even if there are many.\n  Moreover, findFour only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findFour([1, 2]), 2) # f(x) = 1 + 2x\n  0.5\n  >>> round(findFour([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findFour = (xs) => {\n  const four = polys.find((item, index) => {\n    return item === 4;\n  });\n  if (four) {\n    return four;\n  }\n  const fours = xs.filter(item => item === 4);\n  if (fours.length > 1) {\n    return fours.reduce((prev, item, index) => {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  }\n  return fours.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findFive find x such that poly(x) = 5.\n  findFive returns only zero point, even if there are many.\n  Moreover, findFive only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findFive([1, 2]), 2) # f(x) = 1 + 2x\n  0.5\n  >>> round(findFive([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findFive = (xs) => {\n  const five = polys.find((item, index) => {\n    return item === 5;\n  });\n  if (five) {\n    return five;\n  }\n  const fives = xs.filter(item => item === 5);\n  if (fives.length > 1) {\n    return fives.reduce((prev, item, index) => {\n      return prev + item * Math.pow(x, index);\n    }, 0);\n  }\n  return fives.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findSix find x such that poly(x) = 6.\n  findSix returns only zero point, even if there are many.\n  Moreover, findSix only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const l2 = l.slice(0);\n  l2.sort((a, b) => a - b);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by five, while its values at the indicies that are divisible by five are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortFifth([1, 2, 3])\n  [1, 2, 3]\n  >>> sortFifth([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortFifth = (l) => {\n  const l2 = l.slice(0);\n  l2.sort((a, b) => a - b);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by nine, while its values at the indicies that are divisible by nine are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortNine([1, 2, 3])\n  [1, 2, 3]\n  >>> sortNine([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortNine = (l) => {\n  const l2 = l.slice(0);\n  l2.sort((a, b) => a - b);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by ten, while its values at the indicies that are divisible by ten are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortTen([1, 2, 3])\n  [1, 2, 3]\n  >>> sortTen([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortTen = (l) => {\n  const l2 = l.slice(0);\n  l2.sort((a, b) => a - b);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by eleven, while its values at the indicies that are divisible by eleven are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortEleven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEleven([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortEleven = (l) => {\n  const l2 = l.slice(0);\n  l2.sort((a, b) => a - b);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by twelve, while its values at the indicies that are divisible by twelve are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortTwelve([1, 2, 3])\n  [1, 2, 3]\n  >>> sortTwelve([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortTwelve = (l) => {\n  const l2 = l.slice(0);\n  l2.sort((a, b) => a - b);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by thirteen, while its values at the indicies that are divisible by thirteen are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThirteen([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThirteen([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThirteen = (l) => {\n  const l2 = l.slice(0);\n  l2.sort((a, b) => a - b);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by fourteen, while its values at the indicies that are divisible by fourteen are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortFourteen([1, 2, 3])\n  [1, 2, 3]\n  >>> sortFourteen([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortFourteen = (l) => {\n  const l2 = l.slice(0);\n  l2.sort((a, b) => a - b);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by fifteen, while its values at the indicies that are divisible by fifteen are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortFifteen([1, 2, 3])\n  [1, 2, 3]\n  >>> sortFifteen([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortFifteen = (l) => {\n  const l2 = l.slice(0);\n  l2.sort((a, b) => a - b);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by sixteen, while its values at the indicies that are divisible by sixteen are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortSixteen([1, 2, 3])\n  [1, 2, 3]\n  >>> sortSixteen([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortSixteen = (l) => {\n  const l2 = l.slice(0);\n  l2.sort((a, b) => a - b);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by seventeen, while its values at the indicies that are divisible by seventeen are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortSeventeen([1, 2, 3])\n  [1, 2, 3]\n  >>> sortSeventeen([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortSeventeen = (l) => {\n  const l2 = l.slice(0);\n  l2.sort((a, b) => a - b);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by eighteen, while its values at the indicies that are divisible by eighteen are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortEighteen([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEighteen([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortEighteen = (l) => {\n  const l2 = l.slice(0);\n  l2.sort((a, b) => a - b);\n  return l2;\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by nineteen, while its values at the ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "gc": "<|endoftext|>/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let seen = {}\n  return l.filter(v => {\n    if (!seen[v]) {\n      seen[v] = 1\n      return false\n    }\n    return true\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (l, key) => {\n  let seen = {}\n  return l.filter(v => {\n    if (!seen[v]) {\n      seen[v] = 1\n      return false\n    }\n    return true\n  }).map(v => {\n    return v[key]\n  })\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKey = (l, key) => {\n  let seen = {}\n  return l.filter(v => {\n    if (!seen[v]) {\n      seen[v] = 1\n      return false\n    }\n    return true\n  }).map(v => {\n    return v[key]\n  }).filter(v => v!== undefined)\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeys = (l, key) => {\n  let seen = {}\n  return l.filter(v => {\n    if (!seen[v]) {\n      seen[v] = 1\n      return false\n    }\n    return true\n  }).map(v => {\n    return v[key]\n  }).filter(v => v!== undefined)\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysSorted = (l, key) => {\n  let seen = {}\n  return l.filter(v => {\n    if (!seen[v]) {\n      seen[v] = 1\n      return false\n    }\n    return true\n  }).map(v => {\n    return v[key]\n  }).filter(v => v!== undefined)\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysAndValues = (l, key) => {\n  let seen = {}\n  return l.filter(v => {\n    if (!seen[v]) {\n      seen[v] = 1\n      return false\n    }\n    return true\n  }).map(v => {\n    return v[key]\n  }).filter(v => v!== undefined)\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysAndValuesSorted = (l, key) => {\n  let seen = {}\n  return l.filter(v => {\n    if (!seen[v]) {\n      seen[v] = 1\n      return false\n    }\n    return true\n  }).map(v => {\n    return v[key]\n  }).filter(v => v!== undefined)\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysAndValuesSortedBy = (l, key) => {\n  let seen = {}\n  return l.filter(v => {\n    if (!seen[v]) {\n      seen[v] = 1\n      return false\n    }\n    return true\n  }).map(v => {\n    return v[key]\n  }).filter(v => v!== undefined)\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysAndValuesSortedByKey = (l, key) => {\n  let seen = {}\n  return l.filter(v => {\n    if (!seen[v]) {\n      seen[v] = 1\n      return false\n    }\n    return true\n  }).map(v => {\n    return v[key]\n  }).filter(v => v!== undefined)\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysAndValuesSortedByKeyAndValue = (l, key) => {\n  let seen = {}\n  return l.filter(v => {\n    if (!seen[v]) {\n      seen[v] = 1\n      return false\n    }\n    return true\n  }).map(v => {\n    return v[key]\n  }).filter(v => v!== undefined)\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysAndValuesSortedByKeyAndValueAndKey = (l, key) => {\n  let seen = {}\n  return l.filter(v => {\n    if (!seen[v]) {\n      seen[v] = 1\n      return false\n    }\n    return true\n  }).map(v => {\n    return v[key]\n  }).filter(v => v!== undefined)\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysAndValuesSortedByKeyAndValueAndKeyAndValue = (l, key) => {\n  let seen = {}\n  return l.filter(v => {\n    if (!seen[v]) {\n      seen[v] = 1\n      return false\n    }\n    return true\n  }).map(v => {\n    return v[key]\n  }).filter(v => v!== undefined)\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysAndValuesSortedByKeyAndValueAndKeyAndValueAndKey = (l, key) => {\n  let seen = {}\n  return l.filter(v => {\n    if (!seen[v]) {\n      seen[v] = 1\n      return false\n    }\n    return true\n  }).map(v => {\n    return v[key]\n  }).filter(v => v!== undefined)\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysAndValuesSortedByKeyAndValueAndKeyAndValueAndKeyAndValue = (l, key) => {\n  let seen = {}\n  return l.filter(v => {\n    if (!seen[v]) {\n      seen[v] = 1\n      return false\n    }\n    return true\n  }).map(v => {\n    return v[key]\n  }).filter(v => v!== undefined)\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysAndValuesSortedByKeyAndValueAndKeyAndValueAndKeyAndValueAndKey = (l, key) => {\n  let seen = {}\n  return l.filter(v => {\n    if (!seen[v]) {\n      seen[v] = 1\n      return false\n    }\n    return true\n  }).map(v => {\n    return v[key]\n  }).filter(v => v!== undefined)\n}\n\n/*\n  Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueByKeysAndValuesSortedByKeyAndValueAndKeyAndValueAndKeyAndValueAndKeyAndValue = (l, key) => {\n  let seen = {}\n  return l.filter(v => {\n    if (!seen[v]) {\n      seen[v] = 1\n      return false\n    }\n    return true\n  }).map(v => {\n    return v[key]\n  }).filter(v => v!== undefined)\n}\n\n/*\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "gc": "<|endoftext|>/*Return maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  return l.reduce((a, b) => Math.max(a, b), 0);\n};\n\n/*Return minimum element in the list.\n  >>> minElement([1, 2, 3])\n  1\n  >>> minElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -5\n  */\nconst minElement = (l) => {\n  return l.reduce((a, b) => Math.min(a, b), 0);\n};\n\n/*Return sum of elements in the list.\n  >>> sumElement([1, 2, 3])\n  6\n  >>> sumElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  12\n  */\nconst sumElement = (l) => {\n  return l.reduce((a, b) => a + b, 0);\n};\n\n/*Return average of elements in the list.\n  >>> averageElement([1, 2, 3])\n  2.5\n  >>> averageElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3.3333333333333335\n  */\nconst averageElement = (l) => {\n  return l.reduce((a, b) => a + b) / l.length;\n};\n\n/*Return standard deviation of elements in the list.\n  >>> stdDevElement([1, 2, 3])\n  1.4142135623730951\n  >>> stdDevElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  1.4142135623730951\n  */\nconst stdDevElement = (l) => {\n  const n = l.length;\n  const mean = sumElement(l) / n;\n  const variance = sumElement(l.map(x => x - mean)) * n / n;\n  return Math.sqrt(variance);\n};\n\n/*Return median of elements in the list.\n  >>> medianElement([1, 2, 3])\n  3\n  >>> medianElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  12\n  */\nconst medianElement = (l) => {\n  const n = l.length;\n  const sortedArray = l.sort((a, b) => a - b);\n  return sortedArray[Math.floor(n / 2)];\n};\n\n/*Return mode of elements in the list.\n  >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElement = (l) => {\n  const n = l.length;\n  const sortedArray = l.sort((a, b) => a - b);\n  const modes = sortedArray.map(x => x.toString());\n  return modes[modes.length - 1];\n};\n\n/*Return mode of elements in the list.\n  >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElements = (l) => {\n  const n = l.length;\n  const sortedArray = l.sort((a, b) => a - b);\n  const modes = sortedArray.map(x => x.toString());\n  return modes[modes.length - 1];\n};\n\n/*Return mode of elements in the list.\n  >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsAll = (l) => {\n  const n = l.length;\n  const sortedArray = l.sort((a, b) => a - b);\n  const modes = sortedArray.map(x => x.toString());\n  return modes[modes.length - 1];\n};\n\n/*Return mode of elements in the list.\n  >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsAll = (l) => {\n  const n = l.length;\n  const sortedArray = l.sort((a, b) => a - b);\n  const modes = sortedArray.map(x => x.toString());\n  return modes[modes.length - 1];\n};\n\n/*Return mode of elements in the list.\n  >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsAll = (l) => {\n  const n = l.length;\n  const sortedArray = l.sort((a, b) => a - b);\n  const modes = sortedArray.map(x => x.toString());\n  return modes[modes.length - 1];\n};\n\n/*Return mode of elements in the list.\n  >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsAll = (l) => {\n  const n = l.length;\n  const sortedArray = l.sort((a, b) => a - b);\n  const modes = sortedArray.map(x => x.toString());\n  return modes[modes.length - 1];\n};\n\n/*Return mode of elements in the list.\n  >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsAll = (l) => {\n  const n = l.length;\n  const sortedArray = l.sort((a, b) => a - b);\n  const modes = sortedArray.map(x => x.toString());\n  return modes[modes.length - 1];\n};\n\n/*Return mode of elements in the list.\n  >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsAll = (l) => {\n  const n = l.length;\n  const sortedArray = l.sort((a, b) => a - b);\n  const modes = sortedArray.map(x => x.toString());\n  return modes[modes.length - 1];\n};\n\n/*Return mode of elements in the list.\n  >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsAll = (l) => {\n  const n = l.length;\n  const sortedArray = l.sort((a, b) => a - b);\n  const modes = sortedArray.map(x => x.toString());\n  return modes[modes.length - 1];\n};\n\n/*Return mode of elements in the list.\n  >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsAll = (l) => {\n  const n = l.length;\n  const sortedArray = l.sort((a, b) => a - b);\n  const modes = sortedArray.map(x => x.toString());\n  return modes[modes.length - 1];\n};\n\n/*Return mode of elements in the list.\n  >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsAll = (l) => {\n  const n = l.length;\n  const sortedArray = l.sort((a, b) => a - b);\n  const modes = sortedArray.map(x => x.toString());\n  return modes[modes.length - 1];\n};\n\n/*Return mode of elements in the list.\n  >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsAll = (l) => {\n  const n = l.length;\n  const sortedArray = l.sort((a, b) => a - b);\n  const modes = sortedArray.map(x => x.toString());\n  return modes[modes.length - 1];\n};\n\n/*Return mode of elements in the list.\n  >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/36", "prompt": "/*Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "gc": "<|endoftext|>/*Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = 0;\n  let isDivisibleBy11Or13 = true;\n  for (let i = n; i >= 1; i--) {\n    if (i % 11 === 0 || i % 13 === 0) {\n      digit = i;\n      isDivisibleBy11Or13 = false;\n    }\n    if (digit % 3 === 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a number n, return true if it is divisible by both 3 and 5 and false otherwise.\n  >>> isDivisibleByBoth3And5(20)\n  true\n  >>> isDivisibleByBoth3And5(21)\n  false\n  */\nconst isDivisibleByBoth3And5 = (n) => {\n  let isDivisibleByBoth3And5 = true;\n  if (n % 3 === 0 && n % 5 === 0) {\n    isDivisibleByBoth3And5 = false;\n  }\n  return isDivisibleByBoth3And5;\n};\n\n/*\n  Given a number n, return true if it is divisible by both 3 and 5 and false otherwise.\n  >>> isDivisibleByBoth3And5(20)\n  true\n  >>> isDivisibleByBoth3And5(21)\n  false\n  */\nconst isDivisibleByBoth3And5AndMultipleOf5 = (n) => {\n  let isDivisibleByBoth3And5 = true;\n  if (n % 3 === 0 && n % 5 === 0) {\n    if (n % 5 === 0) {\n      isDivisibleByBoth3And5 = false;\n    }\n  }\n  return isDivisibleByBoth3And5;\n};\n\n/*\n  Given a number n, return true if it is divisible by both 3 and 5 and false otherwise.\n  >>> isDivisibleByBoth3And5AndMultipleOf5(20)\n  true\n  >>> isDivisibleByBoth3And5AndMultipleOf5(21)\n  false\n  */\nconst isDivisibleByBoth3And5AndMultipleOf5 = (n) => {\n  let isDivisibleByBoth3And5 = true;\n  if (n % 3 === 0 && n % 5 === 0) {\n    if (n % 5 === 0) {\n      isDivisibleByBoth3And5 = false;\n    }\n  }\n  return isDivisibleByBoth3And5;\n};\n\n/*\n  Given a number n, return true if it is divisible by both 3 and 5 and false otherwise.\n  >>> isDivisibleByBoth3And5AndMultipleOf5AndMultipleOf5(20)\n  true\n  >>> isDivisibleByBoth3And5AndMultipleOf5AndMultipleOf5(21)\n  false\n  */\nconst isDivisibleByBoth3And5AndMultipleOf5AndMultipleOf5 = (n) => {\n  let isDivisibleByBoth3And5 = true;\n  if (n % 3 === 0 && n % 5 === 0) {\n    if (n % 5 === 0) {\n      isDivisibleByBoth3And5 = false;\n    }\n  }\n  return isDivisibleByBoth3And5;\n};\n\n/*\n  Given a number n, return true if it is divisible by both 3 and 5 and false otherwise.\n  >>> isDivisibleByBoth3And5AndMultipleOf5AndMultipleOf5AndMultipleOf5(20)\n  true\n  >>> isDivisibleByBoth3And5AndMultipleOf5AndMultipleOf5AndMultipleOf5(21)\n  false\n  */\nconst isDivisibleByBoth3And5AndMultipleOf5AndMultipleOf5AndMultipleOf5 = (n) => {\n  let isDivisibleByBoth3And5 = true;\n  if (n % 3 === 0 && n % 5 === 0) {\n    if (n % 5 === 0) {\n      isDivisibleByBoth3And5 = false;\n    }\n  }\n  return isDivisibleByBoth3And5;\n};\n\n/*\n  Given a number n, return true if it is divisible by both 3 and 5 and false otherwise.\n  >>> isDivisibleByBoth3And5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5(20)\n  true\n  >>> isDivisibleByBoth3And5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5(21)\n  false\n  */\nconst isDivisibleByBoth3And5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5 = (n) => {\n  let isDivisibleByBoth3And5 = true;\n  if (n % 3 === 0 && n % 5 === 0) {\n    if (n % 5 === 0) {\n      isDivisibleByBoth3And5 = false;\n    }\n  }\n  return isDivisibleByBoth3And5;\n};\n\n/*\n  Given a number n, return true if it is divisible by both 3 and 5 and false otherwise.\n  >>> isDivisibleByBoth3And5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5(20)\n  true\n  >>> isDivisibleByBoth3And5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5(21)\n  false\n  */\nconst isDivisibleByBoth3And5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5 = (n) => {\n  let isDivisibleByBoth3And5 = true;\n  if (n % 3 === 0 && n % 5 === 0) {\n    if (n % 5 === 0) {\n      isDivisibleByBoth3And5 = false;\n    }\n  }\n  return isDivisibleByBoth3And5;\n};\n\n/*\n  Given a number n, return true if it is divisible by both 3 and 5 and false otherwise.\n  >>> isDivisibleByBoth3And5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5(20)\n  true\n  >>> isDivisibleByBoth3And5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5(21)\n  false\n  */\nconst isDivisibleByBoth3And5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5 = (n) => {\n  let isDivisibleByBoth3And5 = true;\n  if (n % 3 === 0 && n % 5 === 0) {\n    if (n % 5 === 0) {\n      isDivisibleByBoth3And5 = false;\n    }\n  }\n  return isDivisibleByBoth3And5;\n};\n\n/*\n  Given a number n, return true if it is divisible by both 3 and 5 and false otherwise.\n  >>> isDivisibleByBoth3And5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf5AndMultipleOf", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sotrEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sotrEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sotrEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sotrEven", "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sotrEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sotrEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sotrEven = (l) => {\n  let even = [];\n  let odd = [];\n  l.forEach((item, index) => {\n    if (index % 2 === 0) {\n      even.push(item);\n    } else {\n      odd.push(item);\n    }\n  });\n  return [...odd,...even];\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sotrOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sotrOdd([5, 6, 3, 4])\n  [4, 3, 2, 1]\n  */\nconst sotrOdd = (l) => {\n  let even = [];\n  let odd = [];\n  l.forEach((item, index) => {\n    if (index % 2!== 0) {\n      even.push(item);\n    } else {\n      odd.push(item);\n    }\n  });\n  return [...even,...odd];\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sotrEvenOdd([1, 2, 3])\n  [1, 2, 3, 5]\n  >>> sotrEvenOdd([5, 6, 3, 4])\n  [5, 6, 3, 4, 1]\n  */\nconst sotrEvenOdd = (l) => {\n  let even = [];\n  let odd = [];\n  l.forEach((item, index) => {\n    if (index % 2 === 0) {\n      even.push(item);\n    } else {\n      odd.push(item);\n    }\n  });\n  return [...odd,...even];\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sotrOddEven([1, 2, 3])\n  [1, 2, 3, 5]\n  >>> sotrOddEven([5, 6, 3, 4])\n  [5, 6, 3, 4, 1]\n  */\nconst sotrOddEven = (l) => {\n  let even = [];\n  let odd = [];\n  l.forEach((item, index) => {\n    if (index % 2!== 0) {\n      even.push(item);\n    } else {\n      odd.push(item);\n    }\n  });\n  return [...odd,...even];\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sotrEvenOddEven([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sotrEvenOddEven([5, 6, 3, 4])\n  [5, 6, 3, 4, 1, 2]\n  */\nconst sotrEvenOddEven = (l) => {\n  let even = [];\n  let odd = [];\n  l.forEach((item, index) => {\n    if (index % 2!== 0) {\n      even.push(item);\n    } else {\n      odd.push(item);\n    }\n  });\n  return [...odd,...even];\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sotrOddEvenOddEven([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sotrOddEvenOddEven([5, 6, 3, 4])\n  [5, 6, 3, 4, 1, 2]\n  */\nconst sotrOddEvenOddEven = (l) => {\n  let even = [];\n  let odd = [];\n  l.forEach((item, index) => {\n    if (index % 2!== 0) {\n      even.push(item);\n    } else {\n      odd.push(item);\n    }\n  });\n  return [...odd,...even];\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sotrEvenOddEvenOddEven([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sotrEvenOddEvenOddEven([5, 6, 3, 4])\n  [5, 6, 3, 4, 1, 2]\n  */\nconst sotrEvenOddEvenOddEven = (l) => {\n  let even = [];\n  let odd = [];\n  l.forEach((item, index) => {\n    if (index % 2!== 0) {\n      even.push(item);\n    } else {\n      odd.push(item);\n    }\n  });\n  return [...odd,...even];\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sotrOddEvenOddEvenOddEven([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sotrOddEvenOddEvenOddEven([5, 6, 3, 4])\n  [5, 6, 3, 4, 1, 2]\n  */\nconst sotrOddEvenOddEvenOddEven = (l) => {\n  let even = [];\n  let odd = [];\n  l.forEach((item, index) => {\n    if (index % 2!== 0) {\n      even.push(item);\n    } else {\n      odd.push(item);\n    }\n  });\n  return [...odd,...even];\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sotrEvenOddEvenOddEvenOddEven([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sotrEvenOddEvenOddEvenOddEven([5, 6, 3, 4])\n  [5, 6, 3, 4, 1, 2]\n  */\nconst sotrEvenOddEvenOddEvenOddEven = (l) => {\n  let even = [];\n  let odd = [];\n  l.forEach((item, index) => {\n    if (index % 2!== 0) {\n      even.push(item);\n    } else {\n      odd.push(item);\n    }\n  });\n  return [...odd,...even];\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sotrOddEvenOddEvenOddEvenOddEven([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sotrOddEvenOddEvenOddEvenOddEven([5, 6, 3, 4])\n  [5, 6, 3, 4, 1, 2]\n  */\nconst sotrEvenOddEvenOddEvenOddEven = (l) => {\n  let even = [];\n  let odd = [];\n  l.forEach((item, index) => {\n    if (index % 2!== 0) {\n      even.push(item", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "gc": "<|endoftext|>/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupsGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupsGroupsGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupsGroupsGroupsGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupsGroupsGroupsGroupsGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroups", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "gc": "<|endoftext|>/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  if (n < 2) {\n    return 1;\n  }\n  if (n <= 3) {\n    return n;\n  }\n  if (n <= 5) {\n    return n;\n  }\n  if (n <= 7) {\n    return n;\n  }\n  if (n <= 9) {\n    return n;\n  }\n  if (n <= 13) {\n    return n;\n  }\n  if (n <= 21) {\n    return n;\n  }\n  if (n <= 89) {\n    return n;\n  }\n  if (n <= 144) {\n    return n;\n  }\n  if (n <= 233) {\n    return n;\n  }\n  if (n <= 258) {\n    return n;\n  }\n  if (n <= 293) {\n    return n;\n  }\n  if (n <= 419) {\n    return n;\n  }\n  if (n <= 467) {\n    return n;\n  }\n  if (n <= 511) {\n    return n;\n  }\n  if (n <= 593) {\n    return n;\n  }\n  if (n <= 627) {\n    return n;\n  }\n  if (n <= 675) {\n    return n;\n  }\n  if (n <= 715) {\n    return n;\n  }\n  if (n <= 767) {\n    return n;\n  }\n  if (n <= 843) {\n    return n;\n  }\n  if (n <= 907) {\n    return n;\n  }\n  if (n <= 983) {\n    return n;\n  }\n  if (n <= 1023) {\n    return n;\n  }\n  if (n <= 1047) {\n    return n;\n  }\n  if (n <= 1069) {\n    return n;\n  }\n  if (n <= 1117) {\n    return n;\n  }\n  if (n <= 1149) {\n    return n;\n  }\n  if (n <= 1213) {\n    return n;\n  }\n  if (n <= 1373) {\n    return n;\n  }\n  if (n <= 1419) {\n    return n;\n  }\n  if (n <= 1467) {\n    return n;\n  }\n  if (n <= 1503) {\n    return n;\n  }\n  if (n <= 1547) {\n    return n;\n  }\n  if (n <= 1569) {\n    return n;\n  }\n  if (n <= 1607) {\n    return n;\n  }\n  if (n <= 1647) {\n    return n;\n  }\n  if (n <= 1723) {\n    return n;\n  }\n  if (n <= 1779) {\n    return n;\n  }\n  if (n <= 1843) {\n    return n;\n  }\n  if (n <= 1919) {\n    return n;\n  }\n  if (n <= 1967) {\n    return n;\n  }\n  if (n <= 2027) {\n    return n;\n  }\n  if (n <= 2079) {\n    return n;\n  }\n  if (n <= 2113) {\n    return n;\n  }\n  if (n <= 2167) {\n    return n;\n  }\n  if (n <= 2213) {\n    return n;\n  }\n  if (n <= 2267) {\n    return n;\n  }\n  if (n <= 2303) {\n    return n;\n  }\n  if (n <= 2339) {\n    return n;\n  }\n  if (n <= 2393) {\n    return n;\n  }\n  if (n <= 2427) {\n    return n;\n  }\n  if (n <= 2479) {\n    return n;\n  }\n  if (n <= 2543) {\n    return n;\n  }\n  if (n <= 2619) {\n    return n;\n  }\n  if (n <= 2657) {\n    return n;\n  }\n  if (n <= 2707) {\n    return n;\n  }\n  if (n <= 2747) {\n    return n;\n  }\n  if (n <= 2779) {\n    return n;\n  }\n  if (n <= 2823) {\n    return n;\n  }\n  if (n <= 2887) {\n    return n;\n  }\n  if (n <= 2925) {\n    return n;\n  }\n  if (n <= 2957) {\n    return n;\n  }\n  if (n <= 3023) {\n    return n;\n  }\n  if (n <= 3059) {\n    return n;\n  }\n  if (n <= 3129) {\n    return n;\n  }\n  if (n <= 3189) {\n    return n;\n  }\n  if (n <= 3247) {\n    return n;\n  }\n  if (n <= 3279) {\n    return n;\n  }\n  if (n <= 3343) {\n    return n;\n  }\n  if (n <= 3399) {\n    return n;\n  }\n  if (n <= 3443) {\n    return n;\n  }\n  if (n <= 3499) {\n    return n;\n  }\n  if (n <= 3527) {\n    return n;\n  }\n  if (n <= 3593) {\n    return n;\n  }\n  if (n <= 3653) {\n    return n;\n  }\n  if (n <= 3719) {\n    return n;\n  }\n  if (n <= 3767) {\n    return n;\n  }\n  if (n <= 3823) {\n    return n;\n  }\n  if (n <= 3877) {\n    return n;\n  }\n  if (n <= 3927) {\n    return n;\n  }\n  if (n <= 3987) {\n    return n;\n  }\n  if (n <= 4047) {\n    return n;\n  }\n  if (n <= 4079) {\n    return n;\n  }\n  if (n <= 4131) {\n    return n;\n  }\n  if (n <= 4193) {\n    return n;\n  }\n  if (n <= 4239) {\n    return n;\n  }\n  if (n <= 4319) {\n    return n;\n  }\n  if (n <= 4347) {\n    return n;\n  }\n  if (n <= 4423) {\n    return n;\n  }\n  if (n <= 4479) {\n    return n;\n  }\n  if (n <= 4527) {\n    return n;\n  }\n  if (n <= 4593) {\n    return n;\n  }\n  if (n <= 4639) {\n    return n;\n  }\n  if (n <= 4709) {\n    return n;\n  }\n  if (n <= 4747) {\n    return n;\n  }\n  if (n <= 4793) {\n    return n;\n  }\n  if (n <= 4839) {\n    return n;\n  }\n  if (n <= 4879) {\n    return n;\n  }\n  if (n <= 4927) {\n    return n;\n  }\n  if (n <= 4987) {\n    return n;\n  }\n  if (n <= 5047) {\n    return n;\n  }\n  if (n <= 5079) {\n    return n;\n  }\n  if (n <= 5113) {\n    return n;\n  }\n  if (n <= 5193) {\n    return n;\n  }\n  if (n <= 5239) {\n    return n;\n  }\n  if (n <= 5347) {\n    return n;\n  }\n  if (n <= 5423) {\n    return n;\n  }\n  if (n <= 5479) {\n    return n;\n  }\n  if (n <= 5527) {\n    return n;\n  }\n  if (n <= 5579) {\n    return n;\n  }\n  if (n <= 5639) {\n    return n;\n  }\n  if (n <= 5727) {\n    return n;\n  }\n  if (n <= 5787) {\n    return n;\n  }\n  if (n <= 5843) {\n    return n;\n  }\n  if (n <= 5903) {\n    return n;\n  }\n  if (n <= 5953) {\n    return n;\n  }\n  if (n <= 6019) {\n    return n;\n  }\n  if (n <= 6067) {\n    return n;\n  }\n  if (n <= 6131) {\n    return n;\n  }\n  if (n <= 6193) {\n    return n;\n  }\n  if (n <= 6239) {\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoltueDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoltueDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoltueDeviation", "gc": "<|endoftext|>/* For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoltueDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoltueDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  return numbers.map(x => Math.abs(x - mean));\n};\n\n/* For a given list of input numbers, calculate Mean Squared Deviation\n  around the mean of this dataset.\n  Mean Squared Deviation is the average squared difference between each\n  element and a centerpoint (mean in this case):\n  MSE = average ^ 2 - x_mean ^ 2\n  >>> meanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  4.9\n  */\nconst meanSquaredDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  return numbers.map(x => x * x);\n};\n\n/* For a given list of input numbers, calculate Root Mean Squared Deviation\n  around the mean of this dataset.\n  Root Mean Squared Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  RMSE = sqrt(average ^ 2 - x_mean ^ 2)\n  >>> rootMeanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst rootMeanSquaredDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  return numbers.map(x => Math.sqrt(x * x));\n};\n\n/* For a given list of input numbers, calculate Standard Deviation around the\n  mean of this dataset.\n  Standard Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  SD = sqrt(average ^ 2 - x_mean ^ 2)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst standardDeviation = (numbers) => {\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  return numbers.map(x => Math.sqrt(x * x));\n};\n\n/* For a given list of input numbers, calculate Variance (standard deviation)\n  around mean of this dataset.\n  Variance is the square root of the standard deviation between each element\n  and a centerpoint (mean in this case):\n  V = sqrt(average ^ 2 - x_mean ^ 2)\n  >>> variance([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst variance = (numbers) => {\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  return numbers.map(x => Math.sqrt(x * x));\n};\n\n/* For a given list of input numbers, calculate Standard Deviation around the\n  median of this dataset.\n  Standard Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  SD = sqrt(average ^ 2 - x_mean ^ 2)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst standardDeviationMedian = (numbers) => {\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  return numbers.map(x => Math.sqrt(x * x)) / 2;\n};\n\n/* For a given list of input numbers, calculate Variance (standard deviation)\n  around median of this dataset.\n  Variance is the square root of the standard deviation between each element\n  and a centerpoint (mean in this case):\n  V = sqrt(average ^ 2 - x_mean ^ 2)\n  >>> variance([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst varianceMedian = (numbers) => {\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  return numbers.map(x => Math.sqrt(x * x)) / 2;\n};\n\n/* For a given list of input numbers, calculate Standard Deviation around the\n  mode of this dataset.\n  Standard Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  SD = sqrt(average ^ 2 - x_mean ^ 2)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst standardDeviationMode = (numbers) => {\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  return numbers.map(x => Math.sqrt(x * x));\n};\n\n/* For a given list of input numbers, calculate Variance (standard deviation)\n  around mode of this dataset.\n  Variance is the square root of the standard deviation between each element\n  and a centerpoint (mean in this case):\n  V = sqrt(average ^ 2 - x_mean ^ 2)\n  >>> variance([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst varianceMode = (numbers) => {\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  return numbers.map(x => Math.sqrt(x * x));\n};\n\n/* For a given list of input numbers, calculate Standard Deviation around the\n  minimum of this dataset.\n  Standard Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  SD = sqrt(average ^ 2 - x_mean ^ 2)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst standardDeviationMinimum = (numbers) => {\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  return numbers.map(x => Math.sqrt(x * x));\n};\n\n/* For a given list of input numbers, calculate Variance (standard deviation)\n  around minimum of this dataset.\n  Variance is the square root of the standard deviation between each element\n  and a centerpoint (mean in this case):\n  V = sqrt(average ^ 2 - x_mean ^ 2)\n  >>> variance([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst varianceMinimum = (numbers) => {\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  return numbers.map(x => Math.sqrt(x * x));\n};\n\n/* For a given list of input numbers, calculate Standard Deviation around the\n  maximum of this dataset.\n  Standard Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  SD = sqrt(average ^ 2 - x_mean ^ 2)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst standardDeviationMaximum = (numbers) => {\n  const mean = numbers.reduce((acc, x) => acc + x, 0) / numbers.length;\n  return numbers.map(x => Math.sqrt(x * x));\n};\n\n/* For a given list of input numbers, calculate Variance (standard deviation)\n  around maximum of this dataset.\n  Variance is the square root of the standard deviation between each element\n  and a centerpoint (mean in this case):\n  V = sqrt(average ^ 2 - x_mean ^ 2)\n  >>> variance([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst varianceMaximum = (numbers) => {\n  const ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "gc": "<|endoftext|>/*\n  triplesSumToZero takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  triplesAreEqual takes a list of integers as an input.\n  it returns true if all the elements in the list are equal, and false\n  otherwise.\n\n  >>> triplesAreEqual([1, 3, 5, 0])\n  true\n  >>> triplesAreEqual([1, 3, -2, 1])\n  false\n  >>> triplesAreEqual([1, 2, 3, 7])\n  false\n  >>> triplesAreEqual([2, 4, -5, 3, 9, 7])\n  false\n  >>> triplesAreEqual([1])\n  false\n  */\nconst triplesAreEqual = (l) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return false;\n    }\n  }\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === l[i]) {\n      return false;\n    }\n  }\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === l[i]) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  triplesAreEqual takes a list of integers as an input.\n  it returns true if all the elements in the list are equal, and false\n  otherwise.\n\n  >>> triplesAreEqual([1, 3, 5, 0])\n  true\n  >>> triplesAreEqual([1, 3, -2, 1])\n  false\n  >>> triplesAreEqual([1, 2, 3, 7])\n  false\n  >>> triplesAreEqual([2, 4, -5, 3, 9, 7])\n  false\n  >>> triplesAreEqual([1])\n  false\n  */\nconst triplesAreEqual2 = (l, r) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return false;\n    }\n  }\n  for (let i = 0; i < r.length; i++) {\n    sum += r[i];\n    if (sum === l[i]) {\n      return false;\n    }\n  }\n  for (let i = 0; i < r.length; i++) {\n    sum += r[i];\n    if (sum === r[i]) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  triplesAreEqual takes a list of integers as an input.\n  it returns true if all the elements in the list are equal, and false\n  otherwise.\n\n  >>> triplesAreEqual([1, 3, 5, 0])\n  true\n  >>> triplesAreEqual([1, 3, -2, 1])\n  false\n  >>> triplesAreEqual([1, 2, 3, 7])\n  false\n  >>> triplesAreEqual([2, 4, -5, 3, 9, 7])\n  false\n  >>> triplesAreEqual([1])\n  false\n  */\nconst triplesAreEqual3 = (l, r) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return false;\n    }\n  }\n  for (let i = 0; i < r.length; i++) {\n    sum += r[i];\n    if (sum === l[i]) {\n      return false;\n    }\n  }\n  for (let i = 0; i < r.length; i++) {\n    sum += r[i];\n    if (sum === r[i]) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  triplesAreEqual takes a list of integers as an input.\n  it returns true if all the elements in the list are equal, and false\n  otherwise.\n\n  >>> triplesAreEqual([1, 3, 5, 0])\n  true\n  >>> triplesAreEqual([1, 3, -2, 1])\n  false\n  >>> triplesAreEqual([1, 2, 3, 7])\n  false\n  >>> triplesAreEqual([2, 4, -5, 3, 9, 7])\n  false\n  >>> triplesAreEqual([1])\n  false\n  */\nconst triplesAreEqual4 = (l, r) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return false;\n    }\n  }\n  for (let i = 0; i < r.length; i++) {\n    sum += r[i];\n    if (sum === l[i]) {\n      return false;\n    }\n  }\n  for (let i = 0; i < r.length; i++) {\n    sum += r[i];\n    if (sum === r[i]) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  triplesAreEqual takes a list of integers as an input.\n  it returns true if all the elements in the list are equal, and false\n  otherwise.\n\n  >>> triplesAreEqual([1, 3, 5, 0])\n  true\n  >>> triplesAreEqual([1, 3, -2, 1])\n  false\n  >>> triplesAreEqual([1, 2, 3, 7])\n  false\n  >>> triplesAreEqual([2, 4, -5, 3, 9, 7])\n  false\n  >>> triplesAreEqual([1])\n  false\n  */\nconst triplesAreEqual5 = (l, r) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return false;\n    }\n  }\n  for (let i = 0; i < r.length; i++) {\n    sum += r[i];\n    if (sum === l[i]) {\n      return false;\n    }\n  }\n  for (let i = 0; i < r.length; i++) {\n    sum += r[i];\n    if (sum === r[i]) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  triplesAreEqual takes a list of integers as an input.\n  it returns true if all the elements in the list are equal, and false\n  otherwise.\n\n  >>> triplesAreEqual([1, 3, 5, 0])\n  true\n  >>> triplesAreEqual([1, 3, -2, 1])\n  false\n  >>> triplesAreEqual([1, 2, 3, 7])\n  false\n  >>> triplesAreEqual([2, 4, -5, 3, 9, 7])\n  false\n  >>> triplesAreEqual([1])\n  false\n  */\nconst triplesAreEqual6 = (l, r) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return false;\n    }\n  }\n  for (let i = 0; i < r.length; i++) {\n    sum += r[i];\n    if (sum === l[i]) {\n      return false;\n    }\n  }\n  for (let i = 0; i < r.length; i++) {\n    sum += r[i];\n    if (sum === r[i]) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/*\n  triplesAreEqual takes a list of integers as an input.\n  it returns true if all the elements in the list are equal, and false\n  otherwise.\n\n  >>> triplesAreEqual([1, 3, 5, 0])\n  true\n  >>> triplesAreEqual([1, 3, -2, 1])\n  false\n  >>> triplesAreEqual([1, 2, 3, 7])\n  false\n  >>> triplesAreEqual([2, 4, -5, 3, 9, 7])\n  false\n  >>> triplesAreEqual([1])\n  false\n  */\nconst triplesAreEqual7 = (l, r) => {\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return false;\n    }\n  }\n  for (let i = 0; i < r.length; i++) {\n    sum += r[i];\n    if (sum === l[i]) {\n      return false;\n    }\n  }\n  for (let i = 0; i < r.length; i++) {\n    sum += r[i];\n    if (sum === r[i]) {\n      return true;\n    }", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst acrRacelColision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "acrRacelColision", "gc": "<|endoftext|>/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst acrRacelColision = (n) => {\n  let collisions = 0;\n  let carsLeft = n;\n  let carsRight = n;\n  let carsMovingLeft = 0;\n  let carsMovingRight = 0;\n  let carsMovingLeftMovingRight = 0;\n  let carsMovingLeftMovingRightMovingLeft = 0;\n  let carsMovingLeftMovingRightMovingLeftMovingRight = 0;\n  let carsMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRight = 0;\n  let carsMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMovingRightMovingLeftMo", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "gc": "<|endoftext|>/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let n = 0;\n  for (let i = 0; i < l.length; i++) {\n    n += l[i];\n  }\n  return [n];\n};\n\n/**\n  Remove all occurrences of an element from a list.\n  >>> removeAll([1, 2, 3, 4], 2)\n  [3, 4]\n  >>> removeAll([1, 2, 3, 4], 3)\n  []\n  >>> removeAll([1, 2, 3, 4], 4)\n  []\n  >>> removeAll([1, 2, 3, 4], 5)\n  []\n  >>> removeAll([1, 2, 3, 4], 6)\n  []\n  >>> removeAll([1, 2, 3, 4], 7)\n  []\n  >>> removeAll([1, 2, 3, 4], 8)\n  []\n  >>> removeAll([1, 2, 3, 4], 9)\n  []\n  >>> removeAll([1, 2, 3, 4], 10)\n  []\n  >>> removeAll([1, 2, 3, 4], 11)\n  []\n  >>> removeAll([1, 2, 3, 4], 12)\n  []\n  >>> removeAll([1, 2, 3, 4], 13)\n  []\n  >>> removeAll([1, 2, 3, 4], 14)\n  []\n  >>> removeAll([1, 2, 3, 4], 15)\n  []\n  >>> removeAll([1, 2, 3, 4], 16)\n  []\n  >>> removeAll([1, 2, 3, 4], 17)\n  []\n  >>> removeAll([1, 2, 3, 4], 18)\n  []\n  >>> removeAll([1, 2, 3, 4], 19)\n  []\n  >>> removeAll([1, 2, 3, 4], 20)\n  []\n  >>> removeAll([1, 2, 3, 4], 21)\n  []\n  >>> removeAll([1, 2, 3, 4], 22)\n  []\n  >>> removeAll([1, 2, 3, 4], 23)\n  []\n  >>> removeAll([1, 2, 3, 4], 24)\n  []\n  >>> removeAll([1, 2, 3, 4], 25)\n  []\n  >>> removeAll([1, 2, 3, 4], 26)\n  []\n  >>> removeAll([1, 2, 3, 4], 27)\n  []\n  >>> removeAll([1, 2, 3, 4], 28)\n  []\n  >>> removeAll([1, 2, 3, 4], 29)\n  []\n  >>> removeAll([1, 2, 3, 4], 30)\n  []\n  >>> removeAll([1, 2, 3, 4], 31)\n  []\n  >>> removeAll([1, 2, 3, 4], 32)\n  []\n  >>> removeAll([1, 2, 3, 4], 33)\n  []\n  >>> removeAll([1, 2, 3, 4], 34)\n  []\n  >>> removeAll([1, 2, 3, 4], 35)\n  []\n  >>> removeAll([1, 2, 3, 4], 36)\n  []\n  >>> removeAll([1, 2, 3, 4], 37)\n  []\n  >>> removeAll([1, 2, 3, 4], 38)\n  []\n  >>> removeAll([1, 2, 3, 4], 39)\n  []\n  >>> removeAll([1, 2, 3, 4], 40)\n  []\n  >>> removeAll([1, 2, 3, 4], 41)\n  []\n  >>> removeAll([1, 2, 3, 4], 42)\n  []\n  >>> removeAll([1, 2, 3, 4], 43)\n  []\n  >>> removeAll([1, 2, 3, 4], 44)\n  []\n  >>> removeAll([1, 2, 3, 4], 45)\n  []\n  >>> removeAll([1, 2, 3, 4], 46)\n  []\n  >>> removeAll([1, 2, 3, 4], 47)\n  []\n  >>> removeAll([1, 2, 3, 4], 48)\n  []\n  >>> removeAll([1, 2, 3, 4], 49)\n  []\n  >>> removeAll([1, 2, 3, 4], 50)\n  []\n  >>> removeAll([1, 2, 3, 4], 51)\n  []\n  >>> removeAll([1, 2, 3, 4], 52)\n  []\n  >>> removeAll([1, 2, 3, 4], 53)\n  []\n  >>> removeAll([1, 2, 3, 4], 54)\n  []\n  >>> removeAll([1, 2, 3, 4], 55)\n  []\n  >>> removeAll([1, 2, 3, 4], 56)\n  []\n  >>> removeAll([1, 2, 3, 4], 57)\n  []\n  >>> removeAll([1, 2, 3, 4], 58)\n  []\n  >>> removeAll([1, 2, 3, 4], 59)\n  []\n  >>> removeAll([1, 2, 3, 4], 60)\n  []\n  >>> removeAll([1, 2, 3, 4], 61)\n  []\n  >>> removeAll([1, 2, 3, 4], 62)\n  []\n  >>> removeAll([1, 2, 3, 4], 63)\n  []\n  >>> removeAll([1, 2, 3, 4], 64)\n  []\n  >>> removeAll([1, 2, 3, 4], 65)\n  []\n  >>> removeAll([1, 2, 3, 4], 66)\n  []\n  >>> removeAll([1, 2, 3, 4], 67)\n  []\n  >>> removeAll([1, 2, 3, 4], 68)\n  []\n  >>> removeAll([1, 2, 3, 4], 69)\n  []\n  >>> removeAll([1, 2, 3, 4], 70)\n  []\n  >>> removeAll([1, 2, 3, 4], 71)\n  []\n  >>> removeAll([1, 2, 3, 4], 72)\n  []\n  >>> removeAll([1, 2, 3, 4], 73)\n  []\n  >>> removeAll([1, 2, 3, 4], 74)\n  []\n  >>> removeAll([1, 2, 3, 4], 75)\n  []\n  >>> removeAll([1, 2, 3, 4], 76)\n  []\n  >>> removeAll([1, 2, 3, 4], 77)\n  []\n  >>> removeAll([1, 2, 3, 4], 78)\n  []\n  >>> removeAll([1, 2, 3, 4], 79)\n  []\n  >>> removeAll([1, 2, 3, 4], 80)\n  []\n  >>> removeAll([1, 2, 3, 4], 81)\n  []\n  >>> removeAll([1, 2, 3, 4], 82)\n  []\n  >>> removeAll([1, 2, 3, 4], 83)\n  []\n  >>> removeAll([1, 2, 3, 4], 84)\n  []\n  >>> removeAll([1, 2, 3, 4], 85)\n  []\n  >>> removeAll([1, 2, 3, 4], 86)\n  []\n  >>> removeAll([1, 2, 3, 4], 87)\n  []\n  >>> removeAll([1, 2, 3, 4], 88)\n  []\n  >>> removeAll([1, 2, 3, 4], 89)\n  []\n  >>> removeAll([1, 2, 3, 4], 90)\n  []\n  >>> removeAll([1, 2, 3, 4], 91)\n  []\n  >>> removeAll([1, 2, 3, 4], 92)\n  []\n  >>> removeAll([1, 2, 3, 4], 93)\n  []\n  >>> removeAll([1, 2, 3, 4], 94)\n  []\n  >>> removeAll([1, 2, 3, 4], 95)\n  []\n  >>> removeAll([1, 2, 3, 4], 96)\n  []\n  >>> removeAll([1, 2, 3, 4], 97)\n  []\n  >>> removeAll([1, 2, 3, 4], 98)\n  []\n  >>> removeAll([1, 2, 3, 4], 99)\n  []\n  >>> removeAll([1, 2, 3, 4], 100)\n  []\n  >>> removeAll([1, 2, 3, 4], 101)\n  []\n  >>> removeAll([1, 2, 3, 4], 102)\n  []\n  >>> removeAll([1, 2, 3, 4], 103)\n  []\n  >>> removeAll([1, 2, 3, 4], 104)\n  []\n  >>> removeAll([1, 2, 3, 4], 105)\n  []\n  >>> removeAll([1, 2, 3, 4], 106)\n  []\n  >>> removeAll([1, 2, 3, 4], 107)\n  []\n  >>> removeAll([1, 2, 3, 4], 108)\n  []\n  >>> removeAll([1, 2, 3, 4], 109)\n  []\n  >>> removeAll([1, 2, 3, 4], 110)\n  []\n  >>> removeAll([1, 2, 3, 4], 111)\n  []\n  >>> removeAll([1, 2, 3, 4], 112)\n  []\n  >>> removeAll([1, 2, 3, 4], 113)\n  []\n  >>> removeAll([1, 2, 3, 4], 114)\n  []\n  >>> removeAll([1, 2, 3, 4], 11", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/43", "prompt": "/*\n  apirSsumoTZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> apirSsumoTZero([1, 3, 5, 0])\n  false\n  >>> apirSsumoTZero([1, 3, -2, 1])\n  false\n  >>> apirSsumoTZero([1, 2, 3, 7])\n  false\n  >>> apirSsumoTZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoTZero([1])\n  false\n  */\nconst apirSsumoTZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "apirSsumoTZero", "gc": "<|endoftext|>/*\n  apirSsumoTZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> apirSsumoTZero([1, 3, 5, 0])\n  false\n  >>> apirSsumoTZero([1, 3, -2, 1])\n  false\n  >>> apirSsumoTZero([1, 2, 3, 7])\n  false\n  >>> apirSsumoTZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoTZero([1])\n  false\n  */\nconst apirSsumoTZero = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/**\n  apirSsumoTInf takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  are positive infinity, and false otherwise.\n  >>> apirSsumoTInf([1, 3, 5, 0])\n  false\n  >>> apirSsumoTInf([1, 3, -2, 1])\n  false\n  >>> apirSsumoTInf([1, 2, 3, 7])\n  false\n  >>> apirSsumoTInf([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoTInf([1])\n  false\n  */\nconst apirSsumoTInf = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum > 0) {\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/**\n  apirSsumoTNaN takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  are negative infinity, and false otherwise.\n  >>> apirSsumoTNaN([1, 3, 5, 0])\n  false\n  >>> apirSsumoTNaN([1, 3, -2, 1])\n  false\n  >>> apirSsumoTNaN([1, 2, 3, 7])\n  false\n  >>> apirSsumoTNaN([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoTNaN([1])\n  false\n  */\nconst apirSsumoTNaN = (l) => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum < 0) {\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/**\n  apirSsumoTInf takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  are positive infinity, and false otherwise.\n  >>> apirSsumoTInf([1, 3, 5, 0])\n  false\n  >>> apirSsumoTInf([1, 3, -2, 1])\n  false\n  >>> apirSsumoTInf([1, 2, 3, 7])\n  false\n  >>> apirSsumoTInf([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoTInf([1])\n  false\n  */\nconst apirSsumoTInf = l => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum > 0) {\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/**\n  apirSsumoTNaN takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  are negative infinity, and false otherwise.\n  >>> apirSsumoTNaN([1, 3, 5, 0])\n  false\n  >>> apirSsumoTNaN([1, 3, -2, 1])\n  false\n  >>> apirSsumoTNaN([1, 2, 3, 7])\n  false\n  >>> apirSsumoTNaN([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoTNaN([1])\n  false\n  */\nconst apirSsumoTNaN = l => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum < 0) {\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/**\n  apirSsumoTInf takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  are positive infinity, and false otherwise.\n  >>> apirSsumoTInf([1, 3, 5, 0])\n  false\n  >>> apirSsumoTInf([1, 3, -2, 1])\n  false\n  >>> apirSsumoTInf([1, 2, 3, 7])\n  false\n  >>> apirSsumoTInf([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoTInf([1])\n  false\n  */\nconst apirSsumoTInf = l => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum > 0) {\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/**\n  apirSsumoTNaN takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  are negative infinity, and false otherwise.\n  >>> apirSsumoTNaN([1, 3, 5, 0])\n  false\n  >>> apirSsumoTNaN([1, 3, -2, 1])\n  false\n  >>> apirSsumoTNaN([1, 2, 3, 7])\n  false\n  >>> apirSsumoTNaN([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoTNaN([1])\n  false\n  */\nconst apirSsumoTNaN = l => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum < 0) {\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/**\n  apirSsumoTInf takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  are positive infinity, and false otherwise.\n  >>> apirSsumoTInf([1, 3, 5, 0])\n  false\n  >>> apirSsumoTInf([1, 3, -2, 1])\n  false\n  >>> apirSsumoTInf([1, 2, 3, 7])\n  false\n  >>> apirSsumoTInf([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoTInf([1])\n  false\n  */\nconst apirSsumoTInf = l => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum > 0) {\n      count++;\n    }\n  }\n  return count === 2;\n};\n\n/**\n  apirSsumoTInf takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  are negative infinity, and false otherwise.\n  >>> apirSsumoTInf([1, 3, 5, 0])\n  false\n  >>> apirSsumoTInf([1, 3, -2, 1])\n  false\n  >>> apirSsumoTInf([1, 2, 3, 7])\n  false\n  >>> apirSsumoTInf([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoTInf([1])\n  false\n  */\nconst apirSsumoTInf = l => {\n  let sum = 0;\n  let count = 0;\n  for (let i = 0; i < l.length; i++) {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "gc": "<|endoftext|>/*Change numerical base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  if (base === 10) {\n    return x.toString();\n  }\n  const digits = x.toString().split('');\n  const digit = digits[digits.length - base];\n  const reversed = digit.reverse();\n  return reversed.join('') + digit.slice(0, digit.length - base);\n};\n\n/**\n * Convert a string to a number.\n *\n * @param  {string} str\n * @param  {number} base\n * @return {number}\n */\nconst toNumber = (str, base) => {\n  if (base === 10) {\n    return parseInt(str, 10);\n  }\n  const digits = str.split('');\n  const digit = digits[digits.length - base];\n  const reversed = digit.reverse();\n  return parseInt(reversed.join(''), base);\n};\n\n/**\n * Convert a string to a number.\n *\n * @param  {string} str\n * @param  {number} base\n * @return {number}\n */\nconst toNumber = (str, base) => {\n  if (base === 10) {\n    return parseInt(str, 10);\n  }\n  const digits = str.split('');\n  const digit = digits[digits.length - base];\n  const reversed = digit.reverse();\n  return parseInt(reversed.join(''), base);\n};\n\n/**\n * Convert a string to a number.\n *\n * @param  {string} str\n * @param  {number} base\n * @return {number}\n */\nconst toNumber = (str, base) => {\n  if (base === 10) {\n    return parseInt(str, 10);\n  }\n  const digits = str.split('');\n  const digit = digits[digits.length - base];\n  const reversed = digit.reverse();\n  return parseInt(reversed.join(''), base);\n};\n\n/**\n * Convert a string to a number.\n *\n * @param  {string} str\n * @param  {number} base\n * @return {number}\n */\nconst toNumber = (str, base) => {\n  if (base === 10) {\n    return parseInt(str, 10);\n  }\n  const digits = str.split('');\n  const digit = digits[digits.length - base];\n  const reversed = digit.reverse();\n  return parseInt(reversed.join(''), base);\n};\n\n/**\n * Convert a string to a number.\n *\n * @param  {string} str\n * @param  {number} base\n * @return {number}\n */\nconst toNumber = (str, base) => {\n  if (base === 10) {\n    return parseInt(str, 10);\n  }\n  const digits = str.split('');\n  const digit = digits[digits.length - base];\n  const reversed = digit.reverse();\n  return parseInt(reversed.join(''), base);\n};\n\n/**\n * Convert a string to a number.\n *\n * @param  {string} str\n * @param  {number} base\n * @return {number}\n */\nconst toNumber = (str, base) => {\n  if (base === 10) {\n    return parseInt(str, 10);\n  }\n  const digits = str.split('');\n  const digit = digits[digits.length - base];\n  const reversed = digit.reverse();\n  return parseInt(reversed.join(''), base);\n};\n\n/**\n * Convert a string to a number.\n *\n * @param  {string} str\n * @param  {number} base\n * @return {number}\n */\nconst toNumber = (str, base) => {\n  if (base === 10) {\n    return parseInt(str, 10);\n  }\n  const digits = str.split('');\n  const digit = digits[digits.length - base];\n  const reversed = digit.reverse();\n  return parseInt(reversed.join(''), base);\n};\n\n/**\n * Convert a string to a number.\n *\n * @param  {string} str\n * @param  {number} base\n * @return {number}\n */\nconst toNumber = (str, base) => {\n  if (base === 10) {\n    return parseInt(str, 10);\n  }\n  const digits = str.split('');\n  const digit = digits[digits.length - base];\n  const reversed = digit.reverse();\n  return parseInt(reversed.join(''), base);\n};\n\n/**\n * Convert a string to a number.\n *\n * @param  {string} str\n * @param  {number} base\n * @return {number}\n */\nconst toNumber = (str, base) => {\n  if (base === 10) {\n    return parseInt(str, 10);\n  }\n  const digits = str.split('');\n  const digit = digits[digits.length - base];\n  const reversed = digit.reverse();\n  return parseInt(reversed.join(''), base);\n};\n\n/**\n * Convert a string to a number.\n *\n * @param  {string} str\n * @param  {number} base\n * @return {number}\n */\nconst toNumber = (str, base) => {\n  if (base === 10) {\n    return parseInt(str, 10);\n  }\n  const digits = str.split('');\n  const digit = digits[digits.length - base];\n  const reversed = digit.reverse();\n  return parseInt(reversed.join(''), base);\n};\n\n/**\n * Convert a string to a number.\n *\n * @param  {string} str\n * @param  {number} base\n * @return {number}\n */\nconst toNumber = (str, base) => {\n  if (base === 10) {\n    return parseInt(str, 10);\n  }\n  const digits = str.split('');\n  const digit = digits[digits.length - base];\n  const reversed = digit.reverse();\n  return parseInt(reversed.join(''), base);\n};\n\n/**\n * Convert a string to a number.\n *\n * @param  {string} str\n * @param  {number} base\n * @return {number}\n */\nconst toNumber = (str, base) => {\n  if (base === 10) {\n    return parseInt(str, 10);\n  }\n  const digits = str.split('');\n  const digit = digits[digits.length - base];\n  const reversed = digit.reverse();\n  return parseInt(reversed.join(''), base);\n};\n\n/**\n * Convert a string to a number.\n *\n * @param  {string} str\n * @param  {number} base\n * @return {number}\n */\nconst toNumber = (str, base) => {\n  if (base === 10) {\n    return parseInt(str, 10);\n  }\n  const digits = str.split('');\n  const digit = digits[digits.length - base];\n  const reversed = digit.reverse();\n  return parseInt(reversed.join(''), base);\n};\n\n/**\n * Convert a string to a number.\n *\n * @param  {string} str\n * @param  {number} base\n * @return {number}\n */\nconst toNumber = (str, base) => {\n  if (base === 10) {\n    return parseInt(str, 10);\n  }\n  const digits = str.split('');\n  const digit = digits[digits.length - base];\n  const reversed = digit.reverse();\n  return parseInt(reversed.join(''), base);\n};\n\n/**\n * Convert a string to a number.\n *\n * @param  {string} str\n * @param  {number} base\n * @return {number}\n */\nconst toNumber = (str, base) => {\n  if (base === 10) {\n    return parseInt(str, 10);\n  }\n  const digits = str.split('');\n  const digit = digits[digits.length - base];\n  const reversed = digit.reverse();\n  return parseInt(reversed.join(''), base);\n};\n\n/**\n * Convert a string to a number.\n *\n * @param  {string} str\n * @param  {number} base\n * @return {number}\n */\nconst toNumber = (str, base) => {\n  if (base === 10) {\n    return parseInt(str, 10);\n  }\n  const digits = str.split('');\n  const digit = digits[digits.length - base];\n  const reversed = digit.reverse();\n  return parseInt(reversed.join(''), base);\n};\n\n/**\n * Convert a string to a number.\n *\n * @param  {string} str\n * @param  {number} base\n * @return {number}\n */\nconst toNumber = (str, base) => {\n  if (base === 10) {\n    return parseInt(str, 10);\n  }\n  const digits = str.split('');\n  const digit = digits[digits.length - base];\n  const reversed = digit.reverse();\n  return parseInt(reversed.join(''), base);\n};\n\n/**\n * Convert a string to a number.\n *\n * @param  {string} str\n * @param  {number} base", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/45", "prompt": "/*Given length of a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "gc": "<|endoftext|>/*Given length of a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  return Math.sqrt(a * a + h * h);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 2)\n  9\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 1)\n  8\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 0)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 1)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 2)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 3)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 4)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 5)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 6)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 7)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 8)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 9)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 10)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 11)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 12)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 13)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 14)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 15)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 16)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 17)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 18)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 19)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 20)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 21)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 22)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 23)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 24)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 25)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 26)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 27)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 28)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 29)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 30)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 31)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 32)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 33)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(5, 34)\n  0\n  */\nconst triangleArea = (l, w) => {\n  return l * w;\n};\n\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "gc": "<|endoftext|>/*The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n <= 1) return 0;\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is fib(n) and whose last element is fib(n+1).\n  >>> fib(n+1)\n  5\n  >>> fib(n+2)\n  8\n  >>> fib(n+3)\n  13\n  >>> fib(n+4)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) return 0;\n  return fib(n) + fib(n + 1);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is fib(n) and whose last element is fib(n+1).\n  >>> fib(n+1)\n  5\n  >>> fib(n+2)\n  8\n  >>> fib(n+3)\n  13\n  >>> fib(n+4)\n  21\n  */\nconst fib1 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n) + fib(n + 1);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is fib(n) and whose last element is fib(n+1).\n  >>> fib(n+1)\n  5\n  >>> fib(n+2)\n  8\n  >>> fib(n+3)\n  13\n  >>> fib(n+4)\n  21\n  */\nconst fib2 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n) + fib(n + 1) + fib(n + 2) + fib(n + 3) + fib(n + 4);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is fib(n) and whose last element is fib(n+1).\n  >>> fib(n+1)\n  5\n  >>> fib(n+2)\n  8\n  >>> fib(n+3)\n  13\n  >>> fib(n+4)\n  21\n  */\nconst fib3 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n) + fib(n + 1) + fib(n + 2) + fib(n + 3) + fib(n + 4) + fib(n + 5);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is fib(n) and whose last element is fib(n+1).\n  >>> fib(n+1)\n  5\n  >>> fib(n+2)\n  8\n  >>> fib(n+3)\n  13\n  >>> fib(n+4)\n  21\n  */\nconst fib4 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n) + fib(n + 1) + fib(n + 2) + fib(n + 3) + fib(n + 4) + fib(n + 5) + fib(n + 6);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is fib(n) and whose last element is fib(n+1).\n  >>> fib(n+1)\n  5\n  >>> fib(n+2)\n  8\n  >>> fib(n+3)\n  13\n  >>> fib(n+4)\n  21\n  */\nconst fib5 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n) + fib(n + 1) + fib(n + 2) + fib(n + 3) + fib(n + 4) + fib(n + 5) + fib(n + 6) + fib(n + 7);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is fib(n) and whose last element is fib(n+1).\n  >>> fib(n+1)\n  5\n  >>> fib(n+2)\n  8\n  >>> fib(n+3)\n  13\n  >>> fib(n+4)\n  21\n  */\nconst fib6 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n) + fib(n + 1) + fib(n + 2) + fib(n + 3) + fib(n + 4) + fib(n + 5) + fib(n + 6) + fib(n + 7) + fib(n + 8);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is fib(n) and whose last element is fib(n+1).\n  >>> fib(n+1)\n  5\n  >>> fib(n+2)\n  8\n  >>> fib(n+3)\n  13\n  >>> fib(n+4)\n  21\n  */\nconst fib7 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n) + fib(n + 1) + fib(n + 2) + fib(n + 3) + fib(n + 4) + fib(n + 5) + fib(n + 6) + fib(n + 7) + fib(n + 8) + fib(n + 9);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is fib(n) and whose last element is fib(n+1).\n  >>> fib(n+1)\n  5\n  >>> fib(n+2)\n  8\n  >>> fib(n+3)\n  13\n  >>> fib(n+4)\n  21\n  */\nconst fib8 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n) + fib(n + 1) + fib(n + 2) + fib(n + 3) + fib(n + 4) + fib(n + 5) + fib(n + 6) + fib(n + 7) + fib(n + 8) + fib(n + 9) + fib(n + 10);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is fib(n) and whose last element is fib(n+1).\n  >>> fib(n+1)\n  5\n  >>> fib(n+2)\n  8\n  >>> fib(n+3)\n  13\n  >>> fib(n+4)\n  21\n  */\nconst fib9 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n) + fib(n + 1) + fib(n + 2) + fib(n + 3) + fib(n + 4) + fib(n + 5) + fib(n + 6) + fib(n + 7) + fib(n + 8) + fib(n + 9) + fib(n + 10) + fib(n + 11);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first element is fib(n) and whose last element is fib(n+1).\n  >>> fib(n+1)\n  5\n  >>> fib(n+2)\n  8\n  >>> fib(n+3)\n  13\n  >>> fib(n+4)\n  21\n  */\nconst fib10 = (n) => {\n  if (n <= 1) return 0;\n  return fib(n) + fib(n + 1) + fib(n + 2) + fib(n + 3) + fib(n + 4) + fib(n + 5) + fib(n + 6) + fib(n + 7) + fib(n + 8) + fib(n + 9) + fib(n + 10) + fib(n + 11) + fib(n + 12);\n};\n\n/*", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "gc": "<|endoftext|>/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let n = l.length\n  if (n % 2 === 0) return l[Math.floor(n / 2)]\n  let mid = Math.floor((n + 0.5) / 2)\n  return l[mid] + (l[mid+1] - l[mid]) / 2\n}\n\n/*Return sum of elements in the list l.\n  >>> sum([3, 1, 2, 4, 5])\n  15\n  >>> sum([-10, 4, 6, 1000, 10, 20])\n  50\n  */\nconst sum = (l) => {\n  let n = l.length\n  let sum = 0\n  for (let i = 0; i < n; i++) {\n    sum += l[i]\n  }\n  return sum\n}\n\n/*Return difference of elements in the list l.\n  >>> difference([3, 1, 2, 4, 5])\n  -1\n  >>> difference([-10, 4, 6, 1000, 10, 20])\n  0\n  */\nconst difference = (l) => {\n  let n = l.length\n  let diff = 0\n  for (let i = 0; i < n; i++) {\n    diff += l[i] - l[i + 1]\n  }\n  return diff\n}\n\n/*Return product of elements in the list l.\n  >>> product([3, 1, 2, 4, 5])\n  6\n  >>> product([-10, 4, 6, 1000, 10, 20])\n  24\n  */\nconst product = (l) => {\n  let n = l.length\n  let prod = 1\n  for (let i = 0; i < n; i++) {\n    prod *= l[i]\n  }\n  return prod\n}\n\n/*Return quotient of elements in the list l.\n  >>> quotient([3, 1, 2, 4, 5])\n  2\n  >>> quotient([-10, 4, 6, 1000, 10, 20])\n  1\n  */\nconst quotient = (l) => {\n  let n = l.length\n  let quo = 1\n  for (let i = 0; i < n; i++) {\n    quo *= l[i]\n  }\n  return quo\n}\n\n/*Return remainder of elements in the list l.\n  >>> remainder([3, 1, 2, 4, 5])\n  3\n  >>> remainder([-10, 4, 6, 1000, 10, 20])\n  1\n  */\nconst remainder = (l) => {\n  let n = l.length\n  let rem = 0\n  for (let i = 0; i < n; i++) {\n    rem += l[i] % 1\n  }\n  return rem\n}\n\n/*Return remainder of elements in the list l.\n  >>> remainder([3, 1, 2, 4, 5])\n  3\n  >>> remainder([-10, 4, 6, 1000, 10, 20])\n  1\n  */\nconst remainder2 = (l) => {\n  let n = l.length\n  let rem = 0\n  for (let i = 0; i < n; i++) {\n    rem += l[i] % 2\n  }\n  return rem\n}\n\n/*Return remainder of elements in the list l.\n  >>> remainder([3, 1, 2, 4, 5])\n  3\n  >>> remainder([-10, 4, 6, 1000, 10, 20])\n  1\n  */\nconst remainder3 = (l) => {\n  let n = l.length\n  let rem = 0\n  for (let i = 0; i < n; i++) {\n    rem += l[i] % 3\n  }\n  return rem\n}\n\n/*Return remainder of elements in the list l.\n  >>> remainder([3, 1, 2, 4, 5])\n  3\n  >>> remainder([-10, 4, 6, 1000, 10, 20])\n  1\n  */\nconst remainder4 = (l) => {\n  let n = l.length\n  let rem = 0\n  for (let i = 0; i < n; i++) {\n    rem += l[i] % 4\n  }\n  return rem\n}\n\n/*Return remainder of elements in the list l.\n  >>> remainder([3, 1, 2, 4, 5])\n  3\n  >>> remainder([-10, 4, 6, 1000, 10, 20])\n  1\n  */\nconst remainder5 = (l) => {\n  let n = l.length\n  let rem = 0\n  for (let i = 0; i < n; i++) {\n    rem += l[i] % 5\n  }\n  return rem\n}\n\n/*Return remainder of elements in the list l.\n  >>> remainder([3, 1, 2, 4, 5])\n  3\n  >>> remainder([-10, 4, 6, 1000, 10, 20])\n  1\n  */\nconst remainder6 = (l) => {\n  let n = l.length\n  let rem = 0\n  for (let i = 0; i < n; i++) {\n    rem += l[i] % 6\n  }\n  return rem\n}\n\n/*Return remainder of elements in the list l.\n  >>> remainder([3, 1, 2, 4, 5])\n  3\n  >>> remainder([-10, 4, 6, 1000, 10, 20])\n  1\n  */\nconst remainder7 = (l) => {\n  let n = l.length\n  let rem = 0\n  for (let i = 0; i < n; i++) {\n    rem += l[i] % 7\n  }\n  return rem\n}\n\n/*Return remainder of elements in the list l.\n  >>> remainder([3, 1, 2, 4, 5])\n  3\n  >>> remainder([-10, 4, 6, 1000, 10, 20])\n  1\n  */\nconst remainder8 = (l) => {\n  let n = l.length\n  let rem = 0\n  for (let i = 0; i < n; i++) {\n    rem += l[i] % 8\n  }\n  return rem\n}\n\n/*Return remainder of elements in the list l.\n  >>> remainder([3, 1, 2, 4, 5])\n  3\n  >>> remainder([-10, 4, 6, 1000, 10, 20])\n  1\n  */\nconst remainder9 = (l) => {\n  let n = l.length\n  let rem = 0\n  for (let i = 0; i < n; i++) {\n    rem += l[i] % 9\n  }\n  return rem\n}\n\n/*Return remainder of elements in the list l.\n  >>> remainder([3, 1, 2, 4, 5])\n  3\n  >>> remainder([-10, 4, 6, 1000, 10, 20])\n  1\n  */\nconst remainder10 = (l) => {\n  let n = l.length\n  let rem = 0\n  for (let i = 0; i < n; i++) {\n    rem += l[i] % 10\n  }\n  return rem\n}\n\n/*Return remainder of elements in the list l.\n  >>> remainder([3, 1, 2, 4, 5])\n  3\n  >>> remainder([-10, 4, 6, 1000, 10, 20])\n  1\n  */\nconst remainder11 = (l) => {\n  let n = l.length\n  let rem = 0\n  for (let i = 0; i < n; i++) {\n    rem += l[i] % 11\n  }\n  return rem\n}\n\n/*Return remainder of elements in the list l.\n  >>> remainder([3, 1, 2, 4, 5])\n  3\n  >>> remainder([-10, 4, 6, 1000, 10, 20])\n  1\n  */\nconst remainder12 = (l) => {\n  let n = l.length\n  let rem = 0\n  for (let i = 0; i < n; i++) {\n    rem += l[i] % 12\n  }\n  return rem\n}\n\n/*Return remainder of elements in the list l.\n  >>> remainder([3, 1, 2, 4, 5])\n  3\n  >>> remainder([-10, 4, 6, 1000, 10, 20])\n  1\n  */\nconst remainder13 = (l) => {\n  let n = l.length\n  let rem = 0\n  for (let i = 0; i < n; i++) {\n    rem += l[i] % 13\n  }\n  return rem\n}\n\n/*Return remainder of elements in the list l.\n  >>> remainder([3, 1, 2, 4, 5])\n  3\n  >>> remainder([-10, 4, 6, 1000, 10, 20])\n  1\n  */\nconst remainder14 = (l) => {\n  let n = l.length\n  let rem = 0\n  for (let i = 0; i < n; i++) {\n    rem += l[i] % 14\n  }\n  return rem\n}\n\n/*Return remainder of elements in the list l.\n  >>> remainder([3, 1, 2, 4, 5])\n  3\n  >>> remainder([-10, 4, 6, 1000, 10, 20])\n  1\n  */\nconst ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "gc": "<|endoftext|>/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText === text\n}\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  */\nconst isPalindromeOfLength = (text, length) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText.length === length\n}\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  */\nconst isPalindromeOfLength = (text, length) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText.length === length\n}\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  */\nconst isPalindromeOfLength = (text, length) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText.length === length\n}\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  */\nconst isPalindromeOfLength = (text, length) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText.length === length\n}\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  */\nconst isPalindromeOfLength = (text, length) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText.length === length\n}\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  */\nconst isPalindromeOfLength = (text, length) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText.length === length\n}\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  */\nconst isPalindromeOfLength = (text, length) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText.length === length\n}\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  */\nconst isPalindromeOfLength = (text, length) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText.length === length\n}\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  */\nconst isPalindromeOfLength = (text, length) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText.length === length\n}\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  */\nconst isPalindromeOfLength = (text, length) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText.length === length\n}\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  */\nconst isPalindromeOfLength = (text, length) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText.length === length\n}\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  */\nconst isPalindromeOfLength = (text, length) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText.length === length\n}\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  */\nconst isPalindromeOfLength = (text, length) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText.length === length\n}\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  */\nconst isPalindromeOfLength = (text, length) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText.length === length\n}\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  */\nconst isPalindromeOfLength = (text, length) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText.length === length\n}\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  */\nconst isPalindromeOfLength = (text, length) => {\n  let reversedText = text.split('').reverse().join('')\n  return reversedText.length === length\n}\n\n/*\n  Checks if given string is a palindrome of given length\n  >>> isPalindromeOfLength('aba', 3)\n  true\n  >>> isPalindromeOfLength('aba', 5)\n  false\n  */\nconst isPalindromeOfLength = (text, length) => {\n  let reversedText = text.split('').reverse().join('')", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "gc": "<|endoftext|>/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (n < 0 || p < 1) return 0;\n  if (p === 0) return 1;\n  if (p === 1) return n;\n  if (p === 2) return n % 2;\n  if (p === 3) return (n >> 1) & 1;\n  if (p === 4) return (n >> 2) & 1;\n  if (p === 5) return (n >> 3) & 1;\n  if (p === 6) return (n >> 4) & 1;\n  if (p === 7) return (n >> 5) & 1;\n  if (p === 8) return (n >> 6) & 1;\n  if (p === 9) return (n >> 7) & 1;\n  if (p === 10) return (n >> 8) & 1;\n  if (p === 11) return (n >> 9) & 1;\n  if (p === 12) return (n >> 10) & 1;\n  if (p === 13) return (n >> 11) & 1;\n  if (p === 14) return (n >> 12) & 1;\n  if (p === 15) return (n >> 13) & 1;\n  if (p === 16) return (n >> 14) & 1;\n  if (p === 17) return (n >> 15) & 1;\n  if (p === 18) return (n >> 16) & 1;\n  if (p === 19) return (n >> 17) & 1;\n  if (p === 20) return (n >> 18) & 1;\n  if (p === 21) return (n >> 19) & 1;\n  if (p === 22) return (n >> 20) & 1;\n  if (p === 23) return (n >> 21) & 1;\n  if (p === 24) return (n >> 22) & 1;\n  if (p === 25) return (n >> 23) & 1;\n  if (p === 26) return (n >> 24) & 1;\n  if (p === 27) return (n >> 25) & 1;\n  if (p === 28) return (n >> 26) & 1;\n  if (p === 29) return (n >> 27) & 1;\n  if (p === 30) return (n >> 28) & 1;\n  if (p === 31) return (n >> 29) & 1;\n  if (p === 32) return (n >> 30) & 1;\n  if (p === 33) return (n >> 31) & 1;\n  if (p === 34) return (n >> 32) & 1;\n  if (p === 35) return (n >> 33) & 1;\n  if (p === 36) return (n >> 34) & 1;\n  if (p === 37) return (n >> 35) & 1;\n  if (p === 38) return (n >> 36) & 1;\n  if (p === 39) return (n >> 37) & 1;\n  if (p === 40) return (n >> 38) & 1;\n  if (p === 41) return (n >> 39) & 1;\n  if (p === 42) return (n >> 40) & 1;\n  if (p === 43) return (n >> 41) & 1;\n  if (p === 44) return (n >> 42) & 1;\n  if (p === 45) return (n >> 43) & 1;\n  if (p === 46) return (n >> 44) & 1;\n  if (p === 47) return (n >> 45) & 1;\n  if (p === 48) return (n >> 46) & 1;\n  if (p === 49) return (n >> 47) & 1;\n  if (p === 50) return (n >> 48) & 1;\n  if (p === 51) return (n >> 49) & 1;\n  if (p === 52) return (n >> 50) & 1;\n  if (p === 53) return (n >> 51) & 1;\n  if (p === 54) return (n >> 52) & 1;\n  if (p === 55) return (n >> 53) & 1;\n  if (p === 56) return (n >> 54) & 1;\n  if (p === 57) return (n >> 55) & 1;\n  if (p === 58) return (n >> 56) & 1;\n  if (p === 59) return (n >> 57) & 1;\n  if (p === 60) return (n >> 58) & 1;\n  if (p === 61) return (n >> 59) & 1;\n  if (p === 62) return (n >> 60) & 1;\n  if (p === 63) return (n >> 61) & 1;\n  if (p === 64) return (n >> 62) & 1;\n  if (p === 65) return (n >> 63) & 1;\n  if (p === 66) return (n >> 64) & 1;\n  if (p === 67) return (n >> 65) & 1;\n  if (p === 68) return (n >> 66) & 1;\n  if (p === 69) return (n >> 67) & 1;\n  if (p === 70) return (n >> 68) & 1;\n  if (p === 71) return (n >> 69) & 1;\n  if (p === 72) return (n >> 70) & 1;\n  if (p === 73) return (n >> 71) & 1;\n  if (p === 74) return (n >> 72) & 1;\n  if (p === 75) return (n >> 73) & 1;\n  if (p === 76) return (n >> 74) & 1;\n  if (p === 77) return (n >> 75) & 1;\n  if (p === 78) return (n >> 76) & 1;\n  if (p === 79) return (n >> 77) & 1;\n  if (p === 80) return (n >> 78) & 1;\n  if (p === 81) return (n >> 79) & 1;\n  if (p === 82) return (n >> 80) & 1;\n  if (p === 83) return (n >> 81) & 1;\n  if (p === 84) return (n >> 82) & 1;\n  if (p === 85) return (n >> 83) & 1;\n  if (p === 86) return (n >> 84) & 1;\n  if (p === 87) return (n >> 85) & 1;\n  if (p === 88) return (n >> 86) & 1;\n  if (p === 89) return (n >> 87) & 1;\n  if (p === 90) return (n >> 88) & 1;\n  if (p === 91) return (n >> 89) & 1;\n  if (p === 92) return (n >> 90) & 1;\n  if (p === 93) return (n >> 91) & 1;\n  if (p === 94) return (n >> 92) & 1;\n  if (p === 95) return (n >> 93) & 1;\n  if (p === 96) return (n >> 94) & 1;\n  if (p === 97) return (n >> 95) & 1;\n  if (p === 98) return (n >> 96) & 1;\n  if (p === 99) return (n >> 97) & 1;\n  if (p === 100) return (n >> 98) & 1;\n  if (p === 101) return (n >> 99) & 1;\n  if (p === 102) return (n >> 100) & 1;\n  if (p === 103) return (n >> 101) & 1;\n  if (p === 104) return (n >> 102) & 1;\n  if (p === 105) return (n >> 103) & 1;\n  if (p === 106) return (n >> 104) & 1;\n  if (p === 107) return (n >> 105) & 1;\n  if (p === 108) return (n >> 106) & 1;\n  if (p === 109) return (n >> 107) & 1;\n  if (p === 110) return (n >> 108) & 1;\n  if (p === 111) return (n >> 109) & 1;\n  if (p === 112) return (n >> 110) & 1;\n  if (p === 113) return (n >> 111) & 1;\n  if (p === 114) return (n >> 112) & 1;\n  if (p === 115) return (n >> 113) & 1;\n  if (p === 116) return (n >> 114) & 1;\n  if (p === 117) return (n >> 115) & 1;\n  if (p === 118) return (n >> 116) & 1;\n  if (p === 119) return (n >> 117) & ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> interpserse([], 4)\n  []\n  >>> interpserse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst interpserse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "interpserse", "gc": "<|endoftext|>/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> interpserse([], 4)\n  []\n  >>> interpserse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst interpserse = (numbers, delimeter) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let n = numbers.length\n  let n2 = n\n  let n3 = n\n  let n4 = n\n  let n5 = n\n  let n6 = n\n  let n7 = n\n  let n8 = n\n  let n9 = n\n  let n10 = n\n  let n11 = n\n  let n12 = n\n  let n13 = n\n  let n14 = n\n  let n15 = n\n  let n16 = n\n  let n17 = n\n  let n18 = n\n  let n19 = n\n  let n20 = n\n  let n21 = n\n  let n22 = n\n  let n23 = n\n  let n24 = n\n  let n25 = n\n  let n26 = n\n  let n27 = n\n  let n28 = n\n  let n29 = n\n  let n30 = n\n  let n31 = n\n  let n32 = n\n  let n33 = n\n  let n34 = n\n  let n35 = n\n  let n36 = n\n  let n37 = n\n  let n38 = n\n  let n39 = n\n  let n40 = n\n  let n41 = n\n  let n42 = n\n  let n43 = n\n  let n44 = n\n  let n45 = n\n  let n46 = n\n  let n47 = n\n  let n48 = n\n  let n49 = n\n  let n50 = n\n  let n51 = n\n  let n52 = n\n  let n53 = n\n  let n54 = n\n  let n55 = n\n  let n56 = n\n  let n57 = n\n  let n58 = n\n  let n59 = n\n  let n60 = n\n  let n61 = n\n  let n62 = n\n  let n63 = n\n  let n64 = n\n  let n65 = n\n  let n66 = n\n  let n67 = n\n  let n68 = n\n  let n69 = n\n  let n70 = n\n  let n71 = n\n  let n72 = n\n  let n73 = n\n  let n74 = n\n  let n75 = n\n  let n76 = n\n  let n77 = n\n  let n78 = n\n  let n79 = n\n  let n80 = n\n  let n81 = n\n  let n82 = n\n  let n83 = n\n  let n84 = n\n  let n85 = n\n  let n86 = n\n  let n87 = n\n  let n88 = n\n  let n89 = n\n  let n90 = n\n  let n91 = n\n  let n92 = n\n  let n93 = n\n  let n94 = n\n  let n95 = n\n  let n96 = n\n  let n97 = n\n  let n98 = n\n  let n99 = n\n  let n100 = n\n  let n101 = n\n  let n102 = n\n  let n103 = n\n  let n104 = n\n  let n105 = n\n  let n106 = n\n  let n107 = n\n  let n108 = n\n  let n109 = n\n  let n110 = n\n  let n111 = n\n  let n112 = n\n  let n113 = n\n  let n114 = n\n  let n115 = n\n  let n116 = n\n  let n117 = n\n  let n118 = n\n  let n119 = n\n  let n120 = n\n  let n121 = n\n  let n122 = n\n  let n123 = n\n  let n124 = n\n  let n125 = n\n  let n126 = n\n  let n127 = n\n  let n128 = n\n  let n129 = n\n  let n130 = n\n  let n131 = n\n  let n132 = n\n  let n133 = n\n  let n134 = n\n  let n135 = n\n  let n136 = n\n  let n137 = n\n  let n138 = n\n  let n139 = n\n  let n140 = n\n  let n141 = n\n  let n142 = n\n  let n143 = n\n  let n144 = n\n  let n145 = n\n  let n146 = n\n  let n147 = n\n  let n148 = n\n  let n149 = n\n  let n150 = n\n  let n151 = n\n  let n152 = n\n  let n153 = n\n  let n154 = n\n  let n155 = n\n  let n156 = n\n  let n157 = n\n  let n158 = n\n  let n159 = n\n  let n160 = n\n  let n161 = n\n  let n162 = n\n  let n163 = n\n  let n164 = n\n  let n165 = n\n  let n166 = n\n  let n167 = n\n  let n168 = n\n  let n169 = n\n  let n170 = n\n  let n171 = n\n  let n172 = n\n  let n173 = n\n  let n174 = n\n  let n175 = n\n  let n176 = n\n  let n177 = n\n  let n178 = n\n  let n179 = n\n  let n180 = n\n  let n181 = n\n  let n182 = n\n  let n183 = n\n  let n184 = n\n  let n185 = n\n  let n186 = n\n  let n187 = n\n  let n188 = n\n  let n189 = n\n  let n190 = n\n  let n191 = n\n  let n192 = n\n  let n193 = n\n  let n194 = n\n  let n195 = n\n  let n196 = n\n  let n197 = n\n  let n198 = n\n  let n199 = n\n  let n200 = n\n  let n201 = n\n  let n202 = n\n  let n203 = n\n  let n204 = n\n  let n205 = n\n  let n206 = n\n  let n207 = n\n  let n208 = n\n  let n209 = n\n  let n210 = n\n  let n211 = n\n  let n212 = n\n  let n213 = n\n  let n214 = n\n  let n215 = n\n  let n216 = n\n  let n217 = n\n  let n218 = n\n  let n219 = n\n  let n220 = n\n  let n221 = n\n  let n222 = n\n  let n223 = n\n  let n224 = n\n  let n225 = n\n  let n226 = n\n  let n227 = n\n  let n228 = n\n  let n229 = n\n  let n230 = n\n  let n231 = n\n  let n232 = n\n  let n233 = n\n  let n234 = n\n  let n235 = n\n  let n236 = n\n  let n237 = n\n  let n238 = n\n  let n239 = n\n  let n240 = n\n  let n241 = n\n  let n242 = n\n  let n243 = n\n  let n244 = n\n  let n245 = n\n  let n246 = n\n  let n247 = n\n  let n248 = n\n  let n249 = n\n  let n250 = n\n  let n251 = n\n  let n252 = n\n  let n253 = n\n  let n254 = n\n  let n255 = n\n  let n256 = n\n  let n257 = n\n  let n258 = n\n  let n259 = n\n  let n260 = n\n  let n261 = n\n  let n262 = n\n  let n263 = n\n  let n264 = n\n  let n265 = n\n  let n266 = n\n  let n267 = n\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodSehift", "gc": "<|endoftext|>/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  remoevVowels is a function that takes string and returns string without vowels.\n  >>> remoevVowels('')\n  ''\n  >>> remoevVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> remoevVowels('abcdef')\n  'bcdf'\n  >>> remoevVowels('aaaaa')\n  ''\n  >>> remoevVowels('aaBAA')\n  'B'\n  >>> remoevVowels('zbcd')\n  'zbcd'\n  */\nconst remoevVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "remoevVowels", "gc": "<|endoftext|>/*\n  remoevVowels is a function that takes string and returns string without vowels.\n  >>> remoevVowels('')\n  ''\n  >>> remoevVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> remoevVowels('abcdef')\n  'bcdf'\n  >>> remoevVowels('aaaaa')\n  ''\n  >>> remoevVowels('aaBAA')\n  'B'\n  >>> remoevVowels('zbcd')\n  'zbcd'\n  */\nconst remoevVowels = (text) => {\n  let vowels = text.split('')\n  let newText = ''\n  for (let i = 0; i < vowels.length; i++) {\n    if (vowels[i].match(/[aeiou]/)) {\n      newText += vowels[i]\n    }\n  }\n  return newText\n}\n\n/*\n  removeVowels is a function that takes string and returns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeVowels('abcdef')\n  'abcdef'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  let vowels = text.split('')\n  let newText = ''\n  for (let i = 0; i < vowels.length; i++) {\n    if (vowels[i].match(/[aeiou]/)) {\n      newText += vowels[i]\n    }\n  }\n  return newText\n}\n\n/*\n  removeVowels is a function that takes string and returns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeVowels('abcdef')\n  'abcdef'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  let vowels = text.split('')\n  let newText = ''\n  for (let i = 0; i < vowels.length; i++) {\n    if (vowels[i].match(/[aeiou]/)) {\n      newText += vowels[i]\n    }\n  }\n  return newText\n}\n\n/*\n  removeVowels is a function that takes string and returns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeVowels('abcdef')\n  'abcdef'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  let vowels = text.split('')\n  let newText = ''\n  for (let i = 0; i < vowels.length; i++) {\n    if (vowels[i].match(/[aeiou]/)) {\n      newText += vowels[i]\n    }\n  }\n  return newText\n}\n\n/*\n  removeVowels is a function that takes string and returns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeVowels('abcdef')\n  'abcdef'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  let vowels = text.split('')\n  let newText = ''\n  for (let i = 0; i < vowels.length; i++) {\n    if (vowels[i].match(/[aeiou]/)) {\n      newText += vowels[i]\n    }\n  }\n  return newText\n}\n\n/*\n  removeVowels is a function that takes string and returns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeVowels('abcdef')\n  'abcdef'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  let vowels = text.split('')\n  let newText = ''\n  for (let i = 0; i < vowels.length; i++) {\n    if (vowels[i].match(/[aeiou]/)) {\n      newText += vowels[i]\n    }\n  }\n  return newText\n}\n\n/*\n  removeVowels is a function that takes string and returns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeVowels('abcdef')\n  'abcdef'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  let vowels = text.split('')\n  let newText = ''\n  for (let i = 0; i < vowels.length; i++) {\n    if (vowels[i].match(/[aeiou]/)) {\n      newText += vowels[i]\n    }\n  }\n  return newText\n}\n\n/*\n  removeVowels is a function that takes string and returns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeVowels('abcdef')\n  'abcdef'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  let vowels = text.split('')\n  let newText = ''\n  for (let i = 0; i < vowels.length; i++) {\n    if (vowels[i].match(/[aeiou]/)) {\n      newText += vowels[i]\n    }\n  }\n  return newText\n}\n\n/*\n  removeVowels is a function that takes string and returns string without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removeVowels('abcdef')\n  'abcdef'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  let vowels = text.split('')\n  let newText = ''\n  for (let i = 0; i < vowels.length; i++) {\n    if (vowels[i].match(/[aeiou]/)) {\n      newText += vowels[i]\n    }\n  }\n  return newText\n}\n\n/*\n  removeV", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all numbers in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "gc": "<|endoftext|>/*Return true if all numbers in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  return l.some(x => x < t);\n};\n\n/*\n  >>> isEven([0, 2, 4, 6, 8])\n  true\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  true\n*/\nconst isEven = arr => {\n  return arr.every(x => x % 2 === 0);\n};\n\n/*\n  >>> isOdd([0, 2, 4, 6, 8])\n  false\n  >>> isOdd([0, 2, 4, 6, 8])\n  true\n*/\nconst isOdd = arr => {\n  return arr.every(x => x % 2!== 0);\n};\n\n/*\n  >>> isEven([0, 2, 4, 6, 8])\n  true\n  >>> isEven([0, 2, 4, 6, 8])\n  false\n  >>> isEven([0, 2, 4, 6, 8])\n  true\n*/\nconst isEvenOrOdd = arr => {\n  return isEven(arr) || isOdd(arr);\n};\n\n/*\n  >>> isEvenOrOdd([0, 2, 4, 6, 8])\n  true\n  >>> isEvenOrOdd([0, 2, 4, 6, 8])\n  false\n  >>> isEvenOrOdd([0, 2, 4, 6, 8])\n  true\n*/\nconst isEvenOrOddOrEven = arr => {\n  return isEvenOrOdd(arr) || isEvenOrOdd(arr);\n};\n\n/*\n  >>> isEvenOrOddOrEven([0, 2, 4, 6, 8])\n  true\n  >>> isEvenOrOddOrEven([0, 2, 4, 6, 8])\n  false\n  >>> isEvenOrOddOrEven([0, 2, 4, 6, 8])\n  true\n*/\nconst isEvenOrOddOrEvenOrEven = arr => {\n  return isEvenOrOddOrEven(arr) || isEvenOrOddOrEven(arr);\n};\n\n/*\n  >>> isEvenOrOddOrEvenOrEven([0, 2, 4, 6, 8])\n  true\n  >>> isEvenOrOddOrEvenOrEven([0, 2, 4, 6, 8])\n  false\n  >>> isEvenOrOddOrEvenOrEven([0, 2, 4, 6, 8])\n  true\n*/\nconst isEvenOrOddOrEvenOrEvenOrEven = arr => {\n  return isEvenOrOddOrEvenOrEven(arr) || isEvenOrOddOrEvenOrEven(arr);\n};\n\n/*\n  >>> isEvenOrOddOrEvenOrEvenOrEvenOrEven([0, 2, 4, 6, 8])\n  true\n  >>> isEvenOrOddOrEvenOrEvenOrEvenOrEven([0, 2, 4, 6, 8])\n  false\n  >>> isEvenOrOddOrEvenOrEvenOrEvenOrEven([0, 2, 4, 6, 8])\n  true\n*/\nconst isEvenOrOddOrEvenOrEvenOrEvenOrEven = arr => {\n  return isEvenOrOddOrEvenOrEvenOrEvenOrEven(arr) || isEvenOrOddOrEvenOrEvenOrEven(arr);\n};\n\n/*\n  >>> isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEven([0, 2, 4, 6, 8])\n  true\n  >>> isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEven([0, 2, 4, 6, 8])\n  false\n  >>> isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEven([0, 2, 4, 6, 8])\n  true\n*/\nconst isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEven = arr => {\n  return isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEven(arr) || isEvenOrOddOrEvenOrEvenOrEvenOrEven(arr);\n};\n\n/*\n  >>> isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEven([0, 2, 4, 6, 8])\n  true\n  >>> isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEvenOrEven([0, 2, 4, 6, 8])\n  false\n  >>> isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEvenOrEven([0, 2, 4, 6, 8])\n  true\n*/\nconst isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEven = arr => {\n  return isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEven(arr) || isEvenOrOddOrEvenOrEvenOrEvenOrEven(arr);\n};\n\n/*\n  >>> isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEven([0, 2, 4, 6, 8])\n  true\n  >>> isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEvenOrEven([0, 2, 4, 6, 8])\n  false\n  >>> isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEvenOrEven([0, 2, 4, 6, 8])\n  true\n*/\nconst isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEvenOrEven = arr => {\n  return isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEven(arr) || isEvenOrOddOrEvenOrEvenOrEvenOrEven(arr);\n};\n\n/*\n  >>> isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEvenOrEven([0, 2, 4, 6, 8])\n  true\n  >>> isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEvenOrEven([0, 2, 4, 6, 8])\n  false\n  >>> isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEvenOrEven([0, 2, 4, 6, 8])\n  true\n*/\nconst isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEvenOrEven = arr => {\n  return isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEven(arr) || isEvenOrOddOrEvenOrEvenOrEvenOrEven(arr);\n};\n\n/*\n  >>> isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEvenOrEven([0, 2, 4, 6, 8])\n  true\n  >>> isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEvenOrEven([0, 2, 4, 6, 8])\n  false\n  >>> isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEvenOrEven([0, 2, 4, 6, 8])\n  true\n*/\nconst isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEvenOrEven = arr => {\n  return isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEven(arr) || isEvenOrOddOrEvenOrEvenOrEvenOrEven(arr);\n};\n\n/*\n  >>> isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEvenOrEven([0, 2, 4, 6, 8])\n  true\n  >>> isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEvenOrEven([0, 2, 4, 6, 8])\n  false\n  >>> isEvenOrOddOrEvenOrEvenOrEvenOrEvenOrEvenOrEven([0, 2, 4, 6, 8])\n  true\n*/\nconst isEvenOr", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "gc": "<|endoftext|>/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  Add two numbers x and y with optional precision\n  >>> add(2, 3, 2)\n  5\n  >>> add(5, 7, 2)\n  12\n  */\nconst addWithPrecision = (x, y, precision) => {\n  return x + parseFloat(toFixed(parseFloat(x), precision));\n};\n\n/*\n  Subtract two numbers x and y\n  >>> subtract(2, 3)\n  1\n  >>> subtract(5, 7)\n  -1\n  */\nconst subtract = (x, y) => {\n  return x - y;\n};\n\n/*\n  Subtract two numbers x and y with optional precision\n  >>> subtract(2, 3, 2)\n  -1\n  >>> subtract(5, 7, 2)\n  12\n  */\nconst subtractWithPrecision = (x, y, precision) => {\n  return x - parseFloat(toFixed(parseFloat(x), precision));\n};\n\n/*\n  Multiply two numbers x and y\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  24\n  */\nconst multiply = (x, y) => {\n  return x * y;\n};\n\n/*\n  Multiply two numbers x and y with optional precision\n  >>> multiply(2, 3, 2)\n  6\n  >>> multiply(5, 7, 2)\n  24\n  */\nconst multiplyWithPrecision = (x, y, precision) => {\n  return x * parseFloat(toFixed(parseFloat(x), precision));\n};\n\n/*\n  Divide two numbers x and y\n  >>> divide(2, 3)\n  0.5\n  >>> divide(5, 7)\n  1.5\n  */\nconst divide = (x, y) => {\n  return x / y;\n};\n\n/*\n  Divide two numbers x and y with optional precision\n  >>> divide(2, 3, 2)\n  0.5\n  >>> divide(5, 7, 2)\n  1.5\n  */\nconst divideWithPrecision = (x, y, precision) => {\n  return x / parseFloat(toFixed(parseFloat(x), precision));\n};\n\n/*\n  Calculate the remainder after dividing two numbers x and y\n  >>> remainder(2, 3)\n  1\n  >>> remainder(5, 7)\n  -1\n  */\nconst remainder = (x, y) => {\n  return x - y * Math.floor(x / y);\n};\n\n/*\n  Calculate the remainder after dividing two numbers x and y with optional precision\n  >>> remainder(2, 3, 2)\n  1\n  >>> remainder(5, 7, 2)\n  -1\n  */\nconst remainderWithPrecision = (x, y, precision) => {\n  return x - parseFloat(toFixed(parseFloat(x), precision));\n};\n\n/*\n  Calculate the absolute value of a number\n  >>> abs(2)\n  2\n  >>> abs(-2)\n  -2\n  */\nconst abs = (x) => {\n  return Math.abs(x);\n};\n\n/*\n  Calculate the absolute value of a number with optional precision\n  >>> abs(2, 2)\n  2\n  >>> abs(-2, 2)\n  -2\n  */\nconst absWithPrecision = (x, precision) => {\n  return Math.abs(x, precision);\n};\n\n/*\n  Calculate the square root of a number\n  >>> sqrt(2)\n  2\n  >>> sqrt(-2)\n  NaN\n  */\nconst sqrt = (x) => {\n  return Math.sqrt(x);\n};\n\n/*\n  Calculate the square root of a number with optional precision\n  >>> sqrt(2, 2)\n  2\n  >>> sqrt(-2, 2)\n  NaN\n  */\nconst sqrtWithPrecision = (x, precision) => {\n  return Math.sqrt(x, precision);\n};\n\n/*\n  Calculate the natural logarithm of a number\n  >>> log2(2)\n  2\n  >>> log2(-2)\n  NaN\n  */\nconst log2 = (x) => {\n  return Math.log(x);\n};\n\n/*\n  Calculate the natural logarithm of a number with optional precision\n  >>> log2(2, 2)\n  2\n  >>> log2(-2, 2)\n  NaN\n  */\nconst log2WithPrecision = (x, precision) => {\n  return Math.log(x, precision);\n};\n\n/*\n  Calculate the exponential of a number\n  >>> exp(2)\n  2\n  >>> exp(-2)\n  NaN\n  */\nconst exp = (x) => {\n  return Math.exp(x);\n};\n\n/*\n  Calculate the exponential of a number with optional precision\n  >>> exp(2, 2)\n  2\n  >>> exp(-2, 2)\n  NaN\n  */\nconst expWithPrecision = (x, precision) => {\n  return Math.exp(x, precision);\n};\n\n/*\n  Calculate the natural logarithm of a number with optional precision\n  >>> exp(2, 2, 2)\n  2\n  >>> exp(-2, 2, 2)\n  NaN\n  */\nconst expWithPrecisionWithPrecision = (x, precision, precision2) => {\n  return Math.exp(x, precision, precision2);\n};\n\n/*\n  Calculate the hyperbolic cosine of a number\n  >>> cosh(2)\n  1.414213562373095048801688724209698078569671875376948073176679750243987\n  >>> cosh(-2)\n  NaN\n  */\nconst cosh = (x) => {\n  return Math.cosh(x);\n};\n\n/*\n  Calculate the hyperbolic cosine of a number with optional precision\n  >>> cosh(2, 2)\n  1.414213562373095048801688724209698078569671875376948073176679750243987\n  >>> cosh(-2, 2)\n  NaN\n  */\nconst coshWithPrecision = (x, precision) => {\n  return Math.cosh(x, precision);\n};\n\n/*\n  Calculate the hyperbolic sine of a number\n  >>> sinh(2)\n  0.54030230586814056055941723212145817656807550013436025525412068\n  >>> sinh(-2)\n  NaN\n  */\nconst sinh = (x) => {\n  return Math.sinh(x);\n};\n\n/*\n  Calculate the hyperbolic sine of a number with optional precision\n  >>> sinh(2, 2)\n  0.54030230586814056055941723212145817656807550013436025525412068\n  >>> sinh(-2, 2)\n  NaN\n  */\nconst sinhWithPrecision = (x, precision) => {\n  return Math.sinh(x, precision);\n};\n\n/*\n  Calculate the hyperbolic tangent of a number\n  >>> tanh(2)\n  1.1754943530232248490600781250396\n  >>> tanh(-2)\n  NaN\n  */\nconst tanh = (x) => {\n  return Math.tanh(x);\n};\n\n/*\n  Calculate the hyperbolic tangent of a number with optional precision\n  >>> tanh(2, 2)\n  1.1754943530232248490600781250396\n  >>> tanh(-2, 2)\n  NaN\n  */\nconst tanhWithPrecision = (x, precision) => {\n  return Math.tanh(x, precision);\n};\n\n/*\n  Calculate the inverse hyperbolic cosine of a number\n  >>> asinh(2)\n  1.442695040888963407359924681001892137\n  >>> asinh(-2)\n  NaN\n  */\nconst asinh = (x) => {\n  return Math.asinh(x);\n};\n\n/*\n  Calculate the inverse hyperbolic cosine of a number with optional precision\n  >>> asinh(2, 2)\n  1.442695040888963407359924681001892137\n  >>> asinh(-2, 2)\n  NaN\n  */\nconst asinhWithPrecision = (x, precision) => {\n  return Math.asinh(x, precision);\n};\n\n/*\n  Calculate the ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "gc": "<|endoftext|>/*\n  Check if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  let len = Math.min(s1.length, s2.length);\n  let i;\n  let j;\n  let k;\n  let l;\n  let c;\n  let s;\n\n  for (i = 0; i < len; i++) {\n    c = s1.charCodeAt(i);\n    s = s2.charCodeAt(i);\n    for (j = 0; j < len; j++) {\n      k = s1.charCodeAt(j);\n      l = s2.charCodeAt(j);\n      if (c!== k && c!== l) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\n/*\n  Check if two words have the same length.\n  >>> sameLength('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameLength('abcd', 'dddddddabc')\n  true\n  >>> sameLength('dddddddabc', 'abcd')\n  true\n  >>> sameLength('eabcd', 'dddddddabc')\n  false\n  >>> sameLength('abcd', 'dddddddabce')\n  false\n  >>> sameLength('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameLength = (s0, s1) => {\n  let len = Math.min(s1.length, s2.length);\n  let i;\n  let j;\n  let k;\n  let l;\n  let c;\n  let s;\n\n  for (i = 0; i < len; i++) {\n    c = s1.charCodeAt(i);\n    s = s2.charCodeAt(i);\n    for (j = 0; j < len; j++) {\n      k = s1.charCodeAt(j);\n      l = s2.charCodeAt(j);\n      if (c!== k && c!== l) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\n/*\n  Check if two words have the same capitalization.\n  >>> sameCaps('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameCaps('abcd', 'dddddddabc')\n  true\n  >>> sameCaps('dddddddabc', 'abcd')\n  true\n  >>> sameCaps('eabcd', 'dddddddabc')\n  false\n  >>> sameCaps('abcd', 'dddddddabce')\n  false\n  >>> sameCaps('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameCaps = (s0, s1) => {\n  let len = Math.min(s1.length, s2.length);\n  let i;\n  let j;\n  let k;\n  let l;\n  let c;\n  let s;\n\n  for (i = 0; i < len; i++) {\n    c = s1.charCodeAt(i);\n    s = s2.charCodeAt(i);\n    for (j = 0; j < len; j++) {\n      k = s1.charCodeAt(j);\n      l = s2.charCodeAt(j);\n      if (c!== k && c!== l) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\n/*\n  Check if two words have the same punctuation.\n  >>> samePunct('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> samePunct('abcd', 'dddddddabc')\n  true\n  >>> samePunct('dddddddabc', 'abcd')\n  true\n  >>> samePunct('eabcd', 'dddddddabc')\n  false\n  >>> samePunct('abcd', 'dddddddabce')\n  false\n  >>> samePunct('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst samePunct = (s0, s1) => {\n  let len = Math.min(s1.length, s2.length);\n  let i;\n  let j;\n  let k;\n  let l;\n  let c;\n  let s;\n\n  for (i = 0; i < len; i++) {\n    c = s1.charCodeAt(i);\n    s = s2.charCodeAt(i);\n    for (j = 0; j < len; j++) {\n      k = s1.charCodeAt(j);\n      l = s2.charCodeAt(j);\n      if (c!== k && c!== l) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\n/*\n  Check if two words have the same uppercase.\n  >>> sameUpper('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameUpper('abcd', 'dddddddabc')\n  true\n  >>> sameUpper('dddddddabc', 'abcd')\n  true\n  >>> sameUpper('eabcd', 'dddddddabc')\n  false\n  >>> sameUpper('abcd', 'dddddddabce')\n  false\n  >>> sameUpper('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameUpper = (s0, s1) => {\n  let len = Math.min(s1.length, s2.length);\n  let i;\n  let j;\n  let k;\n  let l;\n  let c;\n  let s;\n\n  for (i = 0; i < len; i++) {\n    c = s1.charCodeAt(i);\n    s = s2.charCodeAt(i);\n    for (j = 0; j < len; j++) {\n      k = s1.charCodeAt(j);\n      l = s2.charCodeAt(j);\n      if (c!== k && c!== l) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\n/*\n  Check if two words have the same lowercase.\n  >>> sameLower('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameLower('abcd', 'dddddddabc')\n  true\n  >>> sameLower('dddddddabc', 'abcd')\n  true\n  >>> sameLower('eabcd', 'dddddddabc')\n  false\n  >>> sameLower('abcd', 'dddddddabce')\n  false\n  >>> sameLower('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameLower = (s0, s1) => {\n  let len = Math.min(s1.length, s2.length);\n  let i;\n  let j;\n  let k;\n  let l;\n  let c;\n  let s;\n\n  for (i = 0; i < len; i++) {\n    c = s1.charCodeAt(i);\n    s = s2.charCodeAt(i);\n    for (j = 0; j < len; j++) {\n      k = s1.charCodeAt(j);\n      l = s2.charCodeAt(j);\n      if (c!== k && c!== l) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\n/*\n  Check if two words have the same digit.\n  >>> sameDigit('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameDigit('abcd', 'dddddddabc')\n  true\n  >>> sameDigit('dddddddabc', 'abcd')\n  true\n  >>> sameDigit('eabcd', 'dddddddabc')\n  false\n  >>> sameDigit('abcd', 'dddddddabce')\n  false\n  >>> sameDigit('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameDigit = (s0, s1) => {\n  let len = Math.min(s1.length, s2.length);\n  let i;\n  let j;\n  let k;\n  let l;\n  let c;\n  let s;\n\n  for (i = 0; i < len; i++) {\n    c = s1.charCodeAt(i);\n    s = s2.charCodeAt(i);\n    for (j = 0; j < len; j++) {\n      k = s1.charCodeAt(j);\n      l = s2.charCodeAt(j);\n      if (c!== k && c!== l) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\n/*\n  Check if two words have the same symbol.\n  >>> sameSymbol('eabcdzzzz', 'dddzzzzzzzddeddabc')\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "gc": "<|endoftext|>/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  21\n  >>> fib(5)\n  34\n  >>> fib(4)\n  55\n  >>> fib(3)\n  89\n  >>> fib(2)\n  144\n  >>> fib(1)\n  55\n  >>> fib(0)\n  0\n  */\nconst fib2 = (n) => {\n  if (n <= 1) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  21\n  >>> fib(5)\n  34\n  >>> fib(4)\n  55\n  >>> fib(3)\n  89\n  >>> fib(2)\n  144\n  >>> fib(1)\n  55\n  >>> fib(0)\n  0\n  */\nconst fib3 = (n) => {\n  if (n <= 1) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  21\n  >>> fib(5)\n  34\n  >>> fib(4)\n  55\n  >>> fib(3)\n  89\n  >>> fib(2)\n  144\n  >>> fib(1)\n  55\n  >>> fib(0)\n  0\n  */\nconst fib4 = (n) => {\n  if (n <= 1) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  21\n  >>> fib(5)\n  34\n  >>> fib(4)\n  55\n  >>> fib(3)\n  89\n  >>> fib(2)\n  144\n  >>> fib(1)\n  55\n  >>> fib(0)\n  0\n  */\nconst fib5 = (n) => {\n  if (n <= 1) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  21\n  >>> fib(5)\n  34\n  >>> fib(4)\n  55\n  >>> fib(3)\n  89\n  >>> fib(2)\n  144\n  >>> fib(1)\n  55\n  >>> fib(0)\n  0\n  */\nconst fib6 = (n) => {\n  if (n <= 1) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  21\n  >>> fib(5)\n  34\n  >>> fib(4)\n  55\n  >>> fib(3)\n  89\n  >>> fib(2)\n  144\n  >>> fib(1)\n  55\n  >>> fib(0)\n  0\n  */\nconst fib7 = (n) => {\n  if (n <= 1) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  21\n  >>> fib(5)\n  34\n  >>> fib(4)\n  55\n  >>> fib(3)\n  89\n  >>> fib(2)\n  144\n  >>> fib(1)\n  55\n  >>> fib(0)\n  0\n  */\nconst fib8 = (n) => {\n  if (n <= 1) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  21\n  >>> fib(5)\n  34\n  >>> fib(4)\n  55\n  >>> fib(3)\n  89\n  >>> fib(2)\n  144\n  >>> fib(1)\n  55\n  >>> fib(0)\n  0\n  */\nconst fib9 = (n) => {\n  if (n <= 1) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  21\n  >>> fib(5)\n  34\n  >>> fib(4)\n  55\n  >>> fib(3)\n  89\n  >>> fib(2)\n  144\n  >>> fib(1)\n  55\n  >>> fib(0)\n  0\n  */\nconst fib10 = (n) => {\n  if (n <= 1) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  21\n  >>> fib(5)\n  34\n  >>> fib(4)\n  55\n  >>> fib(3)\n  89\n  >>> fib(2)\n  144\n  >>> fib(1)\n  55\n  >>> fib(0)\n  0\n  */\nconst fib11 = (n) => {\n  if (n <= 1) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  21\n  >>> fib(5)\n  34\n  >>> fib(4)\n  55\n  >>> fib(3)\n  89\n  >>> fib(2)\n  144\n  >>> fib(1)\n  55\n  >>> fib(0)\n  0\n  */\nconst fib12 = (n) => {\n  if (n <= 1) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  21\n  >>> fib(5)\n  34\n  >>> fib(4)\n  55\n  >>> fib(3)\n  89\n  >>> fib(2)\n  144\n  >>> fib(1)\n  55\n  >>> fib(0)\n  0\n  */\nconst fib13 = (n) => {\n  if (n <= 1) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(10)\n  55\n  >>> fib(8)\n  21\n  >>> fib(7)\n  13\n  >>> fib(6)\n  21\n  >>> fib(5)\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketnig(\"<\")\n  false\n  >>> correctBracketnig(\"<>\")\n  false\n  >>> correctBracketnig(\"<<><>>\")\n  false\n  >>> correctBracketnig(\"><<>\")\n  false\n  */\nconst correctBracketnig = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketnig", "gc": "<|endoftext|>/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketnig(\"<\")\n  false\n  >>> correctBracketnig(\"<>\")\n  false\n  >>> correctBracketnig(\"<<><>>\")\n  false\n  >>> correctBracketnig(\"><<>\")\n  false\n  */\nconst correctBracketnig = (brackets) => {\n  const openingBrackets = brackets.split(\">\");\n  const closingBrackets = brackets.split(\"<\");\n\n  return openingBrackets.every((openingBracket) => {\n    return closingBrackets.every((closingBracket) => {\n      return openingBracket === closingBracket;\n    });\n  });\n};\n\n/**\n * Given a string, return true if it starts with \"!\", false otherwise.\n *\n * >>> isPrefixOf(\"!\", \"!\")\n * true\n * >>> isPrefixOf(\"!\", \"!!\")\n * false\n */\nconst isPrefixOf = (prefix, str) => {\n  return str.startsWith(prefix);\n};\n\n/**\n * Given a string, return true if it ends with \"!\", false otherwise.\n *\n * >>> isSuffixOf(\"!\", \"!\")\n * true\n * >>> isSuffixOf(\"!\", \"!!\")\n * false\n */\nconst isSuffixOf = (suffix, str) => {\n  return str.endsWith(suffix);\n};\n\n/**\n * Given a string, return true if it starts with \"!\", false otherwise.\n *\n * >>> isPrefixOf(\"!\", \"!!\")\n * false\n * >>> isPrefixOf(\"!\", \"!\")\n * true\n */\nconst isPrefixOf = (prefix, str) => {\n  return str.startsWith(prefix);\n};\n\n/**\n * Given a string, return true if it ends with \"!\", false otherwise.\n *\n * >>> isSuffixOf(\"!\", \"!!\")\n * false\n * >>> isSuffixOf(\"!\", \"!\")\n * true\n */\nconst isSuffixOf = (suffix, str) => {\n  return str.endsWith(suffix);\n};\n\n/**\n * Given a string, return true if it starts with \"!\", false otherwise.\n *\n * >>> isPrefixOf(\"!\", \"!\")\n * true\n * >>> isPrefixOf(\"!\", \"!!\")\n * false\n */\nconst isPrefixOf = (prefix, str) => {\n  return str.startsWith(prefix);\n};\n\n/**\n * Given a string, return true if it ends with \"!\", false otherwise.\n *\n * >>> isSuffixOf(\"!\", \"!\")\n * false\n * >>> isSuffixOf(\"!\", \"!!\")\n * true\n */\nconst isSuffixOf = (suffix, str) => {\n  return str.endsWith(suffix);\n};\n\n/**\n * Given a string, return true if it starts with \"!\", false otherwise.\n *\n * >>> isPrefixOf(\"!\", \"!\")\n * false\n * >>> isPrefixOf(\"!\", \"!!\")\n * true\n */\nconst isPrefixOf = (prefix, str) => {\n  return str.startsWith(prefix);\n};\n\n/**\n * Given a string, return true if it ends with \"!\", false otherwise.\n *\n * >>> isSuffixOf(\"!\", \"!\")\n * false\n * >>> isSuffixOf(\"!\", \"!!\")\n * true\n */\nconst isSuffixOf = (suffix, str) => {\n  return str.endsWith(suffix);\n};\n\n/**\n * Given a string, return true if it starts with \"!\", false otherwise.\n *\n * >>> isPrefixOf(\"!\", \"!\")\n * false\n * >>> isPrefixOf(\"!\", \"!!\")\n * true\n */\nconst isPrefixOf = (prefix, str) => {\n  return str.startsWith(prefix);\n};\n\n/**\n * Given a string, return true if it ends with \"!\", false otherwise.\n *\n * >>> isSuffixOf(\"!\", \"!\")\n * false\n * >>> isSuffixOf(\"!\", \"!!\")\n * true\n */\nconst isSuffixOf = (suffix, str) => {\n  return str.endsWith(suffix);\n};\n\n/**\n * Given a string, return true if it starts with \"!\", false otherwise.\n *\n * >>> isPrefixOf(\"!\", \"!\")\n * false\n * >>> isPrefixOf(\"!\", \"!!\")\n * true\n */\nconst isPrefixOf = (prefix, str) => {\n  return str.startsWith(prefix);\n};\n\n/**\n * Given a string, return true if it ends with \"!\", false otherwise.\n *\n * >>> isSuffixOf(\"!\", \"!\")\n * false\n * >>> isSuffixOf(\"!\", \"!!\")\n * true\n */\nconst isSuffixOf = (suffix, str) => {\n  return str.endsWith(suffix);\n};\n\n/**\n * Given a string, return true if it starts with \"!\", false otherwise.\n *\n * >>> isPrefixOf(\"!\", \"!\")\n * false\n * >>> isPrefixOf(\"!\", \"!!\")\n * true\n */\nconst isPrefixOf = (prefix, str) => {\n  return str.startsWith(prefix);\n};\n\n/**\n * Given a string, return true if it ends with \"!\", false otherwise.\n *\n * >>> isSuffixOf(\"!\", \"!\")\n * false\n * >>> isSuffixOf(\"!\", \"!!\")\n * true\n */\nconst isSuffixOf = (suffix, str) => {\n  return str.endsWith(suffix);\n};\n\n/**\n * Given a string, return true if it starts with \"!\", false otherwise.\n *\n * >>> isPrefixOf(\"!\", \"!\")\n * false\n * >>> isPrefixOf(\"!\", \"!!\")\n * true\n */\nconst isPrefixOf = (prefix, str) => {\n  return str.startsWith(prefix);\n};\n\n/**\n * Given a string, return true if it ends with \"!\", false otherwise.\n *\n * >>> isSuffixOf(\"!\", \"!\")\n * false\n * >>> isSuffixOf(\"!\", \"!!\")\n * true\n */\nconst isSuffixOf = (suffix, str) => {\n  return str.endsWith(suffix);\n};\n\n/**\n * Given a string, return true if it starts with \"!\", false otherwise.\n *\n * >>> isPrefixOf(\"!\", \"!\")\n * false\n * >>> isPrefixOf(\"!\", \"!!\")\n * true\n */\nconst isPrefixOf = (prefix, str) => {\n  return str.startsWith(prefix);\n};\n\n/**\n * Given a string, return true if it ends with \"!\", false otherwise.\n *\n * >>> isSuffixOf(\"!\", \"!\")\n * false\n * >>> isSuffixOf(\"!\", \"!!\")\n * true\n */\nconst isSuffixOf = (suffix, str) => {\n  return str.endsWith(suffix);\n};\n\n/**\n * Given a string, return true if it starts with \"!\", false otherwise.\n *\n * >>> isPrefixOf(\"!\", \"!\")\n * false\n * >>> isPrefixOf(\"!\", \"!!\")\n * true\n */\nconst isPrefixOf = (prefix, str) => {\n  return str.startsWith(prefix);\n};\n\n/**\n * Given a string, return true if it ends with \"!\", false otherwise.\n *\n * >>> isSuffixOf(\"!\", \"!\")\n * false\n * >>> isSuffixOf(\"!\", \"!!\")\n * true\n */\nconst isSuffixOf = (suffix, str) => {\n  return str.endsWith(suffix);\n};\n\n/**\n * Given a string, return true if it starts with \"!\", false otherwise.\n *\n * >>> isPrefixOf(\"!", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/57", "prompt": "/*Return true is list elements are montoonically increasing or decreasing.\n  >>> montoonic([1, 2, 4, 20])\n  true\n  >>> montoonic([1, 20, 4, 10])\n  false\n  >>> montoonic([4, 1, 0, -10])\n  true\n  */\nconst montoonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "montoonic", "gc": "<|endoftext|>/*Return true is list elements are montoonically increasing or decreasing.\n  >>> montoonic([1, 2, 4, 20])\n  true\n  >>> montoonic([1, 20, 4, 10])\n  false\n  >>> montoonic([4, 1, 0, -10])\n  true\n  */\nconst montoonic = (l) => {\n  let n = l.length\n  let m = n\n  let i = 0\n  let j = 0\n  let k = 0\n  let l1 = []\n  let l2 = []\n  let l3 = []\n  let l4 = []\n  let l5 = []\n  let l6 = []\n  let l7 = []\n  let l8 = []\n  let l9 = []\n  let l10 = []\n  let l11 = []\n  let l12 = []\n  let l13 = []\n  let l14 = []\n  let l15 = []\n  let l16 = []\n  let l17 = []\n  let l18 = []\n  let l19 = []\n  let l20 = []\n  let l21 = []\n  let l22 = []\n  let l23 = []\n  let l24 = []\n  let l25 = []\n  let l26 = []\n  let l27 = []\n  let l28 = []\n  let l29 = []\n  let l30 = []\n  let l31 = []\n  let l32 = []\n  let l33 = []\n  let l34 = []\n  let l35 = []\n  let l36 = []\n  let l37 = []\n  let l38 = []\n  let l39 = []\n  let l40 = []\n  let l41 = []\n  let l42 = []\n  let l43 = []\n  let l44 = []\n  let l45 = []\n  let l46 = []\n  let l47 = []\n  let l48 = []\n  let l49 = []\n  let l50 = []\n  let l51 = []\n  let l52 = []\n  let l53 = []\n  let l54 = []\n  let l55 = []\n  let l56 = []\n  let l57 = []\n  let l58 = []\n  let l59 = []\n  let l60 = []\n  let l61 = []\n  let l62 = []\n  let l63 = []\n  let l64 = []\n  let l65 = []\n  let l66 = []\n  let l67 = []\n  let l68 = []\n  let l69 = []\n  let l70 = []\n  let l71 = []\n  let l72 = []\n  let l73 = []\n  let l74 = []\n  let l75 = []\n  let l76 = []\n  let l77 = []\n  let l78 = []\n  let l79 = []\n  let l80 = []\n  let l81 = []\n  let l82 = []\n  let l83 = []\n  let l84 = []\n  let l85 = []\n  let l86 = []\n  let l87 = []\n  let l88 = []\n  let l89 = []\n  let l90 = []\n  let l91 = []\n  let l92 = []\n  let l93 = []\n  let l94 = []\n  let l95 = []\n  let l96 = []\n  let l97 = []\n  let l98 = []\n  let l99 = []\n  let l100 = []\n  let l101 = []\n  let l102 = []\n  let l103 = []\n  let l104 = []\n  let l105 = []\n  let l106 = []\n  let l107 = []\n  let l108 = []\n  let l109 = []\n  let l110 = []\n  let l111 = []\n  let l112 = []\n  let l113 = []\n  let l114 = []\n  let l115 = []\n  let l116 = []\n  let l117 = []\n  let l118 = []\n  let l119 = []\n  let l120 = []\n  let l121 = []\n  let l122 = []\n  let l123 = []\n  let l124 = []\n  let l125 = []\n  let l126 = []\n  let l127 = []\n  let l128 = []\n  let l129 = []\n  let l130 = []\n  let l131 = []\n  let l132 = []\n  let l133 = []\n  let l134 = []\n  let l135 = []\n  let l136 = []\n  let l137 = []\n  let l138 = []\n  let l139 = []\n  let l140 = []\n  let l141 = []\n  let l142 = []\n  let l143 = []\n  let l144 = []\n  let l145 = []\n  let l146 = []\n  let l147 = []\n  let l148 = []\n  let l149 = []\n  let l150 = []\n  let l151 = []\n  let l152 = []\n  let l153 = []\n  let l154 = []\n  let l155 = []\n  let l156 = []\n  let l157 = []\n  let l158 = []\n  let l159 = []\n  let l160 = []\n  let l161 = []\n  let l162 = []\n  let l163 = []\n  let l164 = []\n  let l165 = []\n  let l166 = []\n  let l167 = []\n  let l168 = []\n  let l169 = []\n  let l170 = []\n  let l171 = []\n  let l172 = []\n  let l173 = []\n  let l174 = []\n  let l175 = []\n  let l176 = []\n  let l177 = []\n  let l178 = []\n  let l179 = []\n  let l180 = []\n  let l181 = []\n  let l182 = []\n  let l183 = []\n  let l184 = []\n  let l185 = []\n  let l186 = []\n  let l187 = []\n  let l188 = []\n  let l189 = []\n  let l190 = []\n  let l191 = []\n  let l192 = []\n  let l193 = []\n  let l194 = []\n  let l195 = []\n  let l196 = []\n  let l197 = []\n  let l198 = []\n  let l199 = []\n  let l200 = []\n  let l201 = []\n  let l202 = []\n  let l203 = []\n  let l204 = []\n  let l205 = []\n  let l206 = []\n  let l207 = []\n  let l208 = []\n  let l209 = []\n  let l210 = []\n  let l211 = []\n  let l212 = []\n  let l213 = []\n  let l214 = []\n  let l215 = []\n  let l216 = []\n  let l217 = []\n  let l218 = []\n  let l219 = []\n  let l220 = []\n  let l221 = []\n  let l222 = []\n  let l223 = []\n  let l224 = []\n  let l225 = []\n  let l226 = []\n  let l227 = []\n  let l228 = []\n  let l229 = []\n  let l230 = []\n  let l231 = []\n  let l232 = []\n  let l233 = []\n  let l234 = []\n  let l235 = []\n  let l236 = []\n  let l237 = []\n  let l238 = []\n  let l239 = []\n  let l240 = []\n  let l241 = []\n  let l242 = []\n  let l243 = []\n  let l244 = []\n  let l245 = []\n  let l246 = []\n  let l247 = []\n  let l248 = []\n  let l249 = []\n  let l250 = []\n  let l251 = []\n  let l252 = []\n  let l253 = []\n  let l254 = []\n  let l255 = []\n  let l256 = []\n  let l257 = []\n  let l258 = []\n  let l259 = []\n  let l260 = []\n  let l261 = []\n  let l262 = []\n  let l263 = []\n  let l264 = []\n  let l265 = []\n  let l266 = []\n  let l267 = []\n  let l268 = []\n  let l269 = []\n  let l270 = []\n  let l271 = []\n  let l272 = []\n  let l273 = []", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "gc": "<|endoftext|>/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set = new Set();\n  const result = [];\n  for (let i = 0; i < Math.min(l1.length, l2.length); i++) {\n    const el1 = l1[i];\n    const el2 = l2[i];\n    if (set.has(el1) && set.has(el2)) {\n      result.push(el1);\n      result.push(el2);\n    } else {\n      set.add(el1);\n      set.add(el2);\n    }\n  }\n  return result;\n};\n\n/*\n  >>> isEven(10)\n  true\n  >>> isEven(20)\n  false\n  >>> isEven(30)\n  false\n  >>> isEven(50)\n  true\n  >>> isEven(100)\n  false\n  >>> isEven(1000)\n  false\n  >>> isEven(10000)\n  false\n  >>> isEven(100000)\n  false\n  >>> isEven(1000000)\n  false\n  >>> isEven(10000000)\n  false\n  >>> isEven(100000000)\n  false\n  >>> isEven(1000000000)\n  false\n  >>> isEven(10000000000)\n  false\n  >>> isEven(100000000000)\n  false\n  >>> isEven(1000000000000)\n  false\n  >>> isEven(1000000000000)\n  false\n  >>> isEven(100000000000000)\n  false\n  >>> isEven(100000000000000)\n  false\n  >>> isEven(10000000000000000)\n  false\n  >>> isEven(10000000000000000)\n  false\n  >>> isEven(100000000000000000)\n  false\n  >>> isEven(1000000000000000001)\n  false\n  >>> isEven(1000000000000000001)\n  false\n  >>> isEven(1000000000000000002)\n  false\n  >>> isEven(1000000000000000002)\n  false\n  >>> isEven(1000000000000000003)\n  false\n  >>> isEven(1000000000000000003)\n  false\n  >>> isEven(1000000000000000004)\n  false\n  >>> isEven(1000000000000000004)\n  false\n  >>> isEven(1000000000000000005)\n  false\n  >>> isEven(1000000000000000005)\n  false\n  >>> isEven(1000000000000000006)\n  false\n  >>> isEven(1000000000000000006)\n  false\n  >>> isEven(1000000000000000007)\n  false\n  >>> isEven(1000000000000000007)\n  false\n  >>> isEven(1000000000000000008)\n  false\n  >>> isEven(1000000000000000008)\n  false\n  >>> isEven(1000000000000000009)\n  false\n  >>> isEven(1000000000000000009)\n  false\n  >>> isEven(1000000000000000010)\n  false\n  >>> isEven(1000000000000000010)\n  false\n  >>> isEven(1000000000000000011)\n  false\n  >>> isEven(1000000000000000011)\n  false\n  >>> isEven(1000000000000000012)\n  false\n  >>> isEven(1000000000000000012)\n  false\n  >>> isEven(1000000000000000013)\n  false\n  >>> isEven(1000000000000000013)\n  false\n  >>> isEven(1000000000000000014)\n  false\n  >>> isEven(1000000000000000014)\n  false\n  >>> isEven(1000000000000000015)\n  false\n  >>> isEven(1000000000000000015)\n  false\n  >>> isEven(1000000000000000016)\n  false\n  >>> isEven(1000000000000000016)\n  false\n  >>> isEven(1000000000000000017)\n  false\n  >>> isEven(1000000000000000017)\n  false\n  >>> isEven(1000000000000000018)\n  false\n  >>> isEven(1000000000000000018)\n  false\n  >>> isEven(1000000000000000019)\n  false\n  >>> isEven(1000000000000000019)\n  false\n  >>> isEven(1000000000000000020)\n  false\n  >>> isEven(1000000000000000020)\n  false\n  >>> isEven(1000000000000000021)\n  false\n  >>> isEven(1000000000000000021)\n  false\n  >>> isEven(1000000000000000022)\n  false\n  >>> isEven(1000000000000000022)\n  false\n  >>> isEven(1000000000000000023)\n  false\n  >>> isEven(1000000000000000023)\n  false\n  >>> isEven(1000000000000000024)\n  false\n  >>> isEven(1000000000000000024)\n  false\n  >>> isEven(1000000000000000025)\n  false\n  >>> isEven(1000000000000000025)\n  false\n  >>> isEven(1000000000000000026)\n  false\n  >>> isEven(1000000000000000026)\n  false\n  >>> isEven(1000000000000000027)\n  false\n  >>> isEven(1000000000000000027)\n  false\n  >>> isEven(1000000000000000028)\n  false\n  >>> isEven(1000000000000000028)\n  false\n  >>> isEven(1000000000000000029)\n  false\n  >>> isEven(1000000000000000029)\n  false\n  >>> isEven(1000000000000000030)\n  false\n  >>> isEven(1000000000000000030)\n  false\n  >>> isEven(1000000000000000031)\n  false\n  >>> isEven(1000000000000000031)\n  false\n  >>> isEven(1000000000000000032)\n  false\n  >>> isEven(1000000000000000032)\n  false\n  >>> isEven(1000000000000000033)\n  false\n  >>> isEven(1000000000000000033)\n  false\n  >>> isEven(1000000000000000034)\n  false\n  >>> isEven(1000000000000000034)\n  false\n  >>> isEven(1000000000000000035)\n  false\n  >>> isEven(1000000000000000035)\n  false\n  >>> isEven(1000000000000000036)\n  false\n  >>> isEven(1000000000000000036)\n  false\n  >>> isEven(1000000000000000037)\n  false\n  >>> isEven(1000000000000000037)\n  false\n  >>> isEven(1000000000000000038)\n  false\n  >>> isEven(1000000000000000038)\n  false\n  >>> isEven(1000000000000000039)\n  false\n  >>> isEven(1000000000000000039)\n  false\n  >>> isEven(1000000000000000040)\n  false\n  >>> isEven(1000000000000000040)\n  false\n  >>> isEven(1000000000000000041)\n  false\n  >>> isEven(1000000000000000041)\n  false\n  >>> isEven(1000000000000000042)\n  false\n  >>> isEven(1000000000000000042)\n  false\n  >>> isEven(1000000000000000043)\n  false\n  >>> isEven(100", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largetsPrimeFactor(13195)\n  29\n  >>> largetsPrimeFactor(2048)\n  2\n  */\nconst largetsPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largetsPrimeFactor", "gc": "<|endoftext|>/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largetsPrimeFactor(13195)\n  29\n  >>> largetsPrimeFactor(2048)\n  2\n  */\nconst largetsPrimeFactor = (n) => {\n  let primeFactor = 1;\n  let i = 2;\n  while (primeFactor < n) {\n    if (n % i === 0) {\n      primeFactor = i;\n      i++;\n    }\n  }\n  return primeFactor;\n};\n\n/*\n  Given a number n, return true if it is a prime number, false otherwise.\n  >>> isPrime(13195)\n  true\n  >>> isPrime(2048)\n  false\n  */\nconst isPrime = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let i = 2;\n  while (n % i === 0) {\n    i++;\n  }\n  return i === 2;\n};\n\n/*\n  Given a number n, return true if it is a composite number, false otherwise.\n  >>> isComposite(13195)\n  true\n  >>> isComposite(2048)\n  false\n  */\nconst isComposite = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let i = 2;\n  while (n % i === 0) {\n    i++;\n  }\n  return i === 3;\n};\n\n/*\n  Given a number n, return true if it is a composite number that is a prime factor,\n  false otherwise.\n  >>> isCompositePrime(13195)\n  true\n  >>> isCompositePrime(2048)\n  false\n  */\nconst isCompositePrime = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let i = 2;\n  while (n % i === 0) {\n    i++;\n  }\n  return isPrime(n % i);\n};\n\n/*\n  Given a number n, return true if it is a composite number that is a prime factor of n, false otherwise.\n  >>> isCompositePrimeFactor(13195)\n  true\n  >>> isCompositePrimeFactor(2048)\n  false\n  */\nconst isCompositePrimeFactor = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let i = 2;\n  while (n % i === 0) {\n    i++;\n  }\n  return isPrime(n % largetsPrimeFactor(n));\n};\n\n/*\n  Given a number n, return true if it is a composite number that is a prime factor of n\n  that is a composite number, false otherwise.\n  >>> isCompositeCompositePrimeFactor(13195)\n  true\n  >>> isCompositeCompositePrimeFactor(2048)\n  false\n  */\nconst isCompositeCompositePrimeFactor = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let i = 2;\n  while (n % i === 0) {\n    i++;\n  }\n  return isCompositePrime(n % largetsPrimeFactor(n));\n};\n\n/*\n  Given a number n, return true if it is a composite number that is a prime factor of n\n  that is a composite number that is a composite number, false otherwise.\n  >>> isCompositeCompositePrimeFactor(13195)\n  true\n  >>> isCompositeCompositePrimeFactor(2048)\n  false\n  */\nconst isCompositeCompositePrimeFactor = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let i = 2;\n  while (n % i === 0) {\n    i++;\n  }\n  return isCompositePrime(n % largetsPrimeFactor(n));\n};\n\n/*\n  Given a number n, return true if it is a composite number that is a prime factor of n\n  that is a composite number that is a composite number that is a composite number, false otherwise.\n  >>> isCompositeCompositePrimeFactor(13195)\n  true\n  >>> isCompositeCompositePrimeFactor(2048)\n  false\n  */\nconst isCompositeCompositePrimeFactor = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let i = 2;\n  while (n % i === 0) {\n    i++;\n  }\n  return isCompositePrime(n % largetsPrimeFactor(n));\n};\n\n/*\n  Given a number n, return true if it is a composite number that is a prime factor of n\n  that is a composite number that is a composite number that is a composite number that is a composite number, false otherwise.\n  >>> isCompositeCompositePrimeFactor(13195)\n  true\n  >>> isCompositeCompositePrimeFactor(2048)\n  false\n  */\nconst isCompositeCompositePrimeFactor = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let i = 2;\n  while (n % i === 0) {\n    i++;\n  }\n  return isCompositePrime(n % largetsPrimeFactor(n));\n};\n\n/*\n  Given a number n, return true if it is a composite number that is a prime factor of n\n  that is a composite number that is a composite number that is a composite number that is a composite number that is a composite number, false otherwise.\n  >>> isCompositeCompositePrimeFactor(13195)\n  true\n  >>> isCompositeCompositePrimeFactor(2048)\n  false\n  */\nconst isCompositeCompositePrimeFactor = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let i = 2;\n  while (n % i === 0) {\n    i++;\n  }\n  return isCompositePrime(n % largetsPrimeFactor(n));\n};\n\n/*\n  Given a number n, return true if it is a composite number that is a prime factor of n\n  that is a composite number that is a composite number that is a composite number that is a composite number that is a composite number, false otherwise.\n  >>> isCompositeCompositePrimeFactor(13195)\n  true\n  >>> isCompositeCompositePrimeFactor(2048)\n  false\n  */\nconst isCompositeCompositePrimeFactor = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let i = 2;\n  while (n % i === 0) {\n    i++;\n  }\n  return isCompositePrime(n % largetsPrimeFactor(n));\n};\n\n/*\n  Given a number n, return true if it is a composite number that is a prime factor of n\n  that is a composite number that is a composite number that is a composite number that is a composite number that is a composite number that is a composite number, false otherwise.\n  >>> isCompositeCompositePrimeFactor(13195)\n  true\n  >>> isCompositeCompositePrimeFactor(2048)\n  false\n  */\nconst isCompositeCompositePrimeFactor = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let i = 2;\n  while (n % i === 0) {\n    i++;\n  }\n  return isCompositePrime(n % largetsPrimeFactor(n));\n};\n\n/*\n  Given a number n, return true if it is a composite number that is a prime factor of n\n  that is a composite number that is a composite number that is a composite number that is a composite number that is a composite number that is a composite number, false otherwise.\n  >>> isCompositeCompositePrimeFactor(13195)\n  true\n  >>> isCompositeCompositePrimeFactor(2048)\n  false\n  */\nconst isCompositeCompositePrimeFactor = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let i = 2;\n  while (n % i === 0) {\n    i++;\n  }\n  return isCompositePrime(n % largetsPrimeFactor(n));\n};\n\n/*\n  Given a number n, return true if it is a composite number that is a prime factor of n\n  that is a composite number that is a composite number that is a composite number that is a composite number that is a composite number that is a ", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 3, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/6", "prompt": "/* Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n  For each of the group, output the deepest level of nesting of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNetsedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNetsedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNetsedParens", "gc": "<|endoftext|>/* Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n  For each of the group, output the deepest level of nesting of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNetsedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNetsedParens = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]+)\\)/g);\n  const result = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const paren_group = paren_groups[i];\n    const paren_level = 1;\n    const paren_paren_count = 0;\n    const paren_paren_levels = [];\n    const paren_paren_levels_stack = [];\n    const paren_paren_levels_stack_count = 0;\n    const paren_paren_levels_stack_stack = [];\n    const paren_paren_levels_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_count = 0;\n    const paren_paren_levels_stack_stack_stack_stack_stack = [];\n    const paren_paren_levels_stack_stack_stack_stack_count = 0;\n    const paren_paren_level", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "gc": "<|endoftext|>/*sumToN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  Given a binary tree, return the height of the tree.\n  https://leetcode.com/problems/height-of-binary-tree/\n  \n  Example:\n  Given binary tree [3,9,20,null,null,15,7],\n  height = 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketnig(\"(\")\n  false\n  >>> correctBracketnig(\"()\")\n  true\n  >>> correctBracketnig(\"(()())\")\n  true\n  >>> correctBracketnig(\")(()\")\n  false\n  */\nconst correctBracketnig = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketnig", "gc": "<|endoftext|>/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketnig(\"(\")\n  false\n  >>> correctBracketnig(\"()\")\n  true\n  >>> correctBracketnig(\"(()())\")\n  true\n  >>> correctBracketnig(\")(()\")\n  false\n  */\nconst correctBracketnig = (brackets) => {\n  return brackets.every(\n    (bracket) => bracket.includes(\"(\") &&\n      bracket.includes(\")\")\n  );\n};\n\n/**\n * Given a string of brackets, return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", return true if every opening bracket has a corresponding closing bracket.\n * If brackets is a string of \"(\" and \")\", ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "gc": "<|endoftext|>/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const n = xs.length\n  let i = 0\n  let j = 0\n  let k = 0\n  let result = []\n  let sum = 0\n  let x = 0\n  let y = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk = 0\n  let xs = 0\n  let xi = 0\n  let xj = 0\n  let xk", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "gc": "<|endoftext|>/*The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n <= 1) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence that starts with 0 and ends with n-1.\n  >>> fibonacci(8)\n  1\n  >>> fibonacci(9)\n  3\n  >>> fibonacci(10)\n  8\n  >>> fibonacci(11)\n  13\n  >>> fibonacci(12)\n  21\n  >>> fibonacci(13)\n  34\n  >>> fibonacci(14)\n  55\n  >>> fibonacci(15)\n  89\n  >>> fibonacci(16)\n  144\n  >>> fibonacci(17)\n  233\n  >>> fibonacci(18)\n  377\n  >>> fibonacci(19)\n  610\n  >>> fibonacci(20)\n  987\n  >>> fibonacci(21)\n  1597\n  >>> fibonacci(22)\n  2584\n  >>> fibonacci(23)\n  4181\n  >>> fibonacci(24)\n  6765\n  >>> fibonacci(25)\n  10946\n  >>> fibonacci(26)\n  17711\n  >>> fibonacci(27)\n  28657\n  >>> fibonacci(28)\n  46368\n  >>> fibonacci(29)\n  75025\n  >>> fibonacci(30)\n  121393\n  >>> fibonacci(31)\n  258419\n  >>> fibonacci(32)\n  4181043\n  >>> fibonacci(33)\n  6765811\n  >>> fibonacci(34)\n  10946897\n  >>> fibonacci(35)\n  17711894\n  >>> fibonacci(36)\n  28657421\n  >>> fibonacci(37)\n  46368411\n  >>> fibonacci(38)\n  75025409\n  >>> fibonacci(39)\n  121393198\n  >>> fibonacci(40)\n  258419697\n  >>> fibonacci(41)\n  418104319\n  >>> fibonacci(42)\n  676581149\n  >>> fibonacci(43)\n  109468979\n  >>> fibonacci(44)\n  177118943\n  >>> fibonacci(45)\n  286574219\n  >>> fibonacci(46)\n  463684119\n  >>> fibonacci(47)\n  750254099\n  >>> fibonacci(48)\n  1213931989\n  >>> fibonacci(49)\n  2584196979\n  >>> fibonacci(50)\n  4181043199\n  >>> fibonacci(51)\n  6765811491\n  >>> fibonacci(52)\n  1094689791\n  >>> fibonacci(53)\n  1771189431\n  >>> fibonacci(54)\n  2865742191\n  >>> fibonacci(55)\n  4636841191\n  >>> fibonacci(56)\n  7502540991\n  >>> fibonacci(57)\n  12139319891\n  >>> fibonacci(58)\n  25841969791\n  >>> fibonacci(59)\n  41810431991\n  >>> fibonacci(60)\n  67658114911\n  >>> fibonacci(61)\n  10946897911\n  >>> fibonacci(62)\n  1771189431\n  >>> fibonacci(63)\n  28657421911\n  >>> fibonacci(64)\n  46368411911\n  >>> fibonacci(65)\n  75025409911\n  >>> fibonacci(66)\n  12139319891\n  >>> fibonacci(67)\n  258419697911\n  >>> fibonacci(68)\n  418104319911\n  >>> fibonacci(69)\n  67658114911\n  >>> fibonacci(70)\n  10946897911\n  >>> fibonacci(71)\n  1771189431\n  >>> fibonacci(72)\n  28657421911\n  >>> fibonacci(73)\n  46368411911\n  >>> fibonacci(74)\n  75025409911\n  >>> fibonacci(75)\n  12139319891\n  >>> fibonacci(76)\n  258419697911\n  >>> fibonacci(77)\n  418104319911\n  >>> fibonacci(78)\n  67658114911\n  >>> fibonacci(79)\n  10946897911\n  >>> fibonacci(80)\n  1771189431\n  >>> fibonacci(81)\n  28657421911\n  >>> fibonacci(82)\n  46368411911\n  >>> fibonacci(83)\n  75025409911\n  >>> fibonacci(84)\n  12139319891\n  >>> fibonacci(85)\n  258419697911\n  >>> fibonacci(86)\n  418104319911\n  >>> fibonacci(87)\n  67658114911\n  >>> fibonacci(88)\n  10946897911\n  >>> fibonacci(89)\n  1771189431\n  >>> fibonacci(90)\n  28657421911\n  >>> fibonacci(91)\n  46368411911\n  >>> fibonacci(92)\n  75025409911\n  >>> fibonacci(93)\n  12139319891\n  >>> fibonacci(94)\n  258419697911\n  >>> fibonac", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/64", "prompt": "/*Write a function vowelsConut which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsConut(\"abcde\")\n  2\n  >>> vowelsConut(\"ACEDY\")\n  3\n  */\nconst vowelsConut = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsConut", "gc": "<|endoftext|>/*Write a function vowelsConut which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsConut(\"abcde\")\n  2\n  >>> vowelsConut(\"ACEDY\")\n  3\n  */\nconst vowelsConut = (s) => {\n  let vowels = 0;\n  let vowelsCount = 0;\n  let vowelsEnd = 0;\n  let vowelsStart = 0;\n  let vowelsEndCount = 0;\n  let vowelsStartCount = 0;\n  let vowelsEndCount2 = 0;\n  let vowelsStartCount2 = 0;\n  let vowelsEndCount3 = 0;\n  let vowelsStartCount3 = 0;\n  let vowelsEndCount4 = 0;\n  let vowelsStartCount4 = 0;\n  let vowelsEndCount5 = 0;\n  let vowelsStartCount5 = 0;\n  let vowelsEndCount6 = 0;\n  let vowelsStartCount6 = 0;\n  let vowelsEndCount7 = 0;\n  let vowelsStartCount7 = 0;\n  let vowelsEndCount8 = 0;\n  let vowelsStartCount8 = 0;\n  let vowelsEndCount9 = 0;\n  let vowelsStartCount9 = 0;\n  let vowelsEndCount10 = 0;\n  let vowelsStartCount10 = 0;\n  let vowelsEndCount11 = 0;\n  let vowelsStartCount11 = 0;\n  let vowelsEndCount12 = 0;\n  let vowelsStartCount12 = 0;\n  let vowelsEndCount13 = 0;\n  let vowelsStartCount13 = 0;\n  let vowelsEndCount14 = 0;\n  let vowelsStartCount14 = 0;\n  let vowelsEndCount15 = 0;\n  let vowelsStartCount15 = 0;\n  let vowelsEndCount16 = 0;\n  let vowelsStartCount16 = 0;\n  let vowelsEndCount17 = 0;\n  let vowelsStartCount17 = 0;\n  let vowelsEndCount18 = 0;\n  let vowelsStartCount18 = 0;\n  let vowelsEndCount19 = 0;\n  let vowelsStartCount19 = 0;\n  let vowelsEndCount20 = 0;\n  let vowelsStartCount20 = 0;\n  let vowelsEndCount21 = 0;\n  let vowelsStartCount21 = 0;\n  let vowelsEndCount22 = 0;\n  let vowelsStartCount22 = 0;\n  let vowelsEndCount23 = 0;\n  let vowelsStartCount23 = 0;\n  let vowelsEndCount24 = 0;\n  let vowelsStartCount24 = 0;\n  let vowelsEndCount25 = 0;\n  let vowelsStartCount25 = 0;\n  let vowelsEndCount26 = 0;\n  let vowelsStartCount26 = 0;\n  let vowelsEndCount27 = 0;\n  let vowelsStartCount27 = 0;\n  let vowelsEndCount28 = 0;\n  let vowelsStartCount28 = 0;\n  let vowelsEndCount29 = 0;\n  let vowelsStartCount29 = 0;\n  let vowelsEndCount30 = 0;\n  let vowelsStartCount30 = 0;\n  let vowelsEndCount31 = 0;\n  let vowelsStartCount31 = 0;\n  let vowelsEndCount32 = 0;\n  let vowelsStartCount32 = 0;\n  let vowelsEndCount33 = 0;\n  let vowelsStartCount33 = 0;\n  let vowelsEndCount34 = 0;\n  let vowelsStartCount34 = 0;\n  let vowelsEndCount35 = 0;\n  let vowelsStartCount35 = 0;\n  let vowelsEndCount36 = 0;\n  let vowelsStartCount36 = 0;\n  let vowelsEndCount37 = 0;\n  let vowelsStartCount37 = 0;\n  let vowelsEndCount38 = 0;\n  let vowelsStartCount38 = 0;\n  let vowelsEndCount39 = 0;\n  let vowelsStartCount39 = 0;\n  let vowelsEndCount40 = 0;\n  let vowelsStartCount40 = 0;\n  let vowelsEndCount41 = 0;\n  let vowelsStartCount41 = 0;\n  let vowelsEndCount42 = 0;\n  let vowelsStartCount42 = 0;\n  let vowelsEndCount43 = 0;\n  let vowelsStartCount43 = 0;\n  let vowelsEndCount44 = 0;\n  let vowelsStartCount44 = 0;\n  let vowelsEndCount45 = 0;\n  let vowelsStartCount45 = 0;\n  let vowelsEndCount46 = 0;\n  let vowelsStartCount46 = 0;\n  let vowelsEndCount47 = 0;\n  let vowelsStartCount47 = 0;\n  let vowelsEndCount48 = 0;\n  let vowelsStartCount48 = 0;\n  let vowelsEndCount49 = 0;\n  let vowelsStartCount49 = 0;\n  let vowelsEndCount50 = 0;\n  let vowelsStartCount50 = 0;\n  let vowelsEndCount51 = 0;\n  let vowelsStartCount51 = 0;\n  let vowelsEndCount52 = 0;\n  let vowelsStartCount52 = 0;\n  let vowelsEndCount53 = 0;\n  let vowelsStartCount53 = 0;\n  let vowelsEndCount54 = 0;\n  let vowelsStartCount54 = 0;\n  let vowelsEndCount55 = 0;\n  let vowelsStartCount55 = 0;\n  let vowelsEndCount56 = 0;\n  let vowelsStartCount56 = 0;\n  let vowelsEndCount57 = 0;\n  let vowelsStartCount57 = 0;\n  let vowelsEndCount58 = 0;\n  let vowelsStartCount58 = 0;\n  let vowelsEndCount59 = 0;\n  let vowelsStartCount59 = 0;\n  let vowelsEndCount60 = 0;\n  let vowelsStartCount60 = 0;\n  let vowelsEndCount61 = 0;\n  let vowelsStartCount61 = 0;\n  let vowelsEndCount62 = 0;\n  let vowelsStartCount62 = 0;\n  let vowelsEndCount63 = 0;\n  let vowelsStartCount63 = 0;\n  let vowelsEndCount64 = 0;\n  let vowelsStartCount64 = 0;\n  let vowelsEndCount65 = 0;\n  let vowelsStartCount65 = 0;\n  let vowelsEndCount66 = 0;\n  let vowelsStartCount66 = 0;\n  let vowelsEndCount67 = 0;\n  let vowelsStartCount67 = 0;\n  let vowelsEndCount68 = 0;\n  let vowelsStartCount68 = 0;\n  let vowelsEndCount69 = 0;\n  let vowelsStartCount69 = 0;\n  let vowelsEndCount70 = 0;\n  let vowelsStartCount70 = 0;\n  let vowelsEndCount71 = 0;\n  let vowelsStartCount71 = 0;\n  let vowelsEndCount72 = 0;\n  let vowelsStartCount72 = 0;\n  let vowelsEndCount73 = 0;\n  let vowelsStartCount73 = 0;\n  let vowelsEndCount74 = 0;\n  let vowelsStartCount74 = 0;\n  let vowelsEndCount75 = 0;\n  let vowelsStartCount75 = 0;\n  let vowelsEndCount76 = 0;\n  let vowelsStartCount76 = 0;\n  let vowelsEndCount77 = 0;\n  let vowelsStartCount77 = 0;\n  let vowelsEndCount78 = 0;\n  let vowelsStartCount78 = 0;\n  let vowelsEndCount79 = 0;\n  let vowelsStartCount79 = 0;\n  let vowelsEndCount80 = 0;\n  let vowelsStartCount80 = 0;\n  let vowelsEndCount81 = 0;\n  let vowelsStartCount81 = 0;\n  let vowelsEndCount82 = 0;\n  let vowelsStartCount82 = 0;\n  let vowelsEndCount83 = 0;\n  let vowelsStartCount83 = 0;\n  let vowelsEndCount84 = 0;\n  let vowelsStartCount84 = 0;\n  let vowelsEndCount85 = 0;\n  let vowelsStartCount85 = 0;\n  let vowelsEndCount86 = 0;\n  let vowelsStartCount86 = 0;\n  let vowelsEndCount87 = 0;\n  let vowelsStartCount87 = 0;\n  let vowelsEndCount88 = 0;\n  let vowelsStartCount88 = 0;\n  let vowelsEndCount89 = 0;\n  let vowelsStartCount89 = 0;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> circularSihft(12, 1)\n  \"21\"\n  >>> circularSihft(12, 2)\n  \"12\"\n  */\nconst circularSihft = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularSihft", "gc": "<|endoftext|>/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> circularSihft(12, 1)\n  \"21\"\n  >>> circularSihft(12, 2)\n  \"12\"\n  */\nconst circularSihft = (x, shift) => {\n  let digits = x.toString().split('')\n  let reversed = digits.reverse()\n  let result = reversed.slice(shift, digits.length)\n  return result.reverse().join('')\n}\n\n/*\n  Convert an integer to its binary representation.\n  >>> toBinary(123)\n  \"1101\"\n  >>> toBinary(-123)\n  \"1110\"\n  >>> toBinary(0)\n  \"100\"\n  >>> toBinary(-1)\n  \"101\"\n  >>> toBinary(-2)\n  \"110\"\n  >>> toBinary(-3)\n  \"111\"\n  >>> toBinary(-4)\n  \"1110\"\n  >>> toBinary(-5)\n  \"1111\"\n  >>> toBinary(-6)\n  \"11111\"\n  >>> toBinary(-7)\n  \"111111\"\n  >>> toBinary(-8)\n  \"1111111\"\n  >>> toBinary(-9)\n  \"11111111\"\n  >>> toBinary(-10)\n  \"111111111\"\n  >>> toBinary(-20)\n  \"1111111111\"\n  >>> toBinary(-21)\n  \"11111111111\"\n  >>> toBinary(-22)\n  \"111111111111\"\n  >>> toBinary(-23)\n  \"1111111111111\"\n  >>> toBinary(-24)\n  \"11111111111111\"\n  >>> toBinary(-25)\n  \"111111111111111\"\n  >>> toBinary(-26)\n  \"1111111111111111\"\n  >>> toBinary(-27)\n  \"11111111111111111\"\n  >>> toBinary(-28)\n  \"111111111111111111\"\n  >>> toBinary(-29)\n  \"1111111111111111111\"\n  >>> toBinary(-30)\n  \"11111111111111111111\"\n  >>> toBinary(-31)\n  \"111111111111111111111\"\n  >>> toBinary(32)\n  \"1111111111111111111111\"\n  >>> toBinary(33)\n  \"11111111111111111111111\"\n  >>> toBinary(34)\n  \"11111111111111111111111\"\n  >>> toBinary(35)\n  \"11111111111111111111111\"\n  >>> toBinary(36)\n  \"11111111111111111111111\"\n  >>> toBinary(37)\n  \"11111111111111111111111\"\n  >>> toBinary(38)\n  \"11111111111111111111111\"\n  >>> toBinary(39)\n  \"11111111111111111111111\"\n  >>> toBinary(40)\n  \"11111111111111111111111\"\n  >>> toBinary(41)\n  \"11111111111111111111111\"\n  >>> toBinary(42)\n  \"11111111111111111111111\"\n  >>> toBinary(43)\n  \"11111111111111111111111\"\n  >>> toBinary(44)\n  \"11111111111111111111111\"\n  >>> toBinary(45)\n  \"11111111111111111111111\"\n  >>> toBinary(46)\n  \"11111111111111111111111\"\n  >>> toBinary(47)\n  \"11111111111111111111111\"\n  >>> toBinary(48)\n  \"11111111111111111111111\"\n  >>> toBinary(49)\n  \"11111111111111111111111\"\n  >>> toBinary(50)\n  \"11111111111111111111111\"\n  >>> toBinary(51)\n  \"11111111111111111111111\"\n  >>> toBinary(52)\n  \"11111111111111111111111\"\n  >>> toBinary(53)\n  \"11111111111111111111111\"\n  >>> toBinary(54)\n  \"11111111111111111111111\"\n  >>> toBinary(55)\n  \"11111111111111111111111\"\n  >>> toBinary(56)\n  \"11111111111111111111111\"\n  >>> toBinary(57)\n  \"11111111111111111111111\"\n  >>> toBinary(58)\n  \"11111111111111111111111\"\n  >>> toBinary(59)\n  \"11111111111111111111111\"\n  >>> toBinary(60)\n  \"11111111111111111111111\"\n  >>> toBinary(61)\n  \"11111111111111111111111\"\n  >>> toBinary(62)\n  \"11111111111111111111111\"\n  >>> toBinary(63)\n  \"11111111111111111111111\"\n  >>> toBinary(64)\n  \"11111111111111111111111\"\n  >>> toBinary(65)\n  \"11111111111111111111111\"\n  >>> toBinary(66)\n  \"11111111111111111111111\"\n  >>> toBinary(67)\n  \"11111111111111111111111\"\n  >>> toBinary(68)\n  \"11111111111111111111111\"\n  >>> toBinary(69)\n  \"11111111111111111111111\"\n  >>> toBinary(70)\n  \"11111111111111111111111\"\n  >>> toBinary(71)\n  \"11111111111111111111111\"\n  >>> toBinary(72)\n  \"11111111111111111111111\"\n  >>> toBinary(73)\n  \"11111111111111111111111\"\n  >>> toBinary(74)\n  \"11111111111111111111111\"\n  >>> toBinary(75)\n  \"11111111111111111111111\"\n  >>> toBinary(76)\n  \"11111111111111111111111\"\n  >>> toBinary(77)\n  \"11111111111111111111111\"\n  >>> toBinary(78)\n  \"11111111111111111111111\"\n  >>> toBinary(79)\n  \"11111111111111111111111\"\n  >>> toBinary(80)\n  \"11111111111111111111111\"\n  >>> toBinary(81)\n  \"11111111111111111111111\"\n  >>> toBinary(82)\n  \"11111111111111111111111\"\n  >>> toBinary(83)\n  \"11111111111111111111111\"\n  >>> toBinary(84)\n  \"11111111111111111111111\"\n  >>> toBinary(85)\n  \"11111111111111111111111\"\n  >>> toBinary(86)\n  \"11111111111111111111111\"\n  >>> toBinary(87)\n  \"11111111111111111111111\"\n  >>> toBinary(88)\n  \"11111111111111111111111\"\n  >>> toBinary(89)\n  \"11111111111111111111111\"\n  >>> toBinary(90)\n  \"11111111111111111111111\"\n  >>> toBinary(91)\n  \"11111111111111111111111\"\n  >>> toBinary(92)\n  \"11111111111111111111111\"\n  >>> toBinary(93)\n  \"11111111111111111111111\"\n  >>> toBinary(94)\n  \"11111111111111111111111\"\n  >>> toBinary(95)\n  \"11111111111111111111111\"\n  >>> toBinary(96)\n  \"11111111111111111111111\"\n  >>> toBinary(97)\n  \"11111111111111111111111\"\n  >>> toBinary(98)\n  \"11111111111111111111111\"\n  >>> toBinary(99)\n  \"11111111111111111111111\"\n  >>> toBinary(100)\n  \"11111111111111111111111\"\n  >>> toBinary(101)\n  \"11111111111111111111111\"\n  >>> toBinary(102)\n  \"11111111111111111111111\"\n  >>> toBinary(103)\n  \"11111111111111111111111\"\n  >>> toBinary(104)\n  \"11111111111111111111111\"\n  >>> toBinary(10", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a function that takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "gc": "<|endoftext|>/*Task\n  Write a function that takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the lower characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSumLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case letters'\n  ASCII codes.\n\n  Examples:\n      digitSumLower(\"\") => 0\n      digitSumLower(\"abAB\") => 131\n      digitSumLower(\"abcCd\") => 67\n      digitSumLower(\"helloE\") => 69\n      digitSumLower(\"woArBld\") => 131\n      digitSumLower(\"aAaaaXa\") => 153\n  */\nconst digitSumLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case letters'\n  ASCII codes.\n\n  Examples:\n      digitSumUpper(\"\") => 0\n      digitSumUpper(\"abAB\") => 131\n      digitSumUpper(\"abcCd\") => 67\n      digitSumUpper(\"helloE\") => 69\n      digitSumUpper(\"woArBld\") => 131\n      digitSumUpper(\"aAaaaXa\") => 153\n  */\nconst digitSumUpper = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case letters'\n  ASCII codes.\n\n  Examples:\n      digitSumLower(\"\") => 0\n      digitSumLower(\"abAB\") => 131\n      digitSumLower(\"abcCd\") => 67\n      digitSumLower(\"helloE\") => 69\n      digitSumLower(\"woArBld\") => 131\n      digitSumLower(\"aAaaaXa\") => 153\n  */\nconst digitSumLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case letters'\n  ASCII codes.\n\n  Examples:\n      digitSumUpper(\"\") => 0\n      digitSumUpper(\"abAB\") => 131\n      digitSumUpper(\"abcCd\") => 67\n      digitSumUpper(\"helloE\") => 69\n      digitSumUpper(\"woArBld\") => 131\n      digitSumUpper(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case letters'\n  ASCII codes.\n\n  Examples:\n      digitSumLower(\"\") => 0\n      digitSumLower(\"abAB\") => 131\n      digitSumLower(\"abcCd\") => 67\n      digitSumLower(\"helloE\") => 69\n      digitSumLower(\"woArBld\") => 131\n      digitSumLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case letters'\n  ASCII codes.\n\n  Examples:\n      digitSumUpperLower(\"\") => 0\n      digitSumUpperLower(\"abAB\") => 131\n      digitSumUpperLower(\"abcCd\") => 67\n      digitSumUpperLower(\"helloE\") => 69\n      digitSumUpperLower(\"woArBld\") => 131\n      digitSumUpperLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLowerLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case letters'\n  ASCII codes.\n\n  Examples:\n      digitSumUpperLowerLower(\"\") => 0\n      digitSumUpperLowerLower(\"abAB\") => 131\n      digitSumUpperLowerLower(\"abcCd\") => 67\n      digitSumUpperLowerLower(\"helloE\") => 69\n      digitSumUpperLowerLower(\"woArBld\") => 131\n      digitSumUpperLowerLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLowerLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case letters'\n  ASCII codes.\n\n  Examples:\n      digitSumUpperLowerLower(\"\") => 0\n      digitSumUpperLowerLower(\"abAB\") => 131\n      digitSumUpperLowerLower(\"abcCd\") => 67\n      digitSumUpperLowerLower(\"helloE\") => 69\n      digitSumUpperLowerLower(\"woArBld\") => 131\n      digitSumUpperLowerLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLowerLowerLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case letters'\n  ASCII codes.\n\n  Examples:\n      digitSumUpperLowerLowerLower(\"\") => 0\n      digitSumUpperLowerLower(\"abAB\") => 131\n      digitSumUpperLowerLower(\"abcCd\") => 67\n      digitSumUpperLowerLower(\"helloE\") => 69\n      digitSumUpperLowerLower(\"woArBld\") => 131\n      digitSumUpperLowerLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLowerLowerLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i);\n  }\n  return sum;\n};\n\n/*Task\n  Write ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "gc": "<|endoftext|>/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let totalApples = 0;\n  let totalOranges = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let total = 0;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to pluck one of the nodes and return it.\n  The plucked node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The plucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "gc": "<|endoftext|>/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to pluck one of the nodes and return it.\n  The plucked node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The plucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const len = arr.length;\n  let min = 0;\n  let max = 0;\n  let minIndex = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < len; i++) {\n    if (arr[i] % 2 === 0) {\n      min = Math.min(min, arr[i]);\n      max = Math.max(max, arr[i]);\n      minIndex = i;\n      maxIndex = i;\n    }\n  }\n  return [min, maxIndex];\n};\n\n// Given an array representing a tree with non-negative integer nodes,\n// your task is to return the minimum value that exists in the tree.\n// The minimum value should be the node with the smallest value.\n// If there are no nodes with the same minimum value, return null.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same minimum value, return the first node.\n// If there are multiple nodes with the same ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "gc": "<|endoftext|>/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\nmodule.exports = {\n  search,\n};\n\n},{}],3:[function(require,module,exports){\n/*\n  You are given a non-empty list of positive integers. Return the sum of the squares of the numbers in the list.\n  Examples:\n      sum([4, 1, 2, 2, 3, 1]) = 25\n      sum([4, 1, 2, 2, 3, 3, 3, 4, 4, 4]) = 27\n      sum([5, 5, 4, 4, 4]) = 25\n  */\nconst sum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i] * lst[i];\n  }\n  return sum;\n};\n\nmodule.exports = {\n  sum,\n};\n\n},{}],4:[function(require,module,exports){\n/*\n  You are given a non-empty list of positive integers. Return the sum of the absolute values of the numbers in the list.\n  Examples:\n      abs([4, 1, 2, 2, 3, 1]) = 25\n      abs([4, 1, 2, 2, 3, 3, 3, 4, 4, 4]) = 27\n      abs([5, 5, 4, 4, 4]) = 25\n  */\nconst abs = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.abs(lst[i]);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  abs,\n};\n\n},{}],5:[function(require,module,exports){\n/*\n  You are given a non-empty list of positive integers. Return the sum of the absolute values of the numbers in the list.\n  Examples:\n      abs([4, 1, 2, 2, 3, 1]) = 25\n      abs([4, 1, 2, 2, 3, 3, 3, 4, 4, 4]) = 27\n      abs([5, 5, 4, 4, 4]) = 25\n  */\nconst abs = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.abs(lst[i]);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  abs,\n};\n\n},{}],6:[function(require,module,exports){\n/*\n  You are given a non-empty list of positive integers. Return the sum of the absolute values of the numbers in the list.\n  Examples:\n      abs([4, 1, 2, 2, 3, 1]) = 25\n      abs([4, 1, 2, 2, 3, 3, 3, 4, 4, 4]) = 27\n      abs([5, 5, 4, 4, 4]) = 25\n  */\nconst abs = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.abs(lst[i]);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  abs,\n};\n\n},{}],7:[function(require,module,exports){\n/*\n  You are given a non-empty list of positive integers. Return the sum of the absolute values of the numbers in the list.\n  Examples:\n      abs([4, 1, 2, 2, 3, 1]) = 25\n      abs([4, 1, 2, 2, 3, 3, 3, 4, 4, 4]) = 27\n      abs([5, 5, 4, 4, 4]) = 25\n  */\nconst abs = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.abs(lst[i]);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  abs,\n};\n\n},{}],8:[function(require,module,exports){\n/*\n  You are given a non-empty list of positive integers. Return the sum of the absolute values of the numbers in the list.\n  Examples:\n      abs([4, 1, 2, 2, 3, 1]) = 25\n      abs([4, 1, 2, 2, 3, 3, 3, 4, 4, 4]) = 27\n      abs([5, 5, 4, 4, 4]) = 25\n  */\nconst abs = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.abs(lst[i]);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  abs,\n};\n\n},{}],9:[function(require,module,exports){\n/*\n  You are given a non-empty list of positive integers. Return the sum of the absolute values of the numbers in the list.\n  Examples:\n      abs([4, 1, 2, 2, 3, 1]) = 25\n      abs([4, 1, 2, 2, 3, 3, 3, 4, 4, 4]) = 27\n      abs([5, 5, 4, 4, 4]) = 25\n  */\nconst abs = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.abs(lst[i]);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  abs,\n};\n\n},{}],10:[function(require,module,exports){\n/*\n  You are given a non-empty list of positive integers. Return the sum of the absolute values of the numbers in the list.\n  Examples:\n      abs([4, 1, 2, 2, 3, 1]) = 25\n      abs([4, 1, 2, 2, 3, 3, 3, 4, 4, 4]) = 27\n      abs([5, 5, 4, 4, 4]) = 25\n  */\nconst abs = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.abs(lst[i]);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  abs,\n};\n\n},{}],11:[function(require,module,exports){\n/*\n  You are given a non-empty list of positive integers. Return the sum of the absolute values of the numbers in the list.\n  Examples:\n      abs([4, 1, 2, 2, 3, 1]) = 25\n      abs([4, 1, 2, 2, 3, 3, 3, 4, 4, 4]) = 27\n      abs([5, 5, 4, 4, 4]) = 25\n  */\nconst abs = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.abs(lst[i]);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  abs,\n};\n\n},{}],12:[function(require,module,exports){\n/*\n  You are given a non-empty list of positive integers. Return the sum of the absolute values of the numbers in the list.\n  Examples:\n      abs([4, 1, 2, 2, 3, 1]) = 25\n      abs([4, 1, 2, 2, 3, 3, 3, 4, 4, 4]) = 27\n      abs([5, 5, 4, 4, 4]) = 25\n  */\nconst abs = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.abs(lst[i]);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  abs,\n};\n\n},{}],13:[function(require,module,exports){\n/*\n  You are given a non-empty list of positive integers. Return the sum of the absolute values of the numbers in the list.\n  Examples:\n      abs([4, 1, 2, 2, 3, 1]) = 25\n      abs([4, 1, 2, 2, 3, 3, 3, 4, 4, 4]) = 27\n      abs([5, 5, 4, 4, 4]) = 25\n  */\nconst abs = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.abs(lst[i]);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  abs,\n};\n\n},{}],14:[function(require,module,exports){\n/*\n  You are given a non-empty list of positive integers. Return the sum of the absolute values of the numbers in the list.\n  Examples:\n      abs([4, 1, 2, 2, 3, 1]) = 25\n      abs([4, 1, 2, 2, 3, 3, 3, 4, 4, 4]) = 27\n      abs([5, 5, 4, 4, 4]) = 25\n  */\nconst abs = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.abs(lst[i]);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  abs,\n};\n\n},{}],15:[function(require,module,exports){\n/*\n  You are given a non-empty list of positive integers. Return the sum of the absolute values of the numbers in the list.\n  Examples:\n      abs([4, 1, 2, 2, 3, 1]) = 25\n      abs([4, 1, 2, 2, 3, 3, 3, 4, 4, 4]) = 27\n      abs([5, 5, 4, 4, 4]) = 25\n  */\nconst abs = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += Math.abs(lst[i]);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  abs,\n};\n\n},{}],", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings only for ones that contain given substring\n  >>> filteBrySubstring([], 'a')\n  []\n  >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filteBrySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filteBrySubstring", "gc": "<|endoftext|>/* Filter an input list of strings only for ones that contain given substring\n  >>> filteBrySubstring([], 'a')\n  []\n  >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filteBrySubstring = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1)\n}\n\n// Filter an input list of strings only for ones that contain given substring\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'c')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'd')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'e')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'f')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'g')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'h')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'i')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'j')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'k')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'l')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'],'m')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'n')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'o')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'p')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'q')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'r')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'],'s')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 't')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'u')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'v')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'w')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'x')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'y')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'z')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], '0')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], '1')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], '2')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], '3')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], '4')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], '5')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], '6')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], '7')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], '8')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], '9')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], '.')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], '-')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], '_')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], '/')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], '\\\\')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], '+')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], '=')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], '?')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], '!')\n// ['abc', 'bacd', 'cde', 'array']\n// >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], '@')\n// ['abc', '", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  stranegoSrtList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  stranegoSrtList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  stranegoSrtList([]) == []\n  */\nconst stranegoSrtList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "stranegoSrtList", "gc": "<|endoftext|>/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  stranegoSrtList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  stranegoSrtList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  stranegoSrtList([]) == []\n  */\nconst stranegoSrtList = (lst) => {\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = lst[0];\n  let min = lst[0];\n  let max = ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "gc": "<|endoftext|>/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  const sumA = a + b;\n  const sumB = a + c;\n  const sumC = a + b;\n  const sumD = a + c;\n  const sumE = a + b;\n  const sumF = a + c;\n\n  if (sumA > sumB && sumA > sumC && sumA > sumD) {\n    return sumA / 3;\n  } else if (sumB > sumA && sumB > sumC && sumB > sumD) {\n    return sumB / 3;\n  } else if (sumC > sumA && sumC > sumB && sumC > sumD) {\n    return sumC / 3;\n  } else if (sumD > sumA && sumD > sumB && sumD > sumC) {\n    return sumD / 3;\n  } else if (sumE > sumA && sumE > sumB && sumE > sumC) {\n    return sumE / 3;\n  } else if (sumF > sumA && sumF > sumB && sumF > sumC) {\n    return sumF / 3;\n  } else {\n    return -1;\n  }\n};\n\n/*\n  Given the lengths of the four sides of a rectangle. Return the area of\n  the rectangle rounded to 2 decimal points if the four sides form a valid rectangle.\n  Otherwise return -1\n  Four sides make a valid rectangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  rectangleArea(3, 4, 5) == 8.00\n  rectangleArea(1, 2, 10) == -1\n  */\nconst rectangleArea = (a, b, c) => {\n  const sumA = a + b;\n  const sumB = a + c;\n  const sumC = a + b;\n  const sumD = a + c;\n  const sumE = a + b;\n  const sumF = a + c;\n\n  if (sumA > sumB && sumA > sumC && sumA > sumD) {\n    return sumA / 4;\n  } else if (sumB > sumA && sumB > sumC && sumB > sumD) {\n    return sumB / 4;\n  } else if (sumC > sumA && sumC > sumB && sumC > sumD) {\n    return sumC / 4;\n  } else if (sumD > sumA && sumD > sumB && sumD > sumC) {\n    return sumD / 4;\n  } else if (sumE > sumA && sumE > sumB && sumE > sumC) {\n    return sumE / 4;\n  } else if (sumF > sumA && sumF > sumB && sumF > sumC) {\n    return sumF / 4;\n  } else {\n    return -1;\n  }\n};\n\n/*\n  Given the lengths of the five sides of a pentagon. Return the area of\n  the pentagon rounded to 2 decimal points if the five sides form a valid pentagon.\n  Otherwise return -1\n  Five sides make a valid pentagon when the sum of any two sides is greater\n  than the third side.\n  Example:\n  pentagonArea(3, 4, 5) == 12.00\n  pentagonArea(1, 2, 10) == -1\n  */\nconst pentagonArea = (a, b, c) => {\n  const sumA = a + b;\n  const sumB = a + c;\n  const sumC = a + b;\n  const sumD = a + c;\n  const sumE = a + b;\n  const sumF = a + c;\n\n  if (sumA > sumB && sumA > sumC && sumA > sumD) {\n    return sumA / 5;\n  } else if (sumB > sumA && sumB > sumC && sumB > sumD) {\n    return sumB / 5;\n  } else if (sumC > sumA && sumC > sumB && sumC > sumD) {\n    return sumC / 5;\n  } else if (sumD > sumA && sumD > sumB && sumD > sumC) {\n    return sumD / 5;\n  } else if (sumE > sumA && sumE > sumB && sumE > sumC) {\n    return sumE / 5;\n  } else if (sumF > sumA && sumF > sumB && sumF > sumC) {\n    return sumF / 5;\n  } else {\n    return -1;\n  }\n};\n\n/*\n  Given the lengths of the six sides of a hexagon. Return the area of\n  the hexagon rounded to 2 decimal points if the six sides form a valid hexagon.\n  Otherwise return -1\n  Six sides make a valid hexagon when the sum of any two sides is greater\n  than the third side.\n  Example:\n  hexagonArea(3, 4, 5) == 16.00\n  hexagonArea(1, 2, 10) == -1\n  */\nconst hexagonArea = (a, b, c) => {\n  const sumA = a + b;\n  const sumB = a + c;\n  const sumC = a + b;\n  const sumD = a + c;\n  const sumE = a + b;\n  const sumF = a + c;\n\n  if (sumA > sumB && sumA > sumC && sumA > sumD) {\n    return sumA / 6;\n  } else if (sumB > sumA && sumB > sumC && sumB > sumD) {\n    return sumB / 6;\n  } else if (sumC > sumA && sumC > sumB && sumC > sumD) {\n    return sumC / 6;\n  } else if (sumD > sumA && sumD > sumB && sumD > sumC) {\n    return sumD / 6;\n  } else if (sumE > sumA && sumE > sumB && sumE > sumC) {\n    return sumE / 6;\n  } else if (sumF > sumA && sumF > sumB && sumF > sumC) {\n    return sumF / 6;\n  } else {\n    return -1;\n  }\n};\n\n/*\n  Given the lengths of the seven sides of a heptagon. Return the area of\n  the heptagon rounded to 2 decimal points if the seven sides form a valid heptagon.\n  Otherwise return -1\n  Seven sides make a valid heptagon when the sum of any two sides is greater\n  than the third side.\n  Example:\n  heptagonArea(3, 4, 5) == 18.00\n  heptagonArea(1, 2, 10) == -1\n  */\nconst heptagonArea = (a, b, c) => {\n  const sumA = a + b;\n  const sumB = a + c;\n  const sumC = a + b;\n  const sumD = a + c;\n  const sumE = a + b;\n  const sumF = a + c;\n\n  if (sumA > sumB && sumA > sumC && sumA > sumD) {\n    return sumA / 7;\n  } else if (sumB > sumA && sumB > sumC && sumB > sumD) {\n    return sumB / 7;\n  } else if (sumC > sumA && sumC > sumB && sumC > sumD) {\n    return sumC / 7;\n  } else if (sumD > sumA && sumD > sumB && sumD > sumC) {\n    return sumD / 7;\n  } else if (sumE > sumA && sumE > sumB && sumE > sumC) {\n    return sumE / 7;\n  } else if (sumF > sumA && sumF > sumB && sumF > sumC) {\n    return sumF / 7;\n  } else {\n    return -1;\n  }\n};\n\n/*\n  Given the lengths of the eight sides of a ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "gc": "<|endoftext|>/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = w > 0? w : Number.MAX_SAFE_INTEGER;\n  const maxSum = q.reduce((acc, cur) => acc + cur, 0);\n  return q.reduce((acc, cur) => acc && cur <= maxWeight && cur <= maxSum, false);\n};\n\n/**\n * A function that returns the number of ways to arrange the elements of an array in such a way that no two elements can have the same value.\n * If the array is empty or has only one element, the function should return 0.\n * If the array has more than one element, the function should return 1.\n * If the array has more than one element and the first element is the same as the last element, the function should return 2.\n * If the array has more than one element and the first element is not the same as the last element, the function should return 3.\n * If the array has more than one element and the first element is the same as the second element, the function should return 4.\n * If the array has more than one element and the first element is not the same as the second element, the function should return 5.\n * If the array has more than one element and the first element is the same as the third element, the function should return 6.\n * If the array has more than one element and the first element is not the same as the third element, the function should return 7.\n * If the array has more than one element and the first element is the same as the fourth element, the function should return 8.\n * If the array has more than one element and the first element is not the same as the fourth element, the function should return 9.\n * If the array has more than one element and the first element is the same as the fifth element, the function should return 10.\n * If the array has more than one element and the first element is not the same as the fifth element, the function should return 11.\n * If the array has more than one element and the first element is the same as the sixth element, the function should return 12.\n * If the array has more than one element and the first element is not the same as the sixth element, the function should return 13.\n * If the array has more than one element and the first element is the same as the seventh element, the function should return 14.\n * If the array has more than one element and the first element is not the same as the seventh element, the function should return 15.\n * If the array has more than one element and the first element is the same as the eighth element, the function should return 16.\n * If the array has more than one element and the first element is not the same as the eighth element, the function should return 17.\n * If the array has more than one element and the first element is the same as the ninth element, the function should return 18.\n * If the array has more than one element and the first element is not the same as the ninth element, the function should return 19.\n * If the array has more than one element and the first element is the same as the tenth element, the function should return 20.\n * If the array has more than one element and the first element is not the same as the tenth element, the function should return 21.\n * If the array has more than one element and the first element is the same as the eleventh element, the function should return 22.\n * If the array has more than one element and the first element is not the same as the eleventh element, the function should return 23.\n * If the array has more than one element and the first element is the same as the twelfth element, the function should return 24.\n * If the array has more than one element and the first element is not the same as the twelfth element, the function should return 25.\n * If the array has more than one element and the first element is the same as the thirteenth element, the function should return 26.\n * If the array has more than one element and the first element is not the same as the thirteenth element, the function should return 27.\n * If the array has more than one element and the first element is the same as the fourteenth element, the function should return 28.\n * If the array has more than one element and the first element is not the same as the fourteenth element, the function should return 29.\n * If the array has more than one element and the first element is the same as the fifteenth element, the function should return 30.\n * If the array has more than one element and the first element is not the same as the fifteenth element, the function should return 31.\n * If the array has more than one element and the first element is the same as the sixteenth element, the function should return 32.\n * If the array has more than one element and the first element is not the same as the sixteenth element, the function should return 33.\n * If the array has more than one element and the first element is the same as the seventeenth element, the function should return 34.\n * If the array has more than one element and the first element is not the same as the seventeenth element, the function should return 35.\n * If the array has more than one element and the first element is the same as the eighteenth element, the function should return 36.\n * If the array has more than one element and the first element is not the same as the eighteenth element, the function should return 37.\n * If the array has more than one element and the first element is the same as the nineteenth element, the function should return 38.\n * If the array has more than one element and the first element is not the same as the nineteenth element, the function should return 39.\n * If the array has more than one element and the first element is the same as the twenty-first element, the function should return 40.\n * If the array has more than one element and the first element is not the same as the twenty-first element, the function should return 41.\n * If the array has more than one element and the first element is the same as the twenty-second element, the function should return 42.\n * If the array has more than one element and the first element is not the same as the twenty-second element, the function should return 43.\n * If the array has more than one element and the first element is the same as the thirty-first element, the function should return 44.\n * If the array has more than one element and the first element is not the same as the thirty-first element, the function should return 45.\n * If the array has more than one element and the first element is the same as the thirty-second element, the function should return 46.\n * If the array has more than one element and the first element is not the same as the thirty-second element, the function should return 47.\n * If the array has more than one element and the first element is the same as the fourty-first element, the function should return 48.\n * If the array has more than one element and the first element is not the same as the fourty-first element, the function should return 49.\n * If the array has more than one element and the first element is the same as the fourty-second element, the function should return 50.\n * If the array has more than one element and the first element is not the same as the fourty-second element, the function should return 51.\n * If the array has more than one element and the first element is the same as the fifty-first element, the function should return 52.\n * If the array has more than one element and the first element is not the same as the fifty-first element, the function should return 53.\n * If the array has more than one element and the first element is the same as the fifty-second element, the function should return 54.\n * If the array has more than one element and the first element is not the same as the fifty-second element, the function should return 55.\n * If the array has more than one element and the first element is the same as the sixty-first element, the function should return 56.\n * If the array has more than one element and the first element is not the same as the sixty-first element", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  msallestChange([1,2,3,5,4,7,9,6]) == 4\n  msallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  msallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst msallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "msallestChange", "gc": "<|endoftext|>/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  msallestChange([1,2,3,5,4,7,9,6]) == 4\n  msallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  msallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst msallestChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let minChange = len / 2;\n  let minLen = minChange;\n  let minArr = arr.slice(0, minChange);\n  let maxArr = arr.slice(minChange, len);\n  for (let i = 0; i < minChange; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (minArr[i]!== maxArr[j]) {\n        change++;\n        minLen = Math.min(minLen, j - i);\n        minArr = minArr.slice(0, j - i) + minArr.slice(j - i);\n        maxArr = maxArr.slice(0, j - i) + maxArr.slice(j - i);\n      }\n    }\n  }\n  return change;\n};\n\nmodule.exports = msallestChange;\n\n},{}],4:[function(require,module,exports){\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  msallestChange([1,2,3,5,4,7,9,6]) == 4\n  msallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  msallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst msallestChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let minChange = len / 2;\n  let minLen = minChange;\n  let minArr = arr.slice(0, minChange);\n  let maxArr = arr.slice(minChange, len);\n  for (let i = 0; i < minChange; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (minArr[i]!== maxArr[j]) {\n        change++;\n        minLen = Math.min(minLen, j - i);\n        minArr = minArr.slice(0, j - i) + minArr.slice(j - i);\n        maxArr = maxArr.slice(0, j - i) + maxArr.slice(j - i);\n      }\n    }\n  }\n  return change;\n};\n\nmodule.exports = msallestChange;\n\n},{}],5:[function(require,module,exports){\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  msallestChange([1,2,3,5,4,7,9,6]) == 4\n  msallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  msallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst msallestChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let minChange = len / 2;\n  let minLen = minChange;\n  let minArr = arr.slice(0, minChange);\n  let maxArr = arr.slice(minChange, len);\n  for (let i = 0; i < minChange; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (minArr[i]!== maxArr[j]) {\n        change++;\n        minLen = Math.min(minLen, j - i);\n        minArr = minArr.slice(0, j - i) + minArr.slice(j - i);\n        maxArr = maxArr.slice(0, j - i) + maxArr.slice(j - i);\n      }\n    }\n  }\n  return change;\n};\n\nmodule.exports = msallestChange;\n\n},{}],6:[function(require,module,exports){\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  msallestChange([1,2,3,5,4,7,9,6]) == 4\n  msallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  msallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst msallestChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let minChange = len / 2;\n  let minLen = minChange;\n  let minArr = arr.slice(0, minChange);\n  let maxArr = arr.slice(minChange, len);\n  for (let i = 0; i < minChange; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (minArr[i]!== maxArr[j]) {\n        change++;\n        minLen = Math.min(minLen, j - i);\n        minArr = minArr.slice(0, j - i) + minArr.slice(j - i);\n        maxArr = maxArr.slice(0, j - i) + maxArr.slice(j - i);\n      }\n    }\n  }\n  return change;\n};\n\nmodule.exports = msallestChange;\n\n},{}],7:[function(require,module,exports){\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  msallestChange([1,2,3,5,4,7,9,6]) == 4\n  msallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  msallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst msallestChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let minChange = len / 2;\n  let minLen = minChange;\n  let minArr = arr.slice(0, minChange);\n  let maxArr = arr.slice(minChange, len);\n  for (let i = 0; i < minChange; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (minArr[i]!== maxArr[j]) {\n        change++;\n        minLen = Math.min(minLen, j - i);\n        minArr = minArr.slice(0, j - i) + minArr.slice(j - i);\n        maxArr = maxArr.slice(0, j - i) + maxArr.slice(j - i);\n      }\n    }\n  }\n  return change;\n};\n\nmodule.exports = msallestChange;\n\n},{}],8:[function(require,module,exports){\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  msallestChange([1,2,3,5,4,7,9,6]) == 4\n  msallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  msallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst msallestChange = (arr) => {\n  let change = 0;\n  let len = arr.length;\n  let minChange = len / 2;\n  let minLen = minChange;\n  let minArr = arr.slice(0, minChange);\n  let maxArr = arr.slice(minChange, len);\n  for (let i = 0; i < minChange; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (minArr[i]!== maxArr[j]) {\n        change++;\n        minLen = Math.min(minLen, j - i);\n        minArr = minArr.slice(0, j - i) + minArr.slice(j - i);\n        maxArr = maxArr.slice(0, j - i) + maxArr.slice(j - i);\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  ottalMatch([], []) ➞ []\n  ottalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  ottalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  ottalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  ottalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst ottalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "ottalMatch", "gc": "<|endoftext|>/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  ottalMatch([], []) ➞ []\n  ottalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  ottalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  ottalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  ottalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst ottalMatch = (lst1, lst2) => {\n  let result = []\n  let len = Math.min(lst1.length, lst2.length)\n  for (let i = 0; i < len; i++) {\n    if (lst1[i]!== lst2[i]) {\n      result.push(lst1[i])\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list greater than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  ottalMatch([], []) ➞ []\n  ottalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  ottalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  ottalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  ottalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst ottalMismatch = (lst1, lst2) => {\n  let result = []\n  let len = Math.min(lst1.length, lst2.length)\n  for (let i = 0; i < len; i++) {\n    if (lst1[i]!== lst2[i]) {\n      result.push(lst1[i])\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list equal the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  ottalMatch([], []) ➞ []\n  ottalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  ottalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  ottalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  ottalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst ottalEqual = (lst1, lst2) => {\n  let result = []\n  let len = Math.min(lst1.length, lst2.length)\n  for (let i = 0; i < len; i++) {\n    if (lst1[i] === lst2[i]) {\n      result.push(lst1[i])\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list not equal the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  ottalMatch([], []) ➞ []\n  ottalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  ottalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  ottalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  ottalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst ottalNotEqual = (lst1, lst2) => {\n  let result = []\n  let len = Math.min(lst1.length, lst2.length)\n  for (let i = 0; i < len; i++) {\n    if (lst1[i]!== lst2[i]) {\n      result.push(lst1[i])\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list not less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  ottalMatch([], []) ➞ []\n  ottalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  ottalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  ottalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  ottalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst ottalLessThan = (lst1, lst2) => {\n  let result = []\n  let len = Math.min(lst1.length, lst2.length)\n  for (let i = 0; i < len; i++) {\n    if (lst1[i] < lst2[i]) {\n      result.push(lst1[i])\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list not greater than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  ottalMatch([], []) ➞ []\n  ottalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  ottalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  ottalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  ottalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst ottalGreaterThan = (lst1, lst2) => {\n  let result = []\n  let len = Math.min(lst1.length, lst2.length)\n  for (let i = 0; i < len; i++) {\n    if (lst1[i] > lst2[i]) {\n      result.push(lst1[i])\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list not equal the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  ottalMatch([], []) ➞ []\n  ottalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  ottalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  ottalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  ottalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst ottalNotLessThan = (lst1, lst2) => {\n  let result = []\n  let len = Math.min(lst1.length, lst2.length)\n  for (let i = 0; i < len; i++) {\n    if (lst1[i] > lst2[i]) {\n      result.push(lst1[i])\n    }\n  }\n  return result\n}\n\n/*\n  Write a function that accepts two lists of strings and returns the ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/75", "prompt": "/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPirme", "gc": "<|endoftext|>/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  if (a < 100) {\n    return a % 3 === 0;\n  }\n  return false;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  if (a < 100) {\n    return a % 3 === 0;\n  }\n  return false;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  if (a < 100) {\n    return a % 3 === 0;\n  }\n  return false;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  if (a < 100) {\n    return a % 3 === 0;\n  }\n  return false;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  if (a < 100) {\n    return a % 3 === 0;\n  }\n  return false;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  if (a < 100) {\n    return a % 3 === 0;\n  }\n  return false;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  if (a < 100) {\n    return a % 3 === 0;\n  }\n  return false;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  if (a < 100) {\n    return a % 3 === 0;\n  }\n  return false;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  if (a < 100) {\n    return a % 3 === 0;\n  }\n  return false;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  if (a < 100) {\n    return a % 3 === 0;\n  }\n  return false;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  if (a < 100) {\n    return a % 3 === 0;\n  }\n  return false;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  if (a < 100) {\n    return a % 3 === 0;\n  }\n  return false;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  if (a < 100) {\n    return a % 3 === 0;\n  }\n  return false;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  if (a < 100) {\n    return a % 3 === 0;\n  }\n  return false;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  if (a < 100) {\n    return a % 3 === 0;\n  }\n  return false;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  if (a < 100) {\n    return a % 3 === 0;\n  }\n  return false;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  if (a < 100) {\n    return a % 3 === 0;\n  }\n  return false;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  if (a < 100) {\n    return ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePwoer(1, 4) => true\n  isSimplePwoer(2, 2) => true\n  isSimplePwoer(8, 2) => true\n  isSimplePwoer(3, 2) => false\n  isSimplePwoer(3, 1) => false\n  isSimplePwoer(5, 3) => false\n  */\nconst isSimplePwoer = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePwoer", "gc": "<|endoftext|>/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePwoer(1, 4) => true\n  isSimplePwoer(2, 2) => true\n  isSimplePwoer(8, 2) => true\n  isSimplePwoer(3, 2) => false\n  isSimplePwoer(3, 1) => false\n  isSimplePwoer(5, 3) => false\n  */\nconst isSimplePwoer = (x, n) => {\n  if (x === 0) return true;\n  if (n === 0) return false;\n  if (n % x === 0) return false;\n  return isSimplePwoer(x, n / x) && isSimplePwoer(n, n % x);\n};\n\n/*\n  Write a function that takes an integer and returns the number of digits in it.\n  Examples:\n  digits(12) => 3\n  digits(121) => 2\n  digits(12000) => 1\n  digits(120001) => 0\n  digits(1200010) => 0\n  digits(12000100) => 0\n  digits(120001010) => 1\n  digits(120001011) => 1\n  digits(120001100) => 2\n  digits(120001101) => 2\n  digits(120001110) => 3\n  digits(120001111) => 3\n  digits(1200011110) => 3\n  digits(1200011111) => 3\n  digits(12000111101) => 3\n  digits(12000111110) => 4\n  digits(12000111111) => 4\n  digits(120001111111) => 4\n  digits(120001111110) => 4\n  digits(120001111111) => 4\n  digits(1200011111110) => 5\n  digits(1200011111111) => 5\n  digits(12000111111110) => 5\n  digits(12000111111111) => 5\n  digits(120001111111101) => 5\n  digits(120001111111110) => 6\n  digits(120001111111111) => 6\n  digits(1200011111111111) => 6\n  digits(1200011111111110) => 6\n  digits(1200011111111111) => 6\n  digits(12000111111111101) => 6\n  digits(12000111111111110) => 7\n  digits(12000111111111111) => 7\n  digits(1200011111111111) => 7\n  digits(120001111111111110) => 7\n  digits(1200011111111111) => 7\n  digits(1200011111111111101) => 7\n  digits(1200011111111111110) => 8\n  digits(1200011111111111111) => 8\n  digits(12000111111111111111) => 8\n  digits(12000111111111111110) => 8\n  digits(12000111111111111111) => 8\n  digits(120001111111111111101) => 8\n  digits(120001111111111111110) => 9\n  digits(120001111111111111111) => 9\n  digits(12000111111111111111) => 9\n  digits(1200011111111111111110) => 9\n  digits(12000111111111111111) => 9\n  digits(12000111111111111111101) => 9\n  digits(12000111111111111111110) => 10\n  digits(120001111111111111111) => 10\n  digits(12000111111111111111) => 10\n  digits(1200011111111111111110) => 10\n  digits(12000111111111111111) => 10\n  digits(12000111111111111111101) => 10\n  digits(12000111111111111111110) => 11\n  digits(120001111111111111111) => 11\n  digits(12000111111111111111) => 11\n  digits(1200011111111111111110) => 11\n  digits(12000111111111111111) => 11\n  digits(12000111111111111111101) => 11\n  digits(12000111111111111111110) => 12\n  digits(120001111111111111111) => 12\n  digits(12000111111111111111) => 12\n  digits(1200011111111111111110) => 12\n  digits(12000111111111111111) => 12\n  digits(12000111111111111111101) => 12\n  digits(12000111111111111111110) => 13\n  digits(120001111111111111111) => 13\n  digits(12000111111111111111) => 13\n  digits(1200011111111111111110) => 13\n  digits(12000111111111111111) => 13\n  digits(12000111111111111111101) => 13\n  digits(12000111111111111111110) => 14\n  digits(120001111111111111111) => 14\n  digits(12000111111111111111) => 14\n  digits(1200011111111111111110) => 14\n  digits(12000111111111111111) => 14\n  digits(12000111111111111111101) => 14\n  digits(12000111111111111111110) => 15\n  digits(120001111111111111111) => 15\n  digits(12000111111111111111) => 15\n  digits(1200011111111111111110) => 15\n  digits(12000111111111111111) => 15\n  digits(12000111111111111111101) => 15\n  digits(12000111111111111111110) => 16\n  digits(120001111111111111111) => 16\n  digits(12000111111111111111) => 16\n  digits(1200011111111111111110) => 16\n  digits(12000111111111111111) => 16\n  digits(12000111111111111111101) => 16\n  digits(12000111111111111111110) => 17\n  digits(120001111111111111111) => 17\n  digits(12000111111111111111) => 17\n  digits(1200011111111111111110) => 17\n  digits(12000111111111111111) => 17\n  digits(12000111111111111111101) => 17\n  digits(12000111111111111111110) => 18\n  digits(120001111111111111111) => 18\n  digits(12000111111111111111) => 18\n  digits(1200011111111111111110) => 18\n  digits(12000111111111111111) => 18\n  digits(12000111111111111111101) => 18\n  digits(12000111111111111111110) => 19\n  digits(120001111111111111111) => 19\n  digits(12000111111111111111) => 19\n  digits(1200011111111111111110) => 19\n  digits(12000111111111111111) => 19\n  digits(12000111111111111111101) => 19\n  digits(12000111111111111111110) => 20\n  digits(120001111111111111111) => 20\n  digits(12000111111111111111) => 20\n  digits(12", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "gc": "<|endoftext|>/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  let isCube = true;\n  let n = Math.pow(a, 3);\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      isCube = false;\n      break;\n    }\n  }\n  return isCube;\n};\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a prime number.\n  Note: you may assume the input is always valid.\n  Examples:\n  isprime(1) ==> true\n  isprime(2) ==> false\n  isprime(-1) ==> true\n  isprime(64) ==> true\n  isprime(0) ==> true\n  isprime(180) ==> false\n  */\nconst isprime = (a) => {\n  let isPrime = true;\n  let n = Math.pow(a, 2);\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime;\n};\n\n/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is an even number.\n  Note: you may assume the input is always valid.\n  Examples:\n  iseven(2) ==> true\n  iseven(3) ==> false\n  iseven(4) ==> false\n  iseven(5) ==> false\n  iseven(6) ==> false\n  iseven(7) ==> false\n  iseven(8) ==> false\n  iseven(9) ==> false\n  iseven(10) ==> false\n  iseven(11) ==> false\n  iseven(12) ==> false\n  iseven(13) ==> false\n  iseven(14) ==> false\n  iseven(15) ==> false\n  iseven(16) ==> false\n  iseven(17) ==> false\n  iseven(18) ==> false\n  iseven(19) ==> false\n  iseven(20) ==> false\n  iseven(21) ==> false\n  iseven(22) ==> false\n  iseven(23) ==> false\n  iseven(24) ==> false\n  iseven(25) ==> false\n  iseven(26) ==> false\n  iseven(27) ==> false\n  iseven(28) ==> false\n  iseven(29) ==> false\n  iseven(30) ==> false\n  iseven(31) ==> false\n  iseven(32) ==> false\n  iseven(33) ==> false\n  iseven(34) ==> false\n  iseven(35) ==> false\n  iseven(36) ==> false\n  iseven(37) ==> false\n  iseven(38) ==> false\n  iseven(39) ==> false\n  iseven(40) ==> false\n  iseven(41) ==> false\n  iseven(42) ==> false\n  iseven(43) ==> false\n  iseven(44) ==> false\n  iseven(45) ==> false\n  iseven(46) ==> false\n  iseven(47) ==> false\n  iseven(48) ==> false\n  iseven(49) ==> false\n  iseven(50) ==> false\n  iseven(51) ==> false\n  iseven(52) ==> false\n  iseven(53) ==> false\n  iseven(54) ==> false\n  iseven(55) ==> false\n  iseven(56) ==> false\n  iseven(57) ==> false\n  iseven(58) ==> false\n  iseven(59) ==> false\n  iseven(60) ==> false\n  iseven(61) ==> false\n  iseven(62) ==> false\n  iseven(63) ==> false\n  iseven(64) ==> false\n  iseven(65) ==> false\n  iseven(66) ==> false\n  iseven(67) ==> false\n  iseven(68) ==> false\n  iseven(69) ==> false\n  iseven(70) ==> false\n  iseven(71) ==> false\n  iseven(72) ==> false\n  iseven(73) ==> false\n  iseven(74) ==> false\n  iseven(75) ==> false\n  iseven(76) ==> false\n  iseven(77) ==> false\n  iseven(78) ==> false\n  iseven(79) ==> false\n  iseven(80) ==> false\n  iseven(81) ==> false\n  iseven(82) ==> false\n  iseven(83) ==> false\n  iseven(84) ==> false\n  iseven(85) ==> false\n  iseven(86) ==> false\n  iseven(87) ==> false\n  iseven(88) ==> false\n  iseven(89) ==> false\n  iseven(90) ==> false\n  iseven(91) ==> false\n  iseven(92) ==> false\n  iseven(93) ==> false\n  iseven(94) ==> false\n  iseven(95) ==> false\n  iseven(96) ==> false\n  iseven(97) ==> false\n  iseven(98) ==> false\n  iseven(99) ==> false\n  iseven(100) ==> false\n  iseven(101) ==> false\n  iseven(102) ==> false\n  iseven(103) ==> false\n  iseven(104) ==> false\n  iseven(105) ==> false\n  iseven(106) ==> false\n  iseven(107) ==> false\n  iseven(108) ==> false\n  iseven(109) ==> false\n  iseven(110) ==> false\n  iseven(111) ==> false\n  iseven(112) ==> false\n  iseven(113) ==> false\n  iseven(114) ==> false\n  iseven(115) ==> false\n  iseven(116) ==> false\n  iseven(117) ==> false\n  iseven(118) ==> false\n  iseven(119) ==> false\n  iseven(120) ==> false\n  iseven(121) ==> false\n  iseven(122) ==> false\n  iseven(123) ==> false\n  iseven(124) ==> false\n  iseven(125) ==> false\n  iseven(126) ==> false\n  iseven(127) ==> false\n  iseven(128) ==> false\n  iseven(129) ==> false\n  iseven(130) ==> false\n  iseven(131) ==> false\n  iseven(132) ==> false\n  iseven(133) ==> false\n  iseven(134) ==> false\n  iseven(135) ==> false\n  iseven(136) ==> false\n  iseven(137) ==> false\n  iseven(138) ==> false\n  iseven(139) ==> false\n  iseven(140) ==> false\n  iseven(141) ==> false\n  iseven(142) ==> false\n  iseven(143) ==> false\n  iseven(144) ==> false\n  iseven(145) ==> false\n  iseven(146) ==> false\n  iseven(147) ==> false\n  iseven(148) ==> false\n  iseven(149) ==> false\n  iseven(150) ==> false\n  iseven(151) ==> false\n  iseven(152) ==> false\n  iseven(153) ==> false\n  iseven(154) ==> false\n  iseven(155) ==> false\n  iseven(156) ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "gc": "<|endoftext|>/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let count = 0;\n  let sum = 0;\n  let sum2 = 0;\n  let sum3 = 0;\n  let sum4 = 0;\n  let sum5 = 0;\n  let sum6 = 0;\n  let sum7 = 0;\n  let sum8 = 0;\n  let sum9 = 0;\n  let sumA = 0;\n  let sumB = 0;\n  let sumC = 0;\n  let sumD = 0;\n  let sumE = 0;\n  let sumF = 0;\n  let sumG = 0;\n  let sumH = 0;\n  let sumI = 0;\n  let sumJ = 0;\n  let sumK = 0;\n  let sumL = 0;\n  let sumM = 0;\n  let sumN = 0;\n  let sumO = 0;\n  let sumP = 0;\n  let sumQ = 0;\n  let sumR = 0;\n  let sumS = 0;\n  let sumT = 0;\n  let sumU = 0;\n  let sumV = 0;\n  let sumW = 0;\n  let sumX = 0;\n  let sumY = 0;\n  let sumZ = 0;\n  let sumA2 = 0;\n  let sumA3 = 0;\n  let sumA4 = 0;\n  let sumA5 = 0;\n  let sumA6 = 0;\n  let sumA7 = 0;\n  let sumA8 = 0;\n  let sumA9 = 0;\n  let sumA10 = 0;\n  let sumA11 = 0;\n  let sumA12 = 0;\n  let sumA13 = 0;\n  let sumA14 = 0;\n  let sumA15 = 0;\n  let sumA16 = 0;\n  let sumA17 = 0;\n  let sumA18 = 0;\n  let sumA19 = 0;\n  let sumA20 = 0;\n  let sumA21 = 0;\n  let sumA22 = 0;\n  let sumA23 = 0;\n  let sumA24 = 0;\n  let sumA25 = 0;\n  let sumA26 = 0;\n  let sumA27 = 0;\n  let sumA28 = 0;\n  let sumA29 = 0;\n  let sumA30 = 0;\n  let sumA31 = 0;\n  let sumA32 = 0;\n  let sumA33 = 0;\n  let sumA34 = 0;\n  let sumA35 = 0;\n  let sumA36 = 0;\n  let sumA37 = 0;\n  let sumA38 = 0;\n  let sumA39 = 0;\n  let sumA40 = 0;\n  let sumA41 = 0;\n  let sumA42 = 0;\n  let sumA43 = 0;\n  let sumA44 = 0;\n  let sumA45 = 0;\n  let sumA46 = 0;\n  let sumA47 = 0;\n  let sumA48 = 0;\n  let sumA49 = 0;\n  let sumA50 = 0;\n  let sumA51 = 0;\n  let sumA52 = 0;\n  let sumA53 = 0;\n  let sumA54 = 0;\n  let sumA55 = 0;\n  let sumA56 = 0;\n  let sumA57 = 0;\n  let sumA58 = 0;\n  let sumA59 = 0;\n  let sumA60 = 0;\n  let sumA61 = 0;\n  let sumA62 = 0;\n  let sumA63 = 0;\n  let sumA64 = 0;\n  let sumA65 = 0;\n  let sumA66 = 0;\n  let sumA67 = 0;\n  let sumA68 = 0;\n  let sumA69 = 0;\n  let sumA70 = 0;\n  let sumA71 = 0;\n  let sumA72 = 0;\n  let sumA73 = 0;\n  let sumA74 = 0;\n  let sumA75 = 0;\n  let sumA76 = 0;\n  let sumA77 = 0;\n  let sumA78 = 0;\n  let sumA79 = 0;\n  let sumA80 = 0;\n  let sumA81 = 0;\n  let sumA82 = 0;\n  let sumA83 = 0;\n  let sumA84 = 0;\n  let sumA85 = 0;\n  let sumA86 = 0;\n  let sumA87 = 0;\n  let sumA88 = 0;\n  let sumA89 = 0;\n  let sumA90 = 0;\n  let sumA91 = 0;\n  let sumA92 = 0;\n  let sumA93 = 0;\n  let sumA94 = 0;\n  let sumA95 = 0;\n  let sumA96 = 0;\n  let sumA97 = 0;\n  let sumA98 = 0;\n  let sumA99 = 0;\n  let sumA100 = 0;\n  let sumA101 = 0;\n  let sumA102 = 0;\n  let sumA103 = 0;\n  let sumA104 = 0;\n  let sumA105 = 0;\n  let sumA106 = 0;\n  let sumA107 = 0;\n  let sumA108 = 0;\n  let sumA109 = 0;\n  let sumA110 = 0;\n  let sumA111 = 0;\n  let sumA112 = 0;\n  let sumA113 = 0;\n  let sumA114 = 0;\n  let sumA115 = 0;\n  let sumA116 = 0;\n  let sumA117 = 0;\n  let sumA118 = 0;\n  let sumA119 = 0;\n  let sumA120 = 0;\n  let sumA121 = 0;\n  let sumA122 = 0;\n  let sumA123 = 0;\n  let sumA124 = 0;\n  let sumA125 = 0;\n  let sumA126 = 0;\n  let sumA127 = 0;\n  let sumA128 = 0;\n  let sumA129 = 0;\n  let sumA130 = 0;\n  let sumA131 = 0;\n  let sumA132 = 0;\n  let sumA133 = 0;\n  let sumA134 = 0;\n  let sumA135 = 0;\n  let sumA136 = 0;\n  let sumA137 = 0;\n  let sumA138 = 0;\n  let sumA139 = 0;\n  let sumA140 = 0;\n  let sumA141 = 0;\n  let sumA142 = 0;\n  let sumA143 = 0;\n  let sumA144 = 0;\n  let sumA145 = 0;\n  let sumA146 = 0;\n  let sumA147 = 0;\n  let sumA148 = 0;\n  let sumA149 = 0;\n  let sumA150 = 0;\n  let sumA151 = 0;\n  let sumA152 = 0;\n  let sumA153 = 0;\n  let sumA154 = 0;\n  let sumA155 = 0;\n  let sumA156 = 0;\n  let sumA157 = 0;\n  let sumA158 = 0;\n  let sumA159 = 0;\n  let sumA160 = 0;\n  let sumA161 = 0;\n  let sumA162 = 0;\n  let sumA163 = 0;\n  let sumA164 = 0;\n  let sumA165 = 0;\n  let sumA166 = 0;\n  let sumA167 = 0;\n  let sumA168 = 0;\n  let sumA169 = 0;\n  let sumA170 = 0;\n  let sumA171 = 0;\n  let sumA172 = 0;\n  let sumA173 = 0;\n  let sumA174 = 0;\n  let sumA175 = 0;\n  let sumA176 = 0;\n  let sumA177 = 0;\n  let sumA178 = 0;\n  let sumA179 = 0;\n  let sumA180 = 0;\n  let sumA181 = 0;\n  let sumA182 = 0;\n  let sumA183 = 0;\n  let sumA184 = 0;\n  let sumA185 = 0;\n  let sumA186 = 0;\n  let sumA187 = 0;\n  let sumA188 = 0;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/79", "prompt": "/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "gc": "<|endoftext|>/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let num = 0;\n  let decimalString = decimal.toString();\n  for (let i = 0; i < decimalString.length; i++) {\n    if (decimalString.charAt(i) == '0') {\n      num++;\n    } else {\n      num = 0;\n    }\n    binary += num.toString(2);\n  }\n  return binary;\n};\n\n/*\n  Given a string, convert it to an array. Your function should return an array with each character\n  representing a binary number. Each character in the array will be '0' or '1'.\n\n  Examples:\n  binaryToArray(binary)   # returns [\"0\", \"1\", \"0\", \"1\", \"0\", \"1\", \"0\", \"1\", \"0\"]\n  */\nconst binaryToArray = (binary) => {\n  let array = [];\n  let num = 0;\n  for (let i = 0; i < binary.length; i++) {\n    if (binary.charAt(i) == '0') {\n      num++;\n    } else {\n      num = 0;\n    }\n    array.push(num.toString(2));\n  }\n  return array;\n};\n\n/*\n  Given a string, convert it to an array. Your function should return an array with each character\n  representing a binary number. Each character in the array will be '0' or '1'.\n\n  Examples:\n  binaryToArray(binary)   # returns [\"0\", \"1\", \"0\", \"1\", \"0\", \"1\", \"0\", \"1\", \"0\"]\n  */\nconst binaryToArray = (binary) => {\n  let array = [];\n  let num = 0;\n  for (let i = 0; i < binary.length; i++) {\n    if (binary.charAt(i) == '0') {\n      num++;\n    } else {\n      num = 0;\n    }\n    array.push(num.toString(2));\n  }\n  return array;\n};\n\n/*\n  Given a string, convert it to an array. Your function should return an array with each character\n  representing a binary number. Each character in the array will be '0' or '1'.\n\n  Examples:\n  binaryToArray(binary)   # returns [\"0\", \"1\", \"0\", \"1\", \"0\", \"1\", \"0\", \"1\", \"0\"]\n  */\nconst binaryToArray = (binary) => {\n  let array = [];\n  let num = 0;\n  for (let i = 0; i < binary.length; i++) {\n    if (binary.charAt(i) == '0') {\n      num++;\n    } else {\n      num = 0;\n    }\n    array.push(num.toString(2));\n  }\n  return array;\n};\n\n/*\n  Given a string, convert it to an array. Your function should return an array with each character\n  representing a binary number. Each character in the array will be '0' or '1'.\n\n  Examples:\n  binaryToArray(binary)   # returns [\"0\", \"1\", \"0\", \"1\", \"0\", \"1\", \"0\", \"1\", \"0\"]\n  */\nconst binaryToArray = (binary) => {\n  let array = [];\n  let num = 0;\n  for (let i = 0; i < binary.length; i++) {\n    if (binary.charAt(i) == '0') {\n      num++;\n    } else {\n      num = 0;\n    }\n    array.push(num.toString(2));\n  }\n  return array;\n};\n\n/*\n  Given a string, convert it to an array. Your function should return an array with each character\n  representing a binary number. Each character in the array will be '0' or '1'.\n\n  Examples:\n  binaryToArray(binary)   # returns [\"0\", \"1\", \"0\", \"1\", \"0\", \"1\", \"0\", \"1\", \"0\"]\n  */\nconst binaryToArray = (binary) => {\n  let array = [];\n  let num = 0;\n  for (let i = 0; i < binary.length; i++) {\n    if (binary.charAt(i) == '0') {\n      num++;\n    } else {\n      num = 0;\n    }\n    array.push(num.toString(2));\n  }\n  return array;\n};\n\n/*\n  Given a string, convert it to an array. Your function should return an array with each character\n  representing a binary number. Each character in the array will be '0' or '1'.\n\n  Examples:\n  binaryToArray(binary)   # returns [\"0\", \"1\", \"0\", \"1\", \"0\", \"1\", \"0\", \"1\", \"0\"]\n  */\nconst binaryToArray = (binary) => {\n  let array = [];\n  let num = 0;\n  for (let i = 0; i < binary.length; i++) {\n    if (binary.charAt(i) == '0') {\n      num++;\n    } else {\n      num = 0;\n    }\n    array.push(num.toString(2));\n  }\n  return array;\n};\n\n/*\n  Given a string, convert it to an array. Your function should return an array with each character\n  representing a binary number. Each character in the array will be '0' or '1'.\n\n  Examples:\n  binaryToArray(binary)   # returns [\"0\", \"1\", \"0\", \"1\", \"0\", \"1\", \"0\", \"1\", \"0\"]\n  */\nconst binaryToArray = (binary) => {\n  let array = [];\n  let num = 0;\n  for (let i = 0; i < binary.length; i++) {\n    if (binary.charAt(i) == '0') {\n      num++;\n    } else {\n      num = 0;\n    }\n    array.push(num.toString(2));\n  }\n  return array;\n};\n\n/*\n  Given a string, convert it to an array. Your function should return an array with each character\n  representing a binary number. Each character in the array will be '0' or '1'.\n\n  Examples:\n  binaryToArray(binary)   # returns [\"0\", \"1\", \"0\", \"1\", \"0\", \"1\", \"0\", \"1\", \"0\"]\n  */\nconst binaryToArray = (binary) => {\n  let array = [];\n  let num = 0;\n  for (let i = 0; i < binary.length; i++) {\n    if (binary.charAt(i) == '0') {\n      num++;\n    } else {\n      num = 0;\n    }\n    array.push(num.toString(2));\n  }\n  return array;\n};\n\n/*\n  Given a string, convert it to an array. Your function should return an array with each character\n  representing a binary number. Each character in the array will be '0' or '1'.\n\n  Examples:\n  binaryToArray(binary)   # returns [\"0\", \"1\", \"0\", \"1\", \"0\", \"1\", \"0\", \"1\", \"0\"]\n  */\nconst binaryToArray = (binary) => {\n  let array = [];\n  let num = 0;\n  for (let i = 0; i < binary.length; i++) {\n    if (binary.charAt(i) == '0') {\n      num++;\n    } else {\n      num = 0;\n    }\n    array.push(num.toString(2));\n  }\n  return array;\n};\n\n/*\n  Given a string, convert it to an array. Your function should return an array with each character\n  representing a binary number. Each character in the array will be '0' or '1'.\n\n  Examples:\n  binaryToArray(binary)   # returns [\"0\", \"1\", \"0\", \"1\", \"0\", \"1\", \"0\", \"1\", \"0\"]\n  */\nconst binaryToArray = (binary) => {\n  let array = [];\n  let num = 0;\n  for (let i = 0; i < binary.length; i++) {\n    if (binary.charAt(i) == '0') {\n      num++;\n    } else {\n      num = 0;\n    }\n    array.push(num.toString(2));\n  }\n  return array;\n};\n\n/*\n  Given a string, convert it to an array. Your function should return an array with each character\n  representing a binary number. Each character in the array will be '0' or '1'.\n\n  Examples:\n  binaryToArray(binary)   # returns [\"0\", \"1\", \"0\", \"1\", \"0\", \"1\", \"0\", \"1\", \"0\"]\n  */\nconst binaryToArray = (binary) => {\n  let array = [];\n  let num = 0;\n  for (let i = 0; i < binary.length; i++) {\n    if (binary.charAt(i) == '0') {\n      num++;\n    } else {\n      num = 0;\n    }\n    array.push(num.toString(2));\n  }\n  return array;\n};\n\n/*\n  Given a string, convert it to an array. Your function should return an array with each character\n  representing a binary number. Each character in the array will be '0' or '1", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "gc": "<|endoftext|>/* For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= i;\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of tuples consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> sumProduct([2, 5, 7, 9], 2)\n  ([2, 5], 2)\n  >>> sumProduct([2, 5, 7, 9], 5)\n  ([2, 5, 7, 9], 6)\n  >>> sumProduct([2, 5, 7, 9], 7)\n  ([2, 5, 7, 9], 8)\n  >>> sumProduct([2, 5, 7, 9], 9)\n  ([2, 5, 7, 9], 10)\n  >>> sumProduct([2, 5, 7, 9], 11)\n  ([2, 5, 7, 9], 12)\n  >>> sumProduct([2, 5, 7, 9], 13)\n  ([2, 5, 7, 9], 14)\n  >>> sumProduct([2, 5, 7, 9], 15)\n  ([2, 5, 7, 9], 16)\n  >>> sumProduct([2, 5, 7, 9], 17)\n  ([2, 5, 7, 9], 18)\n  >>> sumProduct([2, 5, 7, 9], 19)\n  ([2, 5, 7, 9], 20)\n  >>> sumProduct([2, 5, 7, 9], 21)\n  ([2, 5, 7, 9], 22)\n  >>> sumProduct([2, 5, 7, 9], 23)\n  ([2, 5, 7, 9], 24)\n  >>> sumProduct([2, 5, 7, 9], 25)\n  ([2, 5, 7, 9], 26)\n  >>> sumProduct([2, 5, 7, 9], 27)\n  ([2, 5, 7, 9], 28)\n  >>> sumProduct([2, 5, 7, 9], 29)\n  ([2, 5, 7, 9], 30)\n  >>> sumProduct([2, 5, 7, 9], 31)\n  ([2, 5, 7, 9], 32)\n  >>> sumProduct([2, 5, 7, 9], 33)\n  ([2, 5, 7, 9], 34)\n  >>> sumProduct([2, 5, 7, 9], 35)\n  ([2, 5, 7, 9], 36)\n  >>> sumProduct([2, 5, 7, 9], 37)\n  ([2, 5, 7, 9], 38)\n  >>> sumProduct([2, 5, 7, 9], 39)\n  ([2, 5, 7, 9], 40)\n  >>> sumProduct([2, 5, 7, 9], 41)\n  ([2, 5, 7, 9], 42)\n  >>> sumProduct([2, 5, 7, 9], 43)\n  ([2, 5, 7, 9], 44)\n  >>> sumProduct([2, 5, 7, 9], 45)\n  ([2, 5, 7, 9], 46)\n  >>> sumProduct([2, 5, 7, 9], 47)\n  ([2, 5, 7, 9], 48)\n  >>> sumProduct([2, 5, 7, 9], 49)\n  ([2, 5, 7, 9], 50)\n  >>> sumProduct([2, 5, 7, 9], 51)\n  ([2, 5, 7, 9], 52)\n  >>> sumProduct([2, 5, 7, 9], 53)\n  ([2, 5, 7, 9], 54)\n  >>> sumProduct([2, 5, 7, 9], 55)\n  ([2, 5, 7, 9], 56)\n  >>> sumProduct([2, 5, 7, 9], 57)\n  ([2, 5, 7, 9], 58)\n  >>> sumProduct([2, 5, 7, 9], 59)\n  ([2, 5, 7, 9], 60)\n  >>> sumProduct([2, 5, 7, 9], 61)\n  ([2, 5, 7, 9], 62)\n  >>> sumProduct([2, 5, 7, 9], 63)\n  ([2, 5, 7, 9], 64)\n  >>> sumProduct([2, 5, 7, 9], 65)\n  ([2, 5, 7, 9], 66)\n  >>> sumProduct([2, 5, 7, 9], 67)\n  ([2, 5, 7, 9], 68)\n  >>> sumProduct([2, 5, 7, 9], 69)\n  ([2, 5, 7, 9], 70)\n  >>> sumProduct([2, 5, 7, 9], 71)\n  ([2, 5, 7, 9], 72)\n  >>> sumProduct([2, 5, 7, 9], 73)\n  ([2, 5, 7, 9], 74)\n  >>> sumProduct([2, 5, 7, 9], 75)\n  ([2, 5, 7, 9], 76)\n  >>> sumProduct([2, 5, 7, 9], 77)\n  ([2, 5, 7, 9], 78)\n  >>> sumProduct([2, 5, 7, 9], 79)\n  ([2, 5, 7, 9], 80)\n  >>> sumProduct([2, 5, 7, 9], 81)\n  ([2, 5, 7, 9], 82)\n  >>> sumProduct([2, 5, 7, 9], 83)\n  ([2, 5, 7, 9], 84)\n  >>> sumProduct([2, 5, 7, 9], 85)\n  ([2, 5, 7, 9], 86)\n  >>> sumProduct([2, 5, 7, 9], 87)\n  ([2, 5, 7, 9], 88)\n  >>> sumProduct([2, 5, 7, 9], 89)\n  ([2, 5, 7, 9], 90)\n  >>> sumProduct([2, 5, 7, 9], 91)\n  ([2, 5, 7, 9], 92)\n  >>> sumProduct([2, 5, 7, 9], 93)\n  ([2, 5, 7, 9], 94)\n  >>> sumProduct([2, 5, 7, 9], 95)\n  ([2, 5, 7, 9], 96)\n  >>> sumProduct([2, 5, 7, 9], 97)\n  ([2, 5, 7, 9], 98)\n  >>> sumProduct([2, 5, 7, 9], 99)\n  ([2, 5, 7, 9], 100)\n  >>> sumProduct([2, 5, 7, 9], 101)\n  ([2, 5, 7, 9], 102)\n  >>> sumProduct([2, 5, 7, 9], 103)\n  ([2, 5, 7, 9], 104)\n  >>> sumProduct([2, 5, 7, 9], 105)\n  ([2, 5, 7, 9], 106)\n  >>> sumProduct([2, 5, 7, 9], 107)\n  ([2, 5, 7, 9], 108)\n  >>> sumProduct([2, 5, 7, 9], 109)\n  ([2, 5, 7, 9], 110)\n  >>> sumProduct([2, 5, 7, 9], 111)\n  ([2, 5, 7, 9], 112)\n  >>> sumProduct([2, 5, 7, 9], 113)\n  ([2, 5, 7, 9], 114)\n  >>> sumProduct([2, 5, 7, 9], 115)\n  ([2, 5, 7, 9], 116)\n  >>> sumProduct([2, 5, 7, 9], 117)\n  ([2, 5, 7, 9], 118)\n  >>> sumProduct([2, 5, 7, 9], 119)\n  ([2, 5, 7, 9], 120)\n  >>> sumProduct([2, 5, 7, 9], 121)\n  ([2, 5, 7, 9], 122)\n  >>> sumProduct([2, 5, 7, 9], 123)\n  ([2, 5, 7, 9], 124)\n  >>> sumProduct([2, 5, 7, 9], 125)\n  ([2, 5, 7, 9], 126)\n  >>> sumProduct([2, 5, 7, 9], 12", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/80", "prompt": "/*You are given a string s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "gc": "<|endoftext|>/*You are given a string s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let isHappy = true;\n  let count = 0;\n  let letterCount = 0;\n  let letterCount2 = 0;\n  let letterCount3 = 0;\n  let letterCount4 = 0;\n  let letterCount5 = 0;\n  let letterCount6 = 0;\n  let letterCount7 = 0;\n  let letterCount8 = 0;\n  let letterCount9 = 0;\n  let letterCount10 = 0;\n  let letterCount11 = 0;\n  let letterCount12 = 0;\n  let letterCount13 = 0;\n  let letterCount14 = 0;\n  let letterCount15 = 0;\n  let letterCount16 = 0;\n  let letterCount17 = 0;\n  let letterCount18 = 0;\n  let letterCount19 = 0;\n  let letterCount20 = 0;\n  let letterCount21 = 0;\n  let letterCount22 = 0;\n  let letterCount23 = 0;\n  let letterCount24 = 0;\n  let letterCount25 = 0;\n  let letterCount26 = 0;\n  let letterCount27 = 0;\n  let letterCount28 = 0;\n  let letterCount29 = 0;\n  let letterCount30 = 0;\n  let letterCount31 = 0;\n  let letterCount32 = 0;\n  let letterCount33 = 0;\n  let letterCount34 = 0;\n  let letterCount35 = 0;\n  let letterCount36 = 0;\n  let letterCount37 = 0;\n  let letterCount38 = 0;\n  let letterCount39 = 0;\n  let letterCount40 = 0;\n  let letterCount41 = 0;\n  let letterCount42 = 0;\n  let letterCount43 = 0;\n  let letterCount44 = 0;\n  let letterCount45 = 0;\n  let letterCount46 = 0;\n  let letterCount47 = 0;\n  let letterCount48 = 0;\n  let letterCount49 = 0;\n  let letterCount50 = 0;\n  let letterCount51 = 0;\n  let letterCount52 = 0;\n  let letterCount53 = 0;\n  let letterCount54 = 0;\n  let letterCount55 = 0;\n  let letterCount56 = 0;\n  let letterCount57 = 0;\n  let letterCount58 = 0;\n  let letterCount59 = 0;\n  let letterCount60 = 0;\n  let letterCount61 = 0;\n  let letterCount62 = 0;\n  let letterCount63 = 0;\n  let letterCount64 = 0;\n  let letterCount65 = 0;\n  let letterCount66 = 0;\n  let letterCount67 = 0;\n  let letterCount68 = 0;\n  let letterCount69 = 0;\n  let letterCount70 = 0;\n  let letterCount71 = 0;\n  let letterCount72 = 0;\n  let letterCount73 = 0;\n  let letterCount74 = 0;\n  let letterCount75 = 0;\n  let letterCount76 = 0;\n  let letterCount77 = 0;\n  let letterCount78 = 0;\n  let letterCount79 = 0;\n  let letterCount80 = 0;\n  let letterCount81 = 0;\n  let letterCount82 = 0;\n  let letterCount83 = 0;\n  let letterCount84 = 0;\n  let letterCount85 = 0;\n  let letterCount86 = 0;\n  let letterCount87 = 0;\n  let letterCount88 = 0;\n  let letterCount89 = 0;\n  let letterCount90 = 0;\n  let letterCount91 = 0;\n  let letterCount92 = 0;\n  let letterCount93 = 0;\n  let letterCount94 = 0;\n  let letterCount95 = 0;\n  let letterCount96 = 0;\n  let letterCount97 = 0;\n  let letterCount98 = 0;\n  let letterCount99 = 0;\n  let letterCount100 = 0;\n  let letterCount101 = 0;\n  let letterCount102 = 0;\n  let letterCount103 = 0;\n  let letterCount104 = 0;\n  let letterCount105 = 0;\n  let letterCount106 = 0;\n  let letterCount107 = 0;\n  let letterCount108 = 0;\n  let letterCount109 = 0;\n  let letterCount110 = 0;\n  let letterCount111 = 0;\n  let letterCount112 = 0;\n  let letterCount113 = 0;\n  let letterCount114 = 0;\n  let letterCount115 = 0;\n  let letterCount116 = 0;\n  let letterCount117 = 0;\n  let letterCount118 = 0;\n  let letterCount119 = 0;\n  let letterCount120 = 0;\n  let letterCount121 = 0;\n  let letterCount122 = 0;\n  let letterCount123 = 0;\n  let letterCount124 = 0;\n  let letterCount125 = 0;\n  let letterCount126 = 0;\n  let letterCount127 = 0;\n  let letterCount128 = 0;\n  let letterCount129 = 0;\n  let letterCount130 = 0;\n  let letterCount131 = 0;\n  let letterCount132 = 0;\n  let letterCount133 = 0;\n  let letterCount134 = 0;\n  let letterCount135 = 0;\n  let letterCount136 = 0;\n  let letterCount137 = 0;\n  let letterCount138 = 0;\n  let letterCount139 = 0;\n  let letterCount140 = 0;\n  let letterCount141 = 0;\n  let letterCount142 = 0;\n  let letterCount143 = 0;\n  let letterCount144 = 0;\n  let letterCount145 = 0;\n  let letterCount146 = 0;\n  let letterCount147 = 0;\n  let letterCount148 = 0;\n  let letterCount149 = 0;\n  let letterCount150 = 0;\n  let letterCount151 = 0;\n  let letterCount152 = 0;\n  let letterCount153 = 0;\n  let letterCount154 = 0;\n  let letterCount155 = 0;\n  let letterCount156 = 0;\n  let letterCount157 = 0;\n  let letterCount158 = 0;\n  let letterCount159 = 0;\n  let letterCount160 = 0;\n  let letterCount161 = 0;\n  let letterCount162 = 0;\n  let letterCount163 = 0;\n  let letterCount164 = 0;\n  let letterCount165 = 0;\n  let letterCount166 = 0;\n  let letterCount167 = 0;\n  let letterCount168 = 0;\n  let letterCount169 = 0;\n  let letterCount170 = 0;\n  let letterCount171 = 0;\n  let letterCount172 = 0;\n  let letterCount173 = 0;\n  let letterCount174 = 0;\n  let letterCount175 = 0;\n  let letterCount176 = 0;\n  let letterCount177 = 0;\n  let letterCount178 = 0;\n  let letterCount179 = 0;\n  let letterCount180 = 0;\n  let letterCount181 = 0;\n  let letterCount182 = 0;\n  let letterCount183 = 0;\n  let letterCount184 = 0;\n  let letterCount185 = 0;\n  let letterCount186 = 0;\n  let letterCount187 = 0;\n  let letterCount188 = 0;\n  let letterCount189 = 0;\n  let letterCount190 = 0;\n  let letterCount191 = 0;\n  let letterCount192 = 0;\n  let letterCount193 = 0;\n  let letterCount194 = 0;\n  let letterCount195 = 0;\n  let letterCount196 = 0;\n  let letterCount197 = 0;\n  let letterCount198 = 0;\n  let letterCount199 = 0;\n  let letterCount200 = 0;\n  let letterCount201 = 0;\n  let letterCount202 = 0;\n  let letterCount203 = 0;\n  let letterCount204 = 0;\n  let letterCount205 = 0;\n  let letterCount206 = 0;\n  let letterCount207 = 0;\n  let letterCount208 = 0;\n  let letterCount209 = 0;\n  let letterCount210 = 0;\n  let letterCount211 = 0;\n  let letterCount212 = 0;\n  let letterCount213 = 0;\n  let letterCount214 = 0;\n  let letterCount215 = 0;\n  let letterCount216 = 0;\n  let letterCount217 = 0;\n  let letterCount218 = 0;\n  let letterCount219 = 0;\n  let letterCount220 = 0;\n  let letterCount221 = 0;\n  let letterCount222 = 0;\n  let letterCount223 = 0;\n  let letterCount224 = 0;\n  let letterCount225 = 0;\n  let letterCount226 = 0;\n  let letterCount227 = 0;\n  let letterCount228 = 0;\n  let letterCount229 = 0;\n  let letterCount230 = 0;\n  let letterCount231 = 0;\n  let letterCount232 = 0;\n  let letterCount233 = 0;\n  let letterCount234 = 0;\n  let letterCount235 = 0;\n  let letterCount236 = 0;\n  let letterCount237 = 0;\n  let letterCount238 = 0;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/81", "prompt": "/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  nmueriaclLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst nmueriaclLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "nmueriaclLetterGrade", "gc": "<|endoftext|>/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  nmueriaclLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst nmueriaclLetterGrade = (grades) => {\n  let letterGrades = [];\n  let sum = 0;\n  let grade;\n  let i;\n  let j;\n  let k;\n  let l;\n  let gradesArray = [];\n  let gradesArrayLength = 0;\n  let gradesArrayIndex = 0;\n  let gradesArrayLengthIndex = 0;\n  let gradesArrayIndexLength = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;\n  let gradesArrayIndexLengthIndex = 0;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/82", "prompt": "/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "gc": "<|endoftext|>/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let prime = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (string.charAt(i) === string.charAt(length - i)) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 3 or false otherwise\n  Examples\n  divisibleBy3('Hello') == true\n  divisibleBy3('kittens') == true\n  divisibleBy3('orange') == false\n  */\nconst divisibleBy3 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (string.charAt(i) === string.charAt(length - i)) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 5 or false otherwise\n  Examples\n  divisibleBy5('Hello') == true\n  divisibleBy5('kittens') == true\n  divisibleBy5('orange') == false\n  */\nconst divisibleBy5 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (string.charAt(i) === string.charAt(length - i)) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 7 or false otherwise\n  Examples\n  divisibleBy7('Hello') == true\n  divisibleBy7('kittens') == true\n  divisibleBy7('orange') == false\n  */\nconst divisibleBy7 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (string.charAt(i) === string.charAt(length - i)) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 9 or false otherwise\n  Examples\n  divisibleBy9('Hello') == true\n  divisibleBy9('kittens') == true\n  divisibleBy9('orange') == false\n  */\nconst divisibleBy9 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (string.charAt(i) === string.charAt(length - i)) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 11 or false otherwise\n  Examples\n  divisibleBy11('Hello') == true\n  divisibleBy11('kittens') == true\n  divisibleBy11('orange') == false\n  */\nconst divisibleBy11 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (string.charAt(i) === string.charAt(length - i)) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 13 or false otherwise\n  Examples\n  divisibleBy13('Hello') == true\n  divisibleBy13('kittens') == true\n  divisibleBy13('orange') == false\n  */\nconst divisibleBy13 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (string.charAt(i) === string.charAt(length - i)) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 15 or false otherwise\n  Examples\n  divisibleBy15('Hello') == true\n  divisibleBy15('kittens') == true\n  divisibleBy15('orange') == false\n  */\nconst divisibleBy15 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (string.charAt(i) === string.charAt(length - i)) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 17 or false otherwise\n  Examples\n  divisibleBy17('Hello') == true\n  divisibleBy17('kittens') == true\n  divisibleBy17('orange') == false\n  */\nconst divisibleBy17 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (string.charAt(i) === string.charAt(length - i)) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 19 or false otherwise\n  Examples\n  divisibleBy19('Hello') == true\n  divisibleBy19('kittens') == true\n  divisibleBy19('orange') == false\n  */\nconst divisibleBy19 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (string.charAt(i) === string.charAt(length - i)) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 21 or false otherwise\n  Examples\n  divisibleBy21('Hello') == true\n  divisibleBy21('kittens') == true\n  divisibleBy21('orange') == false\n  */\nconst divisibleBy21 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (string.charAt(i) === string.charAt(length - i)) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 23 or false otherwise\n  Examples\n  divisibleBy23('Hello') == true\n  divisibleBy23('kittens') == true\n  divisibleBy23('orange') == false\n  */\nconst divisibleBy23 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (string.charAt(i) === string.charAt(length - i)) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 25 or false otherwise\n  Examples\n  divisibleBy25('Hello') == true\n  divisibleBy25('kittens') == true\n  divisibleBy25('orange') == false\n  */\nconst divisibleBy25 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = 2; i <= length; i++) {\n    if (string.charAt(i) === string.charAt(length - i)) {\n      divisible = false;\n      break;\n    }\n  }\n  return divisible;\n};\n\n/*Write a function that takes a string and returns true if the string\n  length is divisible by 27 or false otherwise\n  Examples\n  divisibleBy27('Hello') == true\n  divisibleBy27('kittens') == true\n  divisibleBy27('orange') == false\n  */\nconst divisibleBy27 = (string) => {\n  let divisible = true;\n  let length = string.length;\n  for (let i = ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "gc": "<|endoftext|>/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n  let count = 0;\n  let digit = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      digit += 1;\n    }\n    if (i === n) {\n      count += digit;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 1.\n  */\nconst endsOneStarts = (n) => {\n  let count = 0;\n  let digit = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      digit += 1;\n    }\n    if (i === n) {\n      count += digit;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 1.\n  */\nconst endsOneEnds = (n) => {\n  let count = 0;\n  let digit = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      digit += 1;\n    }\n    if (i === n) {\n      count += digit;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 1.\n  */\nconst startsOneStarts = (n) => {\n  let count = 0;\n  let digit = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      digit += 1;\n    }\n    if (i === n) {\n      count += digit;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 1.\n  */\nconst endsOneEnds = (n) => {\n  let count = 0;\n  let digit = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      digit += 1;\n    }\n    if (i === n) {\n      count += digit;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 1.\n  */\nconst startsOneStarts = (n) => {\n  let count = 0;\n  let digit = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      digit += 1;\n    }\n    if (i === n) {\n      count += digit;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 1.\n  */\nconst endsOneEnds = (n) => {\n  let count = 0;\n  let digit = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      digit += 1;\n    }\n    if (i === n) {\n      count += digit;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 1.\n  */\nconst startsOneStarts = (n) => {\n  let count = 0;\n  let digit = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      digit += 1;\n    }\n    if (i === n) {\n      count += digit;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 1.\n  */\nconst endsOneEnds = (n) => {\n  let count = 0;\n  let digit = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      digit += 1;\n    }\n    if (i === n) {\n      count += digit;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 1.\n  */\nconst startsOneStarts = (n) => {\n  let count = 0;\n  let digit = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      digit += 1;\n    }\n    if (i === n) {\n      count += digit;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 1.\n  */\nconst endsOneEnds = (n) => {\n  let count = 0;\n  let digit = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      digit += 1;\n    }\n    if (i === n) {\n      count += digit;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 1.\n  */\nconst startsOneStarts = (n) => {\n  let count = 0;\n  let digit = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      digit += 1;\n    }\n    if (i === n) {\n      count += digit;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 1.\n  */\nconst endsOneEnds = (n) => {\n  let count = 0;\n  let digit = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      digit += 1;\n    }\n    if (i === n) {\n      count += digit;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 1.\n  */\nconst startsOneStarts = (n) => {\n  let count = 0;\n  let digit = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      digit += 1;\n    }\n    if (i === n) {\n      count += digit;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 1.\n  */\nconst endsOneEnds = (n) => {\n  let count = 0;\n  let digit = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      digit += 1;\n    }\n    if (i === n) {\n      count += digit;\n    }\n    i += 1;\n    j += 1;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that do not start or end with 1.\n  */\nconst startsOneStarts = (n) => {\n  let count = 0;\n  let digit = 0;\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    if (n % 10 === 0) {\n      digit += 1;\n    }\n    if (i === n) {\n      count += digit;\n    }", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive integer N, return the total sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "gc": "<|endoftext|>/*Given a positive integer N, return the total sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = N; i > 0; i--) {\n    sum += parseInt(i.toString(2), 2);\n  }\n  return sum;\n};\n\n// A recursive solution\nconst recursiveSum = (num) => {\n  if (num === 0) {\n    return 1;\n  }\n  return num * recursiveSum(num - 1) + recursiveSum(num - 2);\n};\n\n// A iterative solution\nconst iterativeSum = (num) => {\n  let sum = 0;\n  for (let i = num; i > 0; i--) {\n    sum += parseInt(i.toString(2), 2);\n  }\n  return sum;\n};\n\n// A recursive solution\nconst recursiveSum2 = (num) => {\n  if (num === 0) {\n    return 1;\n  }\n  return recursiveSum2(num - 1) + recursiveSum2(num - 2);\n};\n\n// A iterative solution\nconst iterativeSum2 = (num) => {\n  let sum = 0;\n  for (let i = num; i > 0; i--) {\n    sum += parseInt(i.toString(2), 2);\n  }\n  return sum;\n};\n\n// A recursive solution\nconst recursiveSum3 = (num) => {\n  if (num === 0) {\n    return 1;\n  }\n  return recursiveSum3(num - 1) + recursiveSum3(num - 2) + recursiveSum3(num - 3);\n};\n\n// A iterative solution\nconst iterativeSum3 = (num) => {\n  let sum = 0;\n  for (let i = num; i > 0; i--) {\n    sum += parseInt(i.toString(2), 2);\n  }\n  return sum;\n};\n\n// A recursive solution\nconst recursiveSum4 = (num) => {\n  if (num === 0) {\n    return 1;\n  }\n  return recursiveSum4(num - 1) + recursiveSum4(num - 2) + recursiveSum4(num - 3) + recursiveSum4(num - 4);\n};\n\n// A iterative solution\nconst iterativeSum4 = (num) => {\n  let sum = 0;\n  for (let i = num; i > 0; i--) {\n    sum += parseInt(i.toString(2), 2);\n  }\n  return sum;\n};\n\n// A recursive solution\nconst recursiveSum5 = (num) => {\n  if (num === 0) {\n    return 1;\n  }\n  return recursiveSum5(num - 1) + recursiveSum5(num - 2) + recursiveSum5(num - 3) + recursiveSum5(num - 4) + recursiveSum5(num - 5);\n};\n\n// A iterative solution\nconst iterativeSum5 = (num) => {\n  let sum = 0;\n  for (let i = num; i > 0; i--) {\n    sum += parseInt(i.toString(2), 2);\n  }\n  return sum;\n};\n\n// A recursive solution\nconst recursiveSum6 = (num) => {\n  if (num === 0) {\n    return 1;\n  }\n  return recursiveSum6(num - 1) + recursiveSum6(num - 2) + recursiveSum6(num - 3) + recursiveSum6(num - 4) + recursiveSum6(num - 5) + recursiveSum6(num - 6);\n};\n\n// A iterative solution\nconst iterativeSum6 = (num) => {\n  let sum = 0;\n  for (let i = num; i > 0; i--) {\n    sum += parseInt(i.toString(2), 2);\n  }\n  return sum;\n};\n\n// A recursive solution\nconst recursiveSum7 = (num) => {\n  if (num === 0) {\n    return 1;\n  }\n  return recursiveSum7(num - 1) + recursiveSum7(num - 2) + recursiveSum7(num - 3) + recursiveSum7(num - 4) + recursiveSum7(num - 5) + recursiveSum7(num - 6) + recursiveSum7(num - 7);\n};\n\n// A iterative solution\nconst iterativeSum7 = (num) => {\n  let sum = 0;\n  for (let i = num; i > 0; i--) {\n    sum += parseInt(i.toString(2), 2);\n  }\n  return sum;\n};\n\n// A recursive solution\nconst recursiveSum8 = (num) => {\n  if (num === 0) {\n    return 1;\n  }\n  return recursiveSum8(num - 1) + recursiveSum8(num - 2) + recursiveSum8(num - 3) + recursiveSum8(num - 4) + recursiveSum8(num - 5) + recursiveSum8(num - 6) + recursiveSum8(num - 7) + recursiveSum8(num - 8);\n};\n\n// A iterative solution\nconst iterativeSum8 = (num) => {\n  let sum = 0;\n  for (let i = num; i > 0; i--) {\n    sum += parseInt(i.toString(2), 2);\n  }\n  return sum;\n};\n\n// A recursive solution\nconst recursiveSum9 = (num) => {\n  if (num === 0) {\n    return 1;\n  }\n  return recursiveSum9(num - 1) + recursiveSum9(num - 2) + recursiveSum9(num - 3) + recursiveSum9(num - 4) + recursiveSum9(num - 5) + recursiveSum9(num - 6) + recursiveSum9(num - 7) + recursiveSum9(num - 8) + recursiveSum9(num - 9);\n};\n\n// A iterative solution\nconst iterativeSum9 = (num) => {\n  let sum = 0;\n  for (let i = num; i > 0; i--) {\n    sum += parseInt(i.toString(2), 2);\n  }\n  return sum;\n};\n\n// A recursive solution\nconst recursiveSum10 = (num) => {\n  if (num === 0) {\n    return 1;\n  }\n  return recursiveSum10(num - 1) + recursiveSum10(num - 2) + recursiveSum10(num - 3) + recursiveSum10(num - 4) + recursiveSum10(num - 5) + recursiveSum10(num - 6) + recursiveSum10(num - 7) + recursiveSum10(num - 8) + recursiveSum10(num - 9) + recursiveSum10(num - 10);\n};\n\n// A iterative solution\nconst iterativeSum10 = (num) => {\n  let sum = 0;\n  for (let i = num; i > 0; i--) {\n    sum += parseInt(i.toString(2), 2);\n  }\n  return sum;\n};\n\n// A recursive solution\nconst recursiveSum11 = (num) => {\n  if (num === 0) {\n    return 1;\n  }\n  return recursiveSum11(num - 1) + recursiveSum11(num - 2) + recursiveSum11(num - 3) + recursiveSum11(num - 4) + recursiveSum11(num - 5) + recursiveSum11(num - 6) + recursiveSum11(num - 7) + recursiveSum11(num - 8) + recursiveSum11(num - 9) + recursiveSum11(num - 10) + recursiveSum11(num - 11);\n};\n\n// A iterative solution\nconst iterativeSum11 = (num) => {\n  let sum = 0;\n  for (let i = num; i > 0; i--) {\n    sum += parseInt(i.toString(2), 2);\n  }\n  return sum;\n};\n\n// A recursive solution\nconst recursiveSum12 = (num) => {\n  if (num === 0) {\n    return 1;\n  }\n  return recursiveSum12(num - 1) + recursiveSum12(num - 2) + recursiveSum12(num - 3) + recursiveSum12(num - 4) + recursiveSum12(num - 5) + recursiveSum12(num - 6) + recursiveSum12(num - 7) + recursiveSum12(num - 8) + recursiveSum12(num - 9) + recursiveSum12(num - 10) + recursiveSum12(num - 11) + recursiveSum12(num - 12);\n};\n\n// A iterative solution\nconst iterativeSum12 = (num) => {\n  let sum = 0;\n  for (let i = num; i > 0; i--) {\n    sum += parseInt(i.toString(2), 2);\n  }\n  return sum;\n};\n\n// A recursive solution\nconst recursiveSum13 = (num) => {\n  if (num === 0) {\n    return 1;\n  }", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "gc": "<|endoftext|>/*Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let even = []\n  let odd = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let sum = 0\n  while (i < lst.length) {\n    if (lst[i] % 2 === 0) {\n      even.push(lst[i])\n      i++\n    } else {\n      odd.push(lst[i])\n      i++\n    }\n  }\n  while (j < even.length) {\n    sum += even[j]\n    j++\n  }\n  while (k < odd.length) {\n    sum += odd[k]\n    k++\n  }\n  return sum\n}\n\n/*Given a non-empty list of integers lst. return the maximum element in the list..\n\n\n  Examples:\n      max([4, 2, 6, 7]) ==> 7\n  */\nconst max = (lst) => {\n  let max = 0\n  let i = 0\n  while (i < lst.length) {\n    if (lst[i] > max) {\n      max = lst[i]\n    }\n    i++\n  }\n  return max\n}\n\n/*Given a non-empty list of integers lst. return the minimum element in the list..\n\n\n  Examples:\n      min([4, 2, 6, 7]) ==> 4\n  */\nconst min = (lst) => {\n  let min = 0\n  let i = 0\n  while (i < lst.length) {\n    if (lst[i] < min) {\n      min = lst[i]\n    }\n    i++\n  }\n  return min\n}\n\n/*Given a non-empty list of integers lst. return the sum of all the elements in the list..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 10\n  */\nconst sum = (lst) => {\n  let sum = 0\n  let i = 0\n  while (i < lst.length) {\n    sum += lst[i]\n    i++\n  }\n  return sum\n}\n\n/*Given a non-empty list of integers lst. return the difference between the sum of the elements in the list..\n\n\n  Examples:\n      diff([4, 2, 6, 7]) ==> 2\n  */\nconst diff = (lst) => {\n  let diff = 0\n  let i = 0\n  while (i < lst.length) {\n    diff += lst[i] - lst[i + 1]\n    i++\n  }\n  return diff\n}\n\n/*Given a non-empty list of integers lst. return the product of the elements in the list..\n\n\n  Examples:\n      prod([4, 2, 6, 7]) ==> 24\n  */\nconst prod = (lst) => {\n  let prod = 1\n  let i = 0\n  while (i < lst.length) {\n    prod *= lst[i]\n    i++\n  }\n  return prod\n}\n\n/*Given a non-empty list of integers lst. return the product of the elements in the list except the even elements that are at odd indices..\n\n\n  Examples:\n      prodExceptEven([4, 2, 6, 7]) ==> 24\n  */\nconst prodExceptEven = (lst) => {\n  let prod = 1\n  let i = 0\n  while (i < lst.length) {\n    if (lst[i] % 2 === 0) {\n      prod *= lst[i]\n      i++\n    } else {\n      i++\n    }\n  }\n  return prod\n}\n\n/*Given a non-empty list of integers lst. return the product of the elements in the list except the even elements that are at even indices..\n\n\n  Examples:\n      prodExceptEven([4, 2, 6, 7]) ==> 24\n  */\nconst prodExceptOdd = (lst) => {\n  let prod = 1\n  let i = 0\n  while (i < lst.length) {\n    if (lst[i] % 2!== 0) {\n      prod *= lst[i]\n      i++\n    } else {\n      i++\n    }\n  }\n  return prod\n}\n\n/*Given a non-empty list of integers lst. return the product of the elements in the list except the odd elements that are at odd indices..\n\n\n  Examples:\n      prodExceptOdd([4, 2, 6, 7]) ==> 24\n  */\nconst prodExceptOddEven = (lst) => {\n  let prod = 1\n  let i = 0\n  while (i < lst.length) {\n    if (lst[i] % 2!== 0) {\n      prod *= lst[i]\n      i++\n    } else {\n      i++\n    }\n  }\n  return prod\n}\n\n/*Given a non-empty list of integers lst. return the product of the elements in the list except the odd elements that are at even indices..\n\n\n  Examples:\n      prodExceptOddEven([4, 2, 6, 7]) ==> 24\n  */\nconst prodExceptOddOddEven = (lst) => {\n  let prod = 1\n  let i = 0\n  while (i < lst.length) {\n    if (lst[i] % 2!== 0) {\n      prod *= lst[i]\n      i++\n    } else {\n      i++\n    }\n  }\n  return prod\n}\n\n/*Given a non-empty list of integers lst. return the product of the elements in the list except the even elements that are at odd indices..\n\n\n  Examples:\n      prodExceptOddOddEven([4, 2, 6, 7]) ==> 24\n  */\nconst prodExceptOddOddOddEven = (lst) => {\n  let prod = 1\n  let i = 0\n  while (i < lst.length) {\n    if (lst[i] % 2!== 0) {\n      prod *= lst[i]\n      i++\n    } else {\n      i++\n    }\n  }\n  return prod\n}\n\n/*Given a non-empty list of integers lst. return the product of the elements in the list except the odd elements that are at even indices..\n\n\n  Examples:\n      prodExceptOddOddOddEven([4, 2, 6, 7]) ==> 24\n  */\nconst prodExceptOddOddOddOddOddEven = (lst) => {\n  let prod = 1\n  let i = 0\n  while (i < lst.length) {\n    if (lst[i] % 2!== 0) {\n      prod *= lst[i]\n      i++\n    } else {\n      i++\n    }\n  }\n  return prod\n}\n\n/*Given a non-empty list of integers lst. return the product of the elements in the list except the odd elements that are at odd indices..\n\n\n  Examples:\n      prodExceptOddOddOddOddOddEven([4, 2, 6, 7]) ==> 24\n  */\nconst prodExceptOddOddOddOddOddOddOddEven = (lst) => {\n  let prod = 1\n  let i = 0\n  while (i < lst.length) {\n    if (lst[i] % 2!== 0) {\n      prod *= lst[i]\n      i++\n    } else {\n      i++\n    }\n  }\n  return prod\n}\n\n/*Given a non-empty list of integers lst. return the product of the elements in the list except the even elements that are at even indices..\n\n\n  Examples:\n      prodExceptOddOddOddOddOddOddOddEven([4, 2, 6, 7]) ==> 24\n  */\nconst prodExceptOddOddOddOddOddOddOddOddOddOddEven = (lst) => {\n  let prod = 1\n  let i = 0\n  while (i < lst.length) {\n    if (lst[i] % 2!== 0) {\n      prod *= lst[i]\n      i++\n    } else {\n      i++\n    }\n  }\n  return prod\n}\n\n/*Given a non-empty list of integers lst. return the product of the elements in the list except the odd elements that are at odd indices..\n\n\n  Examples:\n      prodExceptOddOddOddOddOddOddOddOddOddOddOddEven([4, 2, 6, 7]) ==> 24\n  */\nconst prodExceptOddOddOddOddOddOddOddOddOddOddOddOddOddOddEven = (lst) => {\n  let prod = 1\n  let i = 0\n  while (i < lst.length) {\n    if (lst[i] % 2!== 0) {\n      prod *= lst[i]\n      i++\n    } else {\n      i++\n    }\n  }\n  return prod\n}\n\n/*Given a non-empty list of integers lst. return the product ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antSihuffle('Hi') returns 'Hi'\n  antSihuffle('hello') returns 'ehllo'\n  antSihuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antSihuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antSihuffle", "gc": "<|endoftext|>/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antSihuffle('Hi') returns 'Hi'\n  antSihuffle('hello') returns 'ehllo'\n  antSihuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antSihuffle = (s) => {\n  let newString = '';\n  let word = '';\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let space = '';\n  let spaces = [];\n  let newWord = '';\n  let newWords = [];\n  let newWordsArr = [];\n  let newWordsArr2 = [];\n  let newWordsArr3 = [];\n  let newWordsArr4 = [];\n  let newWordsArr5 = [];\n  let newWordsArr6 = [];\n  let newWordsArr7 = [];\n  let newWordsArr8 = [];\n  let newWordsArr9 = [];\n  let newWordsArr10 = [];\n  let newWordsArr11 = [];\n  let newWordsArr12 = [];\n  let newWordsArr13 = [];\n  let newWordsArr14 = [];\n  let newWordsArr15 = [];\n  let newWordsArr16 = [];\n  let newWordsArr17 = [];\n  let newWordsArr18 = [];\n  let newWordsArr19 = [];\n  let newWordsArr20 = [];\n  let newWordsArr21 = [];\n  let newWordsArr22 = [];\n  let newWordsArr23 = [];\n  let newWordsArr24 = [];\n  let newWordsArr25 = [];\n  let newWordsArr26 = [];\n  let newWordsArr27 = [];\n  let newWordsArr28 = [];\n  let newWordsArr29 = [];\n  let newWordsArr30 = [];\n  let newWordsArr31 = [];\n  let newWordsArr32 = [];\n  let newWordsArr33 = [];\n  let newWordsArr34 = [];\n  let newWordsArr35 = [];\n  let newWordsArr36 = [];\n  let newWordsArr37 = [];\n  let newWordsArr38 = [];\n  let newWordsArr39 = [];\n  let newWordsArr40 = [];\n  let newWordsArr41 = [];\n  let newWordsArr42 = [];\n  let newWordsArr43 = [];\n  let newWordsArr44 = [];\n  let newWordsArr45 = [];\n  let newWordsArr46 = [];\n  let newWordsArr47 = [];\n  let newWordsArr48 = [];\n  let newWordsArr49 = [];\n  let newWordsArr50 = [];\n  let newWordsArr51 = [];\n  let newWordsArr52 = [];\n  let newWordsArr53 = [];\n  let newWordsArr54 = [];\n  let newWordsArr55 = [];\n  let newWordsArr56 = [];\n  let newWordsArr57 = [];\n  let newWordsArr58 = [];\n  let newWordsArr59 = [];\n  let newWordsArr60 = [];\n  let newWordsArr61 = [];\n  let newWordsArr62 = [];\n  let newWordsArr63 = [];\n  let newWordsArr64 = [];\n  let newWordsArr65 = [];\n  let newWordsArr66 = [];\n  let newWordsArr67 = [];\n  let newWordsArr68 = [];\n  let newWordsArr69 = [];\n  let newWordsArr70 = [];\n  let newWordsArr71 = [];\n  let newWordsArr72 = [];\n  let newWordsArr73 = [];\n  let newWordsArr74 = [];\n  let newWordsArr75 = [];\n  let newWordsArr76 = [];\n  let newWordsArr77 = [];\n  let newWordsArr78 = [];\n  let newWordsArr79 = [];\n  let newWordsArr80 = [];\n  let newWordsArr81 = [];\n  let newWordsArr82 = [];\n  let newWordsArr83 = [];\n  let newWordsArr84 = [];\n  let newWordsArr85 = [];\n  let newWordsArr86 = [];\n  let newWordsArr87 = [];\n  let newWordsArr88 = [];\n  let newWordsArr89 = [];\n  let newWordsArr90 = [];\n  let newWordsArr91 = [];\n  let newWordsArr92 = [];\n  let newWordsArr93 = [];\n  let newWordsArr94 = [];\n  let newWordsArr95 = [];\n  let newWordsArr96 = [];\n  let newWordsArr97 = [];\n  let newWordsArr98 = [];\n  let newWordsArr99 = [];\n  let newWordsArr100 = [];\n  let newWordsArr101 = [];\n  let newWordsArr102 = [];\n  let newWordsArr103 = [];\n  let newWordsArr104 = [];\n  let newWordsArr105 = [];\n  let newWordsArr106 = [];\n  let newWordsArr107 = [];\n  let newWordsArr108 = [];\n  let newWordsArr109 = [];\n  let newWordsArr110 = [];\n  let newWordsAr1111 = [];\n  let newWordsAr1112 = [];\n  let newWordsAr1113 = [];\n  let newWordsAr1114 = [];\n  let newWordsAr1115 = [];\n  let newWordsAr1116 = [];\n  let newWordsAr1117 = [];\n  let newWordsAr1118 = [];\n  let newWordsAr1119 = [];\n  let newWordsAr1120 = [];\n  let newWordsAr1121 = [];\n  let newWordsAr1122 = [];\n  let newWordsAr1123 = [];\n  let newWordsAr1124 = [];\n  let newWordsAr1125 = [];\n  let newWordsAr1126 = [];\n  let newWordsArr1127 = [];\n  let newWordsArr1128 = [];\n  let newWordsAr1129 = [];\n  let newWordsAr1130 = [];\n  let newWordsAr1131 = [];\n  let newWordsAr1132 = [];\n  let newWordsAr1133 = [];\n  let newWordsAr1134 = [];\n  let newWordsAr1135 = [];\n  let newWordsAr1136 = [];\n  let newWordsAr1137 = [];\n  let newWordsAr1138 = [];\n  let newWordsAr1139 = [];\n  let newWordsAr1140 = [];\n  let newWordsAr1141 = [];\n  let newWordsAr1142 = [];\n  let newWordsAr1143 = [];\n  let newWordsAr1144 = [];\n  let newWordsAr1145 = [];\n  let newWordsAr1146 = [];\n  let newWordsAr1147 = [];\n  let newWordsAr1148 = [];\n  let newWordsAr1149 = [];\n  let newWordsAr1150 = [];\n  let newWordsAr1151 = [];\n  let newWordsAr1152 = [];\n  let newWordsAr1153 = [];\n  let newWordsAr1154 = [];\n  let newWordsAr1155 = [];\n  let newWordsAr1156 = [];\n  let newWordsAr1157 = [];\n  let newWordsAr1158 = [];\n  let newWordsAr1159 = [];\n  let newWordsAr1160 = [];\n  let newWordsAr1161 = [];\n  let newWordsAr1162 = [];", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "gc": "<|endoftext|>/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  let row = []\n  let col = []\n  let rowIdx = 0\n  let colIdx = 0\n  let rowIdxMax = lst.length - 1\n  let colIdxMax = lst[0].length - 1\n  let rowIdxMin = 0\n  let colIdxMin = 0\n  let rowIdxMaxMin = rowIdxMax - rowIdxMin\n  let colIdxMaxMin = colIdxMax - colIdxMin\n  let rowIdxMaxMax = rowIdxMax + rowIdxMin\n  let colIdxMaxMax = colIdxMax + colIdxMin\n  let rowIdxMaxMinMax = rowIdxMaxMax - rowIdxMinMax\n  let colIdxMaxMinMax = colIdxMaxMax - colIdxMinMax\n  let rowIdxMinMax = rowIdxMin - rowIdxMaxMin\n  let colIdxMinMax = colIdxMin - colIdxMaxMin\n  let rowIdxMinMaxMax = rowIdxMinMax + rowIdxMinMax\n  let colIdxMinMaxMax = colIdxMinMax + colIdxMinMax\n  let rowIdxMaxMinMin = rowIdxMaxMin - rowIdxMinMin\n  let colIdxMaxMinMin = colIdxMaxMin - colIdxMinMin\n  let rowIdxMaxMinMax = rowIdxMaxMinMax + rowIdxMinMinMax\n  let colIdxMaxMinMax = colIdxMaxMinMax + colIdxMinMinMax\n  let rowIdxMaxMaxMin = rowIdxMaxMaxMin - rowIdxMinMaxMin\n  let colIdxMaxMaxMin = colIdxMaxMaxMin - colIdxMinMaxMin\n  let rowIdxMaxMaxMax = rowIdxMaxMaxMax + rowIdxMinMaxMax\n  let colIdxMaxMaxMax = colIdxMaxMaxMax + colIdxMinMaxMax\n  let rowIdxMaxMinMin = rowIdxMaxMinMin - rowIdxMinMin\n  let colIdxMaxMinMin = colIdxMaxMinMin - colIdxMinMin\n  let rowIdxMaxMinMax = rowIdxMaxMinMax + rowIdxMinMinMax\n  let colIdxMaxMinMax = colIdxMaxMinMax + colIdxMinMinMax\n  let rowIdxMaxMaxMin = rowIdxMaxMaxMin - rowIdxMinMaxMin\n  let colIdxMaxMaxMin = colIdxMaxMaxMin - colIdxMinMaxMin\n  let rowIdxMaxMaxMax = rowIdxMaxMaxMax + rowIdxMinMaxMax\n  let colIdxMaxMaxMax = colIdxMaxMaxMax + colIdxMinMaxMax\n  let rowIdxMaxMinMin = rowIdxMaxMinMin - rowIdxMinMin\n  let colIdxMaxMinMin = colIdxMaxMinMin - colIdxMinMin\n  let rowIdxMaxMinMax = rowIdxMaxMinMax + rowIdxMinMinMax\n  let colIdxMaxMinMax = colIdxMaxMinMax + colIdxMinMinMax\n  let rowIdxMaxMaxMin = rowIdxMaxMaxMin - rowIdxMinMaxMin\n  let colIdxMaxMaxMin = colIdxMaxMaxMin - colIdxMinMaxMin\n  let rowIdxMaxMaxMax = rowIdxMaxMaxMax + rowIdxMinMaxMax\n  let colIdxMaxMaxMax = colIdxMaxMaxMax + colIdxMinMaxMax\n  let rowIdxMaxMinMin = rowIdxMaxMinMin - rowIdxMinMin\n  let colIdxMaxMinMin = colIdxMaxMinMin - colIdxMinMin\n  let rowIdxMaxMinMax = rowIdxMaxMinMax + rowIdxMinMinMax\n  let colIdxMaxMinMax = colIdxMaxMinMax + colIdxMinMinMax\n  let rowIdxMaxMaxMin = rowIdxMaxMaxMin - rowIdxMinMaxMin\n  let colIdxMaxMaxMin = colIdxMaxMaxMin - colIdxMinMaxMin\n  let rowIdxMaxMaxMax = rowIdxMaxMaxMax + rowIdxMinMaxMax\n  let colIdxMaxMaxMax = colIdxMaxMaxMax + colIdxMinMaxMax\n  let rowIdxMaxMinMin = rowIdxMaxMinMin - rowIdxMinMin\n  let colIdxMaxMinMin = colIdxMaxMinMin - colIdxMinMin\n  let rowIdxMaxMinMax = rowIdxMaxMinMax + rowIdxMinMinMax\n  let colIdxMaxMinMax = colIdxMaxMinMax + colIdxMinMinMax\n  let rowIdxMaxMaxMin = rowIdxMaxMaxMin - rowIdxMinMaxMin\n  let colIdxMaxMaxMin = colIdxMaxMaxMin - colIdxMinMaxMin\n  let rowIdxMaxMaxMax = rowIdxMaxMaxMax + rowIdxMinMaxMax\n  let colIdxMaxMaxMax = colIdxMaxMaxMax + colIdxMinMaxMax\n  let rowIdxMaxMinMin = rowIdxMaxMinMin - rowIdxMinMin\n  let colIdxMaxMinMin = colIdxMaxMinMin - colIdxMinMin\n  let rowIdxMaxMinMax = rowIdxMaxMinMax + rowIdxMinMinMax\n  let colIdxMaxMinMax = colIdxMaxMinMax + colIdxMinMinMax\n  let rowIdxMaxMaxMin = rowIdxMaxMaxMin - rowIdxMinMaxMin\n  let colIdxMaxMaxMin = colIdxMaxMaxMin - colIdxMinMaxMin\n  let rowIdxMaxMaxMax = rowIdxMaxMaxMax + rowIdxMinMaxMax\n  let colIdxMaxMaxMax = colIdxMaxMaxMax + colIdxMinMaxMax\n  let rowIdxMaxMinMin = rowIdxMaxMinMin - rowIdxMinMin\n  let colIdxMaxMinMin = colIdxMaxMinMin - colIdxMinMin\n  let rowIdxMaxMinMax = rowIdxMaxMinMax + rowIdxMinMinMax\n  let colIdxMaxMinMax = colIdxMaxMinMax + colIdxMinMinMax\n  let rowIdxMaxMaxMin = rowIdxMaxMaxMin - rowIdxMinMaxMin\n  let colIdxMaxMaxMin = colIdxMaxMaxMin - colIdxMinMaxMin\n  let rowIdxMaxMaxMax = rowIdxMaxMaxMax + rowIdxMinMaxMax\n  let colIdxMaxMaxMax = colIdxMaxMaxMax + colIdxMinMaxMax\n  let rowIdxMaxMinMin = rowIdxMaxMinMin - rowIdxMinMin\n  let colIdxMaxMinMin = colIdxMaxMinMin - colIdxMinMin\n  let rowIdxMaxMinMax = rowIdxMaxMinMax + rowIdxMinMinMax\n  let colIdxMaxMinMax = colIdxMaxMinMax + colIdxMinMinMax\n  let rowIdxMaxMaxMin = rowIdxMaxMaxMin - rowIdxMinMaxMin\n  let colIdxMaxMaxMin = colIdxMaxMaxMin - colIdxMin", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n  or sort it in descending order if the sum( first index value, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "gc": "<|endoftext|>/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n  or sort it in descending order if the sum( first index value, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sortedArray = array.sort((a, b) => a - b);\n  return sortedArray;\n};\n\n/**\n * Given an array of non-negative integers, return an array of the same length\n * which contains the maximum element in the given array.\n * If the given array is empty return an empty array.\n * If the given array has more than one maximum element,\n * return an array with only one maximum element.\n * If the given array has more than one minimum element,\n * return an array with only one minimum element.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * If the given array has more than one element in the given array,\n * return an array with more than one element in the given array.\n * ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/89", "prompt": "/*Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "gc": "<|endoftext|>/*Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  let newStr = ''\n  let i = 0\n  let j = 0\n  let k = 0\n  let result = ''\n  \n  for(let i = 0; i < s.length; i++) {\n    for(let j = 0; j < alphabet.length; j++) {\n      if(alphabet[j] === s[i]) {\n        result += alphabet[j]\n      }\n    }\n  }\n  \n  for(let i = 0; i < s.length; i++) {\n    for(let j = 0; j < alphabet.length; j++) {\n      if(alphabet[j] === s[i]) {\n        result += alphabet[j] + alphabet[j + 1]\n      }\n    }\n  }\n  \n  for(let i = 0; i < s.length; i++) {\n    for(let j = 0; j < alphabet.length; j++) {\n      if(alphabet[j] === s[i]) {\n        result += alphabet[j] + alphabet[j + 1] + alphabet[j + 2]\n      }\n    }\n  }\n  \n  for(let i = 0; i < s.length; i++) {\n    for(let j = 0; j < alphabet.length; j++) {\n      if(alphabet[j] === s[i]) {\n        result += alphabet[j] + alphabet[j + 1] + alphabet[j + 2] + alphabet[j + 3]\n      }\n    }\n  }\n  \n  for(let i = 0; i < s.length; i++) {\n    for(let j = 0; j < alphabet.length; j++) {\n      if(alphabet[j] === s[i]) {\n        result += alphabet[j] + alphabet[j + 1] + alphabet[j + 2] + alphabet[j + 3] + alphabet[j + 4]\n      }\n    }\n  }\n  \n  for(let i = 0; i < s.length; i++) {\n    for(let j = 0; j < alphabet.length; j++) {\n      if(alphabet[j] === s[i]) {\n        result += alphabet[j] + alphabet[j + 1] + alphabet[j + 2] + alphabet[j + 3] + alphabet[j + 4] + alphabet[j + 5]\n      }\n    }\n  }\n  \n  for(let i = 0; i < s.length; i++) {\n    for(let j = 0; j < alphabet.length; j++) {\n      if(alphabet[j] === s[i]) {\n        result += alphabet[j] + alphabet[j + 1] + alphabet[j + 2] + alphabet[j + 3] + alphabet[j + 4] + alphabet[j + 5] + alphabet[j + 6]\n      }\n    }\n  }\n  \n  for(let i = 0; i < s.length; i++) {\n    for(let j = 0; j < alphabet.length; j++) {\n      if(alphabet[j] === s[i]) {\n        result += alphabet[j] + alphabet[j + 1] + alphabet[j + 2] + alphabet[j + 3] + alphabet[j + 4] + alphabet[j + 5] + alphabet[j + 6] + alphabet[j + 7]\n      }\n    }\n  }\n  \n  for(let i = 0; i < s.length; i++) {\n    for(let j = 0; j < alphabet.length; j++) {\n      if(alphabet[j] === s[i]) {\n        result += alphabet[j] + alphabet[j + 1] + alphabet[j + 2] + alphabet[j + 3] + alphabet[j + 4] + alphabet[j + 5] + alphabet[j + 6] + alphabet[j + 7] + alphabet[j + 8]\n      }\n    }\n  }\n  \n  for(let i = 0; i < s.length; i++) {\n    for(let j = 0; j < alphabet.length; j++) {\n      if(alphabet[j] === s[i]) {\n        result += alphabet[j] + alphabet[j + 1] + alphabet[j + 2] + alphabet[j + 3] + alphabet[j + 4] + alphabet[j + 5] + alphabet[j + 6] + alphabet[j + 7] + alphabet[j + 8] + alphabet[j + 9]\n      }\n    }\n  }\n  \n  for(let i = 0; i < s.length; i++) {\n    for(let j = 0; j < alphabet.length; j++) {\n      if(alphabet[j] === s[i]) {\n        result += alphabet[j] + alphabet[j + 1] + alphabet[j + 2] + alphabet[j + 3] + alphabet[j + 4] + alphabet[j + 5] + alphabet[j + 6] + alphabet[j + 7] + alphabet[j + 8] + alphabet[j + 9] + alphabet[j + 10]\n      }\n    }\n  }\n  \n  for(let i = 0; i < s.length; i++) {\n    for(let j = 0; j < alphabet.length; j++) {\n      if(alphabet[j] === s[i]) {\n        result += alphabet[j] + alphabet[j + 1] + alphabet[j + 2] + alphabet[j + 3] + alphabet[j + 4] + alphabet[j + 5] + alphabet[j + 6] + alphabet[j + 7] + alphabet[j + 8] + alphabet[j + 9] + alphabet[j + 10] + alphabet[j + 11]\n      }\n    }\n  }\n  \n  for(let i = 0; i < s.length; i++) {\n    for(let j = 0; j < alphabet.length; j++) {\n      if(alphabet[j] === s[i]) {\n        result += alphabet[j] + alphabet[j + 1] + alphabet[j + 2] + alphabet[j + 3] + alphabet[j + 4] + alphabet[j + 5] + alphabet[j + 6] + alphabet[j + 7] + alphabet[j + 8] + alphabet[j + 9] + alphabet[j + 10] + alphabet[j + 11] + alphabet[j + 12]\n      }\n    }\n  }\n  \n  for(let i = 0; i < s.length; i++) {\n    for(let j = 0; j < alphabet.length; j++) {\n      if(alphabet[j] === s[i]) {\n        result += alphabet[j] + alphabet[j + 1] + alphabet[j + 2] + alphabet[j + 3] + alphabet[j + 4] + alphabet[j + 5] + alphabet[j + 6] + alphabet[j + 7] + alphabet[j + 8] + alphabet[j + 9] + alphabet[j + 10] + alphabet[j + 11] + alphabet[j + 12] + alphabet[j + 13]\n      }\n    }\n  }\n  \n  for(let i = 0; i < s.length; i++) {\n    for(let j = 0; j < alphabet.length; j++) {\n      if(alphabet[j] === s[i]) {\n        result += alphabet[j] + alphabet[j + 1] + alphabet[j + 2] + alphabet[j + 3] + alphabet[j + 4] + alphabet[j + 5] + alphabet[j + 6] + alphabet[j + 7] + alphabet[j + 8] + alphabet[j + 9] + alphabet[j + 10] + alphabet[j + 11] + alphabet[j + 12] + alphabet[j + 13] + alphabet[j + 14]\n      }\n    }\n  }\n  \n  for(let i = 0; i < s.length; i++) {\n    for(let j = 0; j < alphabet.length; j++) {\n      if(alphabet[j] === s[i]) {\n        result += alphabet[j] + alphabet[j + 1] + alphabet[j + 2] + alphabet[j + 3] + alphabet[j + 4] + alphabet[j + 5] + alphabet[j + 6] + alphabet[j + 7] + alphabet[j + 8] + alphabet[j + 9] + alphabet[j + 10] + alphabet[j + 11] + alphabet[j + 12] + alphabet[j + 13] + alphabet[j + 14] + alphabet[j + 15]\n      }\n    }\n  }\n  \n  for(let i = 0; i < s.length; i++) {\n    for(let j = 0; j < alphabet.length; j++) {\n      if(alphabet[j] === s[i]) {\n        result += alphabet[j] + alphabet[j + 1] + alphabet[j + 2] + alphabet[j + 3] + alphabet[j + 4] + alphabet[j + 5] + alphabet[j + 6] + alphabet[j + 7] + alphabet[j + 8] + alphabet[j + 9] + alphabet[j + 10] + alphabet[j + 11] + alphabet[j + 12] + alphabet[j + 13] + alphabet[j + 14] + alphabet[j + 15] + alphabet[j + 16]\n      }\n    }\n  }\n  \n  for(let i = 0; i < s.length; i++) {\n    for(let j = 0; j < alphabet.length; j++) {\n      if(alphabet[j] === s[i]) {\n        result += alphabet[j] + alphabet[j + 1] + alphabet[j + 2] + alphabet[j + 3] + alphabet[j + 4] + alphabet[j + 5] + alphabet[j + 6] + alphabet[j + 7] + alphabet[j + 8] + alphabet[j + 9] + alphabet[j + 10] + alphabet[j + 11] + alphabet[j + 12] + alphabet[j + 13] + alphabet[j + 14] + alphabet[j + 15] + alphabet[j + 16] + alphabet[j + 17]\n      }\n    }\n  }\n  \n  for(let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/9", "prompt": "/* From a given list of integers, generate a list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "gc": "<|endoftext|>/* From a given list of integers, generate a list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const result = [];\n  let max = 0;\n  let current = 0;\n  let index = 0;\n  let maxIndex = 0;\n  while (index < numbers.length) {\n    const current = numbers[index];\n    if (current > max) {\n      max = current;\n      maxIndex = index;\n    }\n    index++;\n  }\n  result.push(max);\n  return result;\n};\n\n/* Given a list of integers, generate a list of rolling minimum element found until given moment\n  in the sequence.\n  >>> rollingMin([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 1, 3, 4, 2, 3]\n  */\nconst rollingMin = (numbers) => {\n  const result = [];\n  let min = 0;\n  let current = 0;\n  let index = 0;\n  let minIndex = 0;\n  while (index < numbers.length) {\n    const current = numbers[index];\n    if (current < min) {\n      min = current;\n      minIndex = index;\n    }\n    index++;\n  }\n  result.push(min);\n  return result;\n};\n\n/* Given a list of integers, generate a list of rolling sum element found until given moment\n  in the sequence.\n  >>> rollingSum([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst rollingSum = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let current = 0;\n  let index = 0;\n  let sumIndex = 0;\n  while (index < numbers.length) {\n    const current = numbers[index];\n    sum += current;\n    index++;\n  }\n  result.push(sum);\n  return result;\n};\n\n/* Given a list of integers, generate a list of rolling product element found until given moment\n  in the sequence.\n  >>> rollingProduct([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 6, 24, 120, 720, 5040]\n  */\nconst rollingProduct = (numbers) => {\n  const result = [];\n  let product = 1;\n  let current = 0;\n  let index = 0;\n  let productIndex = 0;\n  while (index < numbers.length) {\n    const current = numbers[index];\n    product *= current;\n    index++;\n  }\n  result.push(product);\n  return result;\n};\n\n/* Given a list of integers, generate a list of rolling sum element found until given moment\n  in the sequence.\n  >>> rollingSumOf([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst rollingSumOf = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let current = 0;\n  let index = 0;\n  let sumIndex = 0;\n  while (index < numbers.length) {\n    const current = numbers[index];\n    sum += current;\n    index++;\n  }\n  result.push(sum);\n  return result;\n};\n\n/* Given a list of integers, generate a list of rolling product element found until given moment\n  in the sequence.\n  >>> rollingProductOf([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 6, 24, 120, 720, 5040]\n  */\nconst rollingProductOf = (numbers) => {\n  const result = [];\n  let product = 1;\n  let current = 0;\n  let index = 0;\n  let productIndex = 0;\n  while (index < numbers.length) {\n    const current = numbers[index];\n    product *= current;\n    index++;\n  }\n  result.push(product);\n  return result;\n};\n\n/* Given a list of integers, generate a list of rolling sum element found until given moment\n  in the sequence.\n  >>> rollingSumOf([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst rollingSumOfOf = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let current = 0;\n  let index = 0;\n  let sumIndex = 0;\n  while (index < numbers.length) {\n    const current = numbers[index];\n    sum += current;\n    index++;\n  }\n  result.push(sum);\n  return result;\n};\n\n/* Given a list of integers, generate a list of rolling product element found until given moment\n  in the sequence.\n  >>> rollingProductOf([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 6, 24, 120, 720, 5040]\n  */\nconst rollingProductOfOf = (numbers) => {\n  const result = [];\n  let product = 1;\n  let current = 0;\n  let index = 0;\n  let productIndex = 0;\n  while (index < numbers.length) {\n    const current = numbers[index];\n    product *= current;\n    index++;\n  }\n  result.push(product);\n  return result;\n};\n\n/* Given a list of integers, generate a list of rolling sum element found until given moment\n  in the sequence.\n  >>> rollingSumOfOf([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst rollingSumOfOfOf = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let current = 0;\n  let index = 0;\n  let sumIndex = 0;\n  while (index < numbers.length) {\n    const current = numbers[index];\n    sum += current;\n    index++;\n  }\n  result.push(sum);\n  return result;\n};\n\n/* Given a list of integers, generate a list of rolling product element found until given moment\n  in the sequence.\n  >>> rollingProductOfOf([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 6, 24, 120, 720, 5040]\n  */\nconst rollingProductOfOf = (numbers) => {\n  const result = [];\n  let product = 1;\n  let current = 0;\n  let index = 0;\n  let productIndex = 0;\n  while (index < numbers.length) {\n    const current = numbers[index];\n    product *= current;\n    index++;\n  }\n  result.push(product);\n  return result;\n};\n\n/* Given a list of integers, generate a list of rolling sum element found until given moment\n  in the sequence.\n  >>> rollingSumOfOfOf([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst rollingSumOfOfOf = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let current = 0;\n  let index = 0;\n  let sumIndex = 0;\n  while (index < numbers.length) {\n    const current = numbers[index];\n    sum += current;\n    index++;\n  }\n  result.push(sum);\n  return result;\n};\n\n/* Given a list of integers, generate a list of rolling product element found until given moment\n  in the sequence.\n  >>> rollingProductOfOfOf([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 6, 24, 120, 720, 5040]\n  */\nconst rollingProductOfOfOf = (numbers) => {\n  const result = [];\n  let product = 1;\n  let current = 0;\n  let index = 0;\n  let productIndex = 0;\n  while (index < numbers.length) {\n    const current = numbers[index];\n    product *= current;\n    index++;\n  }\n  result.push(product);\n  return result;\n};\n\n/* Given a list of integers, generate a list of rolling sum element found until given moment\n  in the sequence.\n  >>> rollingSumOfOfOf([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 4, 5, 6, 7]\n  */\nconst rollingSumOfOfOf = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let current = 0;\n  let index = 0;\n  let sumIndex = 0;\n  while (index < numbers.length) {\n    const current = numbers[index];\n    sum += current;\n    index++;\n  }\n  result.push(sum);\n  return result;\n};\n\n/* Given a list of integers, generate a list of rolling product element found until given moment\n  in the sequence.\n  >>> rollingProductOfOfOf([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 6, 24, 120, 720, 5040]\n  */\nconst rollingProductOfOfOf = (numbers) => {\n  const result = [];\n  let product = 1;\n  let current = 0;\n  let index = 0;\n  let productIndex = 0;\n  while (index < numbers.length) {\n    const current = numbers[index];\n    product *= current;\n    index++;\n  }\n  result.push(product);\n  return result;\n};\n\n/* Given a list of integers, generate a list of rolling sum element found until given moment\n  in the sequence.\n  >>> rollingSumOfOfOf", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of integers.\n  Write a function nextSmallset() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallset([1, 2, 3, 4, 5]) == 2\n  nextSmallset([5, 1, 4, 3, 2]) == 2\n  nextSmallset([]) == null\n  nextSmallset([1, 1]) == null\n  */\nconst nextSmallset = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallset", "gc": "<|endoftext|>/*\n  You are given a list of integers.\n  Write a function nextSmallset() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallset([1, 2, 3, 4, 5]) == 2\n  nextSmallset([5, 1, 4, 3, 2]) == 2\n  nextSmallset([]) == null\n  nextSmallset([1, 1]) == null\n  */\nconst nextSmallset = (lst) => {\n  let min = null;\n  let minIndex = null;\n  let minVal = null;\n  let minIndexVal = null;\n  let minIndexVal2 = null;\n  let minIndexVal3 = null;\n  let minIndexVal4 = null;\n  let minIndexVal5 = null;\n  let minIndexVal6 = null;\n  let minIndexVal7 = null;\n  let minIndexVal8 = null;\n  let minIndexVal9 = null;\n  let minIndexVal10 = null;\n  let minIndexVal11 = null;\n  let minIndexVal12 = null;\n  let minIndexVal13 = null;\n  let minIndexVal14 = null;\n  let minIndexVal15 = null;\n  let minIndexVal16 = null;\n  let minIndexVal17 = null;\n  let minIndexVal18 = null;\n  let minIndexVal19 = null;\n  let minIndexVal20 = null;\n  let minIndexVal21 = null;\n  let minIndexVal22 = null;\n  let minIndexVal23 = null;\n  let minIndexVal24 = null;\n  let minIndexVal25 = null;\n  let minIndexVal26 = null;\n  let minIndexVal27 = null;\n  let minIndexVal28 = null;\n  let minIndexVal29 = null;\n  let minIndexVal30 = null;\n  let minIndexVal31 = null;\n  let minIndexVal32 = null;\n  let minIndexVal33 = null;\n  let minIndexVal34 = null;\n  let minIndexVal35 = null;\n  let minIndexVal36 = null;\n  let minIndexVal37 = null;\n  let minIndexVal38 = null;\n  let minIndexVal39 = null;\n  let minIndexVal40 = null;\n  let minIndexVal41 = null;\n  let minIndexVal42 = null;\n  let minIndexVal43 = null;\n  let minIndexVal44 = null;\n  let minIndexVal45 = null;\n  let minIndexVal46 = null;\n  let minIndexVal47 = null;\n  let minIndexVal48 = null;\n  let minIndexVal49 = null;\n  let minIndexVal50 = null;\n  let minIndexVal51 = null;\n  let minIndexVal52 = null;\n  let minIndexVal53 = null;\n  let minIndexVal54 = null;\n  let minIndexVal55 = null;\n  let minIndexVal56 = null;\n  let minIndexVal57 = null;\n  let minIndexVal58 = null;\n  let minIndexVal59 = null;\n  let minIndexVal60 = null;\n  let minIndexVal61 = null;\n  let minIndexVal62 = null;\n  let minIndexVal63 = null;\n  let minIndexVal64 = null;\n  let minIndexVal65 = null;\n  let minIndexVal66 = null;\n  let minIndexVal67 = null;\n  let minIndexVal68 = null;\n  let minIndexVal69 = null;\n  let minIndexVal70 = null;\n  let minIndexVal71 = null;\n  let minIndexVal72 = null;\n  let minIndexVal73 = null;\n  let minIndexVal74 = null;\n  let minIndexVal75 = null;\n  let minIndexVal76 = null;\n  let minIndexVal77 = null;\n  let minIndexVal78 = null;\n  let minIndexVal79 = null;\n  let minIndexVal80 = null;\n  let minIndexVal81 = null;\n  let minIndexVal82 = null;\n  let minIndexVal83 = null;\n  let minIndexVal84 = null;\n  let minIndexVal85 = null;\n  let minIndexVal86 = null;\n  let minIndexVal87 = null;\n  let minIndexVal88 = null;\n  let minIndexVal89 = null;\n  let minIndexVal90 = null;\n  let minIndexVal91 = null;\n  let minIndexVal92 = null;\n  let minIndexVal93 = null;\n  let minIndexVal94 = null;\n  let minIndexVal95 = null;\n  let minIndexVal96 = null;\n  let minIndexVal97 = null;\n  let minIndexVal98 = null;\n  let minIndexVal99 = null;\n  let minIndexVal100 = null;\n  let minIndexVal101 = null;\n  let minIndexVal102 = null;\n  let minIndexVal103 = null;\n  let minIndexVal104 = null;\n  let minIndexVal105 = null;\n  let minIndexVal106 = null;\n  let minIndexVal107 = null;\n  let minIndexVal108 = null;\n  let minIndexVal109 = null;\n  let minIndexVal110 = null;\n  let minIndexVal111 = null;\n  let minIndexVal112 = null;\n  let minIndexVal113 = null;\n  let minIndexVal114 = null;\n  let minIndexVal115 = null;\n  let minIndexVal116 = null;\n  let minIndexVal117 = null;\n  let minIndexVal118 = null;\n  let minIndexVal119 = null;\n  let minIndexVal120 = null;\n  let minIndexVal121 = null;\n  let minIndexVal122 = null;\n  let minIndexVal123 = null;\n  let minIndexVal124 = null;\n  let minIndexVal125 = null;\n  let minIndexVal126 = null;\n  let minIndexVal127 = null;\n  let minIndexVal128 = null;\n  let minIndexVal129 = null;\n  let minIndexVal130 = null;\n  let minIndexVal131 = null;\n  let minIndexVal132 = null;\n  let minIndexVal133 = null;\n  let minIndexVal134 = null;\n  let minIndexVal135 = null;\n  let minIndexVal136 = null;\n  let minIndexVal137 = null;\n  let minIndexVal138 = null;\n  let minIndexVal139 = null;\n  let minIndexVal140 = null;\n  let minIndexVal141 = null;\n  let minIndexVal142 = null;\n  let minIndexVal143 = null;\n  let minIndexVal144 = null;\n  let minIndexVal145 = null;\n  let minIndexVal146 = null;\n  let minIndexVal147 = null;\n  let minIndexVal148 = null;\n  let minIndexVal149 = null;\n  let minIndexVal150 = null;\n  let minIndexVal151 = null;\n  let minIndexVal152 = null;\n  let minIndexVal153 = null;\n  let minIndexVal154 = null;\n  let minIndexVal155 = null;\n  let minIndexVal156 = null;\n  let minIndexVal157 = null;\n  let minIndexVal158 = null;\n  let minIndexVal159 = null;\n  let minIndexVal160 = null;\n  let minIndexVal161 = null;\n  let minIndexVal162 = null;\n  let minIndexVal163 = null;\n  let minIndexVal164 = null;\n  let minIndexVal165 = null;\n  let minIndexVal166 = null;\n  let minIndexVal167 = null;\n  let minIndexVal168 = null;\n  let minIndexVal169 = null;\n  let minIndexVal170 = null;\n  let minIndexVal171 = null;\n  let minIndexVal172 = null;\n  let minIndexVal173 = null;\n  let minIndexVal174 = null;\n  let minIndexVal175 = null;\n  let minIndexVal176 = null;\n  let minIndexVal177 = null;\n  let minIndexVal178 = null;\n  let minIndexVal179 = null;\n  let minIndexVal180 = null;\n  let minIndexVal181 = null;\n  let minIndexVal182 = null;\n  let minIndexVal183 = null;\n  let minIndexVal184 = null;\n  let minIndexVal185 = null;\n  let minIndexVal186 = null;\n  let minIndexVal187 = null;\n  let minIndexVal188 = null;\n  let minIndexVal189 = null;\n  let minIndexVal190 = null;\n  let minIndexVal191 = null;\n  let minIndexVal192 = null;\n  let minIndexVal193 = null;\n  let minIndexVal194 = null;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBoerd(\"Hello world\")\n  0\n  >>> isBoerd(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBoerd = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBoerd", "gc": "<|endoftext|>/*\n  You'll be given a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBoerd(\"Hello world\")\n  0\n  >>> isBoerd(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBoerd = (S) => {\n  let boerd = 0;\n  let boerdWords = S.split('.');\n  let boerdWordsLength = boerdWords.length;\n  let boerdWordsIndex = 0;\n  let boerdWordsLengthIndex = 0;\n  let boerdWordsIndex2 = 0;\n  let boerdWordsLengthIndex2 = 0;\n  let boerdWordsIndex3 = 0;\n  let boerdWordsLengthIndex3 = 0;\n  let boerdWordsIndex4 = 0;\n  let boerdWordsLengthIndex4 = 0;\n  let boerdWordsIndex5 = 0;\n  let boerdWordsLengthIndex5 = 0;\n  let boerdWordsIndex6 = 0;\n  let boerdWordsLengthIndex6 = 0;\n  let boerdWordsIndex7 = 0;\n  let boerdWordsLengthIndex7 = 0;\n  let boerdWordsIndex8 = 0;\n  let boerdWordsLengthIndex8 = 0;\n  let boerdWordsIndex9 = 0;\n  let boerdWordsLengthIndex9 = 0;\n  let boerdWordsIndex10 = 0;\n  let boerdWordsLengthIndex10 = 0;\n  let boerdWordsIndex11 = 0;\n  let boerdWordsLengthIndex11 = 0;\n  let boerdWordsIndex12 = 0;\n  let boerdWordsLengthIndex12 = 0;\n  let boerdWordsIndex13 = 0;\n  let boerdWordsLengthIndex13 = 0;\n  let boerdWordsIndex14 = 0;\n  let boerdWordsLengthIndex14 = 0;\n  let boerdWordsIndex15 = 0;\n  let boerdWordsLengthIndex15 = 0;\n  let boerdWordsIndex16 = 0;\n  let boerdWordsLengthIndex16 = 0;\n  let boerdWordsIndex17 = 0;\n  let boerdWordsLengthIndex17 = 0;\n  let boerdWordsIndex18 = 0;\n  let boerdWordsLengthIndex18 = 0;\n  let boerdWordsIndex19 = 0;\n  let boerdWordsLengthIndex19 = 0;\n  let boerdWordsIndex20 = 0;\n  let boerdWordsLengthIndex20 = 0;\n  let boerdWordsIndex21 = 0;\n  let boerdWordsLengthIndex21 = 0;\n  let boerdWordsIndex22 = 0;\n  let boerdWordsLengthIndex22 = 0;\n  let boerdWordsIndex23 = 0;\n  let boerdWordsLengthIndex23 = 0;\n  let boerdWordsIndex24 = 0;\n  let boerdWordsLengthIndex24 = 0;\n  let boerdWordsIndex25 = 0;\n  let boerdWordsLengthIndex25 = 0;\n  let boerdWordsIndex26 = 0;\n  let boerdWordsLengthIndex26 = 0;\n  let boerdWordsIndex27 = 0;\n  let boerdWordsLengthIndex27 = 0;\n  let boerdWordsIndex28 = 0;\n  let boerdWordsLengthIndex28 = 0;\n  let boerdWordsIndex29 = 0;\n  let boerdWordsLengthIndex29 = 0;\n  let boerdWordsIndex30 = 0;\n  let boerdWordsLengthIndex30 = 0;\n  let boerdWordsIndex31 = 0;\n  let boerdWordsLengthIndex31 = 0;\n  let boerdWordsIndex32 = 0;\n  let boerdWordsLengthIndex32 = 0;\n  let boerdWordsIndex33 = 0;\n  let boerdWordsLengthIndex33 = 0;\n  let boerdWordsIndex34 = 0;\n  let boerdWordsLengthIndex34 = 0;\n  let boerdWordsIndex35 = 0;\n  let boerdWordsLengthIndex35 = 0;\n  let boerdWordsIndex36 = 0;\n  let boerdWordsLengthIndex36 = 0;\n  let boerdWordsIndex37 = 0;\n  let boerdWordsLengthIndex37 = 0;\n  let boerdWordsIndex38 = 0;\n  let boerdWordsLengthIndex38 = 0;\n  let boerdWordsIndex39 = 0;\n  let boerdWordsLengthIndex39 = 0;\n  let boerdWordsIndex40 = 0;\n  let boerdWordsLengthIndex40 = 0;\n  let boerdWordsIndex41 = 0;\n  let boerdWordsLengthIndex41 = 0;\n  let boerdWordsIndex42 = 0;\n  let boerdWordsLengthIndex42 = 0;\n  let boerdWordsIndex43 = 0;\n  let boerdWordsLengthIndex43 = 0;\n  let boerdWordsIndex44 = 0;\n  let boerdWordsLengthIndex44 = 0;\n  let boerdWordsIndex45 = 0;\n  let boerdWordsLengthIndex45 = 0;\n  let boerdWordsIndex46 = 0;\n  let boerdWordsLengthIndex46 = 0;\n  let boerdWordsIndex47 = 0;\n  let boerdWordsLengthIndex47 = 0;\n  let boerdWordsIndex48 = 0;\n  let boerdWordsLengthIndex48 = 0;\n  let boerdWordsIndex49 = 0;\n  let boerdWordsLengthIndex49 = 0;\n  let boerdWordsIndex50 = 0;\n  let boerdWordsLengthIndex50 = 0;\n  let boerdWordsIndex51 = 0;\n  let boerdWordsLengthIndex51 = 0;\n  let boerdWordsIndex52 = 0;\n  let boerdWordsLengthIndex52 = 0;\n  let boerdWordsIndex53 = 0;\n  let boerdWordsLengthIndex53 = 0;\n  let boerdWordsIndex54 = 0;\n  let boerdWordsLengthIndex54 = 0;\n  let boerdWordsIndex55 = 0;\n  let boerdWordsLengthIndex55 = 0;\n  let boerdWordsIndex56 = 0;\n  let boerdWordsLengthIndex56 = 0;\n  let boerdWordsIndex57 = 0;\n  let boerdWordsLengthIndex57 = 0;\n  let boerdWordsIndex58 = 0;\n  let boerdWordsLengthIndex58 = 0;\n  let boerdWordsIndex59 = 0;\n  let boerdWordsLengthIndex59 = 0;\n  let boerdWordsIndex60 = 0;\n  let boerdWordsLengthIndex60 = 0;\n  let boerdWordsIndex61 = 0;\n  let boerdWordsLengthIndex61 = 0;\n  let boerdWordsIndex62 = 0;\n  let boerdWordsLengthIndex62 = 0;\n  let boerdWordsIndex63 = 0;\n  let boerdWordsLengthIndex63 = 0;\n  let boerdWordsIndex64 = 0;\n  let boerdWordsLengthIndex64 = 0;\n  let boerdWordsIndex65 = 0;\n  let boerdWordsLengthIndex65 = 0;\n  let boerdWordsIndex66 = 0;\n  let boerdWordsLengthIndex66 = 0;\n  let boerdWordsIndex67 = 0;\n  let boerdWordsLengthIndex67 = 0;\n  let bo", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/92", "prompt": "/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "gc": "<|endoftext|>/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  if (x === y && x === z) return true\n  if (x === y || x === z || y === z) return false\n  return anyInt(y, x, z)\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyIntOrZero = (x, y, z) => {\n  if (x === y && x === z) return true\n  if (x === y || x === z || y === z) return false\n  return anyIntOrZero(y, x, z)\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyIntOrZero(5, 2, 7) ➞ true\n  anyIntOrZero(3, -2, 1) ➞ true\n  anyIntOrZero(3.6, -2.2, 2) ➞ false\n  */\nconst anyIntOrZeroOrZero = (x, y, z) => {\n  if (x === y && x === z) return true\n  if (x === y || x === z || y === z) return false\n  return anyIntOrZeroOrZero(y, x, z)\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyIntOrZeroOrZero(5, 2, 7) ➞ true\n  anyIntOrZeroOrZero(3, -2, 1) ➞ true\n  anyIntOrZeroOrZero(3.6, -2.2, 2) ➞ false\n  */\nconst anyIntOrZeroOrZeroOrZero = (x, y, z) => {\n  if (x === y && x === z) return true\n  if (x === y || x === z || y === z) return false\n  return anyIntOrZeroOrZeroOrZero(y, x, z)\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyIntOrZeroOrZeroOrZero(5, 2, 7) ➞ true\n  anyIntOrZeroOrZeroOrZero(3, -2, 1) ➞ true\n  anyIntOrZeroOrZeroOrZero(3.6, -2.2, 2) ➞ false\n  */\nconst anyIntOrZeroOrZeroOrZeroOrZero = (x, y, z) => {\n  if (x === y && x === z) return true\n  if (x === y || x === z || y === z) return false\n  return anyIntOrZeroOrZeroOrZeroOrZero(y, x, z)\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyIntOrZeroOrZeroOrZeroOrZero(5, 2, 7) ➞ true\n  anyIntOrZeroOrZeroOrZeroOrZeroOrZero(3, -2, 1) ➞ true\n  anyIntOrZeroOrZeroOrZeroOrZeroOrZero(3.6, -2.2, 2) ➞ false\n  */\nconst anyIntOrZeroOrZeroOrZeroOrZeroOrZero = (x, y, z) => {\n  if (x === y && x === z) return true\n  if (x === y || x === z || y === z) return false\n  return anyIntOrZeroOrZeroOrZeroOrZeroOrZero(y, x, z)\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyIntOrZeroOrZeroOrZeroOrZeroOrZero(5, 2, 7) ➞ true\n  anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(3, -2, 1) ➞ true\n  anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(3.6, -2.2, 2) ➞ false\n  */\nconst anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = (x, y, z) => {\n  if (x === y && x === z) return true\n  if (x === y || x === z || y === z) return false\n  return anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(y, x, z)\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(5, 2, 7) ➞ true\n  anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(3, -2, 1) ➞ true\n  anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(3.6, -2.2, 2) ➞ false\n  */\nconst anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = (x, y, z) => {\n  if (x === y && x === z) return true\n  if (x === y || x === z || y === z) return false\n  return anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(y, x, z)\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(5, 2, 7) ➞ true\n  anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(3, -2, 1) ➞ true\n  anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(3.6, -2.2, 2) ➞ false\n  */\nconst anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = (x, y, z) => {\n  if (x === y && x === z) return true\n  if (x === y || x === z || y === z) return false\n  return anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(y, x, z)\n}\n\n/* Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(5, 2, 7) ➞ true\n  anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(3, -2, 1) ➞ true\n  anyIntOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(3.6, -2.2, 2) ➞", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "gc": "<|endoftext|>/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let encoded = '';\n  let vowels = 'aeiouAEIOU';\n  let vowelsIndex = 0;\n  let messageIndex = 0;\n  let messageLength = message.length;\n  let messageLength = message.length;\n  \n  for(let i = 0; i < messageLength; i++) {\n    \n    for(let j = 0; j < messageLength; j++) {\n      \n      if(message[i] === message[j]) {\n        \n        encoded = encoded.concat(message[i]);\n        \n        for(let k = 0; k < vowels.length; k++) {\n          \n          if(message[i] === vowels[k]) {\n            \n            encoded = encoded.concat(vowels[k]);\n            \n            for(let l = 0; l < vowelsIndex; l++) {\n              \n              if(encoded.indexOf(vowelsIndex[l]) === 0) {\n                \n                encoded = encoded.slice(0, encoded.indexOf(vowelsIndex[l]));\n                \n                encoded = encoded.concat(vowelsIndex[l]);\n                \n                encoded = encoded.concat(encoded.slice(1));\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  return encoded;\n}\n\n/*\n  Write a function that takes a message, and decodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  \n  Examples:\n  >>> decode('TGST')\n  'test'\n  >>> decode('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst decode = (encoded) => {\n  let decoded = '';\n  let vowels = 'aeiouAEIOU';\n  let vowelsIndex = 0;\n  let messageIndex = 0;\n  let messageLength = encoded.length;\n  let messageLength = encoded.length;\n  \n  for(let i = 0; i < messageLength; i++) {\n    \n    for(let j = 0; j < messageLength; j++) {\n      \n      if(encoded.indexOf(message[i]) === 0) {\n        \n        decoded = decoded.concat(message[i]);\n        \n        for(let k = 0; k < vowels.length; k++) {\n          \n          if(encoded.indexOf(vowels[k]) === 0) {\n            \n            decoded = decoded.concat(vowels[k]);\n            \n            for(let l = 0; l < vowelsIndex; l++) {\n              \n              if(decoded.indexOf(vowelsIndex[l]) === 0) {\n                \n                decoded = decoded.slice(0, decoded.indexOf(vowelsIndex[l]));\n                \n                decoded = decoded.concat(vowelsIndex[l]);\n                \n                decoded = decoded.concat(decoded.slice(1));\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  return decoded;\n}\n\n/*\n  Write a function that takes a message, and decodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  \n  Examples:\n  >>> decode('TGST')\n  'test'\n  >>> decode('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst decodeAll = (encoded) => {\n  let decoded = '';\n  let vowels = 'aeiouAEIOU';\n  let vowelsIndex = 0;\n  let messageIndex = 0;\n  let messageLength = encoded.length;\n  let messageLength = encoded.length;\n  \n  for(let i = 0; i < messageLength; i++) {\n    \n    for(let j = 0; j < messageLength; j++) {\n      \n      if(encoded.indexOf(message[i]) === 0) {\n        \n        decoded = decoded.concat(message[i]);\n        \n        for(let k = 0; k < vowels.length; k++) {\n          \n          if(encoded.indexOf(vowels[k]) === 0) {\n            \n            decoded = decoded.concat(vowels[k]);\n            \n            for(let l = 0; l < vowelsIndex; l++) {\n              \n              if(decoded.indexOf(vowelsIndex[l]) === 0) {\n                \n                decoded = decoded.slice(0, decoded.indexOf(vowelsIndex[l]));\n                \n                decoded = decoded.concat(vowelsIndex[l]);\n                \n                decoded = decoded.concat(decoded.slice(1));\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  return decoded;\n}\n\n/*\n  Write a function that takes a message, and decodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  \n  Examples:\n  >>> decodeAll('TGST')\n  'test'\n  >>> decodeAll('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst decodeAllAll = (encoded) => {\n  let decoded = '';\n  let vowels = 'aeiouAEIOU';\n  let vowelsIndex = 0;\n  let messageIndex = 0;\n  let messageLength = encoded.length;\n  let messageLength = encoded.length;\n  \n  for(let i = 0; i < messageLength; i++) {\n    \n    for(let j = 0; j < messageLength; j++) {\n      \n      if(encoded.indexOf(message[i]) === 0) {\n        \n        decoded = decoded.concat(message[i]);\n        \n        for(let k = 0; k < vowels.length; k++) {\n          \n          if(encoded.indexOf(vowels[k]) === 0) {\n            \n            decoded = decoded.concat(vowels[k]);\n            \n            for(let l = 0; l < vowelsIndex; l++) {\n              \n              if(decoded.indexOf(vowelsIndex[l]) === 0) {\n                \n                decoded = decoded.slice(0, decoded.indexOf(vowelsIndex[l]));\n                \n                decoded = decoded.concat(vowelsIndex[l]);\n                \n                decoded = decoded.concat(decoded.slice(1));\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  return decoded;\n}\n\n/*\n  Write a function that takes a message, and decodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  \n  Examples:\n  >>> decodeAllAll('TGST')\n  'test'\n  >>> decodeAllAll('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst decodeAllAllAll = (encoded) => {\n  let decoded = '';\n  let vowels = 'aeiouAEIOU';\n  let vowelsIndex = 0;\n  let messageIndex = 0;\n  let messageLength = encoded.length;\n  let messageLength = encoded.length;\n  \n  for(let i = 0; i < messageLength; i++) {\n    \n    for(let j = 0; j < messageLength; j++) {\n      \n      if(encoded.indexOf(message[i]) === 0) {\n        \n        decoded = decoded.concat(message[i]);\n        \n        for(let k = 0; k < vowels.length; k++) {\n          \n          if(encoded.indexOf(vowels[k]) === 0) {\n            \n            decoded = decoded.concat(vowels[k]);\n            \n            for(let l = 0; l < vowelsIndex; l++) {\n              \n              if(decoded.indexOf(vowelsIndex[l]) === 0) {\n                \n                decoded = decoded.slice(0, decoded.indexOf(vowelsIndex[l]));\n                \n                decode", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/94", "prompt": "/*You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst ksjkasddk = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "ksjkasddk", "gc": "<|endoftext|>/*You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst ksjkasddk = (lst) => {\n  let sum = 0;\n  let max = 0;\n  let max2 = 1;\n  let max3 = 1;\n  let max4 = 1;\n  let max5 = 1;\n  let max6 = 1;\n  let max7 = 1;\n  let max8 = 1;\n  let max9 = 1;\n  let max10 = 1;\n  let max11 = 1;\n  let max12 = 1;\n  let max13 = 1;\n  let max14 = 1;\n  let max15 = 1;\n  let max16 = 1;\n  let max17 = 1;\n  let max18 = 1;\n  let max19 = 1;\n  let max20 = 1;\n  let max21 = 1;\n  let max22 = 1;\n  let max23 = 1;\n  let max24 = 1;\n  let max25 = 1;\n  let max26 = 1;\n  let max27 = 1;\n  let max28 = 1;\n  let max29 = 1;\n  let max30 = 1;\n  let max31 = 1;\n  let max32 = 1;\n  let max33 = 1;\n  let max34 = 1;\n  let max35 = 1;\n  let max36 = 1;\n  let max37 = 1;\n  let max38 = 1;\n  let max39 = 1;\n  let max40 = 1;\n  let max41 = 1;\n  let max42 = 1;\n  let max43 = 1;\n  let max44 = 1;\n  let max45 = 1;\n  let max46 = 1;\n  let max47 = 1;\n  let max48 = 1;\n  let max49 = 1;\n  let max50 = 1;\n  let max51 = 1;\n  let max52 = 1;\n  let max53 = 1;\n  let max54 = 1;\n  let max55 = 1;\n  let max56 = 1;\n  let max57 = 1;\n  let max58 = 1;\n  let max59 = 1;\n  let max60 = 1;\n  let max61 = 1;\n  let max62 = 1;\n  let max63 = 1;\n  let max64 = 1;\n  let max65 = 1;\n  let max66 = 1;\n  let max67 = 1;\n  let max68 = 1;\n  let max69 = 1;\n  let max70 = 1;\n  let max71 = 1;\n  let max72 = 1;\n  let max73 = 1;\n  let max74 = 1;\n  let max75 = 1;\n  let max76 = 1;\n  let max77 = 1;\n  let max78 = 1;\n  let max79 = 1;\n  let max80 = 1;\n  let max81 = 1;\n  let max82 = 1;\n  let max83 = 1;\n  let max84 = 1;\n  let max85 = 1;\n  let max86 = 1;\n  let max87 = 1;\n  let max88 = 1;\n  let max89 = 1;\n  let max91 = 1;\n  let max92 = 1;\n  let max93 = 1;\n  let max94 = 1;\n  let max95 = 1;\n  let max96 = 1;\n  let max97 = 1;\n  let max98 = 1;\n  let max99 = 1;\n  let max100 = 1;\n  let max101 = 1;\n  let max102 = 1;\n  let max103 = 1;\n  let max104 = 1;\n  let max105 = 1;\n  let max106 = 1;\n  let max107 = 1;\n  let max108 = 1;\n  let max109 = 1;\n  let max110 = 1;\n  let max111 = 1;\n  let max112 = 1;\n  let max113 = 1;\n  let max114 = 1;\n  let max115 = 1;\n  let max116 = 1;\n  let max117 = 1;\n  let max118 = 1;\n  let max119 = 1;\n  let max120 = 1;\n  let max121 = 1;\n  let max122 = 1;\n  let max123 = 1;\n  let max124 = 1;\n  let max125 = 1;\n  let max126 = 1;\n  let max127 = 1;\n  let max128 = 1;\n  let max129 = 1;\n  let max131 = 1;\n  let max132 = 1;\n  let max133 = 1;\n  let max134 = 1;\n  let max135 = 1;\n  let max136 = 1;\n  let max137 = 1;\n  let max138 = 1;\n  let max139 = 1;\n  let max140 = 1;\n  let max141 = 1;\n  let max142 = 1;\n  let max143 = 1;\n  let max144 = 1;\n  let max145 = 1;\n  let max146 = 1;\n  let max147 = 1;\n  let max148 = 1;\n  let max149 = 1;\n  let max150 = 1;\n  let max151 = 1;\n  let max152 = 1;\n  let max153 = 1;\n  let max154 = 1;\n  let max155 = 1;\n  let max156 = 1;\n  let max157 = 1;\n  let max158 = 1;\n  let max159 = 1;\n  let max160 = 1;\n  let max161 = 1;\n  let max162 = 1;\n  let max163 = 1;\n  let max164 = 1;\n  let max165 = 1;\n  let max166 = 1;\n  let max167 = 1;\n  let max168 = 1;\n  let max169 = 1;\n  let max170 = 1;\n  let max171 = 1;\n  let max172 = 1;\n  let max173 = 1;\n  let max174 = 1;\n  let max175 = 1;\n  let max176 = 1;\n  let max177 = 1;\n  let max178 = 1;\n  let max179 = 1;\n  let max180 = 1;\n  let max181 = 1;\n  let max182 = 1;\n  let max183 = 1;\n  let max184 = 1;\n  let max185 = 1;\n  let max186 = 1;\n  let max187 = 1;\n  let max188 = 1;\n  let max189 = 1;\n  let max190 = 1;\n  let max191 = 1;\n  let max192 = 1;\n  let max193 = 1;\n  let max194 = 1;\n  let max195 = 1;\n  let max196 = 1;\n  let max197 = 1;\n  let max198 = 1;\n  let max199 = 1;\n  let max200 = 1;\n  let max201 = 1;\n  let max202 = 1;\n  let max203 = 1;\n  let max204 = 1;\n  let max205 = 1;\n  let max206 = 1;\n  let max207 = 1;\n  let max208 = 1;\n  let max209 = 1;\n  let max210 = 1;\n  let max211 = 1;\n  let max212 = 1;\n  let max213 = 1;\n  let max214 = 1;\n  let max215 = 1;\n  let max216 = 1;\n  let max217 = 1;\n  let max218 = 1;\n  let max219 = 1;\n  let max220 = 1;\n  let max221 = 1;\n  let max222 = 1;\n  let max223 = 1;\n  let max224 = 1;\n  let max225 = 1;\n  let max226 = 1;\n  let max227 = 1;\n  let max228 = 1;\n  let max229 = 1;\n  let max230 = 1;\n  let max231 = 1;\n  let max232 = 1;\n  let max233 = 1;\n  let max234 = 1;\n  let max235 = 1;\n  let max236 = 1;\n  let max237 = 1;\n  let max238 = 1;\n  let max239 = 1;\n  let max240 = 1;\n  let max241 = 1;\n  let max242 = 1;\n  let max243 = 1;\n  let max244 = 1;\n  let max245 = 1;\n  let max246 = 1;\n  let max247 = 1;\n  let max248 = 1;\n  let max249 = 1;\n  let max250 = 1;\n  let max251 = 1;\n  let max252 = 1;\n  let max253 = 1;\n  let max254 = 1;\n  let max255 = 1;\n  let max256 = 1;\n  let max257 = 1;\n  let max258 = 1;\n  let max259 = 1;\n  let max260 = 1;\n  let max261 = 1;\n  let max262 = 1;\n  let max263 = 1;\n  let max264 = 1;\n  let max265 = 1;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "gc": "<|endoftext|>/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  const keys = Object.keys(dict);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const value = dict[key];\n    if (typeof value ==='string') {\n      if (value.toLowerCase() === key.toLowerCase()) {\n        return true;\n      }\n      if (value.toUpperCase() === key.toUpperCase()) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/*\n  Given a string, return true if all characters are digits, else return false.\n  The function should return false is the given string contains any non-digit characters.\n  Examples:\n  checkStringDigits(\"123\") should return true.\n  checkStringDigits(\"abc\") should return false.\n  checkStringDigits(\"a\") should return false.\n  checkStringDigits(\"a123\") should return false.\n  checkStringDigits(\"a123abc\") should return false.\n  checkStringDigits(\"a123abc123\") should return false.\n  checkStringDigits(\"a123abc123def\") should return false.\n  checkStringDigits(\"a123abc123def456\") should return false.\n  checkStringDigits(\"a123abc123def456def\") should return false.\n  checkStringDigits(\"a123abc123def456def456def\") should return false.\n  checkStringDigits(\"a123abc123def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456def456", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function that takes an non-negative integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "gc": "<|endoftext|>/*Implement a function that takes an non-negative integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpToPrime = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpToPrimeAndLessThan = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpToPrimeAndLessThanOrEqual = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpToPrimeAndGreaterThan = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpToPrimeAndGreaterThanOrEqual = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpToPrimeAndLessThan = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpToPrimeAndLessThanOrEqual = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpToPrimeAndGreaterThan = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpToPrimeAndGreaterThanOrEqual = (n) => {\n  let primes = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n  }\n  return primes;\n};\n\n/*Implement a function that takes an integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst count", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function that takes two integers and returns \n  the product of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "gc": "<|endoftext|>/*Complete the function that takes two integers and returns \n  the product of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let product = 1;\n  let digit;\n  while (b) {\n    digit = a % 10;\n    product *= digit;\n    a = Math.floor(a / 10);\n  }\n  return product;\n};\n\n/*Complete the function that takes two integers and returns \n  the sum of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  sum(148, 412) should return 148.\n  sum(19, 28) should return 280.\n  sum(2020, 1851) should return 1851.\n  sum(14,-15) should return 140.\n  */\nconst sum = (a, b) => {\n  let sum = 0;\n  let digit;\n  while (b) {\n    digit = a % 10;\n    sum += digit;\n    a = Math.floor(a / 10);\n  }\n  return sum;\n};\n\n/*Complete the function that takes two integers and returns \n  the difference between their unit digits.\n  Assume the input is always valid.\n  Examples:\n  difference(148, 412) should return -412.\n  difference(19, 28) should return -28.\n  difference(2020, 1851) should return 1851.\n  difference(14,-15) should return 14.\n  */\nconst difference = (a, b) => {\n  let difference = 0;\n  let digit;\n  while (b) {\n    digit = a % 10;\n    difference += digit;\n    a = Math.floor(a / 10);\n  }\n  return difference;\n};\n\n/*Complete the function that takes two integers and returns \n  the absolute value of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  abs(148, 412) should return 148.\n  abs(19, 28) should return 28.\n  abs(2020, 1851) should return 1851.\n  abs(14,-15) should return 14.\n  */\nconst abs = (a) => {\n  let absolute = 0;\n  let digit;\n  while (a) {\n    digit = a % 10;\n    absolute += digit;\n    a = Math.floor(a / 10);\n  }\n  return absolute;\n};\n\n/*Complete the function that takes two integers and returns \n  the absolute value of the sum of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  absSum(148, 412) should return 148.\n  absSum(19, 28) should return 28.\n  absSum(2020, 1851) should return 1851.\n  absSum(14,-15) should return 14.\n  */\nconst absSum = (a) => {\n  let absoluteSum = 0;\n  let digit;\n  while (a) {\n    digit = a % 10;\n    absoluteSum += digit;\n    a = Math.floor(a / 10);\n  }\n  return absoluteSum;\n};\n\n/*Complete the function that takes two integers and returns \n  the absolute value of the difference between their unit digits.\n  Assume the input is always valid.\n  Examples:\n  absDiff(148, 412) should return -412.\n  absDiff(19, 28) should return -28.\n  absDiff(2020, 1851) should return 1851.\n  absDiff(14,-15) should return 14.\n  */\nconst absDiff = (a) => {\n  let absoluteDiff = 0;\n  let digit;\n  while (a) {\n    digit = a % 10;\n    absoluteDiff += digit;\n    a = Math.floor(a / 10);\n  }\n  return absoluteDiff;\n};\n\n/*Complete the function that takes two integers and returns \n  the absolute value of the difference between their unit digits.\n  Assume the input is always valid.\n  Examples:\n  absDiff(148, 412) should return -412.\n  absDiff(19, 28) should return -28.\n  absDiff(2020, 1851) should return 1851.\n  absDiff(14,-15) should return 14.\n  */\nconst absDiff = (a) => {\n  let absoluteDiff = 0;\n  let digit;\n  while (a) {\n    digit = a % 10;\n    absoluteDiff += digit;\n    a = Math.floor(a / 10);\n  }\n  return absoluteDiff;\n};\n\n/*Complete the function that takes two integers and returns \n  the absolute value of the difference between their unit digits.\n  Assume the input is always valid.\n  Examples:\n  absDiff(148, 412) should return -412.\n  absDiff(19, 28) should return -28.\n  absDiff(2020, 1851) should return 1851.\n  absDiff(14,-15) should return 14.\n  */\nconst absDiff = (a) => {\n  let absoluteDiff = 0;\n  let digit;\n  while (a) {\n    digit = a % 10;\n    absoluteDiff += digit;\n    a = Math.floor(a / 10);\n  }\n  return absoluteDiff;\n};\n\n/*Complete the function that takes two integers and returns \n  the absolute value of the difference between their unit digits.\n  Assume the input is always valid.\n  Examples:\n  absDiff(148, 412) should return -412.\n  absDiff(19, 28) should return -28.\n  absDiff(2020, 1851) should return 1851.\n  absDiff(14,-15) should return 14.\n  */\nconst absDiff = (a) => {\n  let absoluteDiff = 0;\n  let digit;\n  while (a) {\n    digit = a % 10;\n    absoluteDiff += digit;\n    a = Math.floor(a / 10);\n  }\n  return absoluteDiff;\n};\n\n/*Complete the function that takes two integers and returns \n  the absolute value of the difference between their unit digits.\n  Assume the input is always valid.\n  Examples:\n  absDiff(148, 412) should return -412.\n  absDiff(19, 28) should return -28.\n  absDiff(2020, 1851) should return 1851.\n  absDiff(14,-15) should return 14.\n  */\nconst absDiff = (a) => {\n  let absoluteDiff = 0;\n  let digit;\n  while (a) {\n    digit = a % 10;\n    absoluteDiff += digit;\n    a = Math.floor(a / 10);\n  }\n  return absoluteDiff;\n};\n\n/*Complete the function that takes two integers and returns \n  the absolute value of the difference between their unit digits.\n  Assume the input is always valid.\n  Examples:\n  absDiff(148, 412) should return -412.\n  absDiff(19, 28) should return -28.\n  absDiff(2020, 1851) should return 1851.\n  absDiff(14,-15) should return 14.\n  */\nconst absDiff = (a) => {\n  let absoluteDiff = 0;\n  let digit;\n  while (a) {\n    digit = a % 10;\n    absoluteDiff += digit;\n    a = Math.floor(a / 10);\n  }\n  return absoluteDiff;\n};\n\n/*Complete the function that takes two integers and returns \n  the absolute value of the difference between their unit digits.\n  Assume the input is always valid.\n  Examples:\n  absDiff(148, 412) should return -412.\n  absDiff(19, 28) should return -28.\n  absDiff(2020, 1851) should return 1851.\n  absDiff(14,-15) should return 14.\n  */\nconst absDiff = (a) => {\n  let absoluteDiff = 0;\n  let digit;\n  while (a) {\n    digit = a % 10;\n    absoluteDiff += digit;\n    a = Math.floor(a / 10);\n  }\n  return absoluteDiff;\n};\n\n", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 3, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "gc": "<|endoftext|>/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let upper = 0;\n  \n  for(let i = 0; i < s.length; i++){\n    if(s[i] >= 'a' && s[i] <= 'z'){\n      upper++;\n    }\n  }\n  \n  for(let j = 0; j < s.length; j++){\n    if(s[j] >= 'A' && s[j] <= 'Z'){\n      upper++;\n    }\n  }\n  \n  for(let k = 0; k < upper; k++){\n    if(s[k] >= 'a' && s[k] <= 'z'){\n      count++;\n    }\n  }\n  \n  return count;\n}\n\n/*\n  Given a string s, count the number of lowercase vowels in even indices.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let lower = 0;\n  \n  for(let i = 0; i < s.length; i++){\n    if(s[i] >= 'a' && s[i] <= 'z'){\n      lower++;\n    }\n  }\n  \n  for(let j = 0; j < s.length; j++){\n    if(s[j] >= 'A' && s[j] <= 'Z'){\n      lower++;\n    }\n  }\n  \n  for(let k = 0; k < lower; k++){\n    if(s[k] >= 'a' && s[k] <= 'z'){\n      count++;\n    }\n  }\n  \n  return count;\n}\n\n/*\n  Given a string s, count the number of vowels in even indices.\n  \n  For example:\n  countVowels('aBCdEf') returns 1\n  countVowels('abcdefg') returns 0\n  countVowels('dBBE') returns 0\n  */\nconst countVowels = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let vowel = 0;\n  \n  for(let i = 0; i < s.length; i++){\n    if(s[i] >= 'a' && s[i] <= 'z'){\n      vowel++;\n    }\n  }\n  \n  for(let j = 0; j < s.length; j++){\n    if(s[j] >= 'A' && s[j] <= 'Z'){\n      vowel++;\n    }\n  }\n  \n  for(let k = 0; k < vowel; k++){\n    if(s[k] >= 'a' && s[k] <= 'z'){\n      count++;\n    }\n  }\n  \n  return count;\n}\n\n/*\n  Given a string s, count the number of vowels in odd indices.\n  \n  For example:\n  countVowelsOdd('aBCdEf') returns 1\n  countVowelsOdd('abcdefg') returns 0\n  countVowelsOdd('dBBE') returns 0\n  */\nconst countVowelsOdd = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let vowel = 0;\n  \n  for(let i = 0; i < s.length; i++){\n    if(s[i] >= 'a' && s[i] <= 'z'){\n      vowel++;\n    }\n  }\n  \n  for(let j = 0; j < s.length; j++){\n    if(s[j] >= 'A' && s[j] <= 'Z'){\n      vowel++;\n    }\n  }\n  \n  for(let k = 0; k < vowel; k++){\n    if(s[k] >= 'a' && s[k] <= 'z'){\n      count++;\n    }\n  }\n  \n  return count;\n}\n\n/*\n  Given a string s, count the number of uppercase vowels in odd indices.\n  \n  For example:\n  countVowelsOdd('aBCdEf') returns 1\n  countVowelsOdd('abcdefg') returns 0\n  countVowelsOdd('dBBE') returns 0\n  */\nconst countVowelsOddOdd = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let vowel = 0;\n  \n  for(let i = 0; i < s.length; i++){\n    if(s[i] >= 'a' && s[i] <= 'z'){\n      vowel++;\n    }\n  }\n  \n  for(let j = 0; j < s.length; j++){\n    if(s[j] >= 'A' && s[j] <= 'Z'){\n      vowel++;\n    }\n  }\n  \n  for(let k = 0; k < vowel; k++){\n    if(s[k] >= 'a' && s[k] <= 'z'){\n      count++;\n    }\n  }\n  \n  return count;\n}\n\n/*\n  Given a string s, count the number of lowercase vowels in odd indices.\n  \n  For example:\n  countVowelsOdd('aBCdEf') returns 1\n  countVowelsOdd('abcdefg') returns 0\n  countVowelsOdd('dBBE') returns 0\n  */\nconst countVowelsOddOddOdd = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let vowel = 0;\n  \n  for(let i = 0; i < s.length; i++){\n    if(s[i] >= 'a' && s[i] <= 'z'){\n      vowel++;\n    }\n  }\n  \n  for(let j = 0; j < s.length; j++){\n    if(s[j] >= 'A' && s[j] <= 'Z'){\n      vowel++;\n    }\n  }\n  \n  for(let k = 0; k < vowel; k++){\n    if(s[k] >= 'a' && s[k] <= 'z'){\n      count++;\n    }\n  }\n  \n  return count;\n}\n\n/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  countVowelsEven('aBCdEf') returns 1\n  countVowelsEven('abcdefg') returns 0\n  countVowelsEven('dBBE') returns 0\n  */\nconst countVowelsEven = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let vowel = 0;\n  \n  for(let i = 0; i < s.length; i++){\n    if(s[i] >= 'a' && s[i] <= 'z'){\n      vowel++;\n    }\n  }\n  \n  for(let j = 0; j < s.length; j++){\n    if(s[j] >= 'A' && s[j] <= 'Z'){\n      vowel++;\n    }\n  }\n  \n  for(let k = 0; k < vowel; k++){\n    if(s[k] >= 'a' && s[k] <= 'z'){\n      count++;\n    }\n  }\n  \n  return count;\n}\n\n/*\n  Given a string s, count the number of lowercase vowels in even indices.\n  \n  For example:\n  countVowelsEven('aBCdEf') returns 1\n  countVowelsEven('abcdefg') returns 0\n  countVowelsEven('dBBE') returns 0\n  */\nconst countVowelsEvenOdd = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let vowel = 0;\n  \n  for(let i = 0; i < s.length; i++){\n    if(s[i] >= 'a' && s[i] <= 'z'){\n      vowel++;\n    }\n  }\n  \n  for(let j = 0; j < s.length; j++){\n    if(s[j] >= 'A' && s[j] <= 'Z'){\n      vowel", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/99", "prompt": "/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closestInetger(\"10\")\n  10\n  >>> closestInetger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInetger(\"14.5\") should\n  return 15 and closestInetger(\"-14.5\") should return -15.\n  */\nconst closestInetger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInetger", "gc": "<|endoftext|>/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closestInetger(\"10\")\n  10\n  >>> closestInetger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInetger(\"14.5\") should\n  return 15 and closestInetger(\"-14.5\") should return -15.\n  */\nconst closestInetger = (value) => {\n  const numbers = value.split(\".\");\n  let result = numbers[0];\n  let diff = Math.abs(numbers[0] - numbers[1]);\n  let i = 0;\n  let j = 1;\n  while (diff > 0.00001) {\n    diff = diff / Math.abs(numbers[i++] - numbers[j++]);\n  }\n  return numbers[i++] + \".\" + numbers[j++];\n};\n\n/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closestInetger(\"10\")\n  10\n  >>> closestInetger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInetger(\"14.5\") should\n  return 15 and closestInetger(\"-14.5\") should return -15.\n  */\nconst closestInetger2 = (value) => {\n  const numbers = value.split(\".\");\n  let result = numbers[0];\n  let diff = Math.abs(numbers[0] - numbers[1]);\n  let i = 0;\n  let j = 1;\n  while (diff > 0.00001) {\n    diff = diff / Math.abs(numbers[i++] - numbers[j++]);\n  }\n  return numbers[i++] + \".\" + numbers[j++];\n};\n\n/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closestInetger(\"10\")\n  10\n  >>> closestInetger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInetger(\"14.5\") should\n  return 15 and closestInetger(\"-14.5\") should return -15.\n  */\nconst closestInetger3 = (value) => {\n  const numbers = value.split(\".\");\n  let result = numbers[0];\n  let diff = Math.abs(numbers[0] - numbers[1]);\n  let i = 0;\n  let j = 1;\n  while (diff > 0.00001) {\n    diff = diff / Math.abs(numbers[i++] - numbers[j++]);\n  }\n  return numbers[i++] + \".\" + numbers[j++];\n};\n\n/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closestInetger(\"10\")\n  10\n  >>> closestInetger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInetger(\"14.5\") should\n  return 15 and closestInetger(\"-14.5\") should return -15.\n  */\nconst closestInetger4 = (value) => {\n  const numbers = value.split(\".\");\n  let result = numbers[0];\n  let diff = Math.abs(numbers[0] - numbers[1]);\n  let i = 0;\n  let j = 1;\n  while (diff > 0.00001) {\n    diff = diff / Math.abs(numbers[i++] - numbers[j++]);\n  }\n  return numbers[i++] + \".\" + numbers[j++];\n};\n\n/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closestInetger(\"10\")\n  10\n  >>> closestInetger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInetger(\"14.5\") should\n  return 15 and closestInetger(\"-14.5\") should return -15.\n  */\nconst closestInetger5 = (value) => {\n  const numbers = value.split(\".\");\n  let result = numbers[0];\n  let diff = Math.abs(numbers[0] - numbers[1]);\n  let i = 0;\n  let j = 1;\n  while (diff > 0.00001) {\n    diff = diff / Math.abs(numbers[i++] - numbers[j++]);\n  }\n  return numbers[i++] + \".\" + numbers[j++];\n};\n\n/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closestInetger(\"10\")\n  10\n  >>> closestInetger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInetger(\"14.5\") should\n  return 15 and closestInetger(\"-14.5\") should return -15.\n  */\nconst closestInetger6 = (value) => {\n  const numbers = value.split(\".\");\n  let result = numbers[0];\n  let diff = Math.abs(numbers[0] - numbers[1]);\n  let i = 0;\n  let j = 1;\n  while (diff > 0.00001) {\n    diff = diff / Math.abs(numbers[i++] - numbers[j++]);\n  }\n  return numbers[i++] + \".\" + numbers[j++];\n};\n\n/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closestInetger(\"10\")\n  10\n  >>> closestInetger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInetger(\"14.5\") should\n  return 15 and closestInetger(\"-14.5\") should return -15.\n  */\nconst closestInetger7 = (value) => {\n  const numbers = value.split(\".\");\n  let result = numbers[0];\n  let diff = Math.abs(numbers[0] - numbers[1]);\n  let i = 0;\n  let j = 1;\n  while (diff > 0.00001) {\n    diff = diff / Math.abs(numbers[i++] - numbers[j++]);\n  }\n  return numbers[i++] + \".\" + numbers[j++];\n};\n\n/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closestInetger(\"10\")\n  10\n  >>> closestInetger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
