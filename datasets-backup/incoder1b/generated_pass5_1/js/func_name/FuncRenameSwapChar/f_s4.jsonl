{"task_id": "JavaScript/0", "prompt": "/* Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> hasCloselEements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloselEements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloselEements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloselEements", "gc": "<|endoftext|>/* Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  >>> hasCloselEements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloselEements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloselEements = (numbers, threshold) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const diff = Math.abs(sortedNumbers[0] - sortedNumbers[1]);\n  return diff <= threshold;\n};\n\n/**\n * Get a random element from the given array.\n * If no element is found, returns undefined.\n * If no element can be found, returns undefined.\n * If more than one element can be found, returns undefined.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If an element can be found and it's unique, returns it.\n * If ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/1", "prompt": "/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> separateParenGrousp('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGrousp = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGrousp", "gc": "<|endoftext|>/* Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n  >>> separateParenGrousp('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGrousp = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]+)\\)/).map(\n    (group) => group.match(/\\(([^()]+)\\)/)\n  );\n  const paren_group_strings = paren_groups.map((group) => group[1]);\n  return paren_group_strings;\n};\n\n/**\n  Given a string containing multiple groups of parentheses, return the list of all groups that are\n  not nested within each other. Ignore any spaces in the input string.\n  >>> separateParenGrousp('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGrouspNoSpaces = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]+)\\)/).map(\n    (group) => group.match(/\\(([^()]+)\\)/)\n  );\n  const paren_group_strings = paren_groups.map((group) => group[1]);\n  return paren_group_strings;\n};\n\n/**\n  Given a string containing multiple groups of parentheses, return the list of all groups that are\n  not nested within each other. Ignore any spaces in the input string.\n  >>> separateParenGrouspNoSpaces('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGrouspNoSpacesNoSpaces = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]+)\\)/).map(\n    (group) => group.match(/\\(([^()]+)\\)/)\n  );\n  const paren_group_strings = paren_groups.map((group) => group[1]);\n  return paren_group_strings;\n};\n\n/**\n  Given a string containing multiple groups of parentheses, return the list of all groups that are\n  not nested within each other. Ignore any spaces in the input string.\n  >>> separateParenGrouspNoSpacesNoSpaces('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGrouspNoSpacesNoSpacesNoSpaces = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]+)\\)/).map(\n    (group) => group.match(/\\(([^()]+)\\)/)\n  );\n  const paren_group_strings = paren_groups.map((group) => group[1]);\n  return paren_group_strings;\n};\n\n/**\n  Given a string containing multiple groups of parentheses, return the list of all groups that are\n  not nested within each other. Ignore any spaces in the input string.\n  >>> separateParenGrouspNoSpacesNoSpacesNoSpaces('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGrouspNoSpacesNoSpacesNoSpacesNoSpaces = (\n  paren_string\n) => {\n  const paren_groups = paren_string.match(/\\(([^()]+)\\)/).map(\n    (group) => group.match(/\\(([^()]+)\\)/)\n  );\n  const paren_group_strings = paren_groups.map((group) => group[1]);\n  return paren_group_strings;\n};\n\n/**\n  Given a string containing multiple groups of parentheses, return the list of all groups that are\n  not nested within each other. Ignore any spaces in the input string.\n  >>> separateParenGrouspNoSpacesNoSpacesNoSpacesNoSpaces('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGrouspNoSpacesNoSpacesNoSpacesNoSpacesNoSpaces = (\n  paren_string\n) => {\n  const paren_groups = paren_string.match(/\\(([^()]+)\\)/).map(\n    (group) => group.match(/\\(([^()]+)\\)/)\n  );\n  const paren_group_strings = paren_groups.map((group) => group[1]);\n  return paren_group_strings;\n};\n\n/**\n  Given a string containing multiple groups of parentheses, return the list of all groups that are\n  not nested within each other. Ignore any spaces in the input string.\n  >>> separateParenGrouspNoSpacesNoSpacesNoSpacesNoSpacesNoSpaces('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGrouspNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpaces = (\n  paren_string\n) => {\n  const paren_groups = paren_string.match(/\\(([^()]+)\\)/).map(\n    (group) => group.match(/\\(([^()]+)\\)/)\n  );\n  const paren_group_strings = paren_groups.map((group) => group[1]);\n  return paren_group_strings;\n};\n\n/**\n  Given a string containing multiple groups of parentheses, return the list of all groups that are\n  not nested within each other. Ignore any spaces in the input string.\n  >>> separateParenGrouspNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpaces('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGrouspNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpaces = (\n  paren_string\n) => {\n  const paren_groups = paren_string.match(/\\(([^()]+)\\)/).map(\n    (group) => group.match(/\\(([^()]+)\\)/)\n  );\n  const paren_group_strings = paren_groups.map((group) => group[1]);\n  return paren_group_strings;\n};\n\n/**\n  Given a string containing multiple groups of parentheses, return the list of all groups that are\n  not nested within each other. Ignore any spaces in the input string.\n  >>> separateParenGrouspNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNoSpacesNo", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "gc": "<|endoftext|>/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let longestPalindrome = '';\n  let palindrome = '';\n  let reversedString = '';\n  let prefix = '';\n  let suffix = '';\n\n  /* Find the longest postfix of supplied string that is a palindrome */\n  longestPalindrome = longestPalindrome.reduce((longestPrefix, currentPrefix) => {\n    const currentString = currentPrefix.split('').reverse().join('');\n    const currentLength = currentString.length;\n    const currentPalindrome = currentString.split('').reverse().join('');\n    const currentPalindromeLength = currentPalindrome.length;\n\n    /* If current palindrome length is greater than current prefix length, then add current prefix to end of longest palindrome */\n    if (currentPalindromeLength > currentLength) {\n      longestPrefix = currentPrefix + currentPalindrome;\n    }\n\n    /* If current palindrome length is less than current prefix length, then add current prefix to end of longest palindrome */\n    if (currentPalindromeLength < currentLength) {\n      longestPrefix = currentPrefix + currentPalindrome;\n    }\n\n    return longestPrefix;\n  }, longestPalindrome);\n\n  /* Append to the end of the string reverse of a string prefix that comes before the palindromic suffix */\n  prefix = longestPalindrome.split('').reverse().join('');\n  reversedString = prefix + string;\n  suffix = reversedString.split('').reverse().join('');\n\n  /* If the longest palindrome is longer than the supplied string, then return empty string */\n  if (longestPalindrome.length > string.length) {\n    return '';\n  }\n\n  /* If the longest palindrome is shorter than the supplied string, then return empty string */\n  if (longestPalindrome.length < string.length) {\n    return '';\n  }\n\n  /* If the longest palindrome is equal to the supplied string, then return empty string */\n  if (longestPalindrome === string) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(longestPalindrome)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(prefix)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(suffix)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(reversedString)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(prefix)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(suffix)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(reversedString)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(prefix)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(suffix)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(reversedString)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(prefix)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(suffix)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(reversedString)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(prefix)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(suffix)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(reversedString)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(prefix)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(suffix)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(reversedString)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(prefix)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(suffix)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(reversedString)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(prefix)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(suffix)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(reversedString)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(prefix)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(suffix)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(reversedString)) {\n    return '';\n  }\n\n  /* If the longest palindrome begins with a supplied string, then return empty string */\n  if (isPalindrome(prefix)) {\n    return '';\n  }\n\n  /* If the longest ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "gc": "<|endoftext|>/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [];\n  let level = 1;\n  let num = 1;\n  while (num < n) {\n    levels.push(level);\n    num <<= 1;\n    level <<= 1;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [];\n  let level = 1;\n  let num = 1;\n  while (num < n) {\n    levels.push(level);\n    num <<= 1;\n    level <<= 1;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [];\n  let level = 1;\n  let num = 1;\n  while (num < n) {\n    levels.push(level);\n    num <<= 1;\n    level <<= 1;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [];\n  let level = 1;\n  let num = 1;\n  while (num < n) {\n    levels.push(level);\n    num <<= 1;\n    level <<= 1;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [];\n  let level = 1;\n  let num = 1;\n  while (num < n) {\n    levels.push(level);\n    num <<= 1;\n    level <<= 1;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [];\n  let level = 1;\n  let num = 1;\n  while (num < n) {\n    levels.push(level);\n    num <<= 1;\n    level <<= 1;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [];\n  let level = 1;\n  let num = 1;\n  while (num < n) {\n    levels.push(level);\n    num <<= 1;\n    level <<= 1;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [];\n  let level = 1;\n  let num = 1;\n  while (num < n) {\n    levels.push(level);\n    num <<= 1;\n    level <<= 1;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [];\n  let level = 1;\n  let num = 1;\n  while (num < n) {\n    levels.push(level);\n    num <<= 1;\n    level <<= 1;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const levels = [];\n  let level = 1;\n  let num = 1;\n  while (num < n) {\n    levels.push(level);\n    num <<= 1;\n    level <<= 1;\n  }\n  return levels;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "gc": "<|endoftext|>/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  let words = s.split(\" \");\n  return words.map((w) => w.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words. Your function should\n  return the words in an array, not as a string.\n  \n  For example:\n  wordsArray(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsArray(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsArray = (s) => {\n  let words = s.split(\" \");\n  return words.map((w) => w.trim());\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words. Your function should\n  return the words in an array, not as a string. Your function should also return the\n  number of words in the array.\n  \n  For example:\n  wordsCount(\"Hi, my name is John\") == 3\n  wordsCount(\"One, two, three, four, five, six\") == 6\n  */\nconst wordsCount = (s) => {\n  let words = s.split(\" \");\n  return words.length;\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words. Your function should\n  return the words in an array, not as a string. Your function should also return the\n  number of words in the array. Your function should also return the number of words\n  that are not in the array.\n  \n  For example:\n  wordsNotIn(\"Hi, my name is John\") == 3\n  wordsNotIn(\"One, two, three, four, five, six\") == 6\n  */\nconst wordsNotIn = (s) => {\n  let words = s.split(\" \");\n  return words.length - wordsCount(s);\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words. Your function should\n  return the words in an array, not as a string. Your function should also return the\n  number of words in the array. Your function should also return the number of words\n  that are not in the array. Your function should also return the number of words\n  that are not in the array.\n  \n  For example:\n  wordsNotInArray(\"Hi, my name is John\") == 3\n  wordsNotInArray(\"One, two, three, four, five, six\") == 6\n  */\nconst wordsNotInArray = (s) => {\n  let words = s.split(\" \");\n  return words.length - wordsCount(s);\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words. Your function should\n  return the words in an array, not as a string. Your function should also return the\n  number of words in the array. Your function should also return the number of words\n  that are not in the array. Your function should also return the number of words\n  that are not in the array.\n  \n  For example:\n  wordsNotInArray(\"Hi, my name is John\") == 3\n  wordsNotInArray(\"One, two, three, four, five, six\") == 6\n  */\nconst wordsNotInArrayCount = (s) => {\n  let words = s.split(\" \");\n  return words.length - wordsCount(s);\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words. Your function should\n  return the words in an array, not as a string. Your function should also return the\n  number of words in the array. Your function should also return the number of words\n  that are not in the array. Your function should also return the number of words\n  that are not in the array.\n  \n  For example:\n  wordsNotInArrayCount(\"Hi, my name is John\") == 3\n  wordsNotInArrayCount(\"One, two, three, four, five, six\") == 6\n  */\nconst wordsNotInArrayCount = (s) => {\n  let words = s.split(\" \");\n  return words.length - wordsCount(s);\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words. Your function should\n  return the words in an array, not as a string. Your function should also return the\n  number of words in the array. Your function should also return the number of words\n  that are not in the array. Your function should also return the number of words\n  that are not in the array.\n  \n  For example:\n  wordsNotInArrayCount(\"Hi, my name is John\") == 3\n  wordsNotInArrayCount(\"One, two, three, four, five, six\") == 6\n  */\nconst wordsNotInArrayCount = (s) => {\n  let words = s.split(\" \");\n  return words.length - wordsCount(s);\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words. Your function should\n  return the words in an array, not as a string. Your function should also return the\n  number of words in the array. Your function should also return the number of words\n  that are not in the array. Your function should also return the number of words\n  that are not in the array.\n  \n  For example:\n  wordsNotInArrayCount(\"Hi, my name is John\") == 3\n  wordsNotInArrayCount(\"One, two, three, four, five, six\") == 6\n  */\nconst wordsNotInArrayCount = (s) => {\n  let words = s.split(\" \");\n  return words.length - wordsCount(s);\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words. Your function should\n  return the words in an array, not as a string. Your function should also return the\n  number of words in the array. Your function should also return the number of words\n  that are not in the array. Your function should also return the number of words\n  that are not in the array.\n  \n  For example:\n  wordsNotInArrayCount(\"Hi, my name is John\") == 3\n  wordsNotInArrayCount(\"One, two, three, four, five, six\") == 6\n  */\nconst wordsNotInArrayCount = (s) => {\n  let words = s.split(\" \");\n  return words.length - wordsCount(s);\n};\n\n/*\n  You will be given a string of words separated by commas or spaces. Your task is\n  to split the string into words and return an array of the words. Your function should\n  return the words in an array, not as a string. Your function should also return the\n  number of words in the array. Your function should also return the number of words\n  that are not in the array. Your function should also return the number of words\n  that are not in the array.\n  \n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/102", "prompt": "/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "gc": "<|endoftext|>/*This function takes two positive numbers x and y and returns the\n  biggest even integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x > y || x < 0 || y < 0) {\n    return -1;\n  }\n  if (x === y) {\n    return x;\n  }\n  let num = 0;\n  let temp;\n  let count = 0;\n  while (true) {\n    temp = x % y;\n    if (temp === 0) {\n      num++;\n      count++;\n    }\n    x = Math.floor(x / y);\n    y = Math.floor(y / x);\n    if (count === 2) {\n      return num;\n    }\n  }\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest odd integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x > y || x < 0 || y < 0) {\n    return -1;\n  }\n  if (x === y) {\n    return x;\n  }\n  let num = 0;\n  let temp;\n  let count = 0;\n  while (true) {\n    temp = x % y;\n    if (temp === 0) {\n      num++;\n      count++;\n    }\n    x = Math.floor(x / y);\n    y = Math.floor(y / x);\n    if (count === 2) {\n      return num;\n    }\n  }\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x > y || x < 0 || y < 0) {\n    return -1;\n  }\n  if (x === y) {\n    return x;\n  }\n  let num = 0;\n  let temp;\n  let count = 0;\n  while (true) {\n    temp = x % y;\n    if (temp === 0) {\n      num++;\n      count++;\n    }\n    x = Math.floor(x / y);\n    y = Math.floor(y / x);\n    if (count === 2) {\n      return num;\n    }\n  }\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest negative integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x > y || x < 0 || y < 0) {\n    return -1;\n  }\n  if (x === y) {\n    return x;\n  }\n  let num = 0;\n  let temp;\n  let count = 0;\n  while (true) {\n    temp = x % y;\n    if (temp === 0) {\n      num++;\n      count++;\n    }\n    x = Math.floor(x / y);\n    y = Math.floor(y / x);\n    if (count === 2) {\n      return num;\n    }\n  }\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x > y || x < 0 || y < 0) {\n    return -1;\n  }\n  if (x === y) {\n    return x;\n  }\n  let num = 0;\n  let temp;\n  let count = 0;\n  while (true) {\n    temp = x % y;\n    if (temp === 0) {\n      num++;\n      count++;\n    }\n    x = Math.floor(x / y);\n    y = Math.floor(y / x);\n    if (count === 2) {\n      return num;\n    }\n  }\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest negative integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x > y || x < 0 || y < 0) {\n    return -1;\n  }\n  if (x === y) {\n    return x;\n  }\n  let num = 0;\n  let temp;\n  let count = 0;\n  while (true) {\n    temp = x % y;\n    if (temp === 0) {\n      num++;\n      count++;\n    }\n    x = Math.floor(x / y);\n    y = Math.floor(y / x);\n    if (count === 2) {\n      return num;\n    }\n  }\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x > y || x < 0 || y < 0) {\n    return -1;\n  }\n  if (x === y) {\n    return x;\n  }\n  let num = 0;\n  let temp;\n  let count = 0;\n  while (true) {\n    temp = x % y;\n    if (temp === 0) {\n      num++;\n      count++;\n    }\n    x = Math.floor(x / y);\n    y = Math.floor(y / x);\n    if (count === 2) {\n      return num;\n    }\n  }\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest negative integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x > y || x < 0 || y < 0) {\n    return -1;\n  }\n  if (x === y) {\n    return x;\n  }\n  let num = 0;\n  let temp;\n  let count = 0;\n  while (true) {\n    temp = x % y;\n    if (temp === 0) {\n      num++;\n      count++;\n    }\n    x = Math.floor(x / y);\n    y = Math.floor(y / x);\n    if (count === 2) {\n      return num;\n    }\n  }\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest positive integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x > y || x < 0 || y < 0) {\n    return -1;\n  }\n  if (x === y) {\n    return x;\n  }\n  let num = 0;\n  let temp;\n  let count = 0;\n  while (true) {\n    temp = x % y;\n    if (temp === 0) {\n      num++;\n      count++;\n    }\n    x = Math.floor(x / y);\n    y = Math.floor(y / x);\n    if (count === 2) {\n      return num;\n    }\n  }\n};\n\n/*This function takes two positive numbers x and y and returns the\n  biggest negative integer number that is in the range [x, y] inclusive. If \n  there's no such number, then the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x < 0 || y < 0 || x > y || x < 0 || y < 0) {\n    return -1;\n  }\n  if (x === y) {\n    return x;\n  }\n  let num = 0;\n  let temp;\n  let count = 0;\n  while (true) {\n    temp = x % y;\n    if (temp === 0) {\n      num++;\n      count++;\n    }\n    x = Math.floor(x / y);\n    y = Math.floor(y / x);\n    if (count === 2) {\n      return num;\n    }", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/103", "prompt": "/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "gc": "<|endoftext|>/*You are given two positive integers n and m, and your task is to compute the\n  average of the integers from n through m (including n and m). \n  Round the answer to the nearest integer and convert that to binary.\n  If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  let binary = \"\";\n  let decimal = 0;\n  let decimalCount = 0;\n  let decimalPlaces = 0;\n  let decimalPlaceCount = 0;\n  let decimalPlacePlaces = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlacePlaceCount = 0;\n  let decimalPlacePlacePlacePlaceCount = 0;\n  let decimalPlacePlacePlacePlaceCount = 0;\n  let decimalPlacePlacePlacePlaceCount = 0;\n  let decimalPlacePlacePlacePlaceCount = 0;\n  let decimalPlacePlacePlacePlaceCount = 0;\n  let decimalPlacePlacePlacePlaceCount = 0;\n  let decimalPlacePlacePlacePlaceCount = 0;\n  let decimalPlacePlacePlacePlaceCount = 0;\n  let decimalPlacePlacePlacePlaceCount = 0;\n  let decimalPlacePlacePlacePlaceCount = 0;\n  let decimalPlacePlacePlacePlaceCount = 0;\n  let decimalPlacePlacePlacePlaceCount = 0;\n  let decimalPlacePlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;\n  let decimalPlacePlaceCount = 0;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueDigtis([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigtis([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigtis = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigtis", "gc": "<|endoftext|>/*Given a list of positive integers x. return a sorted list of all \n  elements that hasn't any even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueDigtis([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigtis([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigtis = (x) => {\n  let res = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let temp = 0\n  while (i < x.length) {\n    if (x[i] % 2 === 0) {\n      temp = x[i]\n      x[i] = x[j]\n      x[j] = temp\n      i++\n      j++\n    } else {\n      k = x[i]\n      x[i] = x[j]\n      x[j] = k\n      i++\n      j++\n    }\n  }\n  while (j < x.length) {\n    if (x[j] % 2 === 0) {\n      temp = x[j]\n      x[j] = x[i]\n      x[i] = temp\n      i++\n      j++\n    } else {\n      k = x[j]\n      x[j] = x[i]\n      x[i] = k\n      i++\n      j++\n    }\n  }\n  return res\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueDigtis([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigtis([152, 323, 1422, 10])\n  []\n  */\nconst oddDigtis = (x) => {\n  let res = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let temp = 0\n  while (i < x.length) {\n    if (x[i] % 2 === 1) {\n      temp = x[i]\n      x[i] = x[j]\n      x[j] = temp\n      i++\n      j++\n    } else {\n      k = x[i]\n      x[i] = x[j]\n      x[j] = k\n      i++\n      j++\n    }\n  }\n  while (j < x.length) {\n    if (x[j] % 2 === 1) {\n      temp = x[j]\n      x[j] = x[i]\n      x[i] = temp\n      i++\n      j++\n    } else {\n      k = x[j]\n      x[j] = x[i]\n      x[i] = k\n      i++\n      j++\n    }\n  }\n  return res\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueDigtis([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigtis([152, 323, 1422, 10])\n  []\n  */\nconst evenDigtis = (x) => {\n  let res = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let temp = 0\n  while (i < x.length) {\n    if (x[i] % 2 === 0) {\n      temp = x[i]\n      x[i] = x[j]\n      x[j] = temp\n      i++\n      j++\n    } else {\n      k = x[i]\n      x[i] = x[j]\n      x[j] = k\n      i++\n      j++\n    }\n  }\n  while (j < x.length) {\n    if (x[j] % 2 === 0) {\n      temp = x[j]\n      x[j] = x[i]\n      x[i] = temp\n      i++\n      j++\n    } else {\n      k = x[j]\n      x[j] = x[i]\n      x[i] = k\n      i++\n      j++\n    }\n  }\n  return res\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueDigtis([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigtis([152, 323, 1422, 10])\n  []\n  */\nconst digits = (x) => {\n  let res = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let temp = 0\n  while (i < x.length) {\n    if (x[i] % 2 === 1) {\n      temp = x[i]\n      x[i] = x[j]\n      x[j] = temp\n      i++\n      j++\n    } else {\n      k = x[i]\n      x[i] = x[j]\n      x[j] = k\n      i++\n      j++\n    }\n  }\n  while (j < x.length) {\n    if (x[j] % 2 === 1) {\n      temp = x[j]\n      x[j] = x[i]\n      x[i] = temp\n      i++\n      j++\n    } else {\n      k = x[j]\n      x[j] = x[i]\n      x[i] = k\n      i++\n      j++\n    }\n  }\n  return res\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueDigtis([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigtis([152, 323, 1422, 10])\n  []\n  */\nconst digits2 = (x) => {\n  let res = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let temp = 0\n  while (i < x.length) {\n    if (x[i] % 2 === 1) {\n      temp = x[i]\n      x[i] = x[j]\n      x[j] = temp\n      i++\n      j++\n    } else {\n      k = x[i]\n      x[i] = x[j]\n      x[j] = k\n      i++\n      j++\n    }\n  }\n  while (j < x.length) {\n    if (x[j] % 2 === 1) {\n      temp = x[j]\n      x[j] = x[i]\n      x[i] = temp\n      i++\n      j++\n    } else {\n      k = x[j]\n      x[j] = x[i]\n      x[i] = k\n      i++\n      j++\n    }\n  }\n  return res\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueDigtis([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigtis([152, 323, 1422, 10])\n  []\n  */\nconst digits3 = (x) => {\n  let res = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let temp = 0\n  while (i < x.length) {\n    if (x[i] % 2 === 1) {\n      temp = x[i]\n      x[i] = x[j]\n      x[j] = temp\n      i++\n      j++\n    } else {\n      k = x[i]\n      x[i] = x[j]\n      x[j] = k\n      i++\n      j++\n    }\n  }\n  while (j < x.length) {\n    if (x[j] % 2 === 1) {\n      temp = x[j]\n      x[j] = x[i]\n      x[i] = temp\n      i++\n      j++\n    } else {\n      k = x[j]\n      x[j] = x[i]\n      x[i] = k\n      i++\n      j++\n    }\n  }\n  return res\n}\n\n/*Given a list of positive integers x. return a sorted list of all \n  elements that has odd or even digit.\n\n  Note: Returned list should be sorted in increasing order.\n  \n  For example:\n  >>> uniqueDigtis([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigtis([152, 323, 1422, 10])\n  []\n  */\nconst digits4 = (x) => {\n  let res = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let temp = 0\n  while (i < x.length) {\n    if (", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/105", "prompt": "/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst ybLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "ybLength", "gc": "<|endoftext|>/*\n  Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n  reverse the resulting array, and then replace each digit by its corresponding name from\n  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst ybLength = (arr) => {\n  let len = arr.length\n  let res = []\n  let i\n  let j\n  let k\n  let l\n  let m\n  let n\n  let o\n  let p\n  let q\n  let r\n  let s\n  let t\n  let u\n  let v\n  let w\n  let x\n  let y\n  let z\n  let A\n  let B\n  let C\n  let D\n  let E\n  let F\n  let G\n  let H\n  let I\n  let J\n  let K\n  let L\n  let M\n  let N\n  let O\n  let P\n  let Q\n  let R\n  let S\n  let T\n  let U\n  let V\n  let W\n  let X\n  let Y\n  let Z\n  let a\n  let b\n  let c\n  let d\n  let e\n  let f\n  let g\n  let h\n  let i\n  let j\n  let k\n  let l\n  let m\n  let n\n  let o\n  let p\n  let q\n  let r\n  let s\n  let t\n  let u\n  let v\n  let w\n  let x\n  let y\n  let z\n  let A\n  let B\n  let C\n  let D\n  let E\n  let F\n  let G\n  let H\n  let I\n  let J\n  let K\n  let L\n  let M\n  let N\n  let O\n  let P\n  let Q\n  let R\n  let S\n  let T\n  let U\n  let V\n  let W\n  let X\n  let Y\n  let Z\n  let a\n  let b\n  let c\n  let d\n  let e\n  let f\n  let g\n  let h\n  let i\n  let j\n  let k\n  let l\n  let m\n  let n\n  let o\n  let p\n  let q\n  let r\n  let s\n  let t\n  let u\n  let v\n  let w\n  let x\n  let y\n  let z\n  let A\n  let B\n  let C\n  let D\n  let E\n  let F\n  let G\n  let H\n  let I\n  let J\n  let K\n  let L\n  let M\n  let N\n  let O\n  let P\n  let Q\n  let R\n  let S\n  let T\n  let U\n  let V\n  let W\n  let X\n  let Y\n  let Z\n  let a\n  let b\n  let c\n  let d\n  let e\n  let f\n  let g\n  let h\n  let i\n  let j\n  let k\n  let l\n  let m\n  let n\n  let o\n  let p\n  let q\n  let r\n  let s\n  let t\n  let u\n  let v\n  let w\n  let x\n  let y\n  let z\n  let A\n  let B\n  let C\n  let D\n  let E\n  let F\n  let G\n  let H\n  let I\n  let J\n  let K\n  let L\n  let M\n  let N\n  let O\n  let P\n  let Q\n  let R\n  let S\n  let T\n  let U\n  let V\n  let W\n  let X\n  let Y\n  let Z\n  let a\n  let b\n  let c\n  let d\n  let e\n  let f\n  let g\n  let h\n  let i\n  let j\n  let k\n  let l\n  let m\n  let n\n  let o\n  let p\n  let q\n  let r\n  let s\n  let t\n  let u\n  let v\n  let w\n  let x\n  let y\n  let z\n  let A\n  let B\n  let C\n  let D\n  let E\n  let F\n  let G\n  let H\n  let I\n  let J\n  let K\n  let L\n  let M\n  let N\n  let O\n  let P\n  let Q\n  let R\n  let S\n  let T\n  let U\n  let V\n  let W\n  let X\n  let Y\n  let Z\n  let a\n  let b\n  let c\n  let d\n  let e\n  let f\n  let g\n  let h\n  let i\n  let j\n  let k\n  let l\n  let m\n  let n\n  let o\n  let p\n  let q\n  let r\n  let s\n  let t\n  let u\n  let v\n  let w\n  let x\n  let y\n  let z\n  let A\n  let B\n  let C\n  let D\n  let E\n  let F\n  let G\n  let H\n  let I\n  let J\n  let K\n  let L\n  let M\n  let N\n  let O\n  let P\n  let Q\n  let R\n  let S\n  let T\n  let U\n  let V\n  let W\n  let X\n  let Y\n  let Z\n  let a\n  let b\n  let c\n  let d\n  let e\n  let f\n  let g\n  let h\n  let i\n  let j\n  let k\n  let l\n  let m\n  let n\n  let o\n  let p\n  let q\n  let r\n  let s\n  let t\n  let u\n  let v\n  let w\n  let x\n  let y\n  let z\n  let A\n  let B\n  let C\n  let D\n  let E\n  let F\n  let G\n  let H\n  let I\n  let J\n  let K\n  let L\n  let M\n  let N\n  let O\n  let P\n  let Q\n  let R\n  let S\n  let T\n  let U\n  let V\n  let W\n  let X\n  let Y\n  let Z\n  let a\n  let b\n  let c\n  let d\n  let e\n  let f\n  let g\n  let h\n  let i\n  let j\n  let k\n  let l\n  let m\n  let n\n  let o\n  let p\n  let q\n  let r\n  let s\n  let t\n  let u\n  let v\n  let w\n  let x\n  let y\n  let z\n  let A\n  let B\n  let C\n  let D\n  let E\n  let F\n  let G\n  let H\n  let I\n  let J\n  let K\n  let L\n  let M\n  let N\n  let O\n  let P\n  let Q\n  let R\n  let S\n  let T\n  let U\n  let V\n  let W\n  let X\n  let Y\n  let Z\n  let a\n  let b\n  let c\n  let d\n  let e\n  let f\n  let g\n  let h\n  let i\n  let j\n  let k\n  let l\n  let m\n  let n\n  let o\n  let p\n  let q\n  let r\n  let s\n  let t\n  let u\n  let v\n  let w\n  let x\n  let y\n  let z\n  let A\n  let B\n  let C\n  let D\n  let E\n  let F\n  let G\n  let H\n  let I\n  let J\n  let K\n  let L", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/106", "prompt": "/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "gc": "<|endoftext|>/* Implement the function f that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, curr) => acc + curr, 0));\n    }\n  }\n  return result;\n};\n\n/* Implement the function g that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  g(5) == [1, 2, 6, 24, 15]\n  */\nconst g = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, curr) => acc + curr, 0));\n    }\n  }\n  return result;\n};\n\n/* Implement the function h that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  h(5) == [1, 2, 6, 24, 15]\n  */\nconst h = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, curr) => acc + curr, 0));\n    }\n  }\n  return result;\n};\n\n/* Implement the function i that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  i(5) == [1, 2, 6, 24, 15]\n  */\nconst i = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, curr) => acc + curr, 0));\n    }\n  }\n  return result;\n};\n\n/* Implement the function j that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  j(5) == [1, 2, 6, 24, 15]\n  */\nconst j = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, curr) => acc + curr, 0));\n    }\n  }\n  return result;\n};\n\n/* Implement the function k that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  k(5) == [1, 2, 6, 24, 15]\n  */\nconst k = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, curr) => acc + curr, 0));\n    }\n  }\n  return result;\n};\n\n/* Implement the function l that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  l(5) == [1, 2, 6, 24, 15]\n  */\nconst l = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, curr) => acc + curr, 0));\n    }\n  }\n  return result;\n};\n\n/* Implement the function m that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  m(5) == [1, 2, 6, 24, 15]\n  */\nconst m = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, curr) => acc + curr, 0));\n    }\n  }\n  return result;\n};\n\n/* Implement the function n that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  n(5) == [1, 2, 6, 24, 15]\n  */\nconst n = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, curr) => acc + curr, 0));\n    }\n  }\n  return result;\n};\n\n/* Implement the function o that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  o(5) == [1, 2, 6, 24, 15]\n  */\nconst o = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    } else {\n      result.push(result.reduce((acc, curr) => acc + curr, 0));\n    }\n  }\n  return result;\n};\n\n/* Implement the function p that takes n as a parameter,\n  and returns a list of size n, such that the value of the element at index i is the greatest common divisor of i if i is even\n  or the sum of numbers from 1 to i otherwise.\n  i starts from 1.\n  the greatest common divisor of i is the multiplication of the numbers from 1 to ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/107", "prompt": "/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "gc": "<|endoftext|>/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const oddPalindromes = [];\n  let oddPalindrome = 1;\n  let evenPalindrome = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      evenPalindrome = evenPalindrome * i;\n    } else {\n      oddPalindrome = oddPalindrome * i;\n    }\n    if (evenPalindrome % 2 === 0) {\n      oddPalindromes.push(oddPalindrome);\n      evenPalindrome = 1;\n    } else {\n      evenPalindrome = 1;\n    }\n  }\n  return oddPalindromes;\n};\n\n/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(2, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (2, 3)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome2 = (n) => {\n  const oddPalindromes = [];\n  let oddPalindrome = 2;\n  let evenPalindrome = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      evenPalindrome = evenPalindrome * i;\n    } else {\n      oddPalindrome = oddPalindrome * i;\n    }\n    if (evenPalindrome % 2 === 0) {\n      oddPalindromes.push(oddPalindrome);\n      evenPalindrome = 1;\n    } else {\n      evenPalindrome = 1;\n    }\n  }\n  return oddPalindromes;\n};\n\n/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(3, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (3, 4)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome3 = (n) => {\n  const oddPalindromes = [];\n  let oddPalindrome = 3;\n  let evenPalindrome = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      evenPalindrome = evenPalindrome * i;\n    } else {\n      oddPalindrome = oddPalindrome * i;\n    }\n    if (evenPalindrome % 2 === 0) {\n      oddPalindromes.push(oddPalindrome);\n      evenPalindrome = 1;\n    } else {\n      evenPalindrome = 1;\n    }\n  }\n  return oddPalindromes;\n};\n\n/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(4, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (4, 5)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome4 = (n) => {\n  const oddPalindromes = [];\n  let oddPalindrome = 4;\n  let evenPalindrome = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      evenPalindrome = evenPalindrome * i;\n    } else {\n      oddPalindrome = oddPalindrome * i;\n    }\n    if (evenPalindrome % 2 === 0) {\n      oddPalindromes.push(oddPalindrome);\n      evenPalindrome = 1;\n    } else {\n      evenPalindrome = 1;\n    }\n  }\n  return oddPalindromes;\n};\n\n/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(5, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (5, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome5 = (n) => {\n  const oddPalindromes = [];\n  let oddPalindrome = 5;\n  let evenPalindrome = 1;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      evenPalindrome = evenPalindrome * i;\n    } else {\n      oddPalindrome = oddPalindrome * i;\n    }\n    if (evenPalindrome % 2 === 0) {\n      oddPalindromes.push(oddPalindrome);\n      evenPalindrome = 1;\n    } else {\n      evenPalindrome = 1;\n    }\n  }\n  return oddPalindromes;\n};\n\n/*\n  Given a positive integer n, return a tuple that has the number of even and odd\n  integer palindromes that fall within the range(6, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (6, 7)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNmus", "gc": "<|endoftext|>/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = -arr[i];\n    }\n    if (arr[i] > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = -arr[i];\n    }\n    if (arr[i] > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = -arr[i];\n    }\n    if (arr[i] > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = -arr[i];\n    }\n    if (arr[i] > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = -arr[i];\n    }\n    if (arr[i] > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = -arr[i];\n    }\n    if (arr[i] > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = -arr[i];\n    }\n    if (arr[i] > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = -arr[i];\n    }\n    if (arr[i] > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = -arr[i];\n    }\n    if (arr[i] > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = -arr[i];\n    }\n    if (arr[i] > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  >>> countNmus([-1, 11, -11]) == 1\n  >>> countNmus([1, 1, 2]) == 3\n  */\nconst countNmus = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < 0) {\n      arr[i] = -arr[i];\n    }\n    if (arr[i] > 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countNmus which takes an array of integers and returns\n  the number of elements which has a sum of digits > 0.\n  If a number is negative, then its first signed digit will be negative:\n  e.g. -123 has signed digits -1, 2, and 3.\n  >>> countNmus([]) == 0\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "gc": "<|endoftext|>/*We have an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  let len = arr.length;\n  let i = 0;\n  let j = 0;\n  let temp;\n  let temp2;\n  let temp3;\n  let temp4;\n  let temp5;\n  let temp6;\n  let temp7;\n  let temp8;\n  let temp9;\n  let temp10;\n  let temp11;\n  let temp12;\n  let temp13;\n  let temp14;\n  let temp15;\n  let temp16;\n  let temp17;\n  let temp18;\n  let temp19;\n  let temp20;\n  let temp21;\n  let temp22;\n  let temp23;\n  let temp24;\n  let temp25;\n  let temp26;\n  let temp27;\n  let temp28;\n  let temp29;\n  let temp30;\n  let temp31;\n  let temp32;\n  let temp33;\n  let temp34;\n  let temp35;\n  let temp36;\n  let temp37;\n  let temp38;\n  let temp39;\n  let temp40;\n  let temp41;\n  let temp42;\n  let temp43;\n  let temp44;\n  let temp45;\n  let temp46;\n  let temp47;\n  let temp48;\n  let temp49;\n  let temp50;\n  let temp51;\n  let temp52;\n  let temp53;\n  let temp54;\n  let temp55;\n  let temp56;\n  let temp57;\n  let temp58;\n  let temp59;\n  let temp60;\n  let temp61;\n  let temp62;\n  let temp63;\n  let temp64;\n  let temp65;\n  let temp66;\n  let temp67;\n  let temp68;\n  let temp69;\n  let temp70;\n  let temp71;\n  let temp72;\n  let temp73;\n  let temp74;\n  let temp75;\n  let temp76;\n  let temp77;\n  let temp78;\n  let temp79;\n  let temp80;\n  let temp81;\n  let temp82;\n  let temp83;\n  let temp84;\n  let temp85;\n  let temp86;\n  let temp87;\n  let temp88;\n  let temp89;\n  let temp90;\n  let temp91;\n  let temp92;\n  let temp93;\n  let temp94;\n  let temp95;\n  let temp96;\n  let temp97;\n  let temp98;\n  let temp99;\n  let temp100;\n  let temp101;\n  let temp102;\n  let temp103;\n  let temp104;\n  let temp105;\n  let temp106;\n  let temp107;\n  let temp108;\n  let temp109;\n  let temp110;\n  let temp111;\n  let temp112;\n  let temp113;\n  let temp114;\n  let temp115;\n  let temp116;\n  let temp117;\n  let temp118;\n  let temp119;\n  let temp120;\n  let temp121;\n  let temp122;\n  let temp123;\n  let temp124;\n  let temp125;\n  let temp126;\n  let temp127;\n  let temp128;\n  let temp129;\n  let temp130;\n  let temp131;\n  let temp132;\n  let temp133;\n  let temp134;\n  let temp135;\n  let temp136;\n  let temp137;\n  let temp138;\n  let temp139;\n  let temp140;\n  let temp141;\n  let temp142;\n  let temp143;\n  let temp144;\n  let temp145;\n  let temp146;\n  let temp147;\n  let temp148;\n  let temp149;\n  let temp150;\n  let temp151;\n  let temp152;\n  let temp153;\n  let temp154;\n  let temp155;\n  let temp156;\n  let temp157;\n  let temp158;\n  let temp159;\n  let temp160;\n  let temp161;\n  let temp162;\n  let temp163;\n  let temp164;\n  let temp165;\n  let temp166;\n  let temp167;\n  let temp168;\n  let temp169;\n  let temp170;\n  let temp171;\n  let temp172;\n  let temp173;\n  let temp174;\n  let temp175;\n  let temp176;\n  let temp177;\n  let temp178;\n  let temp179;\n  let temp180;\n  let temp181;\n  let temp182;\n  let temp183;\n  let temp184;\n  let temp185;\n  let temp186;\n  let temp187;\n  let temp188;\n  let temp189;\n  let temp190;\n  let temp191;\n  let temp192;\n  let temp193;\n  let temp194;\n  let temp195;\n  let temp196;\n  let temp197;\n  let temp198;\n  let temp199;\n  let temp200;\n  let temp201;\n  let temp202;\n  let temp203;\n  let temp204;\n  let temp205;\n  let temp206;\n  let temp207;\n  let temp208;\n  let temp209;\n  let temp210;\n  let temp211;\n  let temp212;\n  let temp213;\n  let temp214;\n  let temp215;\n  let temp216;\n  let temp217;\n  let temp218;\n  let temp219;\n  let temp220;\n  let temp221;\n  let temp222;\n  let temp223;\n  let temp224;\n  let temp225;\n  let temp226;\n  let temp227;\n  let temp228;\n  let temp229;\n  let temp230;\n  let temp231;\n  let temp232;\n  let temp233;\n  let temp234;\n  let temp235;\n  let temp236;\n  let temp237;\n  let temp238;\n  let temp239;\n  let temp240;\n  let temp241;\n  let temp242;\n  let temp243;\n  let temp244;\n  let temp245;\n  let temp246;\n  let temp247;\n  let temp248;\n  let temp249;\n  let temp250;\n  let temp251;\n  let temp252;\n  let temp253;\n  let temp254;\n  let temp255;\n  let temp256;\n  let temp257;\n  let temp258;\n  let temp259;\n  let temp", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/11", "prompt": "/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> strinXgor('010', '110')\n  '100'\n  */\nconst strinXgor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "strinXgor", "gc": "<|endoftext|>/* Input are two strings a and b consisting only of 1s and 0s.\n  Perform binary XOR on these inputs and return result also as a string.\n  >>> strinXgor('010', '110')\n  '100'\n  */\nconst strinXgor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) * b.charAt(i);\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> strinXor('010', '110')\n  '100'\n  */\nconst strinXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) * b.charAt(i);\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> strinXor('010', '110')\n  '100'\n  */\nconst strinXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) * b.charAt(i);\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> strinXor('010', '110')\n  '100'\n  */\nconst strinXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) * b.charAt(i);\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> strinXor('010', '110')\n  '100'\n  */\nconst strinXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) * b.charAt(i);\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> strinXor('010', '110')\n  '100'\n  */\nconst strinXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) * b.charAt(i);\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> strinXor('010', '110')\n  '100'\n  */\nconst strinXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) * b.charAt(i);\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> strinXor('010', '110')\n  '100'\n  */\nconst strinXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) * b.charAt(i);\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> strinXor('010', '110')\n  '100'\n  */\nconst strinXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) * b.charAt(i);\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> strinXor('010', '110')\n  '100'\n  */\nconst strinXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) * b.charAt(i);\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> strinXor('010', '110')\n  '100'\n  */\nconst strinXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) * b.charAt(i);\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> strinXor('010', '110')\n  '100'\n  */\nconst strinXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) * b.charAt(i);\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> strinXor('010', '110')\n  '100'\n  */\nconst strinXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) * b.charAt(i);\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> strinXor('010', '110')\n  '100'\n  */\nconst strinXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) * b.charAt(i);\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> strinXor('010', '110')\n  '100'\n  */\nconst strinXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) * b.charAt(i);\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> strinXor('010', '110')\n  '100'\n  */\nconst strinXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) * b.charAt(i);\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> strinXor('010', '110')\n  '100'\n  */\nconst strinXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) * b.charAt(i);\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> strinXor('010', '110')\n  '100'\n  */\nconst strinXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) * b.charAt(i);\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> strinXor('010', '110')\n  '100'\n  */\nconst strinXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) * b.charAt(i);\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> strinXor('010', '110')\n  '100'\n  */\nconst strinXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) * b.charAt(i);\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> strinXor('010', '110')\n  '100'\n  */\nconst strinXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) * b.charAt(i);\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> strinXor('010', '110')\n  '100'\n  */\nconst strinXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) * b.charAt(i);\n  }\n  return result;\n};\n\n/**\n  Perform binary XOR on two strings.\n  >>> strinXor('010', '110')\n  '100'\n  */\nconst strinXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a.charAt(i) * b.charAt(i);\n  }\n  return ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an xechange of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of xechanged elements between lst1 and lst2.\n  If it is possible to xechange elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  xechange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  xechange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst xechange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "xechange", "gc": "<|endoftext|>/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an xechange of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of xechanged elements between lst1 and lst2.\n  If it is possible to xechange elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  xechange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  xechange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst xechange = (lst1, lst2) => {\n  let isXechanged = false\n  let isXechanged2 = false\n  let isXechanged3 = false\n  let isXechanged4 = false\n  let isXechanged5 = false\n  let isXechanged6 = false\n  let isXechanged7 = false\n  let isXechanged8 = false\n  let isXechanged9 = false\n  let isXechanged10 = false\n  let isXechanged11 = false\n  let isXechanged12 = false\n  let isXechanged13 = false\n  let isXechanged14 = false\n  let isXechanged15 = false\n  let isXechanged16 = false\n  let isXechanged17 = false\n  let isXechanged18 = false\n  let isXechanged19 = false\n  let isXechanged20 = false\n  let isXechanged21 = false\n  let isXechanged22 = false\n  let isXechanged23 = false\n  let isXechanged24 = false\n  let isXechanged25 = false\n  let isXechanged26 = false\n  let isXechanged27 = false\n  let isXechanged28 = false\n  let isXechanged29 = false\n  let isXechanged30 = false\n  let isXechanged31 = false\n  let isXechanged32 = false\n  let isXechanged33 = false\n  let isXechanged34 = false\n  let isXechanged35 = false\n  let isXechanged36 = false\n  let isXechanged37 = false\n  let isXechanged38 = false\n  let isXechanged39 = false\n  let isXechanged40 = false\n  let isXechanged41 = false\n  let isXechanged42 = false\n  let isXechanged43 = false\n  let isXechanged44 = false\n  let isXechanged45 = false\n  let isXechanged46 = false\n  let isXechanged47 = false\n  let isXechanged48 = false\n  let isXechanged49 = false\n  let isXechanged50 = false\n  let isXechanged51 = false\n  let isXechanged52 = false\n  let isXechanged53 = false\n  let isXechanged54 = false\n  let isXechanged55 = false\n  let isXechanged56 = false\n  let isXechanged57 = false\n  let isXechanged58 = false\n  let isXechanged59 = false\n  let isXechanged60 = false\n  let isXechanged61 = false\n  let isXechanged62 = false\n  let isXechanged63 = false\n  let isXechanged64 = false\n  let isXechanged65 = false\n  let isXechanged66 = false\n  let isXechanged67 = false\n  let isXechanged68 = false\n  let isXechanged69 = false\n  let isXechanged70 = false\n  let isXechanged71 = false\n  let isXechanged72 = false\n  let isXechanged73 = false\n  let isXechanged74 = false\n  let isXechanged75 = false\n  let isXechanged76 = false\n  let isXechanged77 = false\n  let isXechanged78 = false\n  let isXechanged79 = false\n  let isXechanged80 = false\n  let isXechanged81 = false\n  let isXechanged82 = false\n  let isXechanged83 = false\n  let isXechanged84 = false\n  let isXechanged85 = false\n  let isXechanged86 = false\n  let isXechanged87 = false\n  let isXechanged88 = false\n  let isXechanged89 = false\n  let isXechanged90 = false\n  let isXechanged91 = false\n  let isXechanged92 = false\n  let isXechanged93 = false\n  let isXechanged94 = false\n  let isXechanged95 = false\n  let isXechanged96 = false\n  let isXechanged97 = false\n  let isXechanged98 = false\n  let isXechanged99 = false\n  let isXechanged100 = false\n  let isXechanged101 = false\n  let isXechanged102 = false\n  let isXechanged103 = false\n  let isXechanged104 = false\n  let isXechanged105 = false\n  let isXechanged106 = false\n  let isXechanged107 = false\n  let isXechanged108 = false\n  let isXechanged109 = false\n  let isXechanged110 = false\n  let isXechanged111 = false\n  let isXechanged112 = false\n  let isXechanged113 = false\n  let isXechanged114 = false\n  let isXechanged115 = false\n  let isXechanged116 = false\n  let isXechanged117 = false\n  let isXechanged118 = false\n  let isXechanged119 = false\n  let isXechanged120 = false\n  let isXechanged121 = false\n  let isXechanged122 = false\n  let isXechanged123 = false\n  let isXechanged124 = false\n  let isXechanged125 = false\n  let isXechanged126 = false\n  let isXechanged127 = false\n  let isXechanged128 = false\n  let isXechanged129 = false\n  let isXechanged130 = false\n  let isXechanged131 = false\n  let isXechanged132 = false\n  let isXechanged133 = false\n  let isXechanged134 = false\n  let isXechanged135 = false\n  let isXechanged136 = false\n  let isXechanged137 = false\n  let isXechanged138 = false\n  let isXechanged139 = false\n  let isXechanged140 = false\n  let isXechanged141 = false\n  let isXechanged142 = false\n  let isXechanged143 = false\n  let isXechanged144 = false\n  let isXechanged145 = false\n  let isXechanged146 = false\n  let isXechanged147 = false\n  let isXechanged148 = false\n  let isXechanged149 = false\n  let isXechanged150 = false\n  let isXechanged151 = false\n  let isXechanged152 = false\n  let isXechanged153 = false\n  let isXechanged154 = false\n  let isXechanged155 = false\n  let isXechanged156 = false\n  let isXechanged157 = false\n  let isXechanged158 = false\n  let isXechanged159 = false\n  let isXechanged160 = false\n  let isXechanged161 = false\n  let isXechanged162 = false\n  let isXechanged163 = false\n  let isXechanged164 = false\n  let isXechanged165 = false\n  let is", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/111", "prompt": "/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "gc": "<|endoftext|>/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  letters.forEach((letter) => {\n    counts[letter] = counts[letter] || 0;\n    counts[letter]++;\n  });\n  return counts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  letters.forEach((letter) => {\n    counts[letter] = counts[letter] || 0;\n    counts[letter]++;\n  });\n  return counts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  letters.forEach((letter) => {\n    counts[letter] = counts[letter] || 0;\n    counts[letter]++;\n  });\n  return counts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  letters.forEach((letter) => {\n    counts[letter] = counts[letter] || 0;\n    counts[letter]++;\n  });\n  return counts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  letters.forEach((letter) => {\n    counts[letter] = counts[letter] || 0;\n    counts[letter]++;\n  });\n  return counts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  letters.forEach((letter) => {\n    counts[letter] = counts[letter] || 0;\n    counts[letter]++;\n  });\n  return counts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  letters.forEach((letter) => {\n    counts[letter] = counts[letter] || 0;\n    counts[letter]++;\n  });\n  return counts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  letters.forEach((letter) => {\n    counts[letter] = counts[letter] || 0;\n    counts[letter]++;\n  });\n  return counts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let letters = test.split(' ');\n  let counts = {};\n  letters.forEach((letter) => {\n    counts[letter] = counts[letter] || 0;\n    counts[letter]++;\n  });\n  return counts;\n};\n\n/*Given a string representing a space separated lowercase letters, return a dictionary\n  of the letter with the most repetition and containing the corresponding count.\n  If several letters have the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a'", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/112", "prompt": "/*Task\n  We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reveresDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reveresDelete", "gc": "<|endoftext|>/*Task\n  We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n  then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reveresDelete = (s, c) => {\n  let result = '';\n  let isPalindrome = true;\n  for (let i = 0; i < s.length - 1; i++) {\n    if (s[i] === s[i + 1]) {\n      result += s[i];\n    } else {\n      isPalindrome = false;\n      break;\n    }\n  }\n  return [result, isPalindrome];\n};\n\n/*Task\n  You are given a string s and a number n, you have to delete all the characters in s whose length is less than n.\n  Then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", n = 2, the result should be ('bcd',false)\n  For s = \"abcdef\", n = 4, the result should be ('acdef',false)\n  For s = \"abcdedcba\", n = 5, the result should be ('cdedc',true)\n  */\nconst reveresDeleteLessThan = (s, n) => {\n  let result = '';\n  let isPalindrome = true;\n  for (let i = 0; i < s.length - 1; i++) {\n    if (s.length - i === n) {\n      result += s[i];\n    } else {\n      isPalindrome = false;\n      break;\n    }\n  }\n  return [result, isPalindrome];\n};\n\n/*Task\n  You are given a string s and a number n, you have to delete all the characters in s whose length is greater than n.\n  Then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", n = 2, the result should be ('bcd',false)\n  For s = \"abcdef\", n = 4, the result should be ('acdef',false)\n  For s = \"abcdedcba\", n = 5, the result should be ('cdedc',true)\n  */\nconst reveresDeleteGreaterThan = (s, n) => {\n  let result = '';\n  let isPalindrome = true;\n  for (let i = 0; i < s.length - 1; i++) {\n    if (s.length - i === n) {\n      result += s[i];\n    } else {\n      isPalindrome = false;\n      break;\n    }\n  }\n  return [result, isPalindrome];\n};\n\n/*Task\n  You are given a string s and a number n, you have to delete all the characters in s whose length is equal to n.\n  Then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", n = 2, the result should be ('bcd',false)\n  For s = \"abcdef\", n = 4, the result should be ('acdef',false)\n  For s = \"abcdedcba\", n = 5, the result should be ('cdedc',true)\n  */\nconst reveresDeleteEqualTo = (s, n) => {\n  let result = '';\n  let isPalindrome = true;\n  for (let i = 0; i < s.length - 1; i++) {\n    if (s.length - i === n) {\n      result += s[i];\n    } else {\n      isPalindrome = false;\n      break;\n    }\n  }\n  return [result, isPalindrome];\n};\n\n/*Task\n  You are given a string s and a number n, you have to delete all the characters in s whose length is greater than or equal to n.\n  Then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", n = 2, the result should be ('bcd',false)\n  For s = \"abcdef\", n = 4, the result should be ('acdef',false)\n  For s = \"abcdedcba\", n = 5, the result should be ('cdedc',true)\n  */\nconst reveresDeleteGreaterOrEqualTo = (s, n) => {\n  let result = '';\n  let isPalindrome = true;\n  for (let i = 0; i < s.length - 1; i++) {\n    if (s.length - i === n) {\n      result += s[i];\n    } else {\n      isPalindrome = false;\n      break;\n    }\n  }\n  return [result, isPalindrome];\n};\n\n/*Task\n  You are given a string s and a number n, you have to delete all the characters in s whose length is equal to or less than n.\n  Then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", n = 2, the result should be ('bcd',false)\n  For s = \"abcdef\", n = 4, the result should be ('acdef',false)\n  For s = \"abcdedcba\", n = 5, the result should be ('cdedc',true)\n  */\nconst reveresDeleteLessOrEqualTo = (s, n) => {\n  let result = '';\n  let isPalindrome = true;\n  for (let i = 0; i < s.length - 1; i++) {\n    if (s.length - i === n) {\n      result += s[i];\n    } else {\n      isPalindrome = false;\n      break;\n    }\n  }\n  return [result, isPalindrome];\n};\n\n/*Task\n  You are given a string s and a number n, you have to delete all the characters in s whose length is equal to or greater than n.\n  Then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", n = 2, the result should be ('bcd',false)\n  For s = \"abcdef\", n = 4, the result should be ('acdef',false)\n  For s = \"abcdedcba\", n = 5, the result should be ('cdedc',true)\n  */\nconst reveresDeleteEqualOrLessThan = (s, n) => {\n  let result = '';\n  let isPalindrome = true;\n  for (let i = 0; i < s.length - 1; i++) {\n    if (s.length - i === n) {\n      result += s[i];\n    } else {\n      isPalindrome = false;\n      break;\n    }\n  }\n  return [result, isPalindrome];\n};\n\n/*Task\n  You are given a string s and a number n, you have to delete all the characters in s whose length is equal to or less than n.\n  Then check if the result string is palindrome.\n  A string is called palindrome if it reads the same backward as forward.\n  You should return a tuple containing the result string and true/false for the check.\n  Example\n  For s = \"abcde\", n = 2, the result should be ('bcd',false)\n  For s = \"abcdef\", n = 4, the result should be ('acdef',false)\n  For s = \"abcdedcba\", n = 5, the result should be ('cdedc',true)\n  */\nconst reveresDeleteEqualOrGreaterThan = (s, n) => {\n  let result = '';\n  let isPalindrome = true;\n  for (let i = 0; i < s.length - 1; i++) {\n    if (s.length - i === n) {\n      result += s[i];\n    } else {\n      isPalindrome = false;\n      break;\n    }\n  }\n  return [result, isPalindrome];\n};\n\n/*Task\n  You are given a string s and a number n, you have to delete all the character", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "gc": "<|endoftext|>/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of odd elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of odd digits in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let res = []\n  for (let i = 0; i < lst.length; i++) {\n    let str = lst[i]\n    let oddCount = 0\n    for (let j = 0; j < str.length; j++) {\n      if (str.charAt(j) % 2 === 0) {\n        oddCount++\n      }\n    }\n    res.push(oddCount)\n  }\n  return res\n}\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of even elements in the\n  string i of the input.\" where all the i's should be replaced by the number\n  of even digits in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let res = []\n  for (let i = 0; i < lst.length; i++) {\n    let str = lst[i]\n    let evenCount = 0\n    for (let j = 0; j < str.length; j++) {\n      if (str.charAt(j) % 2!== 0) {\n        evenCount++\n      }\n    }\n    res.push(evenCount)\n  }\n  return res\n}\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of pairs of adjacent elements\n  in the string i of the input.\" where all the i's should be replaced by the number\n  of pairs of adjacent elements found in the i'th string of the input.\n\n  >>> pairCount(['1234567'])\n  [\"the number of pairs of adjacent elements 4n the str4ng 4 of the 4nput.\"]\n  >>> pairCount(['3',\"11111111\"])\n  [\"the number of pairs of adjacent elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of pairs of adjacent elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst pairCount = (lst) => {\n  let res = []\n  for (let i = 0; i < lst.length; i++) {\n    let str = lst[i]\n    let pairCount = 0\n    for (let j = 0; j < str.length; j++) {\n      if (str.charAt(j) % 2 === 0) {\n        pairCount++\n      }\n    }\n    res.push(pairCount)\n  }\n  return res\n}\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of triples of adjacent elements\n  in the string i of the input.\" where all the i's should be replaced by the number\n  of triples of adjacent elements found in the i'th string of the input.\n\n  >>> tripleCount(['1234567'])\n  [\"the number of triples of adjacent elements 4n the str4ng 4 of the 4nput.\"]\n  >>> tripleCount(['3',\"11111111\"])\n  [\"the number of triples of adjacent elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of triples of adjacent elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst tripleCount = (lst) => {\n  let res = []\n  for (let i = 0; i < lst.length; i++) {\n    let str = lst[i]\n    let tripleCount = 0\n    for (let j = 0; j < str.length; j++) {\n      if (str.charAt(j) % 2 === 0) {\n        tripleCount++\n      }\n    }\n    res.push(tripleCount)\n  }\n  return res\n}\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of quatriples of adjacent elements\n  in the string i of the input.\" where all the i's should be replaced by the number\n  of quatriples of adjacent elements found in the i'th string of the input.\n\n  >>> quatripleCount(['1234567'])\n  [\"the number of quatriples of adjacent elements 4n the str4ng 4 of the 4nput.\"]\n  >>> quatripleCount(['3',\"11111111\"])\n  [\"the number of quatriples of adjacent elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of quatriples of adjacent elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst quatripleCount = (lst) => {\n  let res = []\n  for (let i = 0; i < lst.length; i++) {\n    let str = lst[i]\n    let quatripleCount = 0\n    for (let j = 0; j < str.length; j++) {\n      if (str.charAt(j) % 2 === 0) {\n        quatripleCount++\n      }\n    }\n    res.push(quatripleCount)\n  }\n  return res\n}\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of quintiles of adjacent elements\n  in the string i of the input.\" where all the i's should be replaced by the number\n  of quintiles of adjacent elements found in the i'th string of the input.\n\n  >>> quintileCount(['1234567'])\n  [\"the number of quintiles of adjacent elements 4n the str4ng 4 of the 4nput.\"]\n  >>> quintileCount(['3',\"11111111\"])\n  [\"the number of quintiles of adjacent elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of quintiles of adjacent elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst quintileCount = (lst) => {\n  let res = []\n  for (let i = 0; i < lst.length; i++) {\n    let str = lst[i]\n    let quintileCount = 0\n    for (let j = 0; j < str.length; j++) {\n      if (str.charAt(j) % 2 === 0) {\n        quintileCount++\n      }\n    }\n    res.push(quintileCount)\n  }\n  return res\n}\n\n/*Given a list of strings, where each string consists of only digits, return a list.\n  Each element i of the output should be \"the number of nickels of adjacent elements\n  in the string i of the input.\" where all the i's should be replaced by the number\n  of nickels of adjacent elements found in the i'th string of the input.\n\n  >>> nickelCount(['1234567'])\n  [\"the number of nickels of adjacent elements 4n the str4ng 4 of the 4nput.\"]\n  >>> nickelCount(['3',\"11111111\"])\n  [\"the number of nickels of adjacent elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of nickels of adjacent elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst nickelCount = (lst) => {\n  let res = []\n  for (let i = 0; i < lst.length; i++) {\n    let str = lst[i]\n    let nickelCount = 0\n    for (let j = 0; j < str.length; j++) {\n      if (str.charAt(j) % 2 === 0) {\n        nickelCount++\n      }\n    }\n    res.push(nickelCount)\n  }\n  return res\n}\n\n/*Given a list of strings, where each string consists of only digits, return a list.", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "gc": "<|endoftext|>/*\n  Given an array of integers nums, find the minimum sum of any non-empty sub-array\n  of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == 3\n  */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == 3\n  */\nconst minSubArraySum = (nums) => {\n  let sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == 3\n  */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == 3\n  */\nconst minSubArraySum = (nums) => {\n  let sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == 3\n  */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == 3\n  */\nconst minSubArraySum = (nums) => {\n  let sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == 3\n  */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == 3\n  */\nconst minSubArraySum = (nums) => {\n  let sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == 3\n  */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == 3\n  */\nconst minSubArraySum = (nums) => {\n  let sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == 3\n  */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum > maxSum) {\n      maxSum = sum;\n    }\n  }\n  return maxSum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == 3\n  */\nconst minSubArraySum = (nums) => {\n  let sum = 0;\n  let minSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    sum += nums[i];\n    if (sum < minSum) {\n      minSum = sum;\n    }\n  }\n  return minSum;\n};\n\n/*\n  Given an array of integers nums, find the maximum sum of any non-empty sub-array\n  of nums.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == 3\n  */\nconst maxSubArraySum = (nums) => {\n  let sum = 0;\n  let maxSum = nums[0];\n  for (let i = 1; i < num", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "gc": "<|endoftext|>/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n    const n = grid.length;\n    const m = grid[0].length;\n    const result = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (grid[i][j] === 1) {\n                result += (grid[i][j + 1] === 0? 1 : 0);\n                result += (grid[i][j - 1] === 0? 1 : 0);\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Given a rectangular grid of wells, return the number of ways to fill the \n * wells.\n * \n * Example 1:\n * \n * Input: \n * \n * grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n * capacity : 1\n * \n * Output: 6\n * \n * Explanation: \n * \n * There are 6 ways to fill the wells:\n * \n * 1) 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water\n * 2) 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water\n * 3) 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water\n * 4) 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water\n * 5) 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water\n * 6) 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water\n * \n * Example 2:\n * \n * Input: \n * \n * grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n * capacity : 2\n * \n * Output: 5\n * \n * Explanation: \n * \n * There are 5 ways to fill the wells:\n * \n * 1) 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water\n * 2) 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water\n * 3) 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water\n * 4) 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water\n * 5) 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water\n * 6) 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water -> 1 unit of water\n * \n * Example 3:\n * \n * Input: \n * \n * grid : [[0,0,0], [0,0,0]]\n * capacity : 5\n * \n * Output: 0\n * \n * Explanation: \n * \n * There are 0 ways to fill the wells.\n * \n * Example 4:\n * \n * Input: \n * \n * grid : [[0,0,0], [0,0,0]]\n * capacity : 10\n * \n * Output: 0\n * \n * Explanation: \n * \n * There are 0 ways to fill the wells.\n * \n * Example 5:\n * \n * Input: \n * \n * grid : [[0,0,0], [0,0,0]]\n * capacity : 100\n * \n * Output: 0\n * \n * Explanation: \n * \n * There are 0 ways to fill the wells.\n * \n * Example 6:\n * \n * Input: \n * \n * grid : [[0,0,0], [0,0,0]]\n * capacity : 1000\n * \n * Output: 0\n * \n * Explanation: \n * \n * There are 0 ways to fill the wells.\n * \n * Example 7:\n * \n * Input: \n * \n * grid : [[0,0,0], [0,0,0]]\n * capacity : 10000\n * \n * Output: 0\n * \n * Explanation: \n * \n * There are 0 ways to fill the wells.\n * \n * Example 8:\n * \n * Input: \n * \n * grid : [[0,0,0], [0,0,0]]\n * capacity : 100000\n * \n * Output: 0\n * \n * Explanation: \n * \n * There are 0 ways to fill the wells.\n * \n * Example 9:\n * \n * Input: \n * \n * grid : [[0,0,0], [0,0,0]]\n * capacity : 1000000\n * \n * Output: 0\n * \n * Explanation: \n * \n * There are 0 ways to fill the wells.\n * \n * Example 10:\n * \n * Input: \n * \n * grid : [[0,0,0], [0,0,0]]\n * capacity : 10000000\n * \n * Output: 0\n * \n * Explanation: \n * \n * There are 0 ways to fill the wells.\n * \n * Example 11:\n * \n * Input: \n * \n * grid : [[0,0,0], [0,0,0]]\n * capacity : 100000000\n * \n * Output: 0\n * \n * Explanation: \n * \n * There are 0 ways to fill the wells.\n * \n * Example 12:\n * \n * Input: \n * \n * grid : [[0,0,0], [0,0,0]]\n * capacity : 1000000000\n * \n * Output: 0\n * \n * Explanation: \n * \n * There are 0 ways to fill the wells.\n * \n * Example 13:\n * \n * Input: \n * \n * grid : [[0,0,0], [0,0,0]]\n * capacity : 10000000000\n * \n * Output: 0\n * \n * Explanation: \n * \n * There are 0 ways to fill the wells.\n * \n * Example 14:\n * \n * Input: \n * \n * grid : [[0,0,0], [0,0,0]]\n * capacity : 100000000000\n * \n * Output: 0\n * \n * Explanation: \n * \n * There are 0 ways to fill the wells.\n * \n * Example 15:\n * \n * Input: \n * \n * grid : [[0,0,0], [0,0,0]]\n * capacity : 1000000000000\n * \n * Output: 0\n * \n * Explan", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "gc": "<|endoftext|>/*\n  In this Kata, you have to sort an array of non-negative integers according to\n  number of ones in their binary representation in ascending order.\n  For similar number of ones, sort based on decimal value.\n\n  It must be implemented like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const len = arr.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let temp;\n  let temp2;\n  let temp3;\n  let temp4;\n  let temp5;\n  let temp6;\n  let temp7;\n  let temp8;\n  let temp9;\n  let temp10;\n  let temp11;\n  let temp12;\n  let temp13;\n  let temp14;\n  let temp15;\n  let temp16;\n  let temp17;\n  let temp18;\n  let temp19;\n  let temp20;\n  let temp21;\n  let temp22;\n  let temp23;\n  let temp24;\n  let temp25;\n  let temp26;\n  let temp27;\n  let temp28;\n  let temp29;\n  let temp30;\n  let temp31;\n  let temp32;\n  let temp33;\n  let temp34;\n  let temp35;\n  let temp36;\n  let temp37;\n  let temp38;\n  let temp39;\n  let temp40;\n  let temp41;\n  let temp42;\n  let temp43;\n  let temp44;\n  let temp45;\n  let temp46;\n  let temp47;\n  let temp48;\n  let temp49;\n  let temp50;\n  let temp51;\n  let temp52;\n  let temp53;\n  let temp54;\n  let temp55;\n  let temp56;\n  let temp57;\n  let temp58;\n  let temp59;\n  let temp60;\n  let temp61;\n  let temp62;\n  let temp63;\n  let temp64;\n  let temp65;\n  let temp66;\n  let temp67;\n  let temp68;\n  let temp69;\n  let temp70;\n  let temp71;\n  let temp72;\n  let temp73;\n  let temp74;\n  let temp75;\n  let temp76;\n  let temp77;\n  let temp78;\n  let temp79;\n  let temp80;\n  let temp81;\n  let temp82;\n  let temp83;\n  let temp84;\n  let temp85;\n  let temp86;\n  let temp87;\n  let temp88;\n  let temp89;\n  let temp90;\n  let temp91;\n  let temp92;\n  let temp93;\n  let temp94;\n  let temp95;\n  let temp96;\n  let temp97;\n  let temp98;\n  let temp99;\n  let temp100;\n  let temp101;\n  let temp102;\n  let temp103;\n  let temp104;\n  let temp105;\n  let temp106;\n  let temp107;\n  let temp108;\n  let temp109;\n  let temp110;\n  let temp111;\n  let temp112;\n  let temp113;\n  let temp114;\n  let temp115;\n  let temp116;\n  let temp117;\n  let temp118;\n  let temp119;\n  let temp120;\n  let temp121;\n  let temp122;\n  let temp123;\n  let temp124;\n  let temp125;\n  let temp126;\n  let temp127;\n  let temp128;\n  let temp129;\n  let temp130;\n  let temp131;\n  let temp132;\n  let temp133;\n  let temp134;\n  let temp135;\n  let temp136;\n  let temp137;\n  let temp138;\n  let temp139;\n  let temp140;\n  let temp141;\n  let temp142;\n  let temp143;\n  let temp144;\n  let temp145;\n  let temp146;\n  let temp147;\n  let temp148;\n  let temp149;\n  let temp150;\n  let temp151;\n  let temp152;\n  let temp153;\n  let temp154;\n  let temp155;\n  let temp156;\n  let temp157;\n  let temp158;\n  let temp159;\n  let temp160;\n  let temp161;\n  let temp162;\n  let temp163;\n  let temp164;\n  let temp165;\n  let temp166;\n  let temp167;\n  let temp168;\n  let temp169;\n  let temp170;\n  let temp171;\n  let temp172;\n  let temp173;\n  let temp174;\n  let temp175;\n  let temp176;\n  let temp177;\n  let temp178;\n  let temp179;\n  let temp180;\n  let temp181;\n  let temp182;\n  let temp183;\n  let temp184;\n  let temp185;\n  let temp186;\n  let temp187;\n  let temp188;\n  let temp189;\n  let temp190;\n  let temp191;\n  let temp192;\n  let temp193;\n  let temp194;\n  let temp195;\n  let temp196;\n  let temp197;\n  let temp198;\n  let temp199;\n  let temp200;\n  let temp201;\n  let temp202;\n  let temp203;\n  let temp204;\n  let temp205;\n  let temp206;\n  let temp207;\n  let temp208;\n  let temp209;\n  let temp210;\n  let temp211;\n  let temp212;\n  let temp213;\n  let temp214;\n  let temp215;\n  let temp216;\n  let temp217;\n  let temp218;\n  let temp219;\n  let temp220;\n  let temp221;\n  let temp222;\n  let temp223;\n  let temp224;\n  let temp225;\n  let temp226;\n  let temp227;\n  let temp228;\n  let temp229;\n  let temp230;\n  let temp231;\n  let temp232;\n  let temp233;\n  let temp234;\n  let temp235;\n  let temp236;\n  let temp237;\n  let temp238;\n  let temp239;\n  let temp240;\n  let temp241;\n  let temp242;\n  let temp243;\n  let temp244;\n  let temp245;\n  let temp246;\n  let temp247;\n  let temp248;\n  let temp249;\n  let temp250;\n  let temp251;\n  let temp252;\n  let temp253;\n  let temp254;\n  let temp255;\n  let temp256;\n  let temp257;\n  let temp258;\n  let temp259;\n  let temp260;\n  let temp261;\n  let temp262;\n  let temp263;\n  let temp264;\n  let temp265;\n  let temp266;\n  let temp267;\n  let temp268;\n  let temp269;\n  let temp270;\n  let temp271;\n  let temp272;\n  let temp273;\n  let temp274;\n  let temp275;\n  let temp276;\n  let temp277;\n  let temp278;\n  let temp279;\n  let temp280;\n  let temp281;\n  let temp282;\n  let temp283;\n  let temp284;\n  let temp285;\n  let temp286;\n  let temp287;\n  let temp", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selectWdors(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWdors(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWdors(\"simple white space\", 2) ==> []\n  selectWdors(\"Hello world\", 4) ==> [\"world\"]\n  selectWdors(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWdors = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWdors", "gc": "<|endoftext|>/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selectWdors(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWdors(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWdors(\"simple white space\", 2) ==> []\n  selectWdors(\"Hello world\", 4) ==> [\"world\"]\n  selectWdors(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWdors = (s, n) => {\n  let words = []\n  let word = ''\n  let count = 0\n  let wordCount = 0\n  let wordCountMax = s.length\n  let wordCountMin = 0\n  let wordCountMaxMin = wordCountMax\n  let wordCountMaxMinWord = wordCountMax\n  let wordCountMinWord = wordCountMin\n  let wordCountMaxWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n  let wordCountMinWordWord = wordCountMin\n  let wordCountMaxWordWord = wordCountMax\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/118", "prompt": "/*You are given a word. Your task is to find the closest vowel that stands between \n  two consonants from the right side of the word (case sensitive).\n  \n  Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contains English letter only.\n\n  Example:\n  getClossetVowel(\"yogurt\") ==> \"u\"\n  getClossetVowel(\"FULL\") ==> \"U\"\n  getClossetVowel(\"quick\") ==> \"\"\n  getClossetVowel(\"ab\") ==> \"\"\n  */\nconst getClossetVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClossetVowel", "gc": "<|endoftext|>/*You are given a word. Your task is to find the closest vowel that stands between \n  two consonants from the right side of the word (case sensitive).\n  \n  Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n  find any vowel met the above condition. \n\n  You may assume that the given string contains English letter only.\n\n  Example:\n  getClossetVowel(\"yogurt\") ==> \"u\"\n  getClossetVowel(\"FULL\") ==> \"U\"\n  getClossetVowel(\"quick\") ==> \"\"\n  getClossetVowel(\"ab\") ==> \"\"\n  */\nconst getClossetVowel = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  let vowelsIndex = 0;\n  let vowelsLength = 0;\n  let vowelsIndex2 = 0;\n  let vowelsLength2 = 0;\n  let vowelsIndex3 = 0;\n  let vowelsLength3 = 0;\n  let vowelsIndex4 = 0;\n  let vowelsLength4 = 0;\n  let vowelsIndex5 = 0;\n  let vowelsLength5 = 0;\n  let vowelsIndex6 = 0;\n  let vowelsLength6 = 0;\n  let vowelsIndex7 = 0;\n  let vowelsLength7 = 0;\n  let vowelsIndex8 = 0;\n  let vowelsLength8 = 0;\n  let vowelsIndex9 = 0;\n  let vowelsLength9 = 0;\n  let vowelsIndex10 = 0;\n  let vowelsLength10 = 0;\n  let vowelsIndex11 = 0;\n  let vowelsLength11 = 0;\n  let vowelsIndex12 = 0;\n  let vowelsLength12 = 0;\n  let vowelsIndex13 = 0;\n  let vowelsLength13 = 0;\n  let vowelsIndex14 = 0;\n  let vowelsLength14 = 0;\n  let vowelsIndex15 = 0;\n  let vowelsLength15 = 0;\n  let vowelsIndex16 = 0;\n  let vowelsLength16 = 0;\n  let vowelsIndex17 = 0;\n  let vowelsLength17 = 0;\n  let vowelsIndex18 = 0;\n  let vowelsLength18 = 0;\n  let vowelsIndex19 = 0;\n  let vowelsLength19 = 0;\n  let vowelsIndex20 = 0;\n  let vowelsLength20 = 0;\n  let vowelsIndex21 = 0;\n  let vowelsLength21 = 0;\n  let vowelsIndex22 = 0;\n  let vowelsLength22 = 0;\n  let vowelsIndex23 = 0;\n  let vowelsLength23 = 0;\n  let vowelsIndex24 = 0;\n  let vowelsLength24 = 0;\n  let vowelsIndex25 = 0;\n  let vowelsLength25 = 0;\n  let vowelsIndex26 = 0;\n  let vowelsLength26 = 0;\n  let vowelsIndex27 = 0;\n  let vowelsLength27 = 0;\n  let vowelsIndex28 = 0;\n  let vowelsLength28 = 0;\n  let vowelsIndex29 = 0;\n  let vowelsLength29 = 0;\n  let vowelsIndex30 = 0;\n  let vowelsLength30 = 0;\n  let vowelsIndex31 = 0;\n  let vowelsLength31 = 0;\n  let vowelsIndex32 = 0;\n  let vowelsLength32 = 0;\n  let vowelsIndex33 = 0;\n  let vowelsLength33 = 0;\n  let vowelsIndex34 = 0;\n  let vowelsLength34 = 0;\n  let vowelsIndex35 = 0;\n  let vowelsLength35 = 0;\n  let vowelsIndex36 = 0;\n  let vowelsLength36 = 0;\n  let vowelsIndex37 = 0;\n  let vowelsLength37 = 0;\n  let vowelsIndex38 = 0;\n  let vowelsLength38 = 0;\n  let vowelsIndex39 = 0;\n  let vowelsLength39 = 0;\n  let vowelsIndex40 = 0;\n  let vowelsLength40 = 0;\n  let vowelsIndex41 = 0;\n  let vowelsLength41 = 0;\n  let vowelsIndex42 = 0;\n  let vowelsLength42 = 0;\n  let vowelsIndex43 = 0;\n  let vowelsLength43 = 0;\n  let vowelsIndex44 = 0;\n  let vowelsLength44 = 0;\n  let vowelsIndex45 = 0;\n  let vowelsLength45 = 0;\n  let vowelsIndex46 = 0;\n  let vowelsLength46 = 0;\n  let vowelsIndex47 = 0;\n  let vowelsLength47 = 0;\n  let vowelsIndex48 = 0;\n  let vowelsLength48 = 0;\n  let vowelsIndex49 = 0;\n  let vowelsLength49 = 0;\n  let vowelsIndex50 = 0;\n  let vowelsLength50 = 0;\n  let vowelsIndex51 = 0;\n  let vowelsLength51 = 0;\n  let vowelsIndex52 = 0;\n  let vowelsLength52 = 0;\n  let vowelsIndex53 = 0;\n  let vowelsLength53 = 0;\n  let vowelsIndex54 = 0;\n  let vowelsLength54 = 0;\n  let vowelsIndex55 = 0;\n  let vowelsLength55 = 0;\n  let vowelsIndex56 = 0;\n  let vowelsLength56 = 0;\n  let vowelsIndex57 = 0;\n  let vowelsLength57 = 0;\n  let vowelsIndex58 = 0;\n  let vowelsLength58 = 0;\n  let vowelsIndex59 = 0;\n  let vowelsLength59 = 0;\n  let vowelsIndex60 = 0;\n  let vowelsLength60 = 0;\n  let vowelsIndex61 = 0;\n  let vowelsLength61 = 0;\n  let vowelsIndex62 = 0;\n  let vowelsLength62 = 0;\n  let vowelsIndex63 = 0;\n  let vowelsLength63 = 0;\n  let vowelsIndex64 = 0;\n  let vowelsLength64 = 0;\n  let vowelsIndex65 = 0;\n  let vowelsLength65 = 0;\n  let vowelsIndex66 = 0;\n  let vowelsLength66 = 0;\n  let vowelsIndex67 = 0;\n  let vowelsLength67 = 0;\n  let vowelsIndex68 = 0;\n  let vowelsLength68 = 0;\n  let vowelsIndex69 = 0;\n  let vowelsLength69 = 0;\n  let vowelsIndex70 = 0;\n  let vowelsLength70 = 0;\n  let vowelsIndex71 = 0;\n  let vowelsLength71 = 0;\n  let vowelsIndex72 = 0;\n  let vowelsLength72 = 0;\n  let vowelsIndex73 = 0;\n  let vowelsLength73 = 0;\n  let vowelsIndex74 = 0;\n  let vowelsLength74 = 0;\n  let vowelsIndex75 = 0;\n  let vowelsLength75 = 0;\n  let vowelsIndex76 = 0;\n  let vowelsLength76 = 0;\n  let vowelsIndex77 = 0;\n  let vowelsLength77 = 0;\n  let vowelsIndex78 = 0;\n  let vowelsLength78 = 0;\n  let vowelsIndex79 = 0;\n  let vowelsLength79 = 0;\n  let vowelsIndex80 = 0;\n  let vowelsLength80 = 0;\n  let vowelsIndex81 = 0;\n  let vowelsLength81 = 0;\n  let vowelsIndex82 = 0;\n  let vowelsLength82 = 0;\n  let vowelsIndex83 = 0;\n  let vowelsLength83 = 0;\n  let vowelsIndex84 = 0;\n  let vowelsLength84 = 0;\n  let vowelsIndex85 = 0;\n  let vowelsLength85 = 0;\n  let vowelsIndex86 = 0;\n  let vowelsLength86 = 0;\n  let vowelsIndex87 = 0;\n  let vowelsLength87 = 0;\n  let vowelsIndex88 = 0;\n  let vowelsLength88 = 0;\n  let vowelsIndex89 = 0;\n  let vowelsLength89 = 0;\n  let vowelsIndex90 = 0;\n  let vowelsLength90 = 0;\n  let vowelsIndex91 = 0;\n  let vowelsLength91 = 0;\n  let vowelsIndex92 = 0;\n  let vowelsLength92 = 0;\n  let vowelsIndex93 = 0;\n  let vowelsLength93 = 0;\n  let vowelsIndex94 = 0;\n  let vowelsLength94 = 0;\n  let vowelsIndex95 = 0;\n  let vowelsLength95 = 0;\n  let vowelsIndex96 = 0;\n  let vowelsLength96 = 0;\n  let vowelsIndex97 = 0;\n  let vowelsLength97 = 0;\n  let vowelsIndex98 = 0;\n  let vowelsLength98 = 0;\n  let vowelsIndex99 = 0;\n  let vowelsLength99", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/119", "prompt": "/* You are given a list of two strings, both strings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible to concatenate the two strings in\n  some order, that the resulting string will be good.\n  A string S is considered to be good if and only if all parentheses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "gc": "<|endoftext|>/* You are given a list of two strings, both strings consist of open\n  parentheses '(' or close parentheses ')' only.\n  Your job is to check if it is possible to concatenate the two strings in\n  some order, that the resulting string will be good.\n  A string S is considered to be good if and only if all parentheses in S\n  are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let res = []\n  let stack = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "gc": "<|endoftext|>/* Out of list of strings, return the longest one. Return the first one in case of multiple\n  strings of the same length. Return null in case the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  let longestLength = 0;\n  let longestString = '';\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].length > longestLength) {\n      longestLength = strings[i].length;\n      longestString = strings[i];\n    }\n  }\n  return longestString;\n};\n\n/**\n * Given a string, return its first letter capitalized.\n * >>> capitalize('hello')\n  'Hello'\n  >>> capitalize('Hello world')\n  'Hello world'\n  >>> capitalize('Hello world!')\n  'Hello world!'\n  >>> capitalize('Hello world!?')\n  'Hello world!?'\n  */\nconst capitalize = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n/**\n * Given a string, return its first letter lowercase.\n * >>> lowercase('hello')\n  'hello'\n  >>> lowercase('Hello world')\n  'hello world'\n  >>> lowercase('Hello world!')\n  'hello world'\n  >>> lowercase('Hello world!?')\n  'hello world'\n  */\nconst lowercase = (string) => {\n  return string.charAt(0).toLowerCase() + string.slice(1);\n};\n\n/**\n * Given a string, return its first letter uppercase.\n * >>> uppercase('hello')\n  'HELLO'\n  >>> uppercase('Hello world')\n  'HELLO WORLD'\n  >>> uppercase('Hello world!')\n  'HELLO WORLD'\n  >>> uppercase('Hello world!?')\n  'HELLO WORLD'\n  */\nconst uppercase = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n/**\n * Given a string, return its first letter capitalized.\n * >>> capitalize('hello')\n  'HELLO'\n  >>> capitalize('Hello world')\n  'HELLO WORLD'\n  >>> capitalize('Hello world!')\n  'HELLO WORLD'\n  >>> capitalize('Hello world!?')\n  'HELLO WORLD'\n  */\nconst capitalizeFirstLetter = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n/**\n * Given a string, return its first letter lowercase.\n * >>> lowercase('hello')\n  'hello'\n  >>> lowercase('Hello world')\n  'hello world'\n  >>> lowercase('Hello world!')\n  'hello world'\n  >>> lowercase('Hello world!?')\n  'hello world'\n  */\nconst lowercaseFirstLetter = (string) => {\n  return string.charAt(0).toLowerCase() + string.slice(1);\n};\n\n/**\n * Given a string, return its first letter uppercase.\n * >>> uppercase('hello')\n  'HELLO'\n  >>> uppercase('Hello world')\n  'HELLO WORLD'\n  >>> uppercase('Hello world!')\n  'HELLO WORLD'\n  >>> uppercase('Hello world!?')\n  'HELLO WORLD'\n  */\nconst uppercaseFirstLetter = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\n/**\n * Given a string, return its first letter capitalized.\n * >>> capitalize('hello')\n  'HELLO'\n  >>> capitalize('Hello world')\n  'HELLO WORLD'\n  >>> capitalize('Hello world!')\n  'HELLO WORLD'\n  >>> capitalize('Hello world!?')\n  'HELLO WORLD'\n  */\nconst capitalizeFirstLetterFirstLetter = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1) + string.charAt(0);\n};\n\n/**\n * Given a string, return its first letter lowercase.\n * >>> lowercase('hello')\n  'hello'\n  >>> lowercase('Hello world')\n  'hello world'\n  >>> lowercase('Hello world!')\n  'hello world'\n  >>> lowercase('Hello world!?')\n  'hello world'\n  */\nconst lowercaseFirstLetterFirstLetter = (string) => {\n  return string.charAt(0).toLowerCase() + string.slice(1) + string.charAt(0);\n};\n\n/**\n * Given a string, return its first letter uppercase.\n * >>> uppercase('hello')\n  'HELLO'\n  >>> uppercase('Hello world')\n  'HELLO WORLD'\n  >>> uppercase('Hello world!')\n  'HELLO WORLD'\n  >>> uppercase('Hello world!?')\n  'HELLO WORLD'\n  */\nconst uppercaseFirstLetterFirstLetter = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1) + string.charAt(0);\n};\n\n/**\n * Given a string, return its first letter capitalized.\n * >>> capitalize('hello')\n  'HELLO'\n  >>> capitalize('Hello world')\n  'HELLO WORLD'\n  >>> capitalize('Hello world!')\n  'HELLO WORLD'\n  >>> capitalize('Hello world!?')\n  'HELLO WORLD'\n  */\nconst capitalizeFirstLetterFirstLetterFirstLetter = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1) + string.charAt(0) + string.charAt(0);\n};\n\n/**\n * Given a string, return its first letter lowercase.\n * >>> lowercase('hello')\n  'hello'\n  >>> lowercase('Hello world')\n  'hello world'\n  >>> lowercase('Hello world!')\n  'hello world'\n  >>> lowercase('Hello world!?')\n  'hello world'\n  */\nconst lowercaseFirstLetterFirstLetterFirstLetter = (string) => {\n  return string.charAt(0).toLowerCase() + string.slice(1) + string.charAt(0) + string.charAt(0);\n};\n\n/**\n * Given a string, return its first letter uppercase.\n * >>> uppercase('hello')\n  'HELLO'\n  >>> uppercase('Hello world')\n  'HELLO WORLD'\n  >>> uppercase('Hello world!')\n  'HELLO WORLD'\n  >>> uppercase('Hello world!?')\n  'HELLO WORLD'\n  */\nconst uppercaseFirstLetterFirstLetterFirstLetter = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1) + string.charAt(0) + string.charAt(0);\n};\n\n/**\n * Given a string, return its first letter capitalized.\n * >>> capitalize('hello')\n  'HELLO'\n  >>> capitalize('Hello world')\n  'HELLO WORLD'\n  >>> capitalize('Hello world!')\n  'HELLO WORLD'\n  >>> capitalize('Hello world!?')\n  'HELLO WORLD'\n  */\nconst capitalizeFirstLetterFirstLetterFirstLetterFirstLetter = (string) => {\n  return string.charAt(0).toUpperCase() + string.slice(1) + string.charAt(0) + string.charAt(0) + string.charAt(0);\n};\n\n/**\n * Given a string, return its first letter lowercase.\n * >>> lowercase('hello')\n  'hello'\n  >>> lowercase('Hello world')\n  'hello world'\n  >>> lowercase('Hello world!')\n  'hello world'\n  >>> lowercase('Hello world!?')\n  'hello world'\n  */\nconst lowercaseFirstLetterFirstLetterFirstLetterFirstLetter = (string) => {\n  return string.charAt(0).toLowerCase() + string.slice(1) + string.charAt(0) + string.charAt(0) + string.charAt(0);\n};\n\n/**\n * Given a string, return its first letter uppercase.\n * >>> uppercase('hello')\n  'HELLO'\n  >>> uppercase('Hello world')\n  'HELLO WORLD'\n  >>> uppercase('Hello world!')\n  'HELLO WORLD'\n  >>> uppercase('Hello world!?')\n  'HELLO WOR", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/120", "prompt": "/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n  of length k with the maxmium k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maxmium = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maxmium", "gc": "<|endoftext|>/*\n  Given an array arr of integers and a positive integer k, return a sorted list \n  of length k with the maxmium k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maxmium = (arr, k) => {\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return [arr[maxIndex], maxIndex];\n};\n\n/**\n * Given an array arr of integers and a positive integer k, return a sorted list \n * of length k with the minimum k numbers in arr.\n\n * Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst minmium = (arr, k) => {\n  let min = 0;\n  let minIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      minIndex = i;\n    }\n  }\n  return [arr[minIndex], minIndex];\n};\n\n/**\n * Given an array arr of integers and a positive integer k, return a sorted list \n * of length k with the maximum k numbers in arr.\n\n * Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst max = (arr, k) => {\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return [arr[maxIndex], maxIndex];\n};\n\n/**\n * Given an array arr of integers and a positive integer k, return a sorted list \n * of length k with the minimum k numbers in arr.\n\n * Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst min = (arr, k) => {\n  let min = 0;\n  let minIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > min) {\n      min = arr[i];\n      minIndex = i;\n    }\n  }\n  return [arr[minIndex], minIndex];\n};\n\n/**\n * Given an array arr of integers and a positive integer k, return a sorted list \n * of length k with the maximum k numbers in arr.\n\n * Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst max = (arr, k) => {\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return [arr[maxIndex], maxIndex];\n};\n\n/**\n * Given an array arr of integers and a positive integer k, return a sorted list \n * of length k with the minimum k numbers in arr.\n\n * Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst min = (arr, k) => {\n  let min = 0;\n  let minIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      minIndex = i;\n    }\n  }\n  return [arr[minIndex], minIndex];\n};\n\n/**\n * Given an array arr of integers and a positive integer k, return a sorted list \n * of length k with the maximum k numbers in arr.\n\n * Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst max = (arr, k) => {\n  let max = 0;\n  let maxIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIndex = i;\n    }\n  }\n  return [arr[maxIndex], maxIndex];\n};\n\n/**\n * Given an array arr of integers and a positive integer k, return a sorted list \n * of length k with the minimum k numbers in arr.\n\n * Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst min = (arr, k) => {\n  let min = 0;\n  let minIndex = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < min) {\n      min = arr[i];\n      minIndex = i;\n    }\n  }\n  return [arr[minIndex], minIndex];\n};\n\n/**", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/121", "prompt": "/*Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "gc": "<|endoftext|>/*Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solution,\n};\n\n},{}],4:[function(require,module,exports){\n/*\n  Implement a function to check if a number is palindrome. \n  \n  Examples\n  \n  is_palindrome(12) ==> true\n  is_palindrome(13) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> true\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_palindrome(121) ==> false\n  is_p", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/122", "prompt": "/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "gc": "<|endoftext|>/*\n  Given a non-empty array of integers arr and an integer k, return\n  the sum of the elements with at most two digits from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  const len = arr.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    const digit = arr[i];\n    if (digit >= 10) {\n      sum += digit - 10;\n    } else {\n      sum += digit;\n    }\n  }\n  return sum + addElements(arr.slice(k), k);\n};\n\n// https://leetcode.com/problems/sum-of-digits-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar sumOfDigits = function (nums) {\n  const len = nums.length;\n  let sum = 0;\n  for (let i = 0; i < len; i++) {\n    sum += nums[i];\n  }\n  return sum;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctNumbers = function (nums) {\n  const len = nums.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (nums.indexOf(i) === i) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-unique-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findUniqueNumbers = function (nums) {\n  const len = nums.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (nums.indexOf(i)!== i) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctSubarray = function (nums) {\n  const len = nums.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (nums.indexOf(i) === i) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-unique-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findUniqueSubarray = function (nums) {\n  const len = nums.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (nums.indexOf(i)!== i) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctSubarrayWithOdd = function (nums) {\n  const len = nums.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (nums.indexOf(i)!== i && nums.indexOf(i)!== i + 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-unique-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findUniqueSubarrayWithOdd = function (nums) {\n  const len = nums.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (nums.indexOf(i)!== i && nums.indexOf(i)!== i + 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctSubarrayWithEven = function (nums) {\n  const len = nums.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (nums.indexOf(i)!== i && nums.indexOf(i)!== i + 2) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-unique-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findUniqueSubarrayWithEven = function (nums) {\n  const len = nums.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (nums.indexOf(i)!== i && nums.indexOf(i)!== i + 2) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctSubarrayWithOddEven = function (nums) {\n  const len = nums.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (nums.indexOf(i)!== i && nums.indexOf(i)!== i + 3 && nums.indexOf(i)!== i + 4) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-unique-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findUniqueSubarrayWithOddEven = function (nums) {\n  const len = nums.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (nums.indexOf(i)!== i && nums.indexOf(i)!== i + 3 && nums.indexOf(i)!== i + 4) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctSubarrayWithOddOddEven = function (nums) {\n  const len = nums.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (nums.indexOf(i)!== i && nums.indexOf(i)!== i + 3 && nums.indexOf(i)!== i + 4) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-unique-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findUniqueSubarrayWithOddOddOddEven = function (nums) {\n  const len = nums.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (nums.indexOf(i)!== i && nums.indexOf(i)!== i + 3 && nums.indexOf(i)!== i + 4) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctSubarrayWithOddOddOddOddEven = function (nums) {\n  const len = nums.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (nums.indexOf(i)!== i && nums.indexOf(i)!== i + 3 && nums.indexOf(i)!== i + 4) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-unique-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findUniqueSubarrayWithOddOddOddOddOddOddEven = function (nums) {\n  const len = nums.length;\n  let count = 0;\n  for (let i = 0; i < len; i++) {\n    if (nums.indexOf(i)!== i && nums.indexOf(i)!== i + 3 && nums.indexOf(i)!== i + 4) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "gc": "<|endoftext|>/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let collatz = [];\n  let current = 1;\n  let next = 1;\n  while (current <= n) {\n    if (n % 2 === 0) {\n      collatz.push(current);\n      current = next;\n      next = 3;\n    } else {\n      collatz.push(current);\n      current = next;\n      next = 1;\n    }\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the even numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5, 16, 8, 4, 2] # The collatz sequence for 5 is [1, 5, 16, 8, 4, 2, 1], so the even numbers are 1, 5, 16, 8, 4, 2, 5.\n  */\nconst getEvenCollatz = (n) => {\n  let collatz = [];\n  let current = 1;\n  let next = 1;\n  while (current <= n) {\n    if (n % 2 === 0) {\n      collatz.push(current);\n      current = next;\n      next = 3;\n    } else {\n      collatz.push(current);\n      current = next;\n      next = 1;\n    }\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 3, 5, 7, 11, 13, 17, 19] # The collatz sequence for 5 is [1, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997].\n  */\nconst getPrimeCollatz = (n) => {\n  let collatz = [];\n  let current = 1;\n  let next = 1;\n  while (current <= n) {\n    if (n % 2 === 0) {\n      collatz.push(current);\n      current = next;\n      next = 3;\n    } else {\n      collatz.push(current);\n      current = next;\n      next = 1;\n    }\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the natural numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getNaturalCollatz(5) returns [1, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120, 125, 130, 135, 140, 145, 150, 155, 160, 165, 170, 175, 180, 185, 190, 195, 200, 205, 210, 215, 220, 225, 230, 235, 240, 245, 250, 255, 260, 265, 270, 275, 280, 285, 290, 295, 300, 305, 310, 315, 325, 330, 335, 340, 345, 350, 355, 360, 365, 370, 375, 380, 385, 390, 395, 400, 405, 410, 415, 420, 425, 430, 435, 440, 445, 450, 455, 460, 465, 470, 475, 480, 485].\n  */\nconst getNaturalCollatz = (n) => {\n  let collatz = [];\n  let current = 1;\n  let next = 1;\n  while (current <= n) {\n    if (n % 2 === 0) {\n      collatz.push(current);\n      current = next;\n      next = 3;\n    } else {\n      collatz.push(current);\n      current = next;\n      next = 1;\n    }\n  }\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime factors in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/124", "prompt": "/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "gc": "<|endoftext|>/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const dateString = date.toString();\n  const dateParts = dateString.split('-');\n  const dateYear = dateParts[0];\n  const dateMonth = dateParts[1];\n  const dateDay = dateParts[2];\n  const dateYearParts = dateYear.split('-');\n  const dateMonthParts = dateMonth.split('-');\n  const dateDayParts = dateDay.split('-');\n  const dateDaysInMonth = dateDayParts.length - 1;\n  const dateDaysValid = dateDaysInMonth > 0 && dateDaysInMonth < 31;\n  const dateMonthValid = dateMonthParts.length < 1 || dateMonthParts.length > 12;\n  const dateYearValid = dateYearParts.length < 1 || dateYearParts.length > 4;\n  return dateDaysValid && dateMonthValid && dateYearValid;\n};\n\n/**\n * Converts a date string to a date object.\n *\n * @param {String} date The date string in the format: mm-dd-yyyy\n * @return {Date}\n */\nconst parseDate = (date) => {\n  const dateParts = date.toString().split('-');\n  const dateYear = dateParts[0];\n  const dateMonth = dateParts[1];\n  const dateDay = dateParts[2];\n  const dateYearParts = dateYear.split('-');\n  const dateMonthParts = dateMonth.split('-');\n  const dateDayParts = dateDay.split('-');\n  const dateDaysInMonth = dateDayParts.length - 1;\n  const dateDaysValid = dateDaysInMonth > 0 && dateDaysInMonth < 31;\n  const dateMonthValid = dateMonthParts.length < 1 || dateMonthParts.length > 12;\n  const dateYearValid = dateYearParts.length < 1 || dateYearParts.length > 4;\n  const date = new Date(dateYearParts[0], dateMonthParts[0], dateDayParts[0]);\n  date.setFullYear(dateYearParts[0], dateMonthParts[0], dateDayParts[0]);\n  date.setHours(0, 0, 0, 0);\n  date.setDate(dateDayParts[0]);\n  date.setMonth(dateMonthParts[0]);\n  date.setDate(dateDayParts[1]);\n  date.setHours(0, 0, 0, 0);\n  date.setDate(dateDayParts[2]);\n  date.setMonth(dateMonthParts[1]);\n  date.setDate(dateDayParts[2]);\n  date.setHours(0, 0, 0, 0);\n  date.setDate(dateDayParts[3]);\n  date.setMonth(dateMonthParts[2]);\n  date.setDate(dateDayParts[3]);\n  date.setHours(0, 0, 0, 0);\n  date.setDate(dateDayParts[4]);\n  date.setMonth(dateMonthParts[3]);\n  date.setDate(dateDayParts[4]);\n  date.setHours(0, 0, 0, 0);\n  date.setDate(dateDayParts[5]);\n  date.setMonth(dateMonthParts[4]);\n  date.setDate(dateDayParts[5]);\n  date.setHours(0, 0, 0, 0);\n  date.setDate(dateDayParts[6]);\n  date.setMonth(dateMonthParts[5]);\n  date.setDate(dateDayParts[6]);\n  date.setHours(0, 0, 0, 0);\n  date.setDate(dateDayParts[7]);\n  date.setMonth(dateMonthParts[6]);\n  date.setDate(dateDayParts[7]);\n  date.setHours(0, 0, 0, 0);\n  date.setDate(dateDayParts[8]);\n  date.setMonth(dateMonthParts[7]);\n  date.setDate(dateDayParts[8]);\n  date.setHours(0, 0, 0, 0);\n  date.setDate(dateDayParts[9]);\n  date.setMonth(dateMonthParts[8]);\n  date.setDate(dateDayParts[9]);\n  date.setHours(0, 0, 0, 0);\n  date.setDate(dateDayParts[10]);\n  date.setMonth(dateMonthParts[9]);\n  date.setDate(dateDayParts[10]);\n  date.setHours(0, 0, 0, 0);\n  date.setDate(dateDayParts[11]);\n  date.setMonth(dateMonthParts[10]);\n  date.setDate(dateDayParts[11]);\n  date.setHours(0, 0, 0, 0);\n  date.setDate(dateDayParts[12]);\n  date.setMonth(dateMonthParts[11]);\n  date.setDate(dateDayParts[12]);\n  date.setHours(0, 0, 0, 0);\n  date.setDate(dateDayParts[13]);\n  date.setMonth(dateMonthParts[12]);\n  date.setDate(dateDayParts[13]);\n  date.setHours(0, 0, 0, 0);\n  date.setDate(dateDayParts[14]);\n  date.setMonth(dateMonthParts[13]);\n  date.setDate(dateDayParts[14]);\n  date.setHours(0, 0, 0, 0);\n  date.setDate(dateDayParts[15]);\n  date.setMonth(dateMonthParts[14]);\n  date.setDate(dateDayParts[15]);\n  date.setHours(0, 0, 0, 0);\n  date.setDate(dateDayParts[16]);\n  date.setMonth(dateMonthParts[15]);\n  date.setDate(dateDayParts[16]);\n  date.setHours(0, 0, 0, 0);\n  date.setDate(dateDayParts[17]);\n  date.setMonth(dateMonthParts[16]);\n  date.setDate(dateDayParts[17]);\n  date.setHours(0, 0, 0, 0);\n  date.setDate(dateDayParts[18]);\n  date.setMonth(dateMonthParts[17]);\n  date.setDate(dateDayParts[18]);\n  date.setHours(0, 0, 0, 0);\n  date.setDate(dateDayParts[19]);\n  date.setMonth(dateMonthParts[18]);\n  date.setDate(dateDayParts[19]);\n  date.setHours(0, 0, 0, 0);\n  date.setDate(dateDayParts[20]);\n  date.setMonth(dateMonthParts[19]);\n  date.setDate(dateDayParts[20]);\n  date.setHours(0, 0, 0, 0);\n  date.setDate(dateDayParts[21]);\n  date.setMonth(dateMonthParts[20]);\n  date.setDate(dateDayParts[21]);\n  date.setHours(0, 0, 0, 0);\n  date.setDate(dateDayParts[22]);\n  date.setMonth(dateMonthParts[21]);\n  date.setDate(dateDayParts[22]);\n  date.setHours(0, 0, 0, 0);\n  date.setDate(dateDayParts[23]);\n  date.setMonth(dateMonthParts[22]);\n  date.setDate(dateDayParts[23]);\n  date.setHours(0, 0, 0, 0);\n  date.setDate(dateDayParts[24]);\n  date.setMonth(dateMonthParts[23]);\n  date.setDate(", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/125", "prompt": "/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "gc": "<|endoftext|>/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  let words = txt.split(' ');\n  let wordCount = 0;\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length > 0) {\n      wordCount += 1;\n    }\n  }\n  return wordCount;\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsOdd = (txt) => {\n  let words = txt.split(' ');\n  let wordCount = 0;\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length > 0) {\n      wordCount += 1;\n    }\n  }\n  return wordCount;\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsEven = (txt) => {\n  let words = txt.split(' ');\n  let wordCount = 0;\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length > 0) {\n      wordCount += 1;\n    }\n  }\n  return wordCount;\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsOddEven = (txt) => {\n  let words = txt.split(' ');\n  let wordCount = 0;\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length > 0) {\n      wordCount += 1;\n    }\n  }\n  return wordCount;\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsOddEvenOdd = (txt) => {\n  let words = txt.split(' ');\n  let wordCount = 0;\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length > 0) {\n      wordCount += 1;\n    }\n  }\n  return wordCount;\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsOddEvenOddOdd = (txt) => {\n  let words = txt.split(' ');\n  let wordCount = 0;\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length > 0) {\n      wordCount += 1;\n    }\n  }\n  return wordCount;\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsOddEvenOddOddOdd = (txt) => {\n  let words = txt.split(' ');\n  let wordCount = 0;\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length > 0) {\n      wordCount += 1;\n    }\n  }\n  return wordCount;\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsOddEvenOddOddOddOdd = (txt) => {\n  let words = txt.split(' ');\n  let wordCount = 0;\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i];\n    if (word.length > 0) {\n      wordCount += 1;\n    }\n  }\n  return wordCount;\n};\n\n/* Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n  should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n  alphabet, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsOddEvenOddOddOddOddOdd = (txt) => {\n  let words = txt.split(' ');\n  let wordCount = 0;\n  for (let i = 0; i < words.length; i++) {\n    let word = word", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/126", "prompt": "/* Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "gc": "<|endoftext|>/* Given a list of numbers, return whether or not they are sorted\n  in ascending order. If list has more than 1 duplicate of the same\n  number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  let isSorted = true;\n  let i = 0;\n  let j = lst.length - 1;\n  while (i < j) {\n    if (lst[i] > lst[j]) {\n      isSorted = false;\n      break;\n    }\n    i++;\n    j--;\n  }\n  return isSorted;\n};\n\n/* Given an array of numbers, return an array with unique elements. If\n  list has more than 1 duplicate of the same number, return an empty\n  array. Assume no negative numbers and only integers.\n  Examples\n  unique([5, 3, 1]) ➞ [[5, 3], [1, 3]]\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, 1]) ➞ []\n  unique([5, 3, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/127", "prompt": "/*You are given two intervals,\n  where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "gc": "<|endoftext|>/*You are given two intervals,\n  where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n  const [start3, end3] = interval2;\n  const [start4, end4] = interval2;\n  const [start5, end5] = interval2;\n  const [start6, end6] = interval2;\n  const [start7, end7] = interval2;\n  const [start8, end8] = interval2;\n  const [start9, end9] = interval2;\n  const [start10, end10] = interval2;\n  const [start11, end11] = interval2;\n  const [start12, end12] = interval2;\n  const [start13, end13] = interval2;\n  const [start14, end14] = interval2;\n  const [start15, end15] = interval2;\n  const [start16, end16] = interval2;\n  const [start17, end17] = interval2;\n  const [start18, end18] = interval2;\n  const [start19, end19] = interval2;\n  const [start20, end20] = interval2;\n  const [start21, end21] = interval2;\n  const [start22, end22] = interval2;\n  const [start23, end23] = interval2;\n  const [start24, end24] = interval2;\n  const [start25, end25] = interval2;\n  const [start26, end26] = interval2;\n  const [start27, end27] = interval2;\n  const [start28, end28] = interval2;\n  const [start29, end29] = interval2;\n  const [start30, end30] = interval2;\n  const [start31, end31] = interval2;\n  const [start32, end32] = interval2;\n  const [start33, end33] = interval2;\n  const [start34, end34] = interval2;\n  const [start35, end35] = interval2;\n  const [start36, end36] = interval2;\n  const [start37, end37] = interval2;\n  const [start38, end38] = interval2;\n  const [start39, end39] = interval2;\n  const [start40, end40] = interval2;\n  const [start41, end41] = interval2;\n  const [start42, end42] = interval2;\n  const [start43, end43] = interval2;\n  const [start44, end44] = interval2;\n  const [start45, end45] = interval2;\n  const [start46, end46] = interval2;\n  const [start47, end47] = interval2;\n  const [start48, end48] = interval2;\n  const [start49, end49] = interval2;\n  const [start50, end50] = interval2;\n  const [start51, end51] = interval2;\n  const [start52, end52] = interval2;\n  const [start53, end53] = interval2;\n  const [start54, end54] = interval2;\n  const [start55, end55] = interval2;\n  const [start56, end56] = interval2;\n  const [start57, end57] = interval2;\n  const [start58, end58] = interval2;\n  const [start59, end59] = interval2;\n  const [start60, end60] = interval2;\n  const [start61, end61] = interval2;\n  const [start62, end62] = interval2;\n  const [start63, end63] = interval2;\n  const [start64, end64] = interval2;\n  const [start65, end65] = interval2;\n  const [start66, end66] = interval2;\n  const [start67, end67] = interval2;\n  const [start68, end68] = interval2;\n  const [start69, end69] = interval2;\n  const [start70, end70] = interval2;\n  const [start71, end71] = interval2;\n  const [start72, end72] = interval2;\n  const [start73, end73] = interval2;\n  const [start74, end74] = interval2;\n  const [start75, end75] = interval2;\n  const [start76, end76] = interval2;\n  const [start77, end77] = interval2;\n  const [start78, end78] = interval2;\n  const [start79, end79] = interval2;\n  const [start80, end80] = interval2;\n  const [start81, end81] = interval2;\n  const [start82, end82] = interval2;\n  const [start83, end83] = interval2;\n  const [start84, end84] = interval2;\n  const [start85, end85] = interval2;\n  const [start86, end86] = interval2;\n  const [start87, end87] = interval2;\n  const [start88, end88] = interval2;\n  const [start89, end89] = interval2;\n  const [start90, end90] = interval2;\n  const [start91, end91] = interval2;\n  const [start92, end92] = interval2;\n  const [start93, end93] = interval2;\n  const [start94, end94] = interval2;\n  const [start95, end95] = interval2;\n  const [start96, end96] = interval2;\n  const [start97, end97] = interval2;\n  const [start98, end98] = interval2;\n  const [start99, end99] = interval2;\n  const [start100, end100] = interval2;\n  const [start101, end101] = interval2;\n  const [start102, end102] = interval2;\n  const [start103, end103] = interval2;\n  const [start104, end104] = interval2;\n  const [start105, end105] = interval2;\n  const [start106, end106] = interval2;\n  const [start107, end107] = interval2;\n  const [start108, end108] = interval2;\n  const [start109, end109] = interval2;\n  const [start110, end110] = interval2;\n  const [start111, end111] = interval2;\n  const [start112, end112] = interval2;\n  const [start113, end113] = interval2;\n  const [start114, end114] = interval2;\n  const [start115, end115] = interval2;\n  const [start116, end116] = interval2;\n  const [start117, end117] = interval2;\n  const [start118, end118] = interval2;\n  const [start119, end119] = interval2;\n  const [start120, end120] = interval2;\n  const [start121, end121] = interval2;\n  const [start122, end122] = interval2;\n  const [start123, end123] = interval2;\n  const [start124, end124] = interval2;\n  const [start125, end125] = interval2;\n  const [start126, end126] = interval2;\n  const [start127, end127] = interval2;\n  const [start128, end128] = interval2;\n  const [start129, end129] = interval2;\n  const [start", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/128", "prompt": "/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigsn([1, 2, 2, -4]) == -9\n  >>> prodSigsn([0, 1]) == 0\n  >>> prodSigsn([]) == null\n  */\nconst prodSigsn = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigsn", "gc": "<|endoftext|>/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigsn([1, 2, 2, -4]) == -9\n  >>> prodSigsn([0, 1]) == 0\n  >>> prodSigsn([]) == null\n  */\nconst prodSigsn = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = arr.map(sign => sign > 0? 1 : -1)\n  const product = signs.reduce((acc, cur) => acc * cur)\n  return product === 0? '0' : product\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigsn([1, 2, 2, -4]) == -9\n  >>> prodSigsn([0, 1]) == 0\n  >>> prodSigsn([]) == null\n  */\nconst prodSigsd = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = arr.map(sign => sign > 0? 1 : -1)\n  const product = signs.reduce((acc, cur) => acc * cur)\n  return product === 0? '0' : product\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigsd([1, 2, 2, -4]) == -9\n  >>> prodSigsd([0, 1]) == 0\n  >>> prodSigsd([]) == null\n  */\nconst prodSigss = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = arr.map(sign => sign > 0? 1 : -1)\n  const product = signs.reduce((acc, cur) => acc * cur)\n  return product === 0? '0' : product\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigss([1, 2, 2, -4]) == -9\n  >>> prodSigss([0, 1]) == 0\n  >>> prodSigss([]) == null\n  */\nconst prodSigsd = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = arr.map(sign => sign > 0? 1 : -1)\n  const product = signs.reduce((acc, cur) => acc * cur)\n  return product === 0? '0' : product\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigss([1, 2, 2, -4]) == -9\n  >>> prodSigss([0, 1]) == 0\n  >>> prodSigss([]) == null\n  */\nconst prodSigss = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = arr.map(sign => sign > 0? 1 : -1)\n  const product = signs.reduce((acc, cur) => acc * cur)\n  return product === 0? '0' : product\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigss([1, 2, 2, -4]) == -9\n  >>> prodSigss([0, 1]) == 0\n  >>> prodSigss([]) == null\n  */\nconst prodSigsd = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = arr.map(sign => sign > 0? 1 : -1)\n  const product = signs.reduce((acc, cur) => acc * cur)\n  return product === 0? '0' : product\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigss([1, 2, 2, -4]) == -9\n  >>> prodSigss([0, 1]) == 0\n  >>> prodSigss([]) == null\n  */\nconst prodSigss = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = arr.map(sign => sign > 0? 1 : -1)\n  const product = signs.reduce((acc, cur) => acc * cur)\n  return product === 0? '0' : product\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigss([1, 2, 2, -4]) == -9\n  >>> prodSigss([0, 1]) == 0\n  >>> prodSigss([]) == null\n  */\nconst prodSigsd = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = arr.map(sign => sign > 0? 1 : -1)\n  const product = signs.reduce((acc, cur) => acc * cur)\n  return product === 0? '0' : product\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigss([1, 2, 2, -4]) == -9\n  >>> prodSigss([0, 1]) == 0\n  >>> prodSigss([]) == null\n  */\nconst prodSigss = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = arr.map(sign => sign > 0? 1 : -1)\n  const product = signs.reduce((acc, cur) => acc * cur)\n  return product === 0? '0' : product\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigss([1, 2, 2, -4]) == -9\n  >>> prodSigss([0, 1]) == 0\n  >>> prodSigss([]) == null\n  */\nconst prodSigsd = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = arr.map(sign => sign > 0? 1 : -1)\n  const product = signs.reduce((acc, cur) => acc * cur)\n  return product === 0? '0' : product\n}\n\n/*\n  You are given an array arr of integers and you need to return\n  sum of magnitudes of integers multiplied by product of all signs\n  of each number in the array, represented by 1, -1 or 0.\n  Note: return null for empty arr.\n\n  Example:\n  >>> prodSigss([1, 2, 2, -4]) == -9\n  >>> prodSigss([0, 1]) == 0\n  >>> prodSigss([]) == null\n  */\nconst prodSigss = (arr) => {\n  if (arr.length === 0) {\n    return null\n  }\n  const signs = arr.map(sign => sign > 0? 1 : -1)\n  const product = signs.reduce((acc, cur) => acc * cur)\n  return ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "gc": "<|endoftext|>/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const [rows, cols] = grid.length;\n  const [gridValues, gridIndex] = createGridValues(grid, k);\n  const [minPathValues, minPathIndex] = findMinPath(gridValues, gridIndex);\n  return [...minPathValues,...minPathIndex];\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-from-a-given-grid/\nconst findMinPath = (gridValues, gridIndex) => {\n  const [minPathValues, minPathIndex] = createMinPath(gridValues, gridIndex);\n  return [...minPathValues,...minPathIndex];\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-from-a-given-grid/\nconst createMinPath = (gridValues, gridIndex) => {\n  const [minPathValues, minPathIndex] = createGridValues(gridValues, gridIndex);\n  return [...minPathValues,...minPathIndex];\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-from-a-given-grid/\nconst createGridValues = (grid, k) => {\n  const [gridValues, gridIndex] = createGridValuesHelper(grid, k);\n  return [...gridValues,...gridIndex];\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-from-a-given-grid/\nconst createGridValuesHelper = (grid, k) => {\n  const [gridValues, gridIndex] = createGridValuesHelperHelper(grid, k);\n  return [...gridValues,...gridIndex];\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-from-a-given-grid/\nconst createGridValuesHelperHelper = (grid, k) => {\n  const [gridValues, gridIndex] = createGridValuesHelperHelperHelper(grid, k);\n  return [...gridValues,...gridIndex];\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-from-a-given-grid/\nconst createGridValuesHelperHelper = (grid, k) => {\n  const [gridValues, gridIndex] = createGridValuesHelperHelperHelper(grid, k);\n  return [...gridValues,...gridIndex];\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-from-a-given-grid/\nconst createGridValuesHelperHelper = (grid, k) => {\n  const [gridValues, gridIndex] = createGridValuesHelperHelperHelper(grid, k);\n  return [...gridValues,...gridIndex];\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-from-a-given-grid/\nconst createGridValuesHelperHelper = (grid, k) => {\n  const [gridValues, gridIndex] = createGridValuesHelperHelperHelper(grid, k);\n  return [...gridValues,...gridIndex];\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-from-a-given-grid/\nconst createGridValuesHelperHelper = (grid, k) => {\n  const [gridValues, gridIndex] = createGridValuesHelperHelperHelper(grid, k);\n  return [...gridValues,...gridIndex];\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-from-a-given-grid/\nconst createGridValuesHelperHelper = (grid, k) => {\n  const [gridValues, gridIndex] = createGridValuesHelperHelper(grid, k);\n  return [...gridValues,...gridIndex];\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-from-a-given-grid/\nconst createGridValuesHelperHelper = (grid, k) => {\n  const [gridValues, gridIndex] = createGridValuesHelperHelper(grid, k);\n  return [...gridValues,...gridIndex];\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-from-a-given-grid/\nconst createGridValuesHelperHelper = (grid, k) => {\n  const [gridValues, gridIndex] = createGridValuesHelperHelper(grid, k);\n  return [...gridValues,...gridIndex];\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-from-a-given-grid/\nconst createGridValuesHelperHelper = (grid, k) => {\n  const [gridValues, gridIndex] = createGridValuesHelperHelper(grid, k);\n  return [...gridValues,...gridIndex];\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-from-a-given-grid/\nconst createGridValuesHelperHelper = (grid, k) => {\n  const [gridValues, gridIndex] = createGridValuesHelperHelper(grid, k);\n  return [...gridValues,...gridIndex];\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-from-a-given-grid/\nconst createGridValuesHelperHelper = (grid, k) => {\n  const [gridValues, gridIndex] = createGridValuesHelperHelper(grid, k);\n  return [...gridValues,...gridIndex];\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-from-a-given-grid/\nconst createGridValuesHelperHelper = (grid, k) => {\n  const [gridValues, gridIndex] = createGridValuesHelperHelper(grid, k);\n  return [...gridValues,...gridIndex];\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-from-a-given-grid/\nconst createGridValuesHelperHelper = (grid, k) => {\n  const [gridValues, gridIndex] = createGridValuesHelperHelper(grid, k);\n  return [...gridValues,...gridIndex];\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-from-a-given-grid/\nconst createGridValuesHelperHelper = (grid, k) => {\n  const [grid", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/13", "prompt": "/* Return a greatest common divisor of two integers a and b\n  >>> rgeatestCommonDivisor(3, 5)\n  1\n  >>> rgeatestCommonDivisor(25, 15)\n  5\n  */\nconst rgeatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "rgeatestCommonDivisor", "gc": "<|endoftext|>/* Return a greatest common divisor of two integers a and b\n  >>> rgeatestCommonDivisor(3, 5)\n  1\n  >>> rgeatestCommonDivisor(25, 15)\n  5\n  */\nconst rgeatestCommonDivisor = (a, b) => {\n  let gcd = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n\n  while (i < a && j < b) {\n    if (a % j === 0) {\n      gcd *= j;\n    }\n    i++;\n    j++;\n  }\n\n  while (i < a) {\n    gcd *= i;\n    i++;\n  }\n\n  while (j < b) {\n    gcd *= j;\n    j++;\n  }\n\n  while (k < a) {\n    gcd *= k;\n    k++;\n  }\n\n  while (l < b) {\n    gcd *= l;\n    l++;\n  }\n\n  return gcd;\n};\n\n/**\n * Return the greatest common divisor of a and b\n * >>> rgeatestCommonDivisor(25, 15)\n * 5\n */\nconst rgeatestCommonDivisor2 = (a, b) => {\n  let gcd = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n\n  while (i < a && j < b) {\n    if (a % j === 0) {\n      gcd *= j;\n    }\n    i++;\n    j++;\n  }\n\n  while (i < a) {\n    gcd *= i;\n    i++;\n  }\n\n  while (j < b) {\n    gcd *= j;\n    j++;\n  }\n\n  while (k < a) {\n    gcd *= k;\n    k++;\n  }\n\n  while (l < b) {\n    gcd *= l;\n    l++;\n  }\n\n  return gcd;\n};\n\n/**\n * Return the greatest common divisor of a and b\n * >>> rgeatestCommonDivisor2(25, 15)\n * 5\n */\nconst rgeatestCommonDivisor3 = (a, b) => {\n  let gcd = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n\n  while (i < a && j < b) {\n    if (a % j === 0) {\n      gcd *= j;\n    }\n    i++;\n    j++;\n  }\n\n  while (i < a) {\n    gcd *= i;\n    i++;\n  }\n\n  while (j < b) {\n    gcd *= j;\n    j++;\n  }\n\n  while (k < a) {\n    gcd *= k;\n    k++;\n  }\n\n  while (l < b) {\n    gcd *= l;\n    l++;\n  }\n\n  return gcd;\n};\n\n/**\n * Return the greatest common divisor of a and b\n * >>> rgeatestCommonDivisor3(25, 15)\n * 5\n */\nconst rgeatestCommonDivisor4 = (a, b) => {\n  let gcd = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n\n  while (i < a && j < b) {\n    if (a % j === 0) {\n      gcd *= j;\n    }\n    i++;\n    j++;\n  }\n\n  while (i < a) {\n    gcd *= i;\n    i++;\n  }\n\n  while (j < b) {\n    gcd *= j;\n    j++;\n  }\n\n  while (k < a) {\n    gcd *= k;\n    k++;\n  }\n\n  while (l < b) {\n    gcd *= l;\n    l++;\n  }\n\n  return gcd;\n};\n\n/**\n * Return the greatest common divisor of a and b\n * >>> rgeatestCommonDivisor4(25, 15)\n * 5\n */\nconst rgeatestCommonDivisor5 = (a, b) => {\n  let gcd = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n\n  while (i < a && j < b) {\n    if (a % j === 0) {\n      gcd *= j;\n    }\n    i++;\n    j++;\n  }\n\n  while (i < a) {\n    gcd *= i;\n    i++;\n  }\n\n  while (j < b) {\n    gcd *= j;\n    j++;\n  }\n\n  while (k < a) {\n    gcd *= k;\n    k++;\n  }\n\n  while (l < b) {\n    gcd *= l;\n    l++;\n  }\n\n  return gcd;\n};\n\n/**\n * Return the greatest common divisor of a and b\n * >>> rgeatestCommonDivisor5(25, 15)\n * 5\n */\nconst rgeatestCommonDivisor6 = (a, b) => {\n  let gcd = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n\n  while (i < a && j < b) {\n    if (a % j === 0) {\n      gcd *= j;\n    }\n    i++;\n    j++;\n  }\n\n  while (i < a) {\n    gcd *= i;\n    i++;\n  }\n\n  while (j < b) {\n    gcd *= j;\n    j++;\n  }\n\n  while (k < a) {\n    gcd *= k;\n    k++;\n  }\n\n  while (l < b) {\n    gcd *= l;\n    l++;\n  }\n\n  return gcd;\n};\n\n/**\n * Return the greatest common divisor of a and b\n * >>> rgeatestCommonDivisor6(25, 15)\n * 5\n */\nconst rgeatestCommonDivisor7 = (a, b) => {\n  let gcd = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n\n  while (i < a && j < b) {\n    if (a % j === 0) {\n      gcd *= j;\n    }\n    i++;\n    j++;\n  }\n\n  while (i < a) {\n    gcd *= i;\n    i++;\n  }\n\n  while (j < b) {\n    gcd *= j;\n    j++;\n  }\n\n  while (k < a) {\n    gcd *= k;\n    k++;\n  }\n\n  while (l < b) {\n    gcd *= l;\n    l++;\n  }\n\n  return gcd;\n};\n\n/**\n * Return the greatest common divisor of a and b\n * >>> rgeatestCommonDivisor7(25, 15)\n * 5\n */\nconst rgeatestCommonDivisor8 = (a, b) => {\n  let gcd = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n\n  while (i < a && j < b) {\n    if (a % j === 0) {\n      gcd *= j;\n    }\n    i++;\n    j++;\n  }\n\n  while (i < a) {\n    gcd *= i;\n    i++;\n  }\n\n  while (j < b) {\n    gcd *= j;\n    j++;\n  }\n\n  while (k < a) {\n    gcd *= k;\n    k++;\n  }\n\n  while (l < b) {\n    gcd *= l;\n    l++;\n  }\n\n  return gcd;\n};\n\n/**\n * Return the greatest common divisor of a and b\n * >>> rgeatestCommonDivisor8(25, 15)\n * 5\n */\nconst rgeatestCommonDivisor9 = (a, b) => {\n  let gcd = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n\n  while (i < a && j < b) {\n    if (a % j === 0) {\n      gcd *= j;\n    }\n    i++;\n    j++;\n  }\n\n  while (i < a) {\n    gcd *= i;\n    i++;\n  }\n\n  while (j < b) {\n    gcd *= j;\n    j++;\n  }\n\n  while (k < a) {\n    gcd *= k;\n    k++;\n  }\n\n  while (l < b) {\n    gcd *= l;\n    l++;\n  }\n\n  return gcd;\n};\n\n/**\n * Return the greatest common divisor of a and b\n * >>> rgeatestCommonDivisor9(25, 15)\n * 5\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, what people don't know is Tribonacci sequence.\n  Tribonacci sequence is defined by the recurrence:\n  tir(1) = 3\n  tir(n) = 1 + n / 2, if n is even.\n  tir(n) =  tir(n - 1) + tir(n - 2) + tir(n + 1), if n is odd.\n  For example:\n  tir(2) = 1 + (2 / 2) = 2\n  tir(4) = 3\n  tir(3) = tir(2) + tir(1) + tir(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tir(3) = [1, 3, 2, 8]\n  */\nconst tir = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tir", "gc": "<|endoftext|>/*Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n  the last couple centuries. However, what people don't know is Tribonacci sequence.\n  Tribonacci sequence is defined by the recurrence:\n  tir(1) = 3\n  tir(n) = 1 + n / 2, if n is even.\n  tir(n) =  tir(n - 1) + tir(n - 2) + tir(n + 1), if n is odd.\n  For example:\n  tir(2) = 1 + (2 / 2) = 2\n  tir(4) = 3\n  tir(3) = tir(2) + tir(1) + tir(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tir(3) = [1, 3, 2, 8]\n  */\nconst tir = (n) => {\n  let arr = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  if (n <= 1) {\n    return arr;\n  }\n  if (n % 2 === 0) {\n    arr[0] = arr[1] = arr[2] = arr[3];\n    arr[3] = arr[4] = arr[5] = arr[6] = arr[7] = arr[8] = 1;\n    return arr;\n  }\n  while (i <= n) {\n    arr[i] = arr[j] + arr[k];\n    i++;\n    j++;\n    k++;\n  }\n  return arr;\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(3) = [1, 1, 1]\n  fib(2) = [1, 1, 1]\n  fib(4) = [1, 1, 1]\n  fib(6) = [1, 1, 1]\n  fib(7) = [1, 1, 1]\n  fib(8) = [1, 1, 1]\n  fib(10) = [1, 1, 1]\n  fib(11) = [1, 1, 1]\n  fib(12) = [1, 1, 1]\n  fib(13) = [1, 1, 1]\n  fib(14) = [1, 1, 1]\n  fib(15) = [1, 1, 1]\n  fib(16) = [1, 1, 1]\n  fib(17) = [1, 1, 1]\n  fib(18) = [1, 1, 1]\n  fib(19) = [1, 1, 1]\n  fib(20) = [1, 1, 1]\n  fib(21) = [1, 1, 1]\n  fib(22) = [1, 1, 1]\n  fib(23) = [1, 1, 1]\n  fib(24) = [1, 1, 1]\n  fib(25) = [1, 1, 1]\n  fib(26) = [1, 1, 1]\n  fib(27) = [1, 1, 1]\n  fib(28) = [1, 1, 1]\n  fib(29) = [1, 1, 1]\n  fib(30) = [1, 1, 1]\n  fib(31) = [1, 1, 1]\n  fib(32) = [1, 1, 1]\n  fib(33) = [1, 1, 1]\n  fib(34) = [1, 1, 1]\n  fib(35) = [1, 1, 1]\n  fib(36) = [1, 1, 1]\n  fib(37) = [1, 1, 1]\n  fib(38) = [1, 1, 1]\n  fib(39) = [1, 1, 1]\n  fib(40) = [1, 1, 1]\n  fib(41) = [1, 1, 1]\n  fib(42) = [1, 1, 1]\n  fib(43) = [1, 1, 1]\n  fib(44) = [1, 1, 1]\n  fib(45) = [1, 1, 1]\n  fib(46) = [1, 1, 1]\n  fib(47) = [1, 1, 1]\n  fib(48) = [1, 1, 1]\n  fib(49) = [1, 1, 1]\n  fib(50) = [1, 1, 1]\n  fib(51) = [1, 1, 1]\n  fib(52) = [1, 1, 1]\n  fib(53) = [1, 1, 1]\n  fib(54) = [1, 1, 1]\n  fib(55) = [1, 1, 1]\n  fib(56) = [1, 1, 1]\n  fib(57) = [1, 1, 1]\n  fib(58) = [1, 1, 1]\n  fib(59) = [1, 1, 1]\n  fib(60) = [1, 1, 1]\n  fib(61) = [1, 1, 1]\n  fib(62) = [1, 1, 1]\n  fib(63) = [1, 1, 1]\n  fib(64) = [1, 1, 1]\n  fib(65) = [1, 1, 1]\n  fib(66) = [1, 1, 1]\n  fib(67) = [1, 1, 1]\n  fib(68) = [1, 1, 1]\n  fib(69) = [1, 1, 1]\n  fib(70) = [1, 1, 1]\n  fib(71) = [1, 1, 1]\n  fib(72) = [1, 1, 1]\n  fib(73) = [1, 1, 1]\n  fib(74) = [1, 1, 1]\n  fib(75) = [1, 1, 1]\n  fib(76) = [1, 1, 1]\n  fib(77) = [1, 1, 1]\n  fib(78) = [1, 1, 1]\n  fib(79) = [1, 1, 1]\n  fib(80) = [1, 1, 1]\n  fib(81) = [1, 1, 1]\n  fib(82) = [1, 1, 1]\n  fib(83) = [1, 1, 1]\n  fib(84) = [1, 1, 1]\n  fib(85) = [1, 1, 1]\n  fib(86) = [1, 1, 1]\n  fib(87) = [1, 1, 1]\n  fib(88) = [1, 1, 1]\n  fib(89) = [1, 1, 1]\n  fib(90) = [1, 1, 1]\n  fib(91) = [1, 1, 1]\n  fib(92) = [1, 1, 1]\n  fib(93) = [1, 1, 1]\n  fib(94) = [1, 1, 1]\n  fib(95) = [1, 1, 1]\n  fib(96) = [1, 1, 1]\n  fib(97) = [1, 1, 1]\n  fib(98) = [1, 1, 1]\n  fib(99) = [1, 1, 1]\n  fib(100) = [1, 1, 1]\n  fib(101) = [1, 1, 1]\n  fib(102) = [1, 1, 1]\n  fib(103) = [1, 1, 1]\n  fib(104) = [1, 1, 1]\n  fib(105) = [1, 1, 1]\n  fib(106) = [1, 1, 1]\n  fib(107) = [1, 1, 1]\n  fib(108) = [1, 1, 1]\n  fib(109) = [1, 1, 1]\n  fib(110) = [1, 1, 1]\n  fib(111) = [1, 1, 1]\n  fib(112) = [1, 1, 1]\n  fib(113) = [1, 1, 1]\n  fib(114) = [1, 1, 1]\n  fib(115) = [1, 1, 1]\n  fib(116) = [1, 1, 1]\n  fib(117) = [1, 1, 1]\n  fib(118) = [1, 1, 1]\n  fib(119) = [1, 1, 1]\n  fib(120) = [1, 1, 1]\n  fib(121) = [1, 1, 1]\n  fib(122) = [1, 1, 1]\n  fib(123) = [1, 1, 1]\n  fib(124) = [1, 1, 1]\n  fib(125) = [1, 1, 1]\n  fib(126) = [1, 1, 1]\n  fib(127) = [1, 1, 1]\n  fib(128) = [1, 1, 1]\n  fib(129) = [1, 1, 1]\n  fib(130) = [1, 1, 1]\n  fib(131) = [1, 1, 1]\n  fib(132) = [1, 1, 1]\n  fib(133) = [1, 1, 1]\n  fib(134) = [1, 1, 1]\n  fib(135) = [1, 1, 1]\n  fib(136) = [1, 1, 1]\n  fib(137) = [1, 1, 1]\n  fib(138) = [1, 1, 1]\n  fib(139) = [1, 1, 1]\n  fib(140) = [1, 1, 1]\n  fib(141)", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive integer n, return the product of the odd digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "gc": "<|endoftext|>/*Given a positive integer n, return the product of the odd digits.\n  Return 0 if all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let sum = 0;\n  for (let i = Math.floor(Math.log10(n)); i >= 0; i--) {\n    sum += n % Math.pow(10, i);\n    n /= Math.pow(10, i);\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits_mod = (n) => {\n  let sum = 0;\n  for (let i = Math.floor(Math.log10(n)); i >= 0; i--) {\n    sum += n % Math.pow(10, i);\n    n /= Math.pow(10, i);\n  }\n  return sum % 10;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits_mod_10 = (n) => {\n  let sum = 0;\n  for (let i = Math.floor(Math.log10(n)); i >= 0; i--) {\n    sum += n % Math.pow(10, i);\n    n /= Math.pow(10, i);\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits_mod_10_mod = (n) => {\n  let sum = 0;\n  for (let i = Math.floor(Math.log10(n)); i >= 0; i--) {\n    sum += n % Math.pow(10, i);\n    n /= Math.pow(10, i);\n  }\n  return sum % 10;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits_mod_10_mod_10 = (n) => {\n  let sum = 0;\n  for (let i = Math.floor(Math.log10(n)); i >= 0; i--) {\n    sum += n % Math.pow(10, i);\n    n /= Math.pow(10, i);\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits_mod_10_mod_10_mod = (n) => {\n  let sum = 0;\n  for (let i = Math.floor(Math.log10(n)); i >= 0; i--) {\n    sum += n % Math.pow(10, i);\n    n /= Math.pow(10, i);\n  }\n  return sum % 10;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits_mod_10_mod_10_mod_10 = (n) => {\n  let sum = 0;\n  for (let i = Math.floor(Math.log10(n)); i >= 0; i--) {\n    sum += n % Math.pow(10, i);\n    n /= Math.pow(10, i);\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits_mod_10_mod_10_mod_10_mod = (n) => {\n  let sum = 0;\n  for (let i = Math.floor(Math.log10(n)); i >= 0; i--) {\n    sum += n % Math.pow(10, i);\n    n /= Math.pow(10, i);\n  }\n  return sum % 10;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits_mod_10_mod_10_mod_10_mod_10 = (n) => {\n  let sum = 0;\n  for (let i = Math.floor(Math.log10(n)); i >= 0; i--) {\n    sum += n % Math.pow(10, i);\n    n /= Math.pow(10, i);\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits_mod_10_mod_10_mod_10_mod_10_mod = (n) => {\n  let sum = 0;\n  for (let i = Math.floor(Math.log10(n)); i >= 0; i--) {\n    sum += n % Math.pow(10, i);\n    n /= Math.pow(10, i);\n  }\n  return sum % 10;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits_mod_10_mod_10_mod_10_mod_10_mod_10 = (n) => {\n  let sum = 0;\n  for (let i = Math.floor(Math.log10(n)); i >= 0; i--) {\n    sum += n % Math.pow(10, i);\n    n /= Math.pow(10, i);\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits_mod_10_mod_10_mod_10_mod_10_mod_10_mod = (n) => {\n  let sum = 0;\n  for (let i = Math.floor(Math.log10(n)); i >= 0; i--) {\n    sum += n % Math.pow(10, i);\n    n /= Math.pow(10, i);\n  }\n  return sum % 10;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits_mod_10_mod_10_mod_10_mod_10_mod_10_mod_10 = (n) => {\n  let sum = 0;\n  for (let i = Math.floor(Math.log10(n)); i >= 0; i--) {\n    sum += n % Math.pow(10, i);\n    n /= Math.pow(10, i);\n  }\n  return sum;\n};\n\n/*Given a positive integer n, return the sum of its digits, modulo 10.\n  Return 0 if n is 0.\n  For example:\n  digits(0)  == 0\n  digits(1)  == 1\n  digits(4)  == 4\n  digits(235) == 235\n  */\nconst digits_mod_10_mod_10_mod_10_mod_10_mod_10_mod_10_mod = (n) => {\n  let sum = 0;\n  for (let i = Math.floor(Math.log10(n)); ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "gc": "<|endoftext|>/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const nestedBrackets = /\\[(?:[^\\[\\]]*]|(?:\\[(?!\\])[^\\[\\]]*\\]))*\\]/g\n  return nestedBrackets.test(string)\n}\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const nestedBrackets = /\\[(?:[^\\[\\]]*]|(?:\\[(?!\\])[^\\[\\]]*\\]))*\\]/g\n  return nestedBrackets.test(string)\n}\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const nestedBrackets = /\\[(?:[^\\[\\]]*]|(?:\\[(?!\\])[^\\[\\]]*\\]))*\\]/g\n  return nestedBrackets.test(string)\n}\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const nestedBrackets = /\\[(?:[^\\[\\]]*]|(?:\\[(?!\\])[^\\[\\]]*\\]))*\\]/g\n  return nestedBrackets.test(string)\n}\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const nestedBrackets = /\\[(?:[^\\[\\]]*]|(?:\\[(?!\\])[^\\[\\]]*\\]))*\\]/g\n  return nestedBrackets.test(string)\n}\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const nestedBrackets = /\\[(?:[^\\[\\]]*]|(?:\\[(?!\\])[^\\[\\]]*\\]))*\\]/g\n  return nestedBrackets.test(string)\n}\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const nestedBrackets = /\\[(?:[^\\[\\]]*]|(?:\\[(?!\\])[^\\[\\]]*\\]))*\\]/g\n  return nestedBrackets.test(string)\n}\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const nestedBrackets = /\\[(?:[^\\[\\]]*]|(?:\\[(?!\\])[^\\[\\]]*\\]))*\\]/g\n  return nestedBrackets.test(string)\n}\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]') ➞ true\n  isNested('[]]]]]]][[[[[]') ➞ false\n  isNested('[][]') ➞ false\n  isNested('[]') ➞ false\n  isNested('[[][]]') ➞ true\n  isNested('[[]][[') ➞ true\n  */\nconst isNested = (string) => {\n  const nestedBrackets = /\\[(?:[^\\[\\]]*]|(?:\\[(?!\\])[^\\[\\]]*\\]))*\\]/g\n  return nestedBrackets.test(string)\n}\n\n/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/133", "prompt": "/*You are given a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "gc": "<|endoftext|>/*You are given a list of numbers.\n  You need to return the sum of squared numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.round(sum);\n};\n\n/*\n  You are given a list of numbers.\n  You need to return the sum of cubed numbers in the given list,\n  round each element in the list to the lower int(Floor) first.\n  Examples:\n  For lst = [1,2,3] the output should be 9\n  For lst = [1,4,9] the output should be 99\n  For lst = [1,3,5,7] the output should be 98\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumCubes = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 3);\n  });\n  return Math.round(sum);\n};\n\n/*\n  You are given a list of numbers.\n  You need to return the sum of cubed numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 98\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumCubesUp = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 3);\n  });\n  return Math.round(sum);\n};\n\n/*\n  You are given a list of numbers.\n  You need to return the sum of cubed numbers in the given list,\n  round each element in the list to the lower int(Floor) first.\n  Examples:\n  For lst = [1,2,3] the output should be 9\n  For lst = [1,4,9] the output should be 99\n  For lst = [1,3,5,7] the output should be 98\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumCubesDown = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 3);\n  });\n  return Math.round(sum);\n};\n\n/*\n  You are given a list of numbers.\n  You need to return the sum of cubed numbers in the given list,\n  round each element in the list to the lower int(Floor) first.\n  Examples:\n  For lst = [1,2,3] the output should be 9\n  For lst = [1,4,9] the output should be 99\n  For lst = [1,3,5,7] the output should be 98\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumCubesUpDown = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 3);\n  });\n  return Math.round(sum);\n};\n\n/*\n  You are given a list of numbers.\n  You need to return the sum of cubed numbers in the given list,\n  round each element in the list to the lower int(Floor) first.\n  Examples:\n  For lst = [1,2,3] the output should be 9\n  For lst = [1,4,9] the output should be 99\n  For lst = [1,3,5,7] the output should be 98\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumCubesUpDownFloor = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 3);\n  });\n  return Math.round(sum);\n};\n\n/*\n  You are given a list of numbers.\n  You need to return the sum of cubed numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 98\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumCubesUpDownCeiling = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 3);\n  });\n  return Math.round(sum);\n};\n\n/*\n  You are given a list of numbers.\n  You need to return the sum of cubed numbers in the given list,\n  round each element in the list to the lower int(Floor) first.\n  Examples:\n  For lst = [1,2,3] the output should be 9\n  For lst = [1,4,9] the output should be 99\n  For lst = [1,3,5,7] the output should be 98\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumCubesUpDownFloorCeiling = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 3);\n  });\n  return Math.round(sum);\n};\n\n/*\n  You are given a list of numbers.\n  You need to return the sum of cubed numbers in the given list,\n  round each element in the list to the lower int(Floor) first.\n  Examples:\n  For lst = [1,2,3] the output should be 9\n  For lst = [1,4,9] the output should be 99\n  For lst = [1,3,5,7] the output should be 98\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumCubesUpDownFloorCeilingCeiling = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 3);\n  });\n  return Math.round(sum);\n};\n\n/*\n  You are given a list of numbers.\n  You need to return the sum of cubed numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 98\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumCubesUpDownCeiling = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 3);\n  });\n  return Math.round(sum);\n};\n\n/*\n  You are given a list of numbers.\n  You need to return the sum of cubed numbers in the given list,\n  round each element in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 98\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumCubesUpDownCeilingCeiling = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 3);\n  });\n  return Math.round(sum);\n};\n\n/*\n  You are given a list of numbers.\n  You need to return the sum of cubed ", "passed": 1, "run_status": 0, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/134", "prompt": "/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "gc": "<|endoftext|>/* Create a function that returns true if the last character\n  of a given string is an alphabetical character and is not\n  a part of a word, and false otherwise.\n  Note: \"word\" is a group of characters separated by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.charAt(txt.length - 1);\n  let isLastCharAWord = lastChar === \" \" || lastChar === \".\" || lastChar === \",\" || lastChar === \".\" || lastChar === \"?\" || lastChar === \"!\" || lastChar === \"?\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || lastChar === \"!\" || last", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/135", "prompt": "/*Create a function which returns the largest index of an element which\n  is not greater than or equal to the element immediately preceding it. If\n  no such element exists then return -1. The given array will not contain\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "gc": "<|endoftext|>/*Create a function which returns the largest index of an element which\n  is not greater than or equal to the element immediately preceding it. If\n  no such element exists then return -1. The given array will not contain\n  duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let index = -1;\n  let max = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      index = i;\n    }\n  }\n  return index;\n};\n\n/**\n  Given an array of integers, return an array which contains all possible pairs of\n  integers such that each pair contains at least one element from the given\n  array.\n\n  Examples:\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1]]\n  pairs([1,2,3]) = [[1,2],[2,3],[3,1],[2,3],[3,1],[2,3],[3,1],[2,", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/136", "prompt": "/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestSmallestIntgeers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "lagrestSmallestIntgeers", "gc": "<|endoftext|>/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestSmallestIntgeers = (lst) => {\n  let maxIntgeers = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  let minIntgeers = lst.reduce((acc, val) => Math.min(acc, val), 0);\n  return lst.map((val) => val > minIntgeers? val : null);\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestSmallestIntgeersReversed = (lst, acc) => {\n  let maxIntgeers = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  let minIntgeers = lst.reduce((acc, val) => Math.min(acc, val), 0);\n  return lst.map((val) => val > minIntgeers? val : null);\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestSmallestIntgeersReversedReversed = (lst, acc) => {\n  let maxIntgeers = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  let minIntgeers = lst.reduce((acc, val) => Math.min(acc, val), 0);\n  return lst.map((val) => val > minIntgeers? val : null);\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestSmallestIntgeersReversedReversedReversed = (lst, acc) => {\n  let maxIntgeers = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  let minIntgeers = lst.reduce((acc, val) => Math.min(acc, val), 0);\n  return lst.map((val) => val > minIntgeers? val : null);\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestSmallestIntgeersReversedReversedReversedReversedReversed = (lst, acc) => {\n  let maxIntgeers = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  let minIntgeers = lst.reduce((acc, val) => Math.min(acc, val), 0);\n  return lst.map((val) => val > minIntgeers? val : null);\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestSmallestIntgeersReversedReversedReversedReversedReversedReversedReversed = (lst, acc) => {\n  let maxIntgeers = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  let minIntgeers = lst.reduce((acc, val) => Math.min(acc, val), 0);\n  return lst.map((val) => val > minIntgeers? val : null);\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestSmallestIntgeersReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed = (lst, acc) => {\n  let maxIntgeers = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  let minIntgeers = lst.reduce((acc, val) => Math.min(acc, val), 0);\n  return lst.map((val) => val > minIntgeers? val : null);\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmallestIntgeers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  lagrestSmallestIntgeers([]) == (null, null)\n  lagrestSmallestIntgeers([0]) == (null, null)\n  */\nconst lagrestSmallestIntgeersReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed = (lst, acc) => {\n  let maxIntgeers = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  let minIntgeers = lst.reduce((acc, val) => Math.min(acc, val), 0);\n  return lst.map((val) => val > minIntgeers? val : null);\n};\n\n/* Create a function that returns a tuple (a, b), where 'a' is\n  the largest of negative integers, and 'b' is the smallest\n  of positive integers in a list.\n  If there is no negative or positive integers, return them as null.\n  Examples:\n  lagrestSmalle", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be . or ,\n\n  compaerOne(1, 2.5) ➞ 2.5\n  compaerOne(1, \"2,3\") ➞ \"2,3\"\n  compaerOne(\"5,1\", \"6\") ➞ \"6\"\n  compaerOne(\"1\", 1) ➞ null\n  */\nconst compaerOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compaerOne", "gc": "<|endoftext|>/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compaerOne(1, 2.5) ➞ 2.5\n  compaerOne(1, \"2,3\") ➞ \"2,3\"\n  compaerOne(\"5,1\", \"6\") ➞ \"6\"\n  compaerOne(\"1\", 1) ➞ null\n  */\nconst compaerOne = (a, b) => {\n  if (a === null || b === null) return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" && b === \"\") return null\n  if (a === \"\" && b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || b === \"\") return null\n  if (a === \"\" || ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "gc": "<|endoftext|>/*Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  let even = 0;\n  let odd = 0;\n  \n  for(let i = 0; i <= n; i++){\n    sum += i;\n    if(i % 2 === 0){\n      even += i;\n    }\n    else{\n      odd += i;\n    }\n  }\n  \n  return even === 4 && odd === 4;\n};\n\n/*\n  Given a positive integer n, return true if the sum of its digits, starting from right to left, is even.\n  Example\n  isEvenSum(12) == true\n  isEvenSum(13) == false\n  isEvenSum(14) == false\n  isEvenSum(15) == true\n  */\nconst isEvenSum = (n) => {\n  let sum = 0;\n  let even = 0;\n  let odd = 0;\n  \n  for(let i = 0; i <= n; i++){\n    sum += i;\n    if(i % 2 === 0){\n      even += i;\n    }\n    else{\n      odd += i;\n    }\n  }\n  \n  return even === 2;\n};\n\n/*\n  Given a positive integer n, return true if the sum of its digits, starting from right to left, is odd.\n  Example\n  isOddSum(12) == false\n  isOddSum(13) == true\n  isOddSum(14) == true\n  isOddSum(15) == false\n  */\nconst isOddSum = (n) => {\n  let sum = 0;\n  let even = 0;\n  let odd = 0;\n  \n  for(let i = 0; i <= n; i++){\n    sum += i;\n    if(i % 2 === 1){\n      even += i;\n    }\n    else{\n      odd += i;\n    }\n  }\n  \n  return even === 2;\n};\n\n/*\n  Given a positive integer n, return true if the sum of its digits, starting from right to left, is divisible by 3.\n  Example\n  isDivisibleSum(12) == true\n  isDivisibleSum(13) == false\n  isDivisibleSum(14) == false\n  isDivisibleSum(15) == false\n  */\nconst isDivisibleSum = (n) => {\n  let sum = 0;\n  let even = 0;\n  let odd = 0;\n  \n  for(let i = 0; i <= n; i++){\n    sum += i;\n    if(i % 3 === 0){\n      even += i;\n    }\n    else{\n      odd += i;\n    }\n  }\n  \n  return even === 3;\n};\n\n/*\n  Given a positive integer n, return true if the sum of its digits, starting from right to left, is divisible by 5.\n  Example\n  isDivisibleSum(12) == false\n  isDivisibleSum(13) == false\n  isDivisibleSum(14) == true\n  isDivisibleSum(15) == false\n  */\nconst isDivisibleSum = (n) => {\n  let sum = 0;\n  let even = 0;\n  let odd = 0;\n  \n  for(let i = 0; i <= n; i++){\n    sum += i;\n    if(i % 5 === 0){\n      even += i;\n    }\n    else{\n      odd += i;\n    }\n  }\n  \n  return even === 5;\n};\n\n/*\n  Given a positive integer n, return true if the sum of its digits, starting from right to left, is divisible by 7.\n  Example\n  isDivisibleSum(12) == false\n  isDivisibleSum(13) == false\n  isDivisibleSum(14) == false\n  isDivisibleSum(15) == false\n  */\nconst isDivisibleSum = (n) => {\n  let sum = 0;\n  let even = 0;\n  let odd = 0;\n  \n  for(let i = 0; i <= n; i++){\n    sum += i;\n    if(i % 7 === 0){\n      even += i;\n    }\n    else{\n      odd += i;\n    }\n  }\n  \n  return even === 7;\n};\n\n/*\n  Given a positive integer n, return true if the sum of its digits, starting from right to left, is divisible by 9.\n  Example\n  isDivisibleSum(12) == false\n  isDivisibleSum(13) == false\n  isDivisibleSum(14) == false\n  isDivisibleSum(15) == false\n  */\nconst isDivisibleSum = (n) => {\n  let sum = 0;\n  let even = 0;\n  let odd = 0;\n  \n  for(let i = 0; i <= n; i++){\n    sum += i;\n    if(i % 9 === 0){\n      even += i;\n    }\n    else{\n      odd += i;\n    }\n  }\n  \n  return even === 9;\n};\n\n/*\n  Given a positive integer n, return true if the sum of its digits, starting from right to left, is divisible by 11.\n  Example\n  isDivisibleSum(12) == false\n  isDivisibleSum(13) == false\n  isDivisibleSum(14) == false\n  isDivisibleSum(15) == false\n  */\nconst isDivisibleSum = (n) => {\n  let sum = 0;\n  let even = 0;\n  let odd = 0;\n  \n  for(let i = 0; i <= n; i++){\n    sum += i;\n    if(i % 11 === 0){\n      even += i;\n    }\n    else{\n      odd += i;\n    }\n  }\n  \n  return even === 11;\n};\n\n/*\n  Given a positive integer n, return true if the sum of its digits, starting from right to left, is divisible by 13.\n  Example\n  isDivisibleSum(12) == false\n  isDivisibleSum(13) == false\n  isDivisibleSum(14) == false\n  isDivisibleSum(15) == false\n  */\nconst isDivisibleSum = (n) => {\n  let sum = 0;\n  let even = 0;\n  let odd = 0;\n  \n  for(let i = 0; i <= n; i++){\n    sum += i;\n    if(i % 13 === 0){\n      even += i;\n    }\n    else{\n      odd += i;\n    }\n  }\n  \n  return even === 13;\n};\n\n/*\n  Given a positive integer n, return true if the sum of its digits, starting from right to left, is divisible by 15.\n  Example\n  isDivisibleSum(12) == false\n  isDivisibleSum(13) == false\n  isDivisibleSum(14) == false\n  isDivisibleSum(15) == true\n  */\nconst isDivisibleSum = (n) => {\n  let sum = 0;\n  let even = 0;\n  let odd = 0;\n  \n  for(let i = 0; i <= n; i++){\n    sum += i;\n    if(i % 15 === 0){\n      even += i;\n    }\n    else{\n      odd += i;\n    }\n  }\n  \n  return even === 15;\n};\n\n/*\n  Given a positive integer n, return true if the sum of its digits, starting from right to left, is divisible by 17.\n  Example\n  isDivisibleSum(12) == false\n  isDivisibleSum(13) == false\n  isDivisibleSum(14) == false\n  isDivisibleSum(15) == false\n  */\nconst isDivisibleSum = (n) => {\n  let sum = 0;\n  let even = 0;\n  let odd = 0;\n  \n  for(let i = 0; i <= n; i++){\n    sum += i;\n    if(i % 17 === 0){\n      even += i;\n    }\n    else{\n      odd += i;\n    }\n  }\n  \n  return even === 17;\n};\n\n/*\n  Given a positive integer n, return true if the sum of its digits, starting from right to left, is divisible by 19.\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorial is defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "gc": "<|endoftext|>/*The Brazilian factorial is defined as:\n  brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n  where n > 0\n\n  For example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n < 1) {\n    return 1;\n  }\n  return n * n * n * n * n * n;\n};\n\n/*\n  Returns the factorial of n using binary exponentiation.\n  Binary exponentiation is used to calculate large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponentiation can be used for large numbers of large numbers.\n  Binary exponenti", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/14", "prompt": "/* Return list of all prefixes from shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "gc": "<|endoftext|>/* Return list of all prefixes from shortest to longest of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  let prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefixes.push(currentPrefix);\n    currentPrefix = currentPrefix.slice(0, currentPrefix.length - 1);\n  }\n  return prefixes;\n};\n\n/* Return list of all suffixes from shortest to longest of the input string\n  >>> allSuffixes('abc')\n  ['c', 'ba', 'abc']\n  */\nconst allSuffixes = (string) => {\n  let suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.push(currentSuffix);\n    currentSuffix = currentSuffix.slice(currentSuffix.length - 1);\n  }\n  return suffixes;\n};\n\n/* Return list of all substrings from shortest to longest of the input string\n  >>> allSubstrings('abc')\n  ['abc', 'ab', 'ba', 'ca', 'bc', 'ca', 'bc']\n  */\nconst allSubstrings = (string) => {\n  let substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.slice(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/* Return list of all words from shortest to longest of the input string\n  >>> allWords('abc')\n  ['abc', 'ab', 'ba', 'ca', 'bc', 'ca', 'bc']\n  */\nconst allWords = (string) => {\n  let words = [];\n  let currentWord = string;\n  while (currentWord.length > 0) {\n    words.push(currentWord);\n    currentWord = currentWord.slice(0, currentWord.length - 1);\n  }\n  return words;\n};\n\n/* Return list of all words from shortest to longest of the input string\n  >>> allWords('abc')\n  ['abc', 'ab', 'ba', 'ca', 'bc', 'ca', 'bc']\n  */\nconst allWordsWithPrefix = (string) => {\n  let words = [];\n  let currentWord = string;\n  while (currentWord.length > 0) {\n    words.push(currentWord);\n    currentWord = currentWord.slice(0, currentWord.length - 1);\n  }\n  return words.filter((word) => word.length > 0);\n};\n\n/* Return list of all words from shortest to longest of the input string\n  >>> allWordsWithPrefix('abc')\n  ['abc', 'ab', 'ba', 'ca', 'bc', 'ca', 'bc']\n  */\nconst allWordsWithSuffix = (string) => {\n  let words = [];\n  let currentWord = string;\n  while (currentWord.length > 0) {\n    words.push(currentWord);\n    currentWord = currentWord.slice(currentWord.length - 1);\n  }\n  return words.filter((word) => word.length > 0);\n};\n\n/* Return list of all words from shortest to longest of the input string\n  >>> allWordsWithSuffix('abc')\n  ['abc', 'ab', 'ba', 'ca', 'bc', 'ca', 'bc']\n  */\nconst allWordsWithPrefixAndSuffix = (string) => {\n  let words = [];\n  let currentWord = string;\n  while (currentWord.length > 0) {\n    words.push(currentWord);\n    currentWord = currentWord.slice(0, currentWord.length - 1);\n  }\n  return words.filter((word) => word.length > 0);\n};\n\n/* Return list of all words from shortest to longest of the input string\n  >>> allWordsWithPrefixAndSuffix('abc')\n  ['abc', 'ab', 'ba', 'ca', 'bc', 'ca', 'bc']\n  */\nconst allWordsWithPrefixAndSuffixAndPrefix = (string) => {\n  let words = [];\n  let currentWord = string;\n  while (currentWord.length > 0) {\n    words.push(currentWord);\n    currentWord = currentWord.slice(0, currentWord.length - 1);\n  }\n  return words.filter((word) => word.length > 0);\n};\n\n/* Return list of all words from shortest to longest of the input string\n  >>> allWordsWithPrefixAndSuffixAndPrefix('abc')\n  ['abc', 'ab', 'ba', 'ca', 'bc', 'ca', 'bc']\n  */\nconst allWordsWithPrefixAndSuffixAndPrefixAndSuffix = (string) => {\n  let words = [];\n  let currentWord = string;\n  while (currentWord.length > 0) {\n    words.push(currentWord);\n    currentWord = currentWord.slice(0, currentWord.length - 1);\n  }\n  return words.filter((word) => word.length > 0);\n};\n\n/* Return list of all words from shortest to longest of the input string\n  >>> allWordsWithPrefixAndSuffixAndPrefixAndSuffix('abc')\n  ['abc', 'ab', 'ba', 'ca', 'bc', 'ca', 'bc']\n  */\nconst allWordsWithPrefixAndSuffixAndPrefixAndSuffixAndPrefix = (string) => {\n  let words = [];\n  let currentWord = string;\n  while (currentWord.length > 0) {\n    words.push(currentWord);\n    currentWord = currentWord.slice(0, currentWord.length - 1);\n  }\n  return words.filter((word) => word.length > 0);\n};\n\n/* Return list of all words from shortest to longest of the input string\n  >>> allWordsWithPrefixAndSuffixAndPrefixAndSuffixAndPrefix('abc')\n  ['abc', 'ab', 'ba', 'ca', 'bc', 'ca', 'bc']\n  */\nconst allWordsWithPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffix = (string) => {\n  let words = [];\n  let currentWord = string;\n  while (currentWord.length > 0) {\n    words.push(currentWord);\n    currentWord = currentWord.slice(0, currentWord.length - 1);\n  }\n  return words.filter((word) => word.length > 0);\n};\n\n/* Return list of all words from shortest to longest of the input string\n  >>> allWordsWithPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffix('abc')\n  ['abc', 'ab', 'ba', 'ca', 'bc', 'ca', 'bc']\n  */\nconst allWordsWithPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffixAndPrefix = (string) => {\n  let words = [];\n  let currentWord = string;\n  while (currentWord.length > 0) {\n    words.push(currentWord);\n    currentWord = currentWord.slice(0, currentWord.length - 1);\n  }\n  return words.filter((word) => word.length > 0);\n};\n\n/* Return list of all words from shortest to longest of the input string\n  >>> allWordsWithPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffix('abc')\n  ['abc', 'ab', 'ba', 'ca', 'bc', 'ca', 'bc']\n  */\nconst allWordsWithPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffix = (string) => {\n  let words = [];\n  let currentWord = string;\n  while (currentWord.length > 0) {\n    words.push(currentWord);\n    currentWord = currentWord.slice(0, currentWord.length - 1);\n  }\n  return words.filter((word) => word.length > 0);\n};\n\n/* Return list of all words from shortest to longest of the input string\n  >>> allWordsWithPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffix('abc')\n  ['abc', 'ab', 'ba', 'ca', 'bc', 'ca', 'bc']\n  */\nconst allWordsWithPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffixAndPrefixAndSuffixAnd", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/140", "prompt": "/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacse(\"Example\") == \"Example\"\n  fixSpacse(\"Example 1\") == \"Example_1\"\n  fixSpacse(\" Example 2\") == \"_Example_2\"\n  fixSpacse(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpacse = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpacse", "gc": "<|endoftext|>/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacse(\"Example\") == \"Example\"\n  fixSpacse(\"Example 1\") == \"Example_1\"\n  fixSpacse(\" Example 2\") == \"_Example_2\"\n  fixSpacse(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpacse = (text) => {\n  return text.replace(/\\s+/g, '_').replace(/\\s{2,}/g,'');\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixSpacse(\"Example\") == \"Example\"\n  fixSpacse(\"Example 1\") == \"Example_1\"\n  fixSpacse(\" Example 2\") == \"_Example_2\"\n  fixSpacse(\" Example   3\") == \"_Example-3\"\n  */\nconst fixUnderscore = (text) => {\n  return text.replace(/_/g,'').replace(/\\s{2,}/g,'');\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixUnderscore(\"Example\") == \"Example\"\n  fixUnderscore(\"Example 1\") == \"Example_1\"\n  fixUnderscore(\" Example 2\") == \"Example_2\"\n  fixUnderscore(\" Example   3\") == \"Example_3\"\n  */\nconst fixCapital = (text) => {\n  return text.replace(/[A-Z]/g,'');\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixCapital(\"Example\") == \"Example\"\n  fixCapital(\"Example 1\") == \"Example_1\"\n  fixCapital(\" Example 2\") == \"Example_2\"\n  fixCapital(\" Example   3\") == \"Example_3\"\n  */\nconst fixTitle = (text) => {\n  return text.replace(/[A-Z]/g,'');\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixTitle(\"Example\") == \"Example\"\n  fixTitle(\"Example 1\") == \"Example_1\"\n  fixTitle(\" Example 2\") == \"Example_2\"\n  fixTitle(\" Example   3\") == \"Example_3\"\n  */\nconst fixTitleCase = (text) => {\n  return text.replace(/[A-Z]/g,'');\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixTitleCase(\"Example\") == \"Example\"\n  fixTitleCase(\"Example 1\") == \"Example_1\"\n  fixTitleCase(\" Example 2\") == \"Example_2\"\n  fixTitleCase(\" Example   3\") == \"Example_3\"\n  */\nconst fixTitleCase2 = (text) => {\n  return text.replace(/[A-Z]/g,'');\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixTitleCase2(\"Example\") == \"Example\"\n  fixTitleCase2(\"Example 1\") == \"Example_1\"\n  fixTitleCase2(\" Example 2\") == \"Example_2\"\n  fixTitleCase2(\" Example   3\") == \"Example_3\"\n  */\nconst fixTitleCase3 = (text) => {\n  return text.replace(/[A-Z]/g,'');\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixTitleCase3(\"Example\") == \"Example\"\n  fixTitleCase3(\"Example 1\") == \"Example_1\"\n  fixTitleCase3(\" Example 2\") == \"Example_2\"\n  fixTitleCase3(\" Example   3\") == \"Example_3\"\n  */\nconst fixTitleCase4 = (text) => {\n  return text.replace(/[A-Z]/g,'');\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixTitleCase4(\"Example\") == \"Example\"\n  fixTitleCase4(\"Example 1\") == \"Example_1\"\n  fixTitleCase4(\" Example 2\") == \"Example_2\"\n  fixTitleCase4(\" Example   3\") == \"Example_3\"\n  */\nconst fixTitleCase5 = (text) => {\n  return text.replace(/[A-Z]/g,'');\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixTitleCase5(\"Example\") == \"Example\"\n  fixTitleCase5(\"Example 1\") == \"Example_1\"\n  fixTitleCase5(\" Example 2\") == \"Example_2\"\n  fixTitleCase5(\" Example   3\") == \"Example_3\"\n  */\nconst fixTitleCase6 = (text) => {\n  return text.replace(/[A-Z]/g,'');\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixTitleCase6(\"Example\") == \"Example\"\n  fixTitleCase6(\"Example 1\") == \"Example_1\"\n  fixTitleCase6(\" Example 2\") == \"Example_2\"\n  fixTitleCase6(\" Example   3\") == \"Example_3\"\n  */\nconst fixTitleCase7 = (text) => {\n  return text.replace(/[A-Z]/g,'');\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixTitleCase7(\"Example\") == \"Example\"\n  fixTitleCase7(\"Example 1\") == \"Example_1\"\n  fixTitleCase7(\" Example 2\") == \"Example_2\"\n  fixTitleCase7(\" Example   3\") == \"Example_3\"\n  */\nconst fixTitleCase8 = (text) => {\n  return text.replace(/[A-Z]/g,'');\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixTitleCase8(\"Example\") == \"Example\"\n  fixTitleCase8(\"Example 1\") == \"Example_1\"\n  fixTitleCase8(\" Example 2\") == \"Example_2\"\n  fixTitleCase8(\" Example   3\") == \"Example_3\"\n  */\nconst fixTitleCase9 = (text) => {\n  return text.replace(/[A-Z]/g,'');\n}\n\n/*\n  Given a string text, replace all spaces in it with underscores, \n  and if a string has more than 2 consecutive spaces, \n  then replace all consecutive spaces with - \n  \n  fixTitleCase9(\"Example\") == \"Example\"\n  fixTitleCase9(\"Example 1\") == \"Example_1\"\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "gc": "<|endoftext|>/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const file_name_without_extension = file_name.split('.')[0]\n  const file_name_without_extension_length = file_name_without_extension.length\n  const file_name_without_extension_digits = file_name_without_extension.match(/[0-9]/)\n  const file_name_without_extension_digits_length = file_name_without_extension_digits.length\n  const file_name_without_extension_digits_digits = file_name_without_extension_digits.map((digit) => parseInt(digit))\n  const file_name_without_extension_digits_digits_length = file_name_without_extension_digits_digits.length\n  const file_name_without_extension_digits_digits_digits = file_name_without_extension_digits_digits.map((digit) => parseInt(digit))\n  const file_name_without_extension_digits_digits_digits_length = file_name_without_extension_digits_digits_digits.length\n  const file_name_without_extension_digits_digits_digits_digits = file_name_without_extension_digits_digits_digits.map((digit) => parseInt(digit))\n  const file_name_without_extension_digits_digits_digits_digits_length = file_name_without_extension_digits_digits_digits_digits.length\n  const file_name_without_extension_digits_digits_digits_digits_digits = file_name_without_extension_digits_digits_digits_digits.map((digit) => parseInt(digit))\n  const file_name_without_extension_digits_digits_digits_digits_digits_length = file_name_without_extension_digits_digits_digits_digits_digits.length\n  const file_name_without_extension_digits_digits_digits_digits_digits_digits = file_name_without_extension_digits_digits_digits_digits_digits.map((digit) => parseInt(digit))\n  const file_name_without_extension_digits_digits_digits_digits_digits_length = file_name_without_extension_digits_digits_digits_digits_digits_digits.length\n  const file_name_without_extension_digits_digits_digits_digits_digits_digits = file_name_without_extension_digits_digits_digits_digits_digits_digits.map((digit) => parseInt(digit))\n  const file_name_without_extension_digits_digits_digits_digits_digits_digits_length = file_name_without_extension_digits_digits_digits_digits_digits_digits.length\n  const file_name_without_extension_digits_digits_digits_digits_digits_digits_digits = file_name_without_extension_digits_digits_digits_digits_digits_digits.map((digit) => parseInt(digit))\n  const file_name_without_extension_digits_digits_digits_digits_digits_digits_length = file_name_without_extension_digits_digits_digits_digits_digits_digits.length\n  const file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_digits = file_name_without_extension_digits_digits_digits_digits_digits_digits_digits.map((digit) => parseInt(digit))\n  const file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_length = file_name_without_extension_digits_digits_digits_digits_digits_digits_digits.length\n  const file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_digits = file_name_without_extension_digits_digits_digits_digits_digits_digits_digits.map((digit) => parseInt(digit))\n  const file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_length = file_name_without_extension_digits_digits_digits_digits_digits_digits_digits.length\n  const file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_digits = file_name_without_extension_digits_digits_digits_digits_digits_digits_digits.map((digit) => parseInt(digit))\n  const file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_length = file_name_without_extension_digits_digits_digits_digits_digits_digits_digits.length\n  const file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_digits_digits = file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_digits.map((digit) => parseInt(digit))\n  const file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_digits_length = file_name_without_extension_digits_digits_digits_digits_digits_digits_digits.length\n  const file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_digits_digits = file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_digits_digits.map((digit) => parseInt(digit))\n  const file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_digits_length = file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_digits.length\n  const file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits = file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_digits.map((digit) => parseInt(digit))\n  const file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_length = file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_digits.length\n  const file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits = file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_digits_digits.map((digit) => parseInt(digit))\n  const file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_digits_length = file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_digits_digits.length\n  const file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits = file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_digits_digits.map((digit) => parseInt(digit))\n  const file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_digits_digits_length = file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_digits_digits.length\n  const file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits = file_name_without_extension_digits_digits_digits_digits_digits_digits_digits_digits_digits_digits.map((digit) => parseInt(digit))\n  const file_name_without_extension_", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "gc": "<|endoftext|>/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  \n  lst.forEach((item, index) => {\n    if (index % 3 === 0 && index % 4!== 0) {\n      sum += item * item;\n    }\n  });\n  \n  return sum;\n};\n\n/*\n  Given a list containing integers, return true if and only if the list is a permutation of the given list. \n  \n  Examples:\n  Given lst = [1,2,3], return true\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return true\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n  Given lst = [1,2,3], return false\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/143", "prompt": "/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wrodsInSentenec = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wrodsInSentenec", "gc": "<|endoftext|>/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wrodsInSentenec = (sentence) => {\n  const words = sentence.split(\" \");\n  const newWords = [];\n  let count = 0;\n  for (let i = 0; i < words.length; i++) {\n    if (words[i] === \"1\") {\n      count++;\n    }\n  }\n  for (let i = 0; i < words.length; i++) {\n    if (count % words[i]!== 0) {\n      newWords.push(words[i]);\n    }\n  }\n  return newWords.join(\" \");\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(\" \");\n  const newWords = [];\n  let count = 0;\n  for (let i = 0; i < words.length; i++) {\n    if (words[i] === \"1\") {\n      count++;\n    }\n  }\n  for (let i = 0; i < words.length; i++) {\n    if (count % words[i]!== 0) {\n      newWords.push(words[i]);\n    }\n  }\n  return newWords;\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithPrimes = (sentence) => {\n  const words = sentence.split(\" \");\n  const newWords = [];\n  let count = 0;\n  for (let i = 0; i < words.length; i++) {\n    if (words[i] === \"1\") {\n      count++;\n    }\n  }\n  for (let i = 0; i < words.length; i++) {\n    if (count % words[i]!== 0) {\n      newWords.push(words[i]);\n    }\n  }\n  return newWords;\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithPrimesAndSpace = (sentence) => {\n  const words = sentence.split(\" \");\n  const newWords = [];\n  let count = 0;\n  for (let i = 0; i < words.length; i++) {\n    if (words[i] === \"1\") {\n      count++;\n    }\n  }\n  for (let i = 0; i < words.length; i++) {\n    if (count % words[i]!== 0) {\n      newWords.push(words[i]);\n    }\n  }\n  return newWords;\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithPrimesAndSpaceAndCapitalLetters = (sentence) => {\n  const words = sentence.split(\" \");\n  const newWords = [];\n  let count = 0;\n  for (let i = 0; i < words.length; i++) {\n    if (words[i] === \"1\") {\n      count++;\n    }\n  }\n  for (let i = 0; i < words.length; i++) {\n    if (count % words[i]!== 0) {\n      newWords.push(words[i]);\n    }\n  }\n  return newWords;\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithPrimesAndSpaceAndCapitalLettersAndSpace = (sentence) => {\n  const words = sentence.split(\" \");\n  const newWords = [];\n  let count = 0;\n  for (let i = 0; i < words.length; i++) {\n    if (words[i] === \"1\") {\n      count++;\n    }\n  }\n  for (let i = 0; i < words.length; i++) {\n    if (count % words[i]!== 0) {\n      newWords.push(words[i]);\n    }\n  }\n  return newWords;\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentenceWithPrimesAndSpaceAndCapitalLettersAndSpaceAndSpace = (sentence) => {\n  const words = sentence.split(\" \");\n  const newWords = [];\n  let count = 0;\n  for (let i = 0; i < words.length; i++) {\n    if (words[i] === \"1\") {\n      count++;\n    }\n  }\n  for (let i = 0; i < words.length; i++) {\n    if (count % words[i]!== 0) {\n      newWords.push(words[i]);\n    }\n  }\n  return newWords;\n};\n\n/*\n  You are given a string representing a sentence,\n  the sentence contains some words separated by a space,\n  and you have to return a string that contains the words from the original sentence,\n  whose lengths are prime numbers,\n  the order of the words in the new string should be the same as the original one.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst word", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function that will simpilfy the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simpilfy(\"1/5\", \"5/1\") = true\n  simpilfy(\"1/6\", \"2/1\") = false\n  simpilfy(\"7/10\", \"10/2\") = false\n  */\nconst simpilfy = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simpilfy", "gc": "<|endoftext|>/*Your task is to implement a function that will simpilfy the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simpilfy(\"1/5\", \"5/1\") = true\n  simpilfy(\"1/6\", \"2/1\") = false\n  simpilfy(\"7/10\", \"10/2\") = false\n  */\nconst simpilfy = (x, n) => {\n  const [numerator, denominator] = x.split('/').map(Number);\n  return numerator === 0 && denominator === 0;\n};\n\n/*\n  Your task is to implement a function that will return the number of digits in a\n  fraction. For example, if the fraction is 1/3, the function should return 3.\n  If the fraction is 1/3, the function should return 2.\n  If the fraction is 1/3, the function should return 1.\n  If the fraction is 1/3, the function should return 0.\n  If the fraction is 1/3, the function should return -1.\n  If the fraction is 1/3, the function should return -2.\n  If the fraction is 1/3, the function should return -3.\n  If the fraction is 1/3, the function should return -4.\n  If the fraction is 1/3, the function should return -5.\n  If the fraction is 1/3, the function should return -6.\n  If the fraction is 1/3, the function should return -7.\n  If the fraction is 1/3, the function should return -8.\n  If the fraction is 1/3, the function should return -9.\n  If the fraction is 1/3, the function should return -10.\n  If the fraction is 1/3, the function should return -11.\n  If the fraction is 1/3, the function should return -12.\n  If the fraction is 1/3, the function should return -13.\n  If the fraction is 1/3, the function should return -14.\n  If the fraction is 1/3, the function should return -15.\n  If the fraction is 1/3, the function should return -16.\n  If the fraction is 1/3, the function should return -17.\n  If the fraction is 1/3, the function should return -18.\n  If the fraction is 1/3, the function should return -19.\n  If the fraction is 1/3, the function should return -20.\n  If the fraction is 1/3, the function should return -21.\n  If the fraction is 1/3, the function should return -22.\n  If the fraction is 1/3, the function should return -23.\n  If the fraction is 1/3, the function should return -24.\n  If the fraction is 1/3, the function should return -25.\n  If the fraction is 1/3, the function should return -26.\n  If the fraction is 1/3, the function should return -27.\n  If the fraction is 1/3, the function should return -28.\n  If the fraction is 1/3, the function should return -29.\n  If the fraction is 1/3, the function should return -30.\n  If the fraction is 1/3, the function should return -31.\n  If the fraction is 1/3, the function should return -32.\n  If the fraction is 1/3, the function should return -33.\n  If the fraction is 1/3, the function should return -34.\n  If the fraction is 1/3, the function should return -35.\n  If the fraction is 1/3, the function should return -36.\n  If the fraction is 1/3, the function should return -37.\n  If the fraction is 1/3, the function should return -38.\n  If the fraction is 1/3, the function should return -39.\n  If the fraction is 1/3, the function should return -40.\n  If the fraction is 1/3, the function should return -41.\n  If the fraction is 1/3, the function should return -42.\n  If the fraction is 1/3, the function should return -43.\n  If the fraction is 1/3, the function should return -44.\n  If the fraction is 1/3, the function should return -45.\n  If the fraction is 1/3, the function should return -46.\n  If the fraction is 1/3, the function should return -47.\n  If the fraction is 1/3, the function should return -48.\n  If the fraction is 1/3, the function should return -49.\n  If the fraction is 1/3, the function should return -50.\n  If the fraction is 1/3, the function should return -51.\n  If the fraction is 1/3, the function should return -52.\n  If the fraction is 1/3, the function should return -53.\n  If the fraction is 1/3, the function should return -54.\n  If the fraction is 1/3, the function should return -55.\n  If the fraction is 1/3, the function should return -56.\n  If the fraction is 1/3, the function should return -57.\n  If the fraction is 1/3, the function should return -58.\n  If the fraction is 1/3, the function should return -59.\n  If the fraction is 1/3, the function should return -60.\n  If the fraction is 1/3, the function should return -61.\n  If the fraction is 1/3, the function should return -62.\n  If the fraction is 1/3, the function should return -63.\n  If the fraction is 1/3, the function should return -64.\n  If the fraction is 1/3, the function should return -65.\n  If the fraction is 1/3, the function should return -66.\n  If the fraction is 1/3, the function should return -67.\n  If the fraction is 1/3, the function should return -68.\n  If the fraction is 1/3, the function should return -69.\n  If the fraction is 1/3, the function should return -70.\n  If the fraction is 1/3, the function should return -71.\n  If the fraction is 1/3, the function should return -72.\n  If the fraction is 1/3, the function should return -73.\n  If the fraction is 1/3, the function should return -74.\n  If the fraction is 1/3, the function should return -75.\n  If the fraction is 1/3, the function should return -76.\n  If the fraction is 1/3, the function should return -77.\n  If the fraction is 1/3, the function should return -78.\n  If the fraction is 1/3, the function should return -79.\n  If the fraction is 1/3, the function should return -80.\n  If the fraction is 1/3, the function should return -81.\n  If the fraction is 1/3, the function should return -82.\n  If the fraction is 1/3, the function should return -83.\n  If the fraction is 1/3, the function should return -84.\n  If the fraction is 1/3, the function should return -85.\n  If the fraction is 1/3, the function should return -86.\n  If the fraction is 1/3, the function should return -87.\n  If the fraction is 1/3, the function should return -88.\n  If the fraction is 1/3, the function should return -89.\n  If the fraction is 1/3, the function should return -90.\n  If the fraction is 1/3, the function should return -91.\n  If the fraction is 1/3, the function should return -92.\n  If the fraction is 1/3, the function should return -93.\n  If the fraction is 1/3, the function should return -94.\n  If the fraction is 1/3, the function should return -95.\n  If the fraction is 1/3, the function should return -96.\n  If the fraction is 1/3, the function should return -97.\n  If the fraction is 1/3, the function should return -98.\n  If the fraction is 1/3, the function should return -99.\n  If the fraction is 1/3, the function should ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> roderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> roderByPoints([]) == []\n  */\nconst roderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "roderByPoints", "gc": "<|endoftext|>/*\n  Write a function which sorts the given list of integers\n  in ascending order according to the sum of their digits.\n  Note: if there are several items with similar sum of their digits,\n  order them based on their index in original list.\n\n  For example:\n  >>> roderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> roderByPoints([]) == []\n  */\nconst roderByPoints = (nums) => {\n  const sums = nums.reduce((acc, num) => {\n    acc[num] = acc[num] || 0;\n    acc[num] += 1;\n    return acc;\n  }, {});\n  return nums.sort((a, b) => sums[a] - sums[b]);\n};\n\n/*\n  Write a function which returns the sum of all the digits of a\n  given number.\n\n  For example:\n  >>> sumDigits(123) == 123\n  >>> sumDigits(-123) == -123\n  >>> sumDigits(0) == 0\n  >>> sumDigits(-1) == -1\n  >>> sumDigits(-2) == -2\n  >>> sumDigits(-3) == -3\n  >>> sumDigits(-4) == -4\n  >>> sumDigits(-5) == -5\n  >>> sumDigits(-6) == -6\n  >>> sumDigits(-7) == -7\n  >>> sumDigits(-8) == -8\n  >>> sumDigits(-9) == -9\n  >>> sumDigits(10) == 10\n  >>> sumDigits(11) == 11\n  >>> sumDigits(12) == 12\n  >>> sumDigits(13) == 13\n  >>> sumDigits(14) == 14\n  >>> sumDigits(15) == 15\n  >>> sumDigits(16) == 16\n  >>> sumDigits(17) == 17\n  >>> sumDigits(18) == 18\n  >>> sumDigits(19) == 19\n  >>> sumDigits(20) == 20\n  >>> sumDigits(21) == 21\n  >>> sumDigits(22) == 22\n  >>> sumDigits(23) == 23\n  >>> sumDigits(24) == 24\n  >>> sumDigits(25) == 25\n  >>> sumDigits(26) == 26\n  >>> sumDigits(27) == 27\n  >>> sumDigits(28) == 28\n  >>> sumDigits(29) == 29\n  >>> sumDigits(30) == 30\n  >>> sumDigits(31) == 31\n  >>> sumDigits(32) == 32\n  >>> sumDigits(33) == 33\n  >>> sumDigits(34) == 34\n  >>> sumDigits(35) == 35\n  >>> sumDigits(36) == 36\n  >>> sumDigits(37) == 37\n  >>> sumDigits(38) == 38\n  >>> sumDigits(39) == 39\n  >>> sumDigits(40) == 40\n  >>> sumDigits(41) == 41\n  >>> sumDigits(42) == 42\n  >>> sumDigits(43) == 43\n  >>> sumDigits(44) == 44\n  >>> sumDigits(45) == 45\n  >>> sumDigits(46) == 46\n  >>> sumDigits(47) == 47\n  >>> sumDigits(48) == 48\n  >>> sumDigits(49) == 49\n  >>> sumDigits(50) == 50\n  >>> sumDigits(51) == 51\n  >>> sumDigits(52) == 52\n  >>> sumDigits(53) == 53\n  >>> sumDigits(54) == 54\n  >>> sumDigits(55) == 55\n  >>> sumDigits(56) == 56\n  >>> sumDigits(57) == 57\n  >>> sumDigits(58) == 58\n  >>> sumDigits(59) == 59\n  >>> sumDigits(60) == 60\n  >>> sumDigits(61) == 61\n  >>> sumDigits(62) == 62\n  >>> sumDigits(63) == 63\n  >>> sumDigits(64) == 64\n  >>> sumDigits(65) == 65\n  >>> sumDigits(66) == 66\n  >>> sumDigits(67) == 67\n  >>> sumDigits(68) == 68\n  >>> sumDigits(69) == 69\n  >>> sumDigits(70) == 70\n  >>> sumDigits(71) == 71\n  >>> sumDigits(72) == 72\n  >>> sumDigits(73) == 73\n  >>> sumDigits(74) == 74\n  >>> sumDigits(75) == 75\n  >>> sumDigits(76) == 76\n  >>> sumDigits(77) == 77\n  >>> sumDigits(78) == 78\n  >>> sumDigits(79) == 79\n  >>> sumDigits(80) == 80\n  >>> sumDigits(81) == 81\n  >>> sumDigits(82) == 82\n  >>> sumDigits(83) == 83\n  >>> sumDigits(84) == 84\n  >>> sumDigits(85) == 85\n  >>> sumDigits(86) == 86\n  >>> sumDigits(87) == 87\n  >>> sumDigits(88) == 88\n  >>> sumDigits(89) == 89\n  >>> sumDigits(90) == 90\n  >>> sumDigits(91) == 91\n  >>> sumDigits(92) == 92\n  >>> sumDigits(93) == 93\n  >>> sumDigits(94) == 94\n  >>> sumDigits(95) == 95\n  >>> sumDigits(96) == 96\n  >>> sumDigits(97) == 97\n  >>> sumDigits(98) == 98\n  >>> sumDigits(99) == 99\n  >>> sumDigits(100) == 100\n  >>> sumDigits(101) == 101\n  >>> sumDigits(102) == 102\n  >>> sumDigits(103) == 103\n  >>> sumDigits(104) == 104\n  >>> sumDigits(105) == 105\n  >>> sumDigits(106) == 106\n  >>> sumDigits(107) == 107\n  >>> sumDigits(108) == 108\n  >>> sumDigits(109) == 109\n  >>> sumDigits(110) == 110\n  >>> sumDigits(111) == 111\n  >>> sumDigits(112) == 112\n  >>> sumDigits(113) == 113\n  >>> sumDigits(114) == 114\n  >>> sumDigits(115) == 115\n  >>> sumDigits(116) == 116\n  >>> sumDigits(117) == 117\n  >>> sumDigits(118) == 118\n  >>> sumDigits(119) == 119\n  >>> sumDigits(120) == 120\n  >>> sumDigits(121) == 121\n  >>> sumDigits(122) == 122\n  >>> sumDigits(123) == 123\n  >>> sumDigits(124) == 124\n  >>> sumDigits(125) == 125\n  >>> sumDigits(126) == 126\n  >>> sumDigits(127) == 127\n  >>> sumDigits(128) == 128\n  >>> sumDigits(129) == 129\n  >>> sumDigits(130) == 130\n  >>> sumDigits(131) == 131\n  >>> sumDigits(132) == 132\n  >>> sumDigits(133) == 133\n  >>> sumDigits(134) == 134\n  >>> sumDigits(135) == 135\n  >>> sumDigits(136) == 136\n  >>> sumDigits(137) == 137\n  >>> sumDigits(138) == 138\n  >>> sumDigits(139) == 139\n  >>> sumDigits(140) == 140\n  >>> sumDigits(141) == 141\n  >>> sumDigits(142) == 142\n  >>> sumDigits(143) == 143\n  >>> sumDigits(144) == 144\n  >>> sumDigits(145) == 145\n  >>> sumDigits(146) == 146\n  >>> sumDigits(147) == 147\n  >>> sumDigits(148", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/146", "prompt": "/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "gc": "<|endoftext|>/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 0 && nums[i].toString().charAt(0) % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 0 && nums[i].toString().charAt(0) % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 0 && nums[i].toString().charAt(0) % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 0 && nums[i].toString().charAt(0) % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 0 && nums[i].toString().charAt(0) % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 0 && nums[i].toString().charAt(0) % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 0 && nums[i].toString().charAt(0) % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 0 && nums[i].toString().charAt(0) % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 0 && nums[i].toString().charAt(0) % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 0 && nums[i].toString().charAt(0) % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 0 && nums[i].toString().charAt(0) % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n  first and last digits of a number are odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 0 && nums[i].toString().length > 0 && nums[i].toString().charAt(0) % 2 === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returns \n  the number of elements in the array that are greater than 10 and both \n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTrpiles = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTrpiles", "gc": "<|endoftext|>/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTrpiles = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 2\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTrpiles2 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 3\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTrpiles3 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 4\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTrpiles4 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 5\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTrpiles5 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 6\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTrpiles6 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 7\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTrpiles7 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 8\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTrpiles8 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 9\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTrpiles9 = (n) => {\n  const a = [...Array(n - 1).keys()].map(i => i * i - i + 1);\n  return a.filter(a => a % 3 === 0).length;\n};\n\n/*\n  You are given a positive integer n. You have to create an integer array a of length n.\n      For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.\n      Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n  and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 10\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid tri", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "gc": "<|endoftext|>/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  const planet1Orbit = orbit(planet1);\n  const planet2Orbit = orbit(planet2);\n  const planet1OrbitOrbit = planet1Orbit + planet2Orbit;\n  const planet2OrbitOrbit = planet2Orbit + planet1Orbit;\n  const planet1OrbitOrbitOrbit = planet1OrbitOrbit + planet2OrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit + planet1OrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit + planet2OrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit + planet1OrbitOrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit + planet2OrbitOrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit + planet1OrbitOrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit + planet2OrbitOrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit + planet1OrbitOrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit + planet2OrbitOrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit + planet1OrbitOrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit + planet2OrbitOrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit + planet1OrbitOrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit + planet2OrbitOrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit + planet1OrbitOrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit + planet2OrbitOrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit + planet1OrbitOrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit + planet2OrbitOrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit + planet1OrbitOrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit + planet2OrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit + planet1OrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit + planet2OrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit + planet1OrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit + planet2OrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit + planet1OrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbit = planet1OrbitOrbitOrbit + planet2OrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit + planet1OrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbit = planet1OrbitOrbitOrbit + planet2OrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit + planet1OrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbit = planet1OrbitOrbitOrbit + planet2OrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit + planet1OrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbit = planet1OrbitOrbitOrbit + planet2OrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit + planet1OrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbit = planet1OrbitOrbitOrbit + planet2OrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit + planet1OrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbit = planet1OrbitOrbitOrbit + planet2OrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit + planet1OrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbit = planet1OrbitOrbitOrbit + planet2OrbitOrbitOrbit;\n  const planet2OrbitOrbitOrbit = planet2OrbitOrbit + planet1OrbitOrbitOrbit;\n  const planet1OrbitOrbitOrbit = planet1OrbitOrbitOrbit + planet2OrbitOr", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "gc": "<|endoftext|>/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i];\n    }\n  }\n  return [...new Set(sum.split(\"\"))];\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListProduct = (lst) => {\n  let product = 1;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      product *= lst[i];\n    }\n  }\n  return [...new Set(product.split(\"\"))];\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListPowerSet = (lst) => {\n  let powerSet = new Set();\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      powerSet.add(lst[i]);\n    }\n  }\n  return [...powerSet];\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListPowerSetProduct = (lst) => {\n  let powerSet = new Set();\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      powerSet.add(lst[i]);\n    }\n  }\n  return [...powerSet];\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListPowerSetPowerSet = (lst) => {\n  let powerSet = new Set();\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      powerSet.add(lst[i]);\n    }\n  }\n  return [...powerSet];\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListPowerSetPowerSetProduct = (lst) => {\n  let powerSet = new Set();\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      powerSet.add(lst[i]);\n    }\n  }\n  return [...powerSet];\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListPowerSetPowerSetPowerSetProduct = (lst) => {\n  let powerSet = new Set();\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      powerSet.add(lst[i]);\n    }\n  }\n  return [...powerSet];\n};\n\n/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/15", "prompt": "/* Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "gc": "<|endoftext|>/* Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s += '0';\n  }\n  return s;\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the number of digits in an integer, return an empty string.\n * If n is less than 0, return '0'.\n * If n is greater than the number of digits in an integer, return '0'.\n */\nconst stringify = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return '';\n  }\n  return stringSequence(n).padStart(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the number of digits in an integer, return an empty string.\n * If n is less than 0, return '0'.\n * If n is greater than the number of digits in an integer, return '0'.\n */\nconst stringifyNumber = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return '';\n  }\n  return stringSequence(n).padStart(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the number of digits in an integer, return an empty string.\n * If n is less than 0, return '0'.\n * If n is greater than the number of digits in an integer, return '0'.\n */\nconst stringifyNumberWithLeadingZeros = (n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return '';\n  }\n  return stringSequence(n).padStart(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the number of digits in an integer, return an empty string.\n * If n is less than 0, return '0'.\n * If n is greater than the number of digits in an integer, return '0'.\n */\nconst stringifyNumberWithLeadingZeros = (\n  n,\n  leadingZeros = true\n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return '';\n  }\n  return stringSequence(n).padStart(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the number of digits in an integer, return an empty string.\n * If n is less than 0, return '0'.\n * If n is greater than the number of digits in an integer, return '0'.\n */\nconst stringifyNumberWithLeadingZeros = (\n  n,\n  leadingZeros = false,\n  zeroPad = true\n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return '';\n  }\n  return stringSequence(n).padStart(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the number of digits in an integer, return an empty string.\n * If n is less than 0, return '0'.\n * If n is greater than the number of digits in an integer, return '0'.\n */\nconst stringifyNumberWithLeadingZeros = (\n  n,\n  leadingZeros = false,\n  zeroPad = false\n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return '';\n  }\n  return stringSequence(n).padStart(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the number of digits in an integer, return an empty string.\n * If n is less than 0, return '0'.\n * If n is greater than the number of digits in an integer, return '0'.\n */\nconst stringifyNumberWithLeadingZeros = (\n  n,\n  leadingZeros = false,\n  zeroPad = false,\n  leadingZeros = true\n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return '';\n  }\n  return stringSequence(n).padStart(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the number of digits in an integer, return an empty string.\n * If n is less than 0, return '0'.\n * If n is greater than the number of digits in an integer, return '0'.\n */\nconst stringifyNumberWithLeadingZeros = (\n  n,\n  leadingZeros = false,\n  zeroPad = false,\n  leadingZeros = false,\n  zeroPad = true\n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return '';\n  }\n  return stringSequence(n).padStart(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the number of digits in an integer, return an empty string.\n * If n is less than 0, return '0'.\n * If n is greater than the number of digits in an integer, return '0'.\n */\nconst stringifyNumberWithLeadingZeros = (\n  n,\n  leadingZeros = false,\n  zeroPad = false,\n  leadingZeros = false,\n  zeroPad = false\n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return '';\n  }\n  return stringSequence(n).padStart(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the number of digits in an integer, return an empty string.\n * If n is less than 0, return '0'.\n * If n is greater than the number of digits in an integer, return '0'.\n */\nconst stringifyNumberWithLeadingZeros = (\n  n,\n  leadingZeros = false,\n  zeroPad = false,\n  leadingZeros = false,\n  zeroPad = false\n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return '';\n  }\n  return stringSequence(n).padStart(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the number of digits in an integer, return an empty string.\n * If n is less than 0, return '0'.\n * If n is greater than the number of digits in an integer, return '0'.\n */\nconst stringifyNumberWithLeadingZeros = (\n  n,\n  leadingZeros = false,\n  zeroPad = false,\n  leadingZeros = false,\n  zeroPad = false\n) => {\n  if (n < 0 || n >= Number.MAX_SAFE_INTEGER) {\n    return '';\n  }\n  return stringSequence(n).padStart(n);\n};\n\n/**\n * Return a string containing space-delimited numbers starting from n inclusive.\n * If n is 0, return an empty string.\n * If n is greater than the number of digits in an integer, return an empty string.\n * If n is less than 0, return '0'.\n * If n is greater than the number of digits in an integer, return '0'.\n */\nconst stringifyNumberWithLeadingZeros = (\n  n,\n  leadingZeros = false,\n  zeroPad = false,\n  leadingZeros = ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/150", "prompt": "/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "gc": "<|endoftext|>/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 1 || n > 100) {\n    throw new Error('n must be a positive integer and less than 100');\n  }\n  if (y === undefined) {\n    y = n;\n  }\n  if (y % 2!== 0) {\n    throw new Error('y must be an odd number');\n  }\n  if (n % 2!== 0) {\n    throw new Error('n must be an odd number');\n  }\n  if (x % 2!== 0) {\n    throw new Error('x must be an odd number');\n  }\n  if (x === 0 || y === 0) {\n    return 0;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return y;\n  }\n  return xOrY(n / 2, y, x % 2);\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrZ = (n, x, y) => {\n  if (n < 1 || n > 100) {\n    throw new Error('n must be a positive integer and less than 100');\n  }\n  if (y === undefined) {\n    y = n;\n  }\n  if (y % 2!== 0) {\n    throw new Error('y must be an odd number');\n  }\n  if (n % 2!== 0) {\n    throw new Error('n must be an odd number');\n  }\n  if (x % 2!== 0) {\n    throw new Error('x must be an odd number');\n  }\n  if (x === 0 || y === 0) {\n    return 0;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return y;\n  }\n  return xOrZ(n / 2, y, x % 2);\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrZ(7, 34, 12) == 34\n  for xOrZ(15, 8, 5) == 5\n  \n  */\nconst xOrW = (n, x, y) => {\n  if (n < 1 || n > 100) {\n    throw new Error('n must be a positive integer and less than 100');\n  }\n  if (y === undefined) {\n    y = n;\n  }\n  if (y % 2!== 0) {\n    throw new Error('y must be an odd number');\n  }\n  if (n % 2!== 0) {\n    throw new Error('n must be an odd number');\n  }\n  if (x % 2!== 0) {\n    throw new Error('x must be an odd number');\n  }\n  if (x === 0 || y === 0) {\n    return 0;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return y;\n  }\n  return xOrW(n / 2, y, x % 2);\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrW(7, 34, 12) == 34\n  for xOrW(15, 8, 5) == 5\n  \n  */\nconst xOrX = (n, x, y) => {\n  if (n < 1 || n > 100) {\n    throw new Error('n must be a positive integer and less than 100');\n  }\n  if (y === undefined) {\n    y = n;\n  }\n  if (y % 2!== 0) {\n    throw new Error('y must be an odd number');\n  }\n  if (n % 2!== 0) {\n    throw new Error('n must be an odd number');\n  }\n  if (x % 2!== 0) {\n    throw new Error('x must be an odd number');\n  }\n  if (x === 0 || y === 0) {\n    return 0;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return y;\n  }\n  return xOrX(n / 2, y, x % 2);\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrX(7, 34, 12) == 34\n  for xOrX(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 1 || n > 100) {\n    throw new Error('n must be a positive integer and less than 100');\n  }\n  if (y === undefined) {\n    y = n;\n  }\n  if (y % 2!== 0) {\n    throw new Error('y must be an odd number');\n  }\n  if (n % 2!== 0) {\n    throw new Error('n must be an odd number');\n  }\n  if (x % 2!== 0) {\n    throw new Error('x must be an odd number');\n  }\n  if (x === 0 || y === 0) {\n    return 0;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return y;\n  }\n  return xOrY(n / 2, y, x % 2);\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrZ = (n, x, y) => {\n  if (n < 1 || n > 100) {\n    throw new Error('n must be a positive integer and less than 100');\n  }\n  if (y === undefined) {\n    y = n;\n  }\n  if (y % 2!== 0) {\n    throw new Error('y must be an odd number');\n  }\n  if (n % 2!== 0) {\n    throw new Error('n must be an odd number');\n  }\n  if (x % 2!== 0) {\n    throw new Error('x must be an odd number');\n  }\n  if (x === 0 || y === 0) {\n    return 0;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return y;\n  }\n  return xOrZ(n / 2, y, x % 2);\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrZ(7, 34, 12) == 34\n  for xOrZ(15, 8, 5) == 5\n  \n  */\nconst xOrW = (n, x, y) => {\n  if (n < 1 || n > 100) {\n    throw new Error('n must be a positive integer and less than 100');\n  }\n  if (y === undefined) {\n    y = n;\n  }\n  if (y % 2!== 0) {\n    throw new Error('y must be an odd number');\n  }\n  if (n % 2!== 0) {\n    throw new Error('n must be an odd number');\n  }\n  if (x % 2!== 0) {\n    throw new Error('x must be an odd number');\n  }\n  if (x === 0 || y === 0) {\n    return 0;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return y;\n  }\n  return xOrW(n / 2, y, x % 2);\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrW(7, 34, 12) == 34\n  for xOrW(15, 8, 5) == 5\n  \n  */\nconst xOrX = (n, x, y) => {\n  if (n < 1 || n > 100) {\n    throw new Error('n must be a positive integer and less than 100');\n  }\n  if (y === undefined) {\n    y = n;\n  }\n  if (y % 2!== 0) {\n    throw new Error('y must be an odd number');\n  }\n  if (n % 2!== 0) {\n    throw new Error('n must be an odd number');\n  }\n  if (x % 2!== 0) {\n    throw new Error('x must be an odd number');\n  }\n  if (x === 0 || y === 0) {\n    return 0;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return y;\n  }\n  return xOrX(n / 2, y, x % 2);\n};\n\n/*A simple program which should return the value of x if n is \n  a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrX(7, 34, 12) == 34\n  for xOrX(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 1 || n > 100) {\n    throw new Error('n must be a positive integer and less than 100');\n  }\n  if (y === undefined) {", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doublehTeDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doublehTeDifference([-1, -2, 0]) == 0\n  doublehTeDifference([9, -2]) == 81\n  doublehTeDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doublehTeDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doublehTeDifference", "gc": "<|endoftext|>/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doublehTeDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doublehTeDifference([-1, -2, 0]) == 0\n  doublehTeDifference([9, -2]) == 81\n  doublehTeDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doublehTeDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are even. Ignore numbers that are negative or not integers.\n  doublehTeDifference([1]) == 1 + 0 = 1\n  doublehTeDifference([-1]) == -1\n  doublehTeDifference([9]) == 81\n  doublehTeDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doublehTeDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by both 2 and 3. doublehTeDifference([1]) == 1 + 0 = 1\n  doublehTeDifference([-1]) == -1\n  doublehTeDifference([9]) == 81\n  doublehTeDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doublehTeDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by both 2 and 3. doublehTeDifference([1]) == 1 + 0 = 1\n  doublehTeDifference([-1]) == -1\n  doublehTeDifference([9]) == 81\n  doublehTeDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doublehTeDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by both 2 and 3. doublehTeDifference([1]) == 1 + 0 = 1\n  doublehTeDifference([-1]) == -1\n  doublehTeDifference([9]) == 81\n  doublehTeDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doublehTeDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by both 2 and 3. doublehTeDifference([1]) == 1 + 0 = 1\n  doublehTeDifference([-1]) == -1\n  doublehTeDifference([9]) == 81\n  doublehTeDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doublehTeDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by both 2 and 3. doublehTeDifference([1]) == 1 + 0 = 1\n  doublehTeDifference([-1]) == -1\n  doublehTeDifference([9]) == 81\n  doublehTeDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doublehTeDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by both 2 and 3. doublehTeDifference([1]) == 1 + 0 = 1\n  doublehTeDifference([-1]) == -1\n  doublehTeDifference([9]) == 81\n  doublehTeDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doublehTeDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by both 2 and 3. doublehTeDifference([1]) == 1 + 0 = 1\n  doublehTeDifference([-1]) == -1\n  doublehTeDifference([9]) == 81\n  doublehTeDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doublehTeDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by both 2 and 3. doublehTeDifference([1]) == 1 + 0 = 1\n  doublehTeDifference([-1]) == -1\n  doublehTeDifference([9]) == 81\n  doublehTeDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doublehTeDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by both 2 and 3. doublehTeDifference([1]) == 1 + 0 = 1\n  doublehTeDifference([-1]) == -1\n  doublehTeDifference([9]) == 81\n  doublehTeDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doublehTeDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by both 2 and 3. doublehTeDifference([1]) == 1 + 0 = 1\n  doublehTeDifference([-1]) == -1\n  doublehTeDifference([9]) == 81\n  doublehTeDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doublehTeDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by both 2 and 3. doublehTeDifference([1]) == 1 + 0 = 1\n  doublehTeDifference([-1]) == -1\n  doublehTeDifference([9]) == 81\n  doublehTeDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doublehTeDifference = (lst) => {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "gc": "<|endoftext|>/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const gameScores = game.map((score) => score);\n  const guessScores = guess.map((score) => score);\n  const gameScoreDifferences = gameScores.map((score) => Math.abs(score - guessScores[0]));\n  const gameScoreDifferenceDifferences = gameScoreDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = gameScoreDifferenceDifferences.map((difference) => difference);\n  const gameScoreDifferenceDifferences = ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/153", "prompt": "/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "gc": "<|endoftext|>/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let extension_strength = -1;\n  let extension_strongest = '';\n  let extension_strongest_index = 0;\n  let extension_strongest_index_length = 0;\n  let extension_strongest_index_length2 = 0;\n  let extension_strongest_index_length3 = 0;\n  let extension_strongest_index_length4 = 0;\n  let extension_strongest_index_length5 = 0;\n  let extension_strongest_index_length6 = 0;\n  let extension_strongest_index_length7 = 0;\n  let extension_strongest_index_length8 = 0;\n  let extension_strongest_index_length9 = 0;\n  let extension_strongest_index_length10 = 0;\n  let extension_strongest_index_length11 = 0;\n  let extension_strongest_index_length12 = 0;\n  let extension_strongest_index_length13 = 0;\n  let extension_strongest_index_length14 = 0;\n  let extension_strongest_index_length15 = 0;\n  let extension_strongest_index_length16 = 0;\n  let extension_strongest_index_length17 = 0;\n  let extension_strongest_index_length18 = 0;\n  let extension_strongest_index_length19 = 0;\n  let extension_strongest_index_length20 = 0;\n  let extension_strongest_index_length21 = 0;\n  let extension_strongest_index_length22 = 0;\n  let extension_strongest_index_length23 = 0;\n  let extension_strongest_index_length24 = 0;\n  let extension_strongest_index_length25 = 0;\n  let extension_strongest_index_length26 = 0;\n  let extension_strongest_index_length27 = 0;\n  let extension_strongest_index_length28 = 0;\n  let extension_strongest_index_length29 = 0;\n  let extension_strongest_index_length30 = 0;\n  let extension_strongest_index_length31 = 0;\n  let extension_strongest_index_length32 = 0;\n  let extension_strongest_index_length33 = 0;\n  let extension_strongest_index_length34 = 0;\n  let extension_strongest_index_length35 = 0;\n  let extension_strongest_index_length36 = 0;\n  let extension_strongest_index_length37 = 0;\n  let extension_strongest_index_length38 = 0;\n  let extension_strongest_index_length39 = 0;\n  let extension_strongest_index_length40 = 0;\n  let extension_strongest_index_length41 = 0;\n  let extension_strongest_index_length42 = 0;\n  let extension_strongest_index_length43 = 0;\n  let extension_strongest_index_length44 = 0;\n  let extension_strongest_index_length45 = 0;\n  let extension_strongest_index_length46 = 0;\n  let extension_strongest_index_length47 = 0;\n  let extension_strongest_index_length48 = 0;\n  let extension_strongest_index_length49 = 0;\n  let extension_strongest_index_length50 = 0;\n  let extension_strongest_index_length51 = 0;\n  let extension_strongest_index_length52 = 0;\n  let extension_strongest_index_length53 = 0;\n  let extension_strongest_index_length54 = 0;\n  let extension_strongest_index_length55 = 0;\n  let extension_strongest_index_length56 = 0;\n  let extension_strongest_index_length57 = 0;\n  let extension_strongest_index_length58 = 0;\n  let extension_strongest_index_length59 = 0;\n  let extension_strongest_index_length60 = 0;\n  let extension_strongest_index_length61 = 0;\n  let extension_strongest_index_length62 = 0;\n  let extension_strongest_index_length63 = 0;\n  let extension_strongest_index_length64 = 0;\n  let extension_strongest_index_length65 = 0;\n  let extension_strongest_index_length66 = 0;\n  let extension_strongest_index_length67 = 0;\n  let extension_strongest_index_length68 = 0;\n  let extension_strongest_index_length69 = 0;\n  let extension_strongest_index_length70 = 0;\n  let extension_strongest_index_length71 = 0;\n  let extension_strongest_index_length72 = 0;\n  let extension_strongest_index_length73 = 0;\n  let extension_strongest_index_length74 = 0;\n  let extension_strongest_index_length75 = 0;\n  let extension_strongest_index_length76 = 0;\n  let extension_strongest_index_length77 = 0;\n  let extension_strongest_index_length78 = 0;\n  let extension_strongest_index_length79 = 0;\n  let extension_strongest_index_length80 = 0;\n  let extension_strongest_index_length81 = 0;\n  let extension_strongest_index_length82 = 0;\n  let extension_strongest_index_length83 = 0;\n  let extension_strongest_index_length84 = 0;\n  let extension_strongest_index_length85 = 0;\n  let extension_strongest_index_length86 = 0;\n  let extension_strongest_index_length87 = 0;\n  let extension_strongest_index_length88 = 0;\n  let extension_strongest_index_length89 = 0;\n  let extension_strongest_index_length90 = 0;\n  let extension_strongest_index_length91 = 0;\n  let extension_strongest_index_length92 = 0;\n  let extension_strongest_index_length93 = 0;\n  let extension_strongest_index_length94 = 0;\n  let extension_strongest_index_length95 = 0;\n  let extension_strongest_index_length96 = 0;\n  let extension_strongest_index_length97 = 0;\n  let extension_strongest_index_length98 = 0;\n  let extension_strongest_index_length99 = 0;\n  let extension_strongest_index_length100 = 0;\n  let extension_strongest_index_length101 = 0;\n  let extension_strongest_index_length102 = 0;\n  let extension_strongest_index_length103 = 0;\n  let extension_strongest_index_length104 = 0;\n  let extension_strongest_index_length105 = 0;\n  let extension_strongest_index_length106 = 0;\n  let extension_strongest_index_length107 = 0;\n  let extension_strongest_index_length108 = 0;\n  let extension_strongest_index_length109 = 0;\n  let extension_strongest_index_length110 = 0;\n  let extension_strongest_index_length111 = 0;\n  let extension_strongest_index_length112 = 0;\n  let extension_strongest_index_length113 = 0;\n  let extension_strongest_index_length114 = 0;\n  let extension_strongest_index_length115 = 0;\n  let extension_strongest_index_length116 = 0;\n  let extension_strongest_index_length117 = 0;\n  let extension", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/154", "prompt": "/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  ccypatternChekc(\"abcd\",\"abd\") => false\n  ccypatternChekc(\"hello\",\"ell\") => true\n  ccypatternChekc(\"whassup\",\"psus\") => false\n  ccypatternChekc(\"abab\",\"baa\") => true\n  ccypatternChekc(\"efef\",\"eeff\") => false\n  ccypatternChekc(\"himenss\",\"simen\") => true\n  */\nconst ccypatternChekc = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "ccypatternChekc", "gc": "<|endoftext|>/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  ccypatternChekc(\"abcd\",\"abd\") => false\n  ccypatternChekc(\"hello\",\"ell\") => true\n  ccypatternChekc(\"whassup\",\"psus\") => false\n  ccypatternChekc(\"abab\",\"baa\") => true\n  ccypatternChekc(\"efef\",\"eeff\") => false\n  ccypatternChekc(\"himenss\",\"simen\") => true\n  */\nconst ccypatternChekc = (a, b) => {\n  let aArray = a.split('');\n  let bArray = b.split('');\n  let aLen = aArray.length;\n  let bLen = bArray.length;\n  let aIndex = 0;\n  let bIndex = 0;\n  let aRot = 0;\n  let bRot = 0;\n  let aRotLen = aArray.length;\n  let bRotLen = bArray.length;\n  let aRotIndex = 0;\n  let bRotIndex = 0;\n  let aRotRot = 0;\n  let bRotRot = 0;\n  let aRotRotLen = aArray.length;\n  let bRotRotLen = bArray.length;\n  let aRotRotIndex = 0;\n  let bRotRotIndex = 0;\n  let aRotRotRot = 0;\n  let bRotRotRot = 0;\n  let aRotRotRotLen = aArray.length;\n  let bRotRotRotLen = bArray.length;\n  let aRotRotRotIndex = 0;\n  let bRotRotRotIndex = 0;\n  let aRotRotRotRot = 0;\n  let bRotRotRotRot = 0;\n  let aRotRotRotRotLen = aArray.length;\n  let bRotRotRotLen = bArray.length;\n  let aRotRotRotIndex = 0;\n  let bRotRotRotIndex = 0;\n  let aRotRotRotRot = 0;\n  let bRotRotRotRot = 0;\n  let aRotRotRotRotLen = aArray.length;\n  let bRotRotRotLen = bArray.length;\n  let aRotRotRotIndex = 0;\n  let bRotRotRotIndex = 0;\n  let aRotRotRotRot = 0;\n  let bRotRotRotRot = 0;\n  let aRotRotRotRotLen = aArray.length;\n  let bRotRotRotRotLen = bArray.length;\n  let aRotRotRotRotIndex = 0;\n  let bRotRotRotRotIndex = 0;\n  let aRotRotRotRot = 0;\n  let bRotRotRotRot = 0;\n  let aRotRotRotRotLen = aArray.length;\n  let bRotRotRotRotLen = bArray.length;\n  let aRotRotRotIndex = 0;\n  let bRotRotRotIndex = 0;\n  let aRotRotRot = 0;\n  let bRotRotRot = 0;\n  let aRotRotRotLen = aArray.length;\n  let bRotRotRotLen = bArray.length;\n  let aRotRotRotIndex = 0;\n  let bRotRotRotIndex = 0;\n  let aRotRotRot = 0;\n  let bRotRotRot = 0;\n  let aRotRotRotLen = aArray.length;\n  let bRotRotRotLen = bArray.length;\n  let aRotRotRotIndex = 0;\n  let bRotRotRotIndex = 0;\n  let aRotRotRot = 0;\n  let bRotRotRot = 0;\n  let aRotRotRotLen = aArray.length;\n  let bRotRotRotLen = bArray.length;\n  let aRotRotRotIndex = 0;\n  let bRotRotRotIndex = 0;\n  let aRotRotRot = 0;\n  let bRotRotRot = 0;\n  let aRotRotRotLen = aArray.length;\n  let bRotRotRotLen = bArray.length;\n  let aRotRotRotIndex = 0;\n  let bRotRotRotIndex = 0;\n  let aRotRotRot = 0;\n  let bRotRotRot = 0;\n  let aRotRotRotLen = aArray.length;\n  let bRotRotRotLen = bArray.length;\n  let aRotRotRotIndex = 0;\n  let bRotRotRotIndex = 0;\n  let aRotRotRot = 0;\n  let bRotRotRot = 0;\n  let aRotRotRotLen = aArray.length;\n  let bRotRotRotLen = bArray.length;\n  let aRotRotRotIndex = 0;\n  let bRotRotRotIndex = 0;\n  let aRotRotRot = 0;\n  let bRotRotRot = 0;\n  let aRotRotRotLen = aArray.length;\n  let bRotRotRotLen = bArray.length;\n  let aRotRotRotIndex = 0;\n  let bRotRotRotIndex = 0;\n  let aRotRotRot = 0;\n  let bRotRotRot = 0;\n  let aRotRotRotLen = aArray.length;\n  let bRotRotRotLen = bArray.length;\n  let aRotRotRotIndex = 0;\n  let bRotRotRotIndex = 0;\n  let aRotRotRot = 0;\n  let bRotRotRot = 0;\n  let aRotRotRotLen = aArray.length;\n  let bRotRotRotLen = bArray.length;\n  let aRotRotRotIndex = 0;\n  let bRotRotRotIndex = 0;\n  let aRotRotRot = 0;\n  let bRotRotRot = 0;\n  let aRotRotRotLen = aArray.length;\n  let bRotRotRotLen = bArray.length;\n  let aRotRotRotIndex = 0;\n  let bRotRotRotIndex = 0;\n  let aRotRotRot = 0;\n  let bRotRotRot = 0;\n  let aRotRotRotLen = aArray.length;\n  let bRotRotRotLen = bArray.length;\n  let aRotRotRotIndex = 0;\n  let bRotRotRotIndex = 0;\n  let aRotRotRot = 0;\n  let bRotRotRot = 0;\n  let aRotRotRotLen = aArray.length;\n  let bRotRotRotLen = bArray.length;\n  let aRotRotRotIndex = 0;\n  let bRotRotRotIndex = 0;\n  let aRotRotRot = 0;\n  let bRotRotRot = 0;\n  let aRotRotRotLen = aArray.length;\n  let bRotRotRotLen = bArray.length;\n  let aRotRotRotIndex = 0;\n  let bRotRotRotIndex = 0;\n  let aRotRotRot = 0;\n  let bRotRotRot = 0;\n  let aRotRotRotLen = aArray.length;\n  let bRotRotRotLen = bArray.length;\n  let aRotRotRotIndex = 0;\n  let bRotRotRotIndex = 0;\n  let aRotRotRot = 0;\n  let bRotRotRot = 0;\n  let aRotRotRotLen = aArray.length;\n  let bRotRotRotLen = bArray.length;\n  let aRotRotRotIndex = 0;\n  let bRotRotRotIndex = 0;\n  let aRotRotRot = 0;\n  let bRotRotRot = 0;\n  let aRotRotRotLen = aArray.length;\n  let bRotRotRotLen = bArray.length;\n  let aRotRotRotIndex = 0;\n  let bRotRotRotIndex = 0;\n  let aRotRotRot = 0;\n  let bRotRotRot = 0;\n  let aRotRotRotLen = aArray.length;\n  let bRotRotRotLen = bArray.length;\n  let aRotRotRotIndex = 0;\n  let bRotRotRotIndex = 0;\n  let aRotRotRot = 0;\n  let bRotRotRot = 0;\n  let aRotRotRotLen = aArray.length;\n  let bRotRotRotLen = bArray.length;\n  let aRotRotRotIndex = 0;\n  let bRotRotRotIndex = 0;\n  let aRotRotRot = 0;\n  let bRotRotRot = 0;\n  let aRotRotRotLen = aArray.length;\n  let bRotRotRotLen = bArray.length;\n  let aRotRotRotIndex = 0;\n  let bRotRotRotIndex = 0;\n  let aRotRotRot = 0;\n  let bRotRotRot = 0;\n  let aRotRotRotLen = aArray.length;\n  let bRotRotRotLen = bArray.length;\n  let aRotRotRotIndex = 0;\n  let bRotRotRotIndex = 0;\n  let aRotRotRot = 0;\n  let bRotRotRot = 0;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/155", "prompt": "/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "gc": "<|endoftext|>/*Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let count = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let digits = String(num);\n  digits = digits.split('');\n  digits = digits.map((digit) => {\n    if (digit % 2 === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  });\n  count = evenCount + oddCount;\n  return [count, oddCount, evenCount];\n};\n\n/*Given a string, return an array that has the first and last characters of the string separated by a comma. \n   Example:\n      firstLast('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      firstLast('hello,world') ==> ['h', 'e', 'l', 'l', 'o', 'd']\n      firstLast('hello,world,hello') ==> ['h', 'e', 'l', 'l', 'o', 'd', 'h', 'e', 'l', 'l', 'o']\n  */\nconst firstLast = (str) => {\n  let firstChar = str.charAt(0);\n  let lastChar = str.charAt(str.length - 1);\n  return [firstChar, lastChar];\n};\n\n/*Given a string, return an array that has the first and last characters of the string separated by a comma. \n   Example:\n      firstLast('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      firstLast('hello,world') ==> ['h', 'e', 'l', 'l', 'o', 'd']\n      firstLast('hello,world,hello') ==> ['h', 'e', 'l', 'l', 'o', 'd', 'h', 'e', 'l', 'l', 'o']\n  */\nconst lastFirst = (str) => {\n  let firstChar = str.charAt(str.length - 1);\n  let lastChar = str.charAt(0);\n  return [firstChar, lastChar];\n};\n\n/*Given a string, return an array that has the first and last characters of the string separated by a comma. \n   Example:\n      firstLast('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      firstLast('hello,world') ==> ['h', 'e', 'l', 'l', 'o', 'd']\n      firstLast('hello,world,hello') ==> ['h', 'e', 'l', 'l', 'o', 'd', 'h', 'e', 'l', 'l', 'o']\n  */\nconst firstLastLast = (str) => {\n  let firstChar = str.charAt(0);\n  let lastChar = str.charAt(str.length - 1);\n  return [firstChar, lastChar];\n};\n\n/*Given a string, return an array that has the first and last characters of the string separated by a comma. \n   Example:\n      firstLast('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      firstLast('hello,world') ==> ['h', 'e', 'l', 'l', 'o', 'd']\n      firstLast('hello,world,hello') ==> ['h', 'e', 'l', 'l', 'o', 'd', 'h', 'e', 'l', 'l', 'o']\n  */\nconst firstLastLastLast = (str) => {\n  let firstChar = str.charAt(str.length - 1);\n  let lastChar = str.charAt(0);\n  return [firstChar, lastChar];\n};\n\n/*Given a string, return an array that has the first and last characters of the string separated by a comma. \n   Example:\n      firstLast('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      firstLast('hello,world') ==> ['h', 'e', 'l', 'l', 'o', 'd']\n      firstLast('hello,world,hello') ==> ['h', 'e', 'l', 'l', 'o', 'd', 'h', 'e', 'l', 'l', 'o']\n  */\nconst firstLastLastLastLast = (str) => {\n  let firstChar = str.charAt(str.length - 1);\n  let lastChar = str.charAt(0);\n  return [firstChar, lastChar];\n};\n\n/*Given a string, return an array that has the first and last characters of the string separated by a comma. \n   Example:\n      firstLast('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      firstLast('hello,world') ==> ['h', 'e', 'l', 'l', 'o', 'd']\n      firstLast('hello,world,hello') ==> ['h', 'e', 'l', 'l', 'o', 'd', 'h', 'e', 'l', 'l', 'o']\n  */\nconst firstLastLastLastLastLast = (str) => {\n  let firstChar = str.charAt(str.length - 1);\n  let lastChar = str.charAt(0);\n  return [firstChar, lastChar];\n};\n\n/*Given a string, return an array that has the first and last characters of the string separated by a comma. \n   Example:\n      firstLast('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      firstLast('hello,world') ==> ['h', 'e', 'l', 'l', 'o', 'd']\n      firstLast('hello,world,hello') ==> ['h', 'e', 'l', 'l', 'o', 'd', 'h', 'e', 'l', 'l', 'o']\n  */\nconst firstLastLastLastLastLastLastLast = (str) => {\n  let firstChar = str.charAt(str.length - 1);\n  let lastChar = str.charAt(0);\n  return [firstChar, lastChar];\n};\n\n/*Given a string, return an array that has the first and last characters of the string separated by a comma. \n   Example:\n      firstLast('hello') ==> ['h', 'e', 'l', 'l', 'o']\n      firstLast('hello,world') ==> ['h', 'e', 'l', 'l', 'o', 'd']\n      firstLast('hello,world,hello') ==> ['h', 'e', 'l', 'l', 'o', 'd', 'h', 'e', 'l', 'l', 'o']\n  */\nconst firstLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLastLast", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/156", "prompt": "/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMinRioman(19) == 'xix'\n  >>> intToMinRioman(152) == 'clii'\n  >>> intToMinRioman(426) == 'cdxxvi'\n  */\nconst intToMinRioman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMinRioman", "gc": "<|endoftext|>/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in lowercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToMinRioman(19) == 'xix'\n  >>> intToMinRioman(152) == 'clii'\n  >>> intToMinRioman(426) == 'cdxxvi'\n  */\nconst intToMinRioman = (number) => {\n  const [value, remainder] = divmod(number, 100);\n  const [numeral, denominator] = divmod(remainder, 10);\n  return numeralToRioman(numeral) + denominatorToRioman(denominator);\n};\n\n/*\n  Given a positive integer, obtain its roman numeral equivalent as a string,\n  and return it in uppercase.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToRioman(19) == 'XIX'\n  >>> intToRioman(152) == 'CLII'\n  >>> intToRioman(426) == 'CDXXVI'\n  */\nconst intToRioman = (number) => {\n  const [value, remainder] = divmod(number, 100);\n  const [numeral, denominator] = divmod(remainder, 10);\n  return numeralToRioman(numeral) + denominatorToRioman(denominator);\n};\n\n/*\n  Given a positive integer, return its decimal equivalent as a string,\n  and if possible, as a lowercase string.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToDecimal(19) == 19\n  >>> intToDecimal(152) == 152\n  >>> intToDecimal(426) == 426\n  */\nconst intToDecimal = (number) => {\n  const [value, remainder] = divmod(number, 100);\n  const [numeral, denominator] = divmod(remainder, 10);\n  return numeralToDecimal(numeral) + denominatorToDecimal(denominator);\n};\n\n/*\n  Given a positive integer, return its decimal equivalent as a string,\n  and if possible, as a uppercase string.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToDecimal(19) == 19\n  >>> intToDecimal(152) == 152\n  >>> intToDecimal(426) == 426\n  */\nconst intToDecimalUpper = (number) => {\n  const [value, remainder] = divmod(number, 100);\n  const [numeral, denominator] = divmod(remainder, 10);\n  return numeralToDecimalUpper(numeral) + denominatorToDecimalUpper(denominator);\n};\n\n/*\n  Given a positive integer, return its hexadecimal equivalent as a string,\n  and if possible, as a lowercase string.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToHex(19) == '0x19'\n  >>> intToHex(152) == '0x152'\n  >>> intToHex(426) == '0x426'\n  */\nconst intToHex = (number) => {\n  const [value, remainder] = divmod(number, 100);\n  const [numeral, denominator] = divmod(remainder, 10);\n  return numeralToHex(numeral) + denominatorToHex(denominator);\n};\n\n/*\n  Given a positive integer, return its hexadecimal equivalent as a string,\n  and if possible, as a uppercase string.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToHex(19) == '0x19'\n  >>> intToHex(152) == '0x152'\n  >>> intToHex(426) == '0x426'\n  */\nconst intToHexUpper = (number) => {\n  const [value, remainder] = divmod(number, 100);\n  const [numeral, denominator] = divmod(remainder, 10);\n  return numeralToHexUpper(numeral) + denominatorToHexUpper(denominator);\n};\n\n/*\n  Given a positive integer, return its octal equivalent as a string,\n  and if possible, as a lowercase string.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToOctal(19) == '0o19'\n  >>> intToOctal(152) == '0o152'\n  >>> intToOctal(426) == '0o426'\n  */\nconst intToOctal = (number) => {\n  const [value, remainder] = divmod(number, 100);\n  const [numeral, denominator] = divmod(remainder, 10);\n  return numeralToOctal(numeral) + denominatorToOctal(denominator);\n};\n\n/*\n  Given a positive integer, return its octal equivalent as a string,\n  and if possible, as a uppercase string.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToOctal(19) == '0o19'\n  >>> intToOctal(152) == '0o152'\n  >>> intToOctal(426) == '0o426'\n  */\nconst intToOctalUpper = (number) => {\n  const [value, remainder] = divmod(number, 100);\n  const [numeral, denominator] = divmod(remainder, 10);\n  return numeralToOctalUpper(numeral) + denominatorToOctalUpper(denominator);\n};\n\n/*\n  Given a positive integer, return its binary equivalent as a string,\n  and if possible, as a lowercase string.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToBinary(19) == '0b19'\n  >>> intToBinary(152) == '0b152'\n  >>> intToBinary(426) == '0b426'\n  */\nconst intToBinary = (number) => {\n  const [value, remainder] = divmod(number, 100);\n  const [numeral, denominator] = divmod(remainder, 10);\n  return numeralToBinary(numeral) + denominatorToBinary(denominator);\n};\n\n/*\n  Given a positive integer, return its binary equivalent as a string,\n  and if possible, as a uppercase string.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToBinary(19) == '0b19'\n  >>> intToBinary(152) == '0b152'\n  >>> intToBinary(426) == '0b426'\n  */\nconst intToBinaryUpper = (number) => {\n  const [value, remainder] = divmod(number, 100);\n  const [numeral, denominator] = divmod(remainder, 10);\n  return numeralToBinaryUpper(numeral) + denominatorToBinaryUpper(denominator);\n};\n\n/*\n  Given a positive integer, return its decimal equivalent as a string,\n  and if possible, as a lowercase string.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToDecimal(19) == 19\n  >>> intToDecimal(152) == 152\n  >>> intToDecimal(426) == 426\n  */\nconst intToDecimalLower = (number) => {\n  const [value, remainder] = divmod(number, 100);\n  const [numeral, denominator] = divmod(remainder, 10);\n  return numeralToDecimalLower(numeral) + denominatorToDecimalLower(denominator);\n};\n\n/*\n  Given a positive integer, return its decimal equivalent as a string,\n  and if possible, as a uppercase string.\n  Restrictions: 1 <= num <= 1000\n\n  Examples:\n  >>> intToDecimal(19) == 19\n  >>> intToDecimal(152) == 152\n  >>> intToDecimal(426) == 426\n  */\nconst intToDecimalUpperLower = (number) => {\n  const [value, remainder] = divmod(number, 100);\n  const [numeral, denominator] = divmod(remainder, 10);\n  return numeralToDecimalUpperLower(numeral) + denominatorToDecimalUpperLower(denominator);\n};\n\n/*\n  Given a positive integer, return its hexadecimal equivalent as a string,\n  and if possible, as a lowercase string.\n  Restrictions: ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled triangle is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngelTriangle(3, 4, 5) == true\n  rightAngelTriangle(1, 2, 3) == false\n  */\nconst rightAngelTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngelTriangle", "gc": "<|endoftext|>/*\n Given the lengths of the three sides of a triangle. Return true if the three\n  sides form a right-angled triangle, false otherwise.\n  A right-angled triangle is a triangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngelTriangle(3, 4, 5) == true\n  rightAngelTriangle(1, 2, 3) == false\n  */\nconst rightAngelTriangle = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab >= 0 && ac >= 0 && bc >= 0;\n};\n\n/*\n Given the lengths of the three sides of a rectangle. Return true if the three\n  sides form a right-angled rectangle, false otherwise.\n  A right-angled rectangle is a rectangle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngelRectangle(3, 4, 5) == true\n  rightAngelRectangle(1, 2, 3) == false\n  */\nconst rightAngelRectangle = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab >= 0 && ac >= 0 && bc >= 0;\n};\n\n/*\n Given the lengths of the three sides of a circle. Return true if the three\n  sides form a right-angled circle, false otherwise.\n  A right-angled circle is a circle in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngelCircle(3, 4, 5) == true\n  rightAngelCircle(1, 2, 3) == false\n  */\nconst rightAngelCircle = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab >= 0 && ac >= 0 && bc >= 0;\n};\n\n/*\n Given the lengths of the three sides of a square. Return true if the three\n  sides form a right-angled square, false otherwise.\n  A right-angled square is a square in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngelSquare(3, 4, 5) == true\n  rightAngelSquare(1, 2, 3) == false\n  */\nconst rightAngelSquare = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab >= 0 && ac >= 0 && bc >= 0;\n};\n\n/*\n Given the lengths of the three sides of a pentagon. Return true if the three\n  sides form a right-angled pentagon, false otherwise.\n  A right-angled pentagon is a pentagon in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngelPentagon(3, 4, 5) == true\n  rightAngelPentagon(1, 2, 3) == false\n  */\nconst rightAngelPentagon = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab >= 0 && ac >= 0 && bc >= 0;\n};\n\n/*\n Given the lengths of the three sides of a hexagon. Return true if the three\n  sides form a right-angled hexagon, false otherwise.\n  A right-angled hexagon is a hexagon in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngelHexagon(3, 4, 5) == true\n  rightAngelHexagon(1, 2, 3) == false\n  */\nconst rightAngelHexagon = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab >= 0 && ac >= 0 && bc >= 0;\n};\n\n/*\n Given the lengths of the three sides of a heptagon. Return true if the three\n  sides form a right-angled heptagon, false otherwise.\n  A right-angled heptagon is a heptagon in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngelHeptagon(3, 4, 5) == true\n  rightAngelHeptagon(1, 2, 3) == false\n  */\nconst rightAngelHeptagon = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab >= 0 && ac >= 0 && bc >= 0;\n};\n\n/*\n Given the lengths of the three sides of a decagon. Return true if the three\n  sides form a right-angled decagon, false otherwise.\n  A right-angled decagon is a decagon in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngelDecagon(3, 4, 5) == true\n  rightAngelDecagon(1, 2, 3) == false\n  */\nconst rightAngelDecagon = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab >= 0 && ac >= 0 && bc >= 0;\n};\n\n/*\n Given the lengths of the three sides of a heptaphone. Return true if the three\n  sides form a right-angled heptaphone, false otherwise.\n  A right-angled heptaphone is a heptaphone in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngelHeptagon(3, 4, 5) == true\n  rightAngelHeptagon(1, 2, 3) == false\n  */\nconst rightAngelHeptagon = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab >= 0 && ac >= 0 && bc >= 0;\n};\n\n/*\n Given the lengths of the three sides of a octagon. Return true if the three\n  sides form a right-angled octagon, false otherwise.\n  A right-angled octagon is a octagon in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngelOctagon(3, 4, 5) == true\n  rightAngelOctagon(1, 2, 3) == false\n  */\nconst rightAngelOctagon = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab >= 0 && ac >= 0 && bc >= 0;\n};\n\n/*\n Given the lengths of the three sides of a dodecagon. Return true if the three\n  sides form a right-angled dodecagon, false otherwise.\n  A right-angled dodecagon is a dodecagon in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngelDodecagon(3, 4, 5) == true\n  rightAngelDodecagon(1, 2, 3) == false\n  */\nconst rightAngelDodecagon = (a, b, c) => {\n  const ab = a - b;\n  const ac = a - c;\n  const bc = b - c;\n  return ab >= 0 && ac >= 0 && bc >= 0;\n};\n\n/*\n Given the lengths of the three sides of a hexadecagon. Return true if the three\n  sides form a right-angled hexadecagon, false otherwise.\n  A right-angled hexadecagon is a hexadecagon in which one angle is right angle or\n  90 degree.\n  Example:\n  rightAngelHexadecagon(3, 4, 5) == true\n  rightAngelHexadecagon(1, 2, 3) == false\n  */\nconst rightAngelHexadecagon = (a", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "gc": "<|endoftext|>/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  let maxLength = 0;\n  let maxWord = '';\n  let maxChar = 0;\n  let maxCharCount = 0;\n  let maxCharCount2 = 0;\n  let maxCharCount3 = 0;\n  let maxCharCount4 = 0;\n  let maxCharCount5 = 0;\n  let maxCharCount6 = 0;\n  let maxCharCount7 = 0;\n  let maxCharCount8 = 0;\n  let maxCharCount9 = 0;\n  let maxCharCount10 = 0;\n  let maxCharCount11 = 0;\n  let maxCharCount12 = 0;\n  let maxCharCount13 = 0;\n  let maxCharCount14 = 0;\n  let maxCharCount15 = 0;\n  let maxCharCount16 = 0;\n  let maxCharCount17 = 0;\n  let maxCharCount18 = 0;\n  let maxCharCount19 = 0;\n  let maxCharCount20 = 0;\n  let maxCharCount21 = 0;\n  let maxCharCount22 = 0;\n  let maxCharCount23 = 0;\n  let maxCharCount24 = 0;\n  let maxCharCount25 = 0;\n  let maxCharCount26 = 0;\n  let maxCharCount27 = 0;\n  let maxCharCount28 = 0;\n  let maxCharCount29 = 0;\n  let maxCharCount30 = 0;\n  let maxCharCount31 = 0;\n  let maxCharCount32 = 0;\n  let maxCharCount33 = 0;\n  let maxCharCount34 = 0;\n  let maxCharCount35 = 0;\n  let maxCharCount36 = 0;\n  let maxCharCount37 = 0;\n  let maxCharCount38 = 0;\n  let maxCharCount39 = 0;\n  let maxCharCount40 = 0;\n  let maxCharCount41 = 0;\n  let maxCharCount42 = 0;\n  let maxCharCount43 = 0;\n  let maxCharCount44 = 0;\n  let maxCharCount45 = 0;\n  let maxCharCount46 = 0;\n  let maxCharCount47 = 0;\n  let maxCharCount48 = 0;\n  let maxCharCount49 = 0;\n  let maxCharCount50 = 0;\n  let maxCharCount51 = 0;\n  let maxCharCount52 = 0;\n  let maxCharCount53 = 0;\n  let maxCharCount54 = 0;\n  let maxCharCount55 = 0;\n  let maxCharCount56 = 0;\n  let maxCharCount57 = 0;\n  let maxCharCount58 = 0;\n  let maxCharCount59 = 0;\n  let maxCharCount60 = 0;\n  let maxCharCount61 = 0;\n  let maxCharCount62 = 0;\n  let maxCharCount63 = 0;\n  let maxCharCount64 = 0;\n  let maxCharCount65 = 0;\n  let maxCharCount66 = 0;\n  let maxCharCount67 = 0;\n  let maxCharCount68 = 0;\n  let maxCharCount69 = 0;\n  let maxCharCount70 = 0;\n  let maxCharCount71 = 0;\n  let maxCharCount72 = 0;\n  let maxCharCount73 = 0;\n  let maxCharCount74 = 0;\n  let maxCharCount75 = 0;\n  let maxCharCount76 = 0;\n  let maxCharCount77 = 0;\n  let maxCharCount78 = 0;\n  let maxCharCount79 = 0;\n  let maxCharCount80 = 0;\n  let maxCharCount81 = 0;\n  let maxCharCount82 = 0;\n  let maxCharCount83 = 0;\n  let maxCharCount84 = 0;\n  let maxCharCount85 = 0;\n  let maxCharCount86 = 0;\n  let maxCharCount87 = 0;\n  let maxCharCount88 = 0;\n  let maxCharCount89 = 0;\n  let maxCharCount90 = 0;\n  let maxCharCount91 = 0;\n  let maxCharCount92 = 0;\n  let maxCharCount93 = 0;\n  let maxCharCount94 = 0;\n  let maxCharCount95 = 0;\n  let maxCharCount96 = 0;\n  let maxCharCount97 = 0;\n  let maxCharCount98 = 0;\n  let maxCharCount99 = 0;\n  let maxCharCount100 = 0;\n  let maxCharCount101 = 0;\n  let maxCharCount102 = 0;\n  let maxCharCount103 = 0;\n  let maxCharCount104 = 0;\n  let maxCharCount105 = 0;\n  let maxCharCount106 = 0;\n  let maxCharCount107 = 0;\n  let maxCharCount108 = 0;\n  let maxCharCount109 = 0;\n  let maxCharCount110 = 0;\n  let maxCharCount111 = 0;\n  let maxCharCount112 = 0;\n  let maxCharCount113 = 0;\n  let maxCharCount114 = 0;\n  let maxCharCount115 = 0;\n  let maxCharCount116 = 0;\n  let maxCharCount117 = 0;\n  let maxCharCount118 = 0;\n  let maxCharCount119 = 0;\n  let maxCharCount120 = 0;\n  let maxCharCount121 = 0;\n  let maxCharCount122 = 0;\n  let maxCharCount123 = 0;\n  let maxCharCount124 = 0;\n  let maxCharCount125 = 0;\n  let maxCharCount126 = 0;\n  let maxCharCount127 = 0;\n  let maxCharCount128 = 0;\n  let maxCharCount129 = 0;\n  let maxCharCount130 = 0;\n  let maxCharCount131 = 0;\n  let maxCharCount132 = 0;\n  let maxCharCount133 = 0;\n  let maxCharCount134 = 0;\n  let maxCharCount135 = 0;\n  let maxCharCount136 = 0;\n  let maxCharCount137 = 0;\n  let maxCharCount138 = 0;\n  let maxCharCount139 = 0;\n  let maxCharCount140 = 0;\n  let maxCharCount141 = 0;\n  let maxCharCount142 = 0;\n  let maxCharCount143 = 0;\n  let maxCharCount144 = 0;\n  let maxCharCount145 = 0;\n  let maxCharCount146 = 0;\n  let maxCharCount147 = 0;\n  let maxCharCount148 = 0;\n  let maxCharCount149 = 0;\n  let maxCharCount150 = 0;\n  let maxCharCount151 = 0;\n  let maxCharCount152 = 0;\n  let maxCharCount153 = 0;\n  let maxCharCount154 = 0;\n  let maxCharCount155 = 0;\n  let maxCharCount156 = 0;\n  let maxCharCount157 = 0;\n  let maxCharCount158 = 0;\n  let maxCharCount159 = 0;\n  let maxCharCount160 = 0;\n  let maxCharCount161 = 0;\n  let maxCharCount162 = 0;\n  let maxCharCount163 = 0;\n  let maxCharCount164 = 0;\n  let maxCharCount165 = 0;\n  let maxCharCount166 = 0;\n  let maxCharCount167 = 0;\n  let maxCharCount168 = 0;\n  let maxCharCount169 = 0;\n  let maxCharCount170 = 0;\n  let maxCharCount171 = 0;\n  let maxCharCount172 = 0;\n  let maxCharCount173 = 0;\n  let maxCharCount174 = 0;\n  let maxCharCount175 = 0;\n  let maxCharCount176 = 0;\n  let maxCharCount177 = 0;\n  let maxCharCount178 = 0;\n  let maxCharCount179 = 0;\n  let maxCharCount180 = 0;\n  let maxCharCount181 = 0;\n  let maxCharCount182 = 0;\n  let maxCharCount183 = 0;\n  let maxCharCount184 = 0;\n  let maxCharCount185 = 0;\n  let maxCharCount186 = 0;\n  let maxCharCount187 = 0;\n  let maxCharCount188 = 0;\n  let maxCharCount189 = 0;\n  let maxCharCount190 = 0;\n  let maxCharCount191 = 0;\n  let maxCharCount192 = 0;\n  let maxCharCount193 = 0;\n  let maxCharCount194 = 0;\n  let maxCharCount195 = 0;\n  let maxCharCount196 = 0;\n  let maxCharCount197 = 0;\n  let maxCharCount198 = 0;\n  let maxCharCount199 = 0;\n  let maxCharCount200 = 0;\n  let maxCharCount201 = 0;\n  let maxCharCount202 = 0;\n  let maxCharCount203 = 0;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "gc": "<|endoftext|>/*\n  You're a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const carrots = Math.ceil(number / need);\n  const remainingCarrots = Math.ceil(remaining / carrots);\n  const remainingEaten = remaining - carrots * need;\n  const remainingCarrotLeft = remainingCarrots - remainingEaten;\n  const carrotLeft = carrots - remainingCarrotLeft;\n  const carrotRight = carrots + remainingCarrotLeft;\n  const carrotLeftRemaining = carrotLeft - remainingEaten;\n  const carrotRightRemaining = carrotRight - remainingEaten;\n  const carrotLeftRemainingCarrots = carrotLeft - remainingCarrotLeft;\n  const carrotRightRemainingCarrots = carrotRight - remainingCarrotLeft;\n  const carrotLeftRemainingCarrotLeftRemaining = carrotLeft - remainingCarrotLeftCarrots;\n  const carrotRightRemainingCarrotRightRemaining = carrotRight - remainingCarrotRightCarrots;\n  const carrotLeftRemainingCarrotLeftRemainingCarrots = carrotLeft - remainingCarrotLeftCarrotLeftRemaining;\n  const carrotRightRemainingCarrotRightRemainingCarrots = carrotRight - remainingCarrotRightCarrotRightRemaining;\n  const carrotLeftRemainingCarrotLeftRemainingCarrotLeftRemaining = carrotLeft - remainingCarrotLeftCarrotLeftRemainingCarrots;\n  const carrotRightRemainingCarrotRightRemainingCarrotRightRemaining = carrotRight - remainingCarrotRightCarrotRightRemaining;\n  const carrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrots = carrotLeft - remainingCarrotLeftCarrotLeftRemainingCarrotLeftRemaining;\n  const carrotRightRemainingCarrotRightRemainingCarrotRightRemainingCarrots = carrotRight - remainingCarrotRightCarrotRightRemainingCarrotRightRemaining;\n  const carrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemaining = carrotLeft - remainingCarrotLeftCarrotLeftRemainingCarrotLeftRemainingCarrots;\n  const carrotRightRemainingCarrotRightRemainingCarrotRightRemainingCarrotRightRemaining = carrotRight - remainingCarrotRightCarrotRightRemainingCarrotRightRemaining;\n  const carrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrots = carrotLeft - remainingCarrotLeftCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrots;\n  const carrotRightRemainingCarrotRightRemainingCarrotRightRemainingCarrotRightRemainingCarrots = carrotRight - remainingCarrotRightCarrotRightRemainingCarrotRightRemainingCarrotRightRemaining;\n  const carrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemaining = carrotLeft - remainingCarrotLeftCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrots;\n  const carrotRightRemainingCarrotRightRemainingCarrotRightRemainingCarrotRightRemainingCarrots = carrotRight - remainingCarrotRightCarrotRightRemainingCarrotRightRemainingCarrotRightRemainingCarrots;\n  const carrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrots = carrotLeft - remainingCarrotLeftCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrots;\n  const carrotRightRemainingCarrotRightRemainingCarrotRightRemainingCarrotRightRemainingCarrots = carrotRight - remainingCarrotRightCarrotRightRemainingCarrotRightRemainingCarrotRightRemainingCarrots;\n  const carrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrots = carrotLeft - remainingCarrotLeftCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrots;\n  const carrotRightRemainingCarrotRightRemainingCarrotRightRemainingCarrotRightRemainingCarrots = carrotRight - remainingCarrotRightCarrotRightRemainingCarrotRightRemainingCarrotRightRemainingCarrots;\n  const carrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrots = carrotLeft - remainingCarrotLeftCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrots;\n  const carrotRightRemainingCarrotRightRemainingCarrotRightRemainingCarrotRightRemainingCarrots = carrotRight - remainingCarrotRightCarrotRightRemainingCarrotRightRemainingCarrotRightRemainingCarrots;\n  const carrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrots = carrotLeft - remainingCarrotLeftCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrots;\n  const carrotRightRemainingCarrotRightRemainingCarrotRightRemainingCarrotRightRemainingCarrots = carrotRight - remainingCarrotRightCarrotRightRemainingCarrotRightRemainingCarrotRightRemainingCarrots;\n  const carrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrots = carrotLeft - remainingCarrotLeftCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrots;\n  const carrotRightRemainingCarrotRightRemainingCarrotRightRemainingCarrotRightRemainingCarrots = carrotRight - remainingCarrotRightCarrotRightRemainingCarrotRightRemainingCarrotRightRemainingCarrotRightRemainingCarrots;\n  const carrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrots = carrotLeft - remainingCarrotLeftCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrotLeftRemainingCarrots;\n  const car", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/16", "prompt": "/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "gc": "<|endoftext|>/* Given a string, find out how many distinct characters (regardless of case) does it consist of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let count = 0;\n  let chars = string.split('');\n  for (let i = 0; i < chars.length; i++) {\n    count += chars.indexOf(chars[i]) === i;\n  }\n  return count;\n};\n\n/**\n * Given a string, find the longest common subsequence (LCS) of all characters in the string.\n * \n * Complexity: O(n^2)\n * \n * Source: https://en.wikipedia.org/wiki/Longest_common_subsequence_problem\n * \n * Example 1:\n * \n * Input: \"abcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 2:\n * \n * Input: \"abcabcabc\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 3:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 4:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 5:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 6:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 7:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 8:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 9:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 10:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 11:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 12:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 13:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 14:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 15:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 16:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 17:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 18:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 19:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 20:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 21:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 22:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 23:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 24:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 25:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 26:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 27:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 28:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 29:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 30:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 31:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 32:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 33:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 34:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 35:\n * \n * Input: \"abcabcabcbb\"\n * Output: \"abc\"\n * Explanation: The longest common subsequence is \"abc\".\n * \n * Example 36:\n * \n * Input: \"abcabcabcbb\"\n * Output", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "gc": "<|endoftext|>/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('+')\n  const result = []\n  \n  operatorList.forEach((operator, index) => {\n    if (index === 0) {\n      result.push(operator)\n    } else {\n      result.push(operatorList[index - 1] + operandList[index])\n    }\n  })\n  return result\n}\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('+')\n  const result = []\n  \n  operatorList.forEach((operator, index) => {\n    if (index === 0) {\n      result.push(operator)\n    } else {\n      result.push(operatorList[index - 1] + operandList[index])\n    }\n  })\n  return result\n}\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('+')\n  const result = []\n  \n  operatorList.forEach((operator, index) => {\n    if (index === 0) {\n      result.push(operator)\n    } else {\n      result.push(operatorList[index - 1] + operandList[index])\n    }\n  })\n  return result\n}\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('+')\n  const result = []\n  \n  operatorList.forEach((operator, index) => {\n    if (index === 0) {\n      result.push(operator)\n    } else {\n      result.push(operatorList[index - 1] + operandList[index])\n    }\n  })\n  return result\n}\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('+')\n  const result = []\n  \n  operatorList.forEach((operator, index) => {\n    if (index === 0) {\n      result.push(operator)\n    } else {\n      result.push(operatorList[index - 1] + operandList[index])\n    }\n  })\n  return result\n}\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+')\n  const operandList = operand.split('+')\n  const result = []\n  \n  operatorList.forEach((operator, index) => {\n    if (index === 0) {\n      result.push(operator)\n    } else {\n      result.push(operatorList[index - 1] + operandList[index])\n    }\n  })\n  return result\n}\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/161", "prompt": "/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "gc": "<|endoftext|>/*You are given a string s.\n  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n  otherwise keep it as it is.\n  If the string contains no letters, reverse the string.\n  The function should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let reversed = \"\";\n  let letter = \"\";\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = s.length;\n  let temp = \"\";\n  let temp2 = \"\";\n  let temp3 = \"\";\n  let temp4 = \"\";\n  let temp5 = \"\";\n  let temp6 = \"\";\n  let temp7 = \"\";\n  let temp8 = \"\";\n  let temp9 = \"\";\n  let temp10 = \"\";\n  let temp11 = \"\";\n  let temp12 = \"\";\n  let temp13 = \"\";\n  let temp14 = \"\";\n  let temp15 = \"\";\n  let temp16 = \"\";\n  let temp17 = \"\";\n  let temp18 = \"\";\n  let temp19 = \"\";\n  let temp20 = \"\";\n  let temp21 = \"\";\n  let temp22 = \"\";\n  let temp23 = \"\";\n  let temp24 = \"\";\n  let temp25 = \"\";\n  let temp26 = \"\";\n  let temp27 = \"\";\n  let temp28 = \"\";\n  let temp29 = \"\";\n  let temp30 = \"\";\n  let temp31 = \"\";\n  let temp32 = \"\";\n  let temp33 = \"\";\n  let temp34 = \"\";\n  let temp35 = \"\";\n  let temp36 = \"\";\n  let temp37 = \"\";\n  let temp38 = \"\";\n  let temp39 = \"\";\n  let temp40 = \"\";\n  let temp41 = \"\";\n  let temp42 = \"\";\n  let temp43 = \"\";\n  let temp44 = \"\";\n  let temp45 = \"\";\n  let temp46 = \"\";\n  let temp47 = \"\";\n  let temp48 = \"\";\n  let temp49 = \"\";\n  let temp50 = \"\";\n  let temp51 = \"\";\n  let temp52 = \"\";\n  let temp53 = \"\";\n  let temp54 = \"\";\n  let temp55 = \"\";\n  let temp56 = \"\";\n  let temp57 = \"\";\n  let temp58 = \"\";\n  let temp59 = \"\";\n  let temp60 = \"\";\n  let temp61 = \"\";\n  let temp62 = \"\";\n  let temp63 = \"\";\n  let temp64 = \"\";\n  let temp65 = \"\";\n  let temp66 = \"\";\n  let temp67 = \"\";\n  let temp68 = \"\";\n  let temp69 = \"\";\n  let temp70 = \"\";\n  let temp71 = \"\";\n  let temp72 = \"\";\n  let temp73 = \"\";\n  let temp74 = \"\";\n  let temp75 = \"\";\n  let temp76 = \"\";\n  let temp77 = \"\";\n  let temp78 = \"\";\n  let temp79 = \"\";\n  let temp80 = \"\";\n  let temp81 = \"\";\n  let temp82 = \"\";\n  let temp83 = \"\";\n  let temp84 = \"\";\n  let temp85 = \"\";\n  let temp86 = \"\";\n  let temp87 = \"\";\n  let temp88 = \"\";\n  let temp89 = \"\";\n  let temp90 = \"\";\n  let temp91 = \"\";\n  let temp92 = \"\";\n  let temp93 = \"\";\n  let temp94 = \"\";\n  let temp95 = \"\";\n  let temp96 = \"\";\n  let temp97 = \"\";\n  let temp98 = \"\";\n  let temp99 = \"\";\n  let temp100 = \"\";\n  let temp101 = \"\";\n  let temp102 = \"\";\n  let temp103 = \"\";\n  let temp104 = \"\";\n  let temp105 = \"\";\n  let temp106 = \"\";\n  let temp107 = \"\";\n  let temp108 = \"\";\n  let temp109 = \"\";\n  let temp110 = \"\";\n  let temp111 = \"\";\n  let temp112 = \"\";\n  let temp113 = \"\";\n  let temp114 = \"\";\n  let temp115 = \"\";\n  let temp116 = \"\";\n  let temp117 = \"\";\n  let temp118 = \"\";\n  let temp119 = \"\";\n  let temp120 = \"\";\n  let temp121 = \"\";\n  let temp122 = \"\";\n  let temp123 = \"\";\n  let temp124 = \"\";\n  let temp125 = \"\";\n  let temp126 = \"\";\n  let temp127 = \"\";\n  let temp128 = \"\";\n  let temp129 = \"\";\n  let temp130 = \"\";\n  let temp131 = \"\";\n  let temp132 = \"\";\n  let temp133 = \"\";\n  let temp134 = \"\";\n  let temp135 = \"\";\n  let temp136 = \"\";\n  let temp137 = \"\";\n  let temp138 = \"\";\n  let temp139 = \"\";\n  let temp140 = \"\";\n  let temp141 = \"\";\n  let temp142 = \"\";\n  let temp143 = \"\";\n  let temp144 = \"\";\n  let temp145 = \"\";\n  let temp146 = \"\";\n  let temp147 = \"\";\n  let temp148 = \"\";\n  let temp149 = \"\";\n  let temp150 = \"\";\n  let temp151 = \"\";\n  let temp152 = \"\";\n  let temp153 = \"\";\n  let temp154 = \"\";\n  let temp155 = \"\";\n  let temp156 = \"\";\n  let temp157 = \"\";\n  let temp158 = \"\";\n  let temp159 = \"\";\n  let temp160 = \"\";\n  let temp161 = \"\";\n  let temp162 = \"\";\n  let temp163 = \"\";\n  let temp164 = \"\";\n  let temp165 = \"\";\n  let temp166 = \"\";\n  let temp167 = \"\";\n  let temp168 = \"\";\n  let temp169 = \"\";\n  let temp170 = \"\";\n  let temp171 = \"\";\n  let temp172 = \"\";\n  let temp173 = \"\";\n  let temp174 = \"\";\n  let temp175 = \"\";\n  let temp176 = \"\";\n  let temp177 = \"\";\n  let temp178 = \"\";\n  let temp179 = \"\";\n  let temp180 = \"\";\n  let temp181 = \"\";\n  let temp182 = \"\";\n  let temp183 = \"\";\n  let temp184 = \"\";\n  let temp185 = \"\";\n  let temp186 = \"\";\n  let temp187 = \"\";\n  let temp188 = \"\";\n  let temp189 = \"\";\n  let temp190 = \"\";\n  let temp191 = \"\";\n  let temp192 = \"\";\n  let temp193 = \"\";\n  let temp194 = \"\";\n  let temp195 = \"\";\n  let temp196 = \"\";\n  let temp197 = \"\";\n  let temp198 = \"\";\n  let temp199 = \"\";\n  let temp200 = \"\";\n  let temp201 = \"\";\n  let temp202 = \"\";\n  let temp203 = \"\";\n  let temp204 = \"\";\n  let temp205 = \"\";\n  let temp206 = \"\";\n  let temp207 = \"\";\n  let temp208 = \"\";\n  let temp209 = \"\";\n  let temp210 = \"\";\n  let temp211 = \"\";\n  let temp212 = \"\";\n  let temp213 = \"\";\n  let temp214 = \"\";\n  let temp215 = \"\";\n  let temp216 = \"\";\n  let temp217 = \"\";\n  let temp218 = \"\";\n  let temp219 = \"\";\n  let temp220 = \"\";\n  let temp221 = \"\";\n  let temp222 = \"\";\n  let temp223 = \"\";\n  let temp224 = \"\";\n  let temp225 = \"\";\n  let temp226 = \"\";\n  let temp227 = \"\";\n  let temp228 = \"\";\n  let temp229 = \"\";\n  let temp230 = \"\";\n  let temp231 = \"\";\n  let temp232 = \"\";\n  let temp233 = \"\";\n  let temp234 = \"\";\n  let temp235 = \"\";\n  let temp236 = \"\";\n  let temp237 = \"\";\n  let temp238 = \"\";\n  let temp239 = \"\";\n  let temp240 = \"\";\n  let temp241 = \"\";\n  let temp242 = \"\";\n  let temp243 = \"\";\n  let temp244 = \"\";\n  let temp245 = \"\";\n  let temp246 = \"\";\n  let temp247 = \"\";\n  let temp248 = \"\";\n  let temp249 = \"\";\n  let temp250 = \"\";\n  let temp251 = \"\";\n  let temp252 = \"\";\n  let temp253 = \"\";\n  let temp254 = \"\";\n  let temp255 = \"\";\n  let temp256 = \"\";\n  let temp257 = \"\";\n  let temp258 = \"\";\n  let temp259 = \"\";\n  let temp260 = \"\";\n  let temp261 = \"\";\n  let temp262 = ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/162", "prompt": "/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "gc": "<|endoftext|>/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5Hex = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5Hex('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5HexString = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5HexString('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5HexStringWithLength = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5HexStringWithLength('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5HexStringWithLengthString = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5HexStringWithLengthString('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5HexStringWithLengthHex = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5HexStringWithLengthHex('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5HexStringWithLengthHexString = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5HexStringWithLengthHexString('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5HexStringWithLengthHexStringWithLength = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5HexStringWithLengthHexStringWithLength('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5HexStringWithLengthHexStringWithLengthString = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5HexStringWithLengthHexStringWithLengthString('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5HexStringWithLengthHexStringWithLengthHex = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5HexStringWithLengthHexStringWithLengthHex('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5HexStringWithLengthHexStringWithLengthHexString = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5HexStringWithLengthHexStringWithLengthHexString('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5HexStringWithLengthHexStringWithLengthHexStringWithLength = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5HexStringWithLengthHexStringWithLengthHexStringWithLength('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5HexStringWithLengthHexStringWithLengthHexStringWithLengthHex = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', return its md5 hash equivalent string.\n  If 'text' is an empty string, return null.\n\n  >>> stringToMd5HexStringWithLengthHexStringWithLengthHexStringWithLengthHexString('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5HexStringWithLengthHexStringWithLengthHexStringWithLengthHexString = (text) => {\n  if (!text) {\n    return null;\n  }\n\n  return crypto.createHash('md5').update(text).digest('hex');\n};\n\n/*\n  Given a string 'text', ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Given two positive integers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "gc": "<|endoftext|>/*\n  Given two positive integers a and b, return the even digits between a\n  and b, in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const result = [];\n  let i = a;\n  let j = 0;\n  while (i < b) {\n    const digit = i % 10;\n    result.push(digit);\n    i += 1;\n  }\n  return result;\n};\n\n/**\n * Given a string, return the number of unique characters in it.\n * \n * For example:\n * countUniqueChars('abcabc') => 3\n * countUniqueChars('abcabcabc') => 3\n * countUniqueChars('abcabcabcabc') => 3\n * countUniqueChars('abcabcabcabcabcabc') => 3\n * countUniqueChars('abcabcabcabcabcabcabcabc') => 3\n * countUniqueChars('abcabcabcabcabcabcabcabcabcabcabc') => 3\n * countUniqueChars('abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcab", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/17", "prompt": "/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "gc": "<|endoftext|>/* Input to this function is a string representing musical notes in a special ASCII format.\n  Your task is to parse this string and return list of integers corresponding to how many beats does each\n  not last.\n\n  Here is a legend:\n  'o' - whole note, lasts four beats\n  'o|' - half note, lasts two beats\n  '.|' - quater note, lasts one beat\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes = music_string.split('|');\n  const result = [];\n  for (let i = 0; i < notes.length; i++) {\n    const note = notes[i];\n    if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note.includes('.')) {\n      result.push(2);\n    } else if (note.includes('o')) {\n      result.push(2);\n    } else if (note.includes('.')) {\n      result.push(1);\n    } else if (note.includes('o')) {\n      result.push(4);\n    } else if (note", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/18", "prompt": "/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "gc": "<|endoftext|>/* Find how many times a given substring can be found in the original string. Count overlaping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  let index = 0;\n  let length = string.length;\n  let current;\n\n  while (index < length) {\n    current = string.charAt(index);\n    if (current === substring) {\n      count++;\n    }\n    index++;\n  }\n\n  return count;\n};\n\n/**\n * Return a new string made from all the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n * Otherwise, return a string made from the characters of the given string.\n * If the given string contains only whitespace characters, return an empty string.\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "gc": "<|endoftext|>/* Input is a space-delimited string of numberals from 'zero' to 'nine'.\n  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'.\n  Return the string with numbers sorted from smallest to largest\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberList = [];\n  let numberString = '';\n  let number = 0;\n  let numberIndex = 0;\n  let numberLength = 0;\n  let numberStringLength = 0;\n  let numberStringIndex = 0;\n  let numberStringLengthIndex = 0;\n  let numberStringLengthLength = 0;\n  let numberStringIndexLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringLengthLengthIndex = 0;\n  let numberStringIndexLengthLength = 0;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/2", "prompt": "/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNubmer(3.5)\n  0.5\n  */\nconst truncateNubmer = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNubmer", "gc": "<|endoftext|>/* Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part of the number.\n  >>> truncateNubmer(3.5)\n  0.5\n  */\nconst truncateNubmer = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part of the number.\n  >>> truncateNubmer(3.5)\n  3\n  */\nconst truncateNubmerInteger = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part (decimal part) of the number.\n  >>> truncateNubmerInteger(3.5)\n  3\n  */\nconst truncateNubmerIntegerDecimal = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part (integer part) of the number.\n  >>> truncateNubmerIntegerDecimal(3.5)\n  3.5\n  */\nconst truncateNubmerIntegerDecimalInteger = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part (decimal part) of the number.\n  >>> truncateNubmerIntegerDecimalInteger(3.5)\n  3.5\n  */\nconst truncateNubmerIntegerDecimalIntegerDecimal = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part (integer part) of the number.\n  >>> truncateNubmerIntegerDecimalIntegerDecimal(3.5)\n  3.5\n  */\nconst truncateNubmerIntegerDecimalIntegerDecimalInteger = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part (decimal part) of the number.\n  >>> truncateNubmerIntegerDecimalIntegerDecimalInteger(3.5)\n  3.5\n  */\nconst truncateNubmerIntegerDecimalIntegerDecimalDecimal = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part (integer part) of the number.\n  >>> truncateNubmerIntegerDecimalIntegerDecimalDecimalInteger(3.5)\n  3.5\n  */\nconst truncateNubmerIntegerDecimalIntegerDecimalDecimalInteger = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part (decimal part) of the number.\n  >>> truncateNubmerIntegerDecimalIntegerDecimalIntegerDecimal(3.5)\n  3.5\n  */\nconst truncateNubmerIntegerDecimalIntegerDecimalDecimalDecimal = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part (integer part) of the number.\n  >>> truncateNubmerIntegerDecimalIntegerDecimalDecimalDecimalInteger(3.5)\n  3.5\n  */\nconst truncateNubmerIntegerDecimalIntegerDecimalDecimalDecimalInteger = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part (integer part) of the number.\n  >>> truncateNubmerIntegerDecimalIntegerDecimalDecimalDecimalDecimalInteger(3.5)\n  3.5\n  */\nconst truncateNubmerIntegerDecimalIntegerDecimalDecimalDecimalDecimal = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part (decimal part) of the number.\n  >>> truncateNubmerIntegerDecimalIntegerDecimalDecimalDecimalDecimalDecimalInteger(3.5)\n  3.5\n  */\nconst truncateNubmerIntegerDecimalIntegerDecimalDecimalDecimalDecimalDecimalInteger = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the decimal part (integer part) of the number.\n  >>> truncateNubmerIntegerDecimalIntegerDecimalDecimalDecimalDecimalDecimalInteger(3.5)\n  3.5\n  */\nconst truncateNubmerIntegerDecimalIntegerDecimalDecimalDecimalDecimalDecimal = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n\n  Return the integer part (decimal part) of the number.\n  >>> truncateNubmerIntegerDecimalIntegerDecimalDecimalDecimalDecimalDecimalInteger(3.5)\n  3.5\n  */\nconst truncateNubmerIntegerDecimalIntegerDecimalDecimalDecimalDecimalDecimalInteger = (number) => {\n  const [integer, decimals] = number.toString().split('.');\n  return integer > 0? integer : integer * Math.pow(10, decimals);\n};\n\n/**\n  Given a positive floating point number, it can be decomposed into\n  and integer part (", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/20", "prompt": "/* From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n  other and return them in order (smaller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "gc": "<|endoftext|>/* From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n  other and return them in order (smaller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const sortedNumbers = numbers.sort((a, b) => a - b);\n  const closestToTheEnd = sortedNumbers.reduce((a, b) => Math.min(a, b), 0);\n  const closestToTheStart = sortedNumbers.reduce((a, b) => Math.max(a, b), 0);\n  return [closestToTheEnd, closestToTheStart];\n};\n\nmodule.exports = findClosestElements;\n\n},{}],6:[function(require,module,exports){\nconst findClosestElements = require('./findClosestElements');\n\n/**\n * Given an array of numbers, return an array of numbers that is closest to each other in order (smallest to largest).\n * If no numbers are close to each other, return an empty array.\n * If there are multiple numbers that are close to each other, return an array with one number in each position.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple numbers that are not close to each other, return an array with one number in each position.\n * If there are no numbers that are not close to each other, return an empty array.\n * If there are multiple number", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/21", "prompt": "/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleTonUit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleTonUit", "gc": "<|endoftext|>/* Given list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleTonUit = (numbers) => {\n  const minValue = Math.min.apply(null, numbers);\n  const maxValue = Math.max.apply(null, numbers);\n  const scaledValue = (maxValue - minValue) * 0.5;\n  return [minValue, scaledValue];\n};\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleTonUit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleTonUitWithOffset = (numbers, offset) => {\n  const minValue = Math.min.apply(null, numbers);\n  const maxValue = Math.max.apply(null, numbers);\n  const scaledValue = (maxValue - minValue) * 0.5;\n  return [minValue + offset, scaledValue];\n};\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleTonUitWithOffset([1.0, 2.0, 3.0, 4.0, 5.0], 0.5)\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleTonUitWithOffsetWithOffset = (numbers, offset, offsetOffset) => {\n  const minValue = Math.min.apply(null, numbers);\n  const maxValue = Math.max.apply(null, numbers);\n  const scaledValue = (maxValue - minValue) * 0.5;\n  return [minValue + offsetOffset, scaledValue];\n};\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleTonUitWithOffsetWithOffset([1.0, 2.0, 3.0, 4.0, 5.0], -0.5, 0.5)\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleTonUitWithOffsetWithOffsetWithOffset = (numbers, offsetOffset, offsetOffsetOffset) => {\n  const minValue = Math.min.apply(null, numbers);\n  const maxValue = Math.max.apply(null, numbers);\n  const scaledValue = (maxValue - minValue) * 0.5;\n  return [minValue + offsetOffsetOffset, scaledValue];\n};\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleTonUitWithOffsetWithOffsetWithOffset([1.0, 2.0, 3.0, 4.0, 5.0], -0.5, -0.5, 0.5)\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleTonUitWithOffsetWithOffsetWithOffsetWithOffset = (numbers, offsetOffset, offsetOffsetOffset, offsetOffsetOffsetOffset) => {\n  const minValue = Math.min.apply(null, numbers);\n  const maxValue = Math.max.apply(null, numbers);\n  const scaledValue = (maxValue - minValue) * 0.5;\n  return [minValue + offsetOffsetOffsetOffset, scaledValue];\n};\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleTonUitWithOffsetWithOffsetWithOffsetWithOffset([1.0, 2.0, 3.0, 4.0, 5.0], -0.5, -0.5, -0.5, -0.5, 0.5)\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleTonUitWithOffsetWithOffsetWithOffsetWithOffsetWithOffset = (numbers, offsetOffset, offsetOffsetOffset, offsetOffsetOffsetOffset, offsetOffsetOffsetOffsetOffset) => {\n  const minValue = Math.min.apply(null, numbers);\n  const maxValue = Math.max.apply(null, numbers);\n  const scaledValue = (maxValue - minValue) * 0.5;\n  return [minValue + offsetOffsetOffsetOffsetOffset, scaledValue];\n};\n\n/**\n * Given a list of numbers (of at least two elements), apply a linear transform to that list,\n  such that the smallest number will become 0 and the largest will become 1\n  >>> rescaleTonUitWithOffsetWithOffsetWithOffsetWithOffsetWithOffset([1.0, 2.0, 3.0, 4.0, 5.0], -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/22", "prompt": "/* Filter given list of any python values only for integers\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filetrItnegers", "gc": "<|endoftext|>/* Filter given list of any python values only for integers\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegers = (values) => {\n  return values.filter(v => typeof v === 'number' && isFinite(v))\n}\n\n/**\n * Filter given list of any python values only for floats\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersFloats = (values) => {\n  return values.filter(v => typeof v === 'number' && isFinite(v))\n}\n\n/**\n * Filter given list of any python values only for strings\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersStrings = (values) => {\n  return values.filter(v => typeof v ==='string')\n}\n\n/**\n * Filter given list of any python values only for booleans\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersBooleans = (values) => {\n  return values.filter(v => typeof v === 'boolean')\n}\n\n/**\n * Filter given list of any python values only for None\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersNones = (values) => {\n  return values.filter(v => v === undefined)\n}\n\n/**\n * Filter given list of any python values only for empty lists\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyLists = (values) => {\n  return values.filter(v => v === [])\n}\n\n/**\n * Filter given list of any python values only for empty dictionaries\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyDicts = (values) => {\n  return values.filter(v => v === {})\n}\n\n/**\n * Filter given list of any python values only for empty strings\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyStrings = (values) => {\n  return values.filter(v => v === \"\")\n}\n\n/**\n * Filter given list of any python values only for empty numbers\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyNumbers = (values) => {\n  return values.filter(v => v === 0)\n}\n\n/**\n * Filter given list of any python values only for empty arrays\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyArrays = (values) => {\n  return values.filter(v => v === [])\n}\n\n/**\n * Filter given list of any python values only for empty dictionaries\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyDicts = (values) => {\n  return values.filter(v => v === {})\n}\n\n/**\n * Filter given list of any python values only for empty strings\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyStrings = (values) => {\n  return values.filter(v => v === \"\")\n}\n\n/**\n * Filter given list of any python values only for empty numbers\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyNumbers = (values) => {\n  return values.filter(v => v === 0)\n}\n\n/**\n * Filter given list of any python values only for empty arrays\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyArrays = (values) => {\n  return values.filter(v => v === [])\n}\n\n/**\n * Filter given list of any python values only for empty dictionaries\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyDicts = (values) => {\n  return values.filter(v => v === {})\n}\n\n/**\n * Filter given list of any python values only for empty strings\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyStrings = (values) => {\n  return values.filter(v => v === \"\")\n}\n\n/**\n * Filter given list of any python values only for empty numbers\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyNumbers = (values) => {\n  return values.filter(v => v === 0)\n}\n\n/**\n * Filter given list of any python values only for empty arrays\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyArrays = (values) => {\n  return values.filter(v => v === [])\n}\n\n/**\n * Filter given list of any python values only for empty dictionaries\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyDicts = (values) => {\n  return values.filter(v => v === {})\n}\n\n/**\n * Filter given list of any python values only for empty strings\n  >>> filetrItnegers(['a', 3.14, 5])\n  [5]\n  >>> filetrItnegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filetrItnegersEmptyStrings = (values) => {\n  return values.filter(v => v === \"\")\n}\n\n/**\n * Filter given list of any python values only for empty numbers\n  >>> filetrItnegers(['a', 3.14, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/23", "prompt": "/* Return length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "gc": "<|endoftext|>/* Return length of given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  let length = 0;\n  for (let i = 0; i < string.length; i++) {\n    length += string.charCodeAt(i).length;\n  }\n  return length;\n};\n\n// Return true if given string starts with given prefix\nconst startsWith = (string, prefix) => {\n  return string.slice(0, prefix.length) === prefix;\n};\n\n// Return true if given string ends with given suffix\nconst endsWith = (string, suffix) => {\n  return string.slice(string.length - suffix.length) === suffix;\n};\n\n// Return true if given string contains given substring\nconst contains = (string, substring) => {\n  return string.indexOf(substring) > -1;\n};\n\n// Return true if given string starts with given substring\nconst startsWithSubstring = (string, substring) => {\n  return string.startsWith(substring);\n};\n\n// Return true if given string ends with given substring\nconst endsWithSubstring = (string, substring) => {\n  return string.endsWith(substring);\n};\n\n// Return true if given string contains given substring\nconst containsSubstring = (string, substring) => {\n  return string.includes(substring);\n};\n\n// Return true if given string starts with given substring\nconst startsWithSubstringSubstring = (string, substring) => {\n  return string.startsWith(substring) && string.endsWith(substring);\n};\n\n// Return true if given string ends with given substring\nconst endsWithSubstringSubstring = (string, substring) => {\n  return string.endsWith(substring) && string.startsWith(substring);\n};\n\n// Return true if given string contains given substring\nconst containsSubstringSubstring = (string, substring) => {\n  return string.includes(substring) && string.startsWith(substring) && string.endsWith(substring);\n};\n\n// Return true if given string starts with given substring\nconst startsWithSubstringSubstringSubstring = (string, substring) => {\n  return string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring);\n};\n\n// Return true if given string ends with given substring\nconst endsWithSubstringSubstringSubstring = (string, substring) => {\n  return string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring);\n};\n\n// Return true if given string contains given substring\nconst containsSubstringSubstringSubstring = (string, substring) => {\n  return string.includes(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring);\n};\n\n// Return true if given string starts with given substring\nconst startsWithSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring);\n};\n\n// Return true if given string ends with given substring\nconst endsWithSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring);\n};\n\n// Return true if given string contains given substring\nconst containsSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.includes(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring);\n};\n\n// Return true if given string starts with given substring\nconst startsWithSubstringSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring);\n};\n\n// Return true if given string ends with given substring\nconst endsWithSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring);\n};\n\n// Return true if given string contains given substring\nconst containsSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.includes(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring);\n};\n\n// Return true if given string starts with given substring\nconst startsWithSubstringSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring);\n};\n\n// Return true if given string ends with given substring\nconst endsWithSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring);\n};\n\n// Return true if given string contains given substring\nconst containsSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.includes(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring);\n};\n\n// Return true if given string starts with given substring\nconst startsWithSubstringSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring);\n};\n\n// Return true if given string ends with given substring\nconst endsWithSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring);\n};\n\n// Return true if given string contains given substring\nconst containsSubstringSubstringSubstringSubstring = (string, substring) => {\n  return string.includes(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith(substring) && string.startsWith(substring) && string.endsWith", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/24", "prompt": "/* For a given number n, find the largest number that divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "gc": "<|endoftext|>/* For a given number n, find the largest number that divides n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let divisor = 1;\n  while (n % divisor === 0) {\n    divisor += 1;\n  }\n  return divisor;\n};\n\n/**\n * Given a number n, return the largest number that divides n evenly, smaller than n\n * >>> largestDivisor(15)\n * 5\n */\nconst largestMultiple = (n) => {\n  let multiple = 1;\n  while (n % multiple === 0) {\n    multiple += 1;\n  }\n  return multiple;\n};\n\n/**\n * Given a number n, return the largest number that divides n evenly, smaller than n\n * >>> largestMultiple(15)\n * 5\n */\nconst largestMultipleOf = (n) => {\n  let multiple = 1;\n  while (n % multiple === 0) {\n    multiple += 1;\n  }\n  return multiple;\n};\n\n/**\n * Given a number n, return the largest number that divides n evenly, smaller than n\n * >>> largestMultipleOf(15)\n * 5\n */\nconst largestMultipleOfDivisor = (n) => {\n  let multiple = 1;\n  while (n % multiple === 0) {\n    multiple += 1;\n  }\n  return multiple;\n};\n\n/**\n * Given a number n, return the largest number that divides n evenly, smaller than n\n * >>> largestMultipleOfDivisor(15)\n * 5\n */\nconst largestMultipleOfDivisorOf = (n) => {\n  let multiple = 1;\n  while (n % multiple === 0) {\n    multiple += 1;\n  }\n  return multiple;\n};\n\n/**\n * Given a number n, return the largest number that divides n evenly, smaller than n\n * >>> largestMultipleOfDivisorOf(15)\n * 5\n */\nconst largestMultipleOfDivisorOfDivisor = (n) => {\n  let multiple = 1;\n  while (n % multiple === 0) {\n    multiple += 1;\n  }\n  return multiple;\n};\n\n/**\n * Given a number n, return the largest number that divides n evenly, smaller than n\n * >>> largestMultipleOfDivisorOfDivisor(15)\n * 5\n */\nconst largestMultipleOfDivisorOfDivisorOf = (n) => {\n  let multiple = 1;\n  while (n % multiple === 0) {\n    multiple += 1;\n  }\n  return multiple;\n};\n\n/**\n * Given a number n, return the largest number that divides n evenly, smaller than n\n * >>> largestMultipleOfDivisorOfDivisorOf(15)\n * 5\n */\nconst largestMultipleOfDivisorOfDivisorOfDivisorOf = (n) => {\n  let multiple = 1;\n  while (n % multiple === 0) {\n    multiple += 1;\n  }\n  return multiple;\n};\n\n/**\n * Given a number n, return the largest number that divides n evenly, smaller than n\n * >>> largestMultipleOfDivisorOfDivisorOfDivisorOf(15)\n * 5\n */\nconst largestMultipleOfDivisorOfDivisorOfDivisorOfDivisorOf = (n) => {\n  let multiple = 1;\n  while (n % multiple === 0) {\n    multiple += 1;\n  }\n  return multiple;\n};\n\n/**\n * Given a number n, return the largest number that divides n evenly, smaller than n\n * >>> largestMultipleOfDivisorOfDivisorOfDivisorOfDivisorOf(15)\n * 5\n */\nconst largestMultipleOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOf = (n) => {\n  let multiple = 1;\n  while (n % multiple === 0) {\n    multiple += 1;\n  }\n  return multiple;\n};\n\n/**\n * Given a number n, return the largest number that divides n evenly, smaller than n\n * >>> largestMultipleOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOf(15)\n * 5\n */\nconst largestMultipleOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOf = (n) => {\n  let multiple = 1;\n  while (n % multiple === 0) {\n    multiple += 1;\n  }\n  return multiple;\n};\n\n/**\n * Given a number n, return the largest number that divides n evenly, smaller than n\n * >>> largestMultipleOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOf(15)\n * 5\n */\nconst largestMultipleOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOf = (n) => {\n  let multiple = 1;\n  while (n % multiple === 0) {\n    multiple += 1;\n  }\n  return multiple;\n};\n\n/**\n * Given a number n, return the largest number that divides n evenly, smaller than n\n * >>> largestMultipleOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOf(15)\n * 5\n */\nconst largestMultipleOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOf = (n) => {\n  let multiple = 1;\n  while (n % multiple === 0) {\n    multiple += 1;\n  }\n  return multiple;\n};\n\n/**\n * Given a number n, return the largest number that divides n evenly, smaller than n\n * >>> largestMultipleOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOf(15)\n * 5\n */\nconst largestMultipleOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOf = (n) => {\n  let multiple = 1;\n  while (n % multiple === 0) {\n    multiple += 1;\n  }\n  return multiple;\n};\n\n/**\n * Given a number n, return the largest number that divides n evenly, smaller than n\n * >>> largestMultipleOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOf(15)\n * 5\n */\nconst largestMultipleOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOf = (n) => {\n  let multiple = 1;\n  while (n % multiple === 0) {\n    multiple += 1;\n  }\n  return multiple;\n};\n\n/**\n * Given a number n, return the largest number that divides n evenly, smaller than n\n * >>> largestMultipleOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisorOfDivisor", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/25", "prompt": "/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "gc": "<|endoftext|>/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 2;\n  while (i < n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize2 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 2;\n  while (i < n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize3 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 2;\n  while (i < n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize4 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 2;\n  while (i < n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize5 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 2;\n  while (i < n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize6 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 2;\n  while (i < n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize7 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 2;\n  while (i < n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize8 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 2;\n  while (i < n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize9 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 2;\n  while (i < n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize10 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 2;\n  while (i < n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize11 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 2;\n  while (i < n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n    }\n    i++;\n  }\n  return factors;\n};\n\n/* Return list of prime factors of given integer in the order from smallest to largest.\n  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n  Input number should be equal to the product of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, ", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers, remove all elements that occur more than once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "gc": "<|endoftext|>/* From a list of integers, remove all elements that occur more than once.\n  Keep order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const seen = new Set();\n  const result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    const number = numbers[i];\n    if (seen.has(number)) {\n      continue;\n    }\n    seen.add(number);\n    result.push(number);\n  }\n  return result;\n};\n\nconst getRandom = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nconst getRandomInt = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nconst getRandomFloat = (min, max) => {\n  return Math.random() * (max - min + 1) + min;\n};\n\nconst getRandomString = (length) => {\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  const randomString = '';\n  for (let i = 0; i < length; i++) {\n    randomString += chars.charAt(getRandom(0, chars.length - 1));\n  }\n  return randomString;\n};\n\nconst getRandomArray = (length) => {\n  const randomArray = [];\n  for (let i = 0; i < length; i++) {\n    randomArray.push(getRandom(0, 10));\n  }\n  return randomArray;\n};\n\nconst getRandomObject = (length) => {\n  const randomObject = {};\n  for (let i = 0; i < length; i++) {\n    randomObject[getRandom(0, 10)] = getRandom(0, 10);\n  }\n  return randomObject;\n};\n\nconst getRandomArrayOfObjects = (length) => {\n  const randomArrayOfObjects = [];\n  for (let i = 0; i < length; i++) {\n    randomArrayOfObjects.push(getRandomObject());\n  }\n  return randomArrayOfObjects;\n};\n\nconst getRandomArrayOfNumbers = (length) => {\n  const randomArrayOfNumbers = [];\n  for (let i = 0; i < length; i++) {\n    randomArrayOfNumbers.push(getRandom(0, 10));\n  }\n  return randomArrayOfNumbers;\n};\n\nconst getRandomArrayOfStrings = (length) => {\n  const randomArrayOfStrings = [];\n  for (let i = 0; i < length; i++) {\n    randomArrayOfStrings.push(getRandomString(10));\n  }\n  return randomArrayOfStrings;\n};\n\nconst getRandomArrayOfFloats = (length) => {\n  const randomArrayOfFloats = [];\n  for (let i = 0; i < length; i++) {\n    randomArrayOfFloats.push(getRandomFloat(0, 10));\n  }\n  return randomArrayOfFloats;\n};\n\nconst getRandomArrayOfBooleans = (length) => {\n  const randomArrayOfBooleans = [];\n  for (let i = 0; i < length; i++) {\n    randomArrayOfBooleans.push(getRandom(0, 1));\n  }\n  return randomArrayOfBooleans;\n};\n\nconst getRandomArrayOfDates = (length) => {\n  const randomArrayOfDates = [];\n  for (let i = 0; i < length; i++) {\n    randomArrayOfDates.push(new Date(getRandomInt(0, 9999)));\n  }\n  return randomArrayOfDates;\n};\n\nconst getRandomArrayOfRegExps = (length) => {\n  const randomArrayOfRegExps = [];\n  for (let i = 0; i < length; i++) {\n    randomArrayOfRegExps.push(new RegExp(getRandomString(10)));\n  }\n  return randomArrayOfRegExps;\n};\n\nconst getRandomArrayOfArrays = (length) => {\n  const randomArrayOfArrays = [];\n  for (let i = 0; i < length; i++) {\n    randomArrayOfArrays.push(getRandomArrayOfNumbers(10));\n  }\n  return randomArrayOfArrays;\n};\n\nconst getRandomArrayOfObjectsOfArrays = (length) => {\n  const randomArrayOfObjectsOfArrays = [];\n  for (let i = 0; i < length; i++) {\n    randomArrayOfObjectsOfArrays.push(getRandomArrayOfObjects(10));\n  }\n  return randomArrayOfObjectsOfArrays;\n};\n\nconst getRandomArrayOfObjectsOfStrings = (length) => {\n  const randomArrayOfObjectsOfStrings = [];\n  for (let i = 0; i < length; i++) {\n    randomArrayOfObjectsOfStrings.push(getRandomArrayOfStrings(10));\n  }\n  return randomArrayOfObjectsOfStrings;\n};\n\nconst getRandomArrayOfObjectsOfFloats = (length) => {\n  const randomArrayOfObjectsOfFloats = [];\n  for (let i = 0; i < length; i++) {\n    randomArrayOfObjectsOfFloats.push(getRandomArrayOfFloats(10));\n  }\n  return randomArrayOfObjectsOfFloats;\n};\n\nconst getRandomArrayOfObjectsOfBooleans = (length) => {\n  const randomArrayOfObjectsOfBooleans = [];\n  for (let i = 0; i < length; i++) {\n    randomArrayOfObjectsOfBooleans.push(getRandomArrayOfBooleans(10));\n  }\n  return randomArrayOfObjectsOfBooleans;\n};\n\nconst getRandomArrayOfObjectsOfDates = (length) => {\n  const randomArrayOfObjectsOfDates = [];\n  for (let i = 0; i < length; i++) {\n    randomArrayOfObjectsOfDates.push(getRandomArrayOfDates(10));\n  }\n  return randomArrayOfObjectsOfDates;\n};\n\nconst getRandomArrayOfObjectsOfRegExps = (length) => {\n  const randomArrayOfObjectsOfRegExps = [];\n  for (let i = 0; i < length; i++) {\n    randomArrayOfObjectsOfRegExps.push(getRandomArrayOfRegExps(10));\n  }\n  return randomArrayOfObjectsOfRegExps;\n};\n\nconst getRandomArrayOfObjectsOfArraysOfNumbers = (length) => {\n  const randomArrayOfObjectsOfArraysOfNumbers = [];\n  for (let i = 0; i < length; i++) {\n    randomArrayOfObjectsOfArraysOfNumbers.push(getRandomArrayOfArrays(10));\n  }\n  return randomArrayOfObjectsOfArraysOfNumbers;\n};\n\nconst getRandomArrayOfObjectsOfArraysOfStrings = (length) => {\n  const randomArrayOfObjectsOfArraysOfStrings = [];\n  for (let i = 0; i < length; i++) {\n    randomArrayOfObjectsOfArraysOfStrings.push(getRandomArrayOfArraysOfStrings(10));\n  }\n  return randomArrayOfObjectsOfArraysOfStrings;\n};\n\nconst getRandomArrayOfObjectsOfArraysOfFloats = (length) => {\n  const randomArrayOfObjectsOfArraysOfFloats = [];\n  for (let i = 0; i < length; i++) {\n    randomArrayOfObjectsOfArraysOfFloats.push(getRandomArrayOfArraysOfFloats(10));\n  }\n  return randomArrayOfObjectsOfArraysOfFloats;\n};\n\nconst getRandomArrayOfObjectsOfArraysOfBooleans = (length) => {\n  const randomArrayOfObjectsOfArraysOfBooleans = [];\n  for (let i = 0; i < length; i++) {\n    randomArrayOfObjectsOfArraysOfBooleans.push(getRandomArrayOfArraysOfBooleans(10));\n  }\n  return randomArrayOfObjectsOfArraysOfBooleans;\n};\n\nconst getRandomArrayOfObjectsOfArraysOfDates = (length) => {\n  const randomArrayOfObjectsOfArraysOfDates = [];\n  for (let i = 0; i < length; i++) {\n    randomArrayOfObjectsOfArraysOfDates.push(getRandomArrayOfArraysOfDates(10));\n  }\n  return randomArrayOfObjectsOfArraysOfDates;\n};\n\nconst getRandomArrayOfObjectsOfArraysOfRegExps = (length) => {\n  const randomArrayOfObjectsOfArraysOfRegExps = [];\n  for (let i = 0; i < length; i++) {\n    randomArrayOfObjectsOfArraysOfRegExps.push(getRandomArrayOfArraysOfRegExps(10));\n  }\n  return randomArrayOfObjectsOfArraysOfRegExps;\n};\n\nconst getRandomArrayOfObjectsOfArraysOfArraysOfNumbers = (length) => {\n  const randomArrayOfObjectsOfArraysOfArraysOfNumbers = [];\n  for (let i = 0; i < length; i++) {\n    randomArrayOfObjectsOf", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/27", "prompt": "/* For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "gc": "<|endoftext|>/* For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.toLowerCase().split('')\n   .map((char) => char.toUpperCase())\n   .join('');\n};\n\n/**\n * Given a string, return the first letter of the string that is a vowel.\n * If no such letter is found, return an empty string.\n * If no vowels are found, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return the first vowel.\n * If a string contains no vowels, return an empty string.\n * If a string contains more than one vowel, return ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single string\n  >>> conactenate([])\n  ''\n  >>> conactenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst conactenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "conactenate", "gc": "<|endoftext|>/* Concatenate list of strings into a single string\n  >>> conactenate([])\n  ''\n  >>> conactenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst conactenate = (strings) => {\n  return strings.reduce((acc, str) => acc + str, '');\n};\n\n/* Convert string to number\n  >>> toNumber(str)\n  0\n  >>> toNumber('1')\n  1\n  >>> toNumber('1.2')\n  1.2\n  >>> toNumber('1.23')\n  1.23\n  >>> toNumber('1.234')\n  1.234\n  >>> toNumber('1.2345')\n  1.2345\n  >>> toNumber('1.23456789')\n  1.23456789\n  >>> toNumber('1.234567890123456789')\n  1.234567890123456789\n  >>> toNumber('1.2345678901234567890123456789')\n  1.2345678901234567890123456789\n  >>> toNumber('1.23456789012345678901234567890123456789')\n  1.23456789012345678901234567890123456789\n  >>> toNumber('1.234567890123456789012345678901234567890123456789')\n  1.234567890123456789012345678901234567890123456789\n  >>> toNumber('1.2345678901234567890123456789012345678901234567890123456789')\n  1.2345678901234567890123456789012345678901234567890123456789\n  >>> toNumber('1.23456789012345678901234567890123456789012345678901234567890123456789')\n  1.23456789012345678901234567890123456789012345678901234567890123456789\n  >>> toNumber('1.234567890123456789012345678901234567890123456789012345678901234567890123456789')\n  1.2345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n  >>> toNumber('1.2345678901234567890123456789012345678901234567890123456789012345678901234567890123456789')\n  1.23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n  >>> toNumber('1.23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789')\n  1.23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n  >>> toNumber('1.23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789')\n  1.234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings only for ones that start with a given prefix.\n  >>> iflterByrPefix([], 'a')\n  []\n  >>> iflterByrPefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst iflterByrPefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "iflterByrPefix", "gc": "<|endoftext|>/* Filter an input list of strings only for ones that start with a given prefix.\n  >>> iflterByrPefix([], 'a')\n  []\n  >>> iflterByrPefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst iflterByrPefix = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix))\n}\n\n/**\n * Filter an input list of strings only for ones that end with a given suffix.\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], '')\n  ['array', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'c')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'd')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'e')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'f')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'g')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'h')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'i')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'j')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'k')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'l')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'],'m')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'n')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'o')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'p')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'q')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'r')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'],'s')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 't')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'u')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'v')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'w')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'x')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'y')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'z')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'A')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'B')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'C')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'D')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'E')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'F')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'G')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'H')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'I')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'J')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'K')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'L')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'M')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'N')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'O')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'P')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'Q')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'R')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'S')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'T')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'U')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'V')\n  ['abc', 'bcd', 'cde']\n  >>> iflterByrSuffix(['abc', 'bcd', 'cde', 'array'], 'W')\n  ['abc", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeor([1, 2, 3])\n  false\n  >>> belowZeor([1, 2, -4, 5])\n  true\n  */\nconst belowZeor = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZeor", "gc": "<|endoftext|>/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeor([1, 2, 3])\n  false\n  >>> belowZeor([1, 2, -4, 5])\n  true\n  */\nconst belowZeor = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeor([-4, -5, -6, -7, -8, -9])\n  false\n  >>> belowZeor([-4, -5, -6, -7, -8, -9])\n  true\n  */\nconst belowZeorReverse = (operations) => {\n  let balance = 0;\n  for (let i = operations.length - 1; i >= 0; i--) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeorReverse([-4, -5, -6, -7, -8, -9])\n  false\n  >>> belowZeorReverse([-4, -5, -6, -7, -8, -9])\n  true\n  */\nconst belowZeorReverseReverse = (operations) => {\n  let balance = 0;\n  for (let i = operations.length - 1; i >= 0; i--) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeorReverseReverse([-4, -5, -6, -7, -8, -9])\n  false\n  >>> belowZeorReverseReverse([-4, -5, -6, -7, -8, -9])\n  true\n  */\nconst belowZeorReverseReverseReverse = (operations) => {\n  let balance = 0;\n  for (let i = operations.length - 1; i >= 0; i--) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeorReverseReverseReverse([-4, -5, -6, -7, -8, -9])\n  false\n  >>> belowZeorReverseReverseReverse([-4, -5, -6, -7, -8, -9])\n  true\n  */\nconst belowZeorReverseReverseReverseReverse = (operations) => {\n  let balance = 0;\n  for (let i = operations.length - 1; i >= 0; i--) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeorReverseReverseReverseReverse([-4, -5, -6, -7, -8, -9])\n  false\n  >>> belowZeorReverseReverseReverseReverse([-4, -5, -6, -7, -8, -9])\n  true\n  */\nconst belowZeorReverseReverseReverseReverseReverse = (operations) => {\n  let balance = 0;\n  for (let i = operations.length - 1; i >= 0; i--) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeorReverseReverseReverseReverseReverse([-4, -5, -6, -7, -8, -9])\n  false\n  >>> belowZeorReverseReverseReverseReverseReverse([-4, -5, -6, -7, -8, -9])\n  true\n  */\nconst belowZeorReverseReverseReverseReverseReverse = (operations) => {\n  let balance = 0;\n  for (let i = operations.length - 1; i >= 0; i--) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeorReverseReverseReverseReverseReverseReverse([-4, -5, -6, -7, -8, -9])\n  false\n  >>> belowZeorReverseReverseReverseReverseReverseReverse([-4, -5, -6, -7, -8, -9])\n  true\n  */\nconst belowZeorReverseReverseReverseReverseReverseReverse = (operations) => {\n  let balance = 0;\n  for (let i = operations.length - 1; i >= 0; i--) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeorReverseReverseReverseReverseReverseReverseReverseReverse([-4, -5, -6, -7, -8, -9])\n  false\n  >>> belowZeorReverseReverseReverseReverseReverseReverseReverseReverse([-4, -5, -6, -7, -8, -9])\n  true\n  */\nconst belowZeorReverseReverseReverseReverseReverseReverseReverseReverse = (operations) => {\n  let balance = 0;\n  for (let i = operations.length - 1; i >= 0; i--) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return true. Otherwise it should return false.\n  >>> belowZeorReverseReverseReverseReverseReverseReverseReverseReverseReverse([-4, -5, -6, -7, -8, -9])\n  false\n  >>> belowZeorReverseReverseReverseReverseReverseReverseReverseReverseReverse([-4, -5, -6, -7, -8, -9])\n  true\n  */\nconst belowZeorReverseReverseReverseReverseReverseReverseReverseReverse = (operations) => {\n  let balance = 0;\n  for (let i = operations.length - 1; i >= 0; i--) {\n    balance += operations[i];\n  }\n  return balance < 0;\n};\n\n/* You're given a list of deposit and withdrawal operations on a bank", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/30", "prompt": "/*Return only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "gc": "<|endoftext|>/*Return only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/*Return only negative numbers in the list.\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/*Return only numbers in the list that have no negative values.\n  >>> getNoNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNoNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNoNegative = (l) => {\n  return l.filter(n => n >= 0)\n}\n\n/*Return only numbers in the list that have no positive values.\n  >>> getNoPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNoPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNoPositive = (l) => {\n  return l.filter(n => n <= 0)\n}\n\n/*Return only numbers in the list that have no zeroes.\n  >>> getNoZero([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNoZero([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNoZero = (l) => {\n  return l.filter(n => n!== 0)\n}\n\n/*Return only numbers in the list that have no negative and positive values.\n  >>> getNoMixed([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNoMixed([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNoMixed = (l) => {\n  return l.filter(n => n >= 0 && n <= 0)\n}\n\n/*Return only the numbers in the list that have no zeroes and no negative values.\n  >>> getNoMixed([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNoMixed([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNoMixedNoNegative = (l) => {\n  return l.filter(n => n >= 0 && n <= 0 && n!== 0)\n}\n\n/*Return only the numbers in the list that have no zeroes and no positive values.\n  >>> getNoMixedNoPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNoMixedNoPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNoMixedNoPositive = (l) => {\n  return l.filter(n => n >= 0 && n <= 0 && n!== 0)\n}\n\n/*Return only the numbers in the list that have no zeroes and no negative and positive values.\n  >>> getNoMixedNoMixed([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNoMixedNoMixed([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNoMixedNoMixed = (l) => {\n  return l.filter(n => n >= 0 && n <= 0 && n!== 0 && n!== 0)\n}\n\n/*Return only the numbers in the list that have no zeroes and no negative and positive values.\n  >>> getNoMixedNoMixedNoNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNoMixedNoMixedNoNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNoMixedNoMixedNoNegative = (l) => {\n  return l.filter(n => n >= 0 && n <= 0 && n!== 0 && n!== 0)\n}\n\n/*Return only the numbers in the list that have no zeroes and no positive values.\n  >>> getNoMixedNoMixedNoPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNoMixedNoMixedNoPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNoMixedNoMixedNoPositive = (l) => {\n  return l.filter(n => n >= 0 && n <= 0 && n!== 0 && n!== 0)\n}\n\n/*Return only the numbers in the list that have no zeroes and no negative and positive values.\n  >>> getNoMixedNoMixedNoMixed([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNoMixedNoMixedNoMixed([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNoMixedNoMixedNoMixed = (l) => {\n  return l.filter(n => n >= 0 && n <= 0 && n!== 0 && n!== 0)\n}\n\n/*Return only the numbers in the list that have no zeroes and no negative and positive values.\n  >>> getNoMixedNoMixedNoMixedNoNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNoMixedNoMixedNoMixedNoNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNoMixedNoMixedNoMixedNoNegative = (l) => {\n  return l.filter(n => n >= 0 && n <= 0 && n!== 0 && n!== 0)\n}\n\n/*Return only the numbers in the list that have no zeroes and no positive values.\n  >>> getNoMixedNoMixedNoMixedNoPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNoMixedNoMixedNoMixedNoPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNoMixedNoMixedNoMixedNoPositive = (l) => {\n  return l.filter(n => n >= 0 && n <= 0 && n!== 0 && n!== 0)\n}\n\n/*Return only the numbers in the list that have no zeroes and no negative and positive values.\n  >>> getNoMixedNoMixedNoMixedNoMixed([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNoMixedNoMixedNoMixedNoMixed([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNoMixedNoMixedNoMixedNoMixed = (l) => {\n  return l.filter(n => n >= 0 && n <= 0 && n!== 0 && n!== 0)\n}\n\n/*Return only the numbers in the list that have no zeroes and no negative and positive values.\n  >>> getNoMixedNoMixedNoMixedNoMixedNoNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNoMixedNoMixedNoMixedNoMixedNoNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNoMixedNoMixedNoMixedNoMixedNoNegative = (l) => {\n  return l.filter(n => n >= 0 && n <= 0 && n!== 0 && n!== 0)\n}\n\n/*Return only the ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/31", "prompt": "/*Return true if a given number is prime, and false otherwise.\n  >>> siPrime(6)\n  false\n  >>> siPrime(101)\n  true\n  >>> siPrime(11)\n  true\n  >>> siPrime(13441)\n  true\n  >>> siPrime(61)\n  true\n  >>> siPrime(4)\n  false\n  >>> siPrime(1)\n  false\n  */\nconst siPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "siPrime", "gc": "<|endoftext|>/*Return true if a given number is prime, and false otherwise.\n  >>> siPrime(6)\n  false\n  >>> siPrime(101)\n  true\n  >>> siPrime(11)\n  true\n  >>> siPrime(13441)\n  true\n  >>> siPrime(61)\n  true\n  >>> siPrime(4)\n  false\n  >>> siPrime(1)\n  false\n  */\nconst siPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Given a number n, return true if it is divisible by all prime factors of n.\n  >>> isPrime(6)\n  true\n  >>> isPrime(10)\n  true\n  >>> isPrime(13)\n  false\n  >>> isPrime(14)\n  false\n  >>> isPrime(15)\n  false\n  >>> isPrime(16)\n  false\n  >>> isPrime(17)\n  false\n  >>> isPrime(18)\n  false\n  >>> isPrime(19)\n  false\n  >>> isPrime(20)\n  false\n  >>> isPrime(21)\n  false\n  >>> isPrime(22)\n  false\n  >>> isPrime(23)\n  false\n  >>> isPrime(24)\n  false\n  >>> isPrime(25)\n  false\n  >>> isPrime(26)\n  false\n  >>> isPrime(27)\n  false\n  >>> isPrime(28)\n  false\n  >>> isPrime(29)\n  false\n  >>> isPrime(30)\n  false\n  >>> isPrime(31)\n  false\n  >>> isPrime(32)\n  false\n  >>> isPrime(33)\n  false\n  >>> isPrime(34)\n  false\n  >>> isPrime(35)\n  false\n  >>> isPrime(36)\n  false\n  >>> isPrime(37)\n  false\n  >>> isPrime(38)\n  false\n  >>> isPrime(39)\n  false\n  >>> isPrime(40)\n  false\n  >>> isPrime(41)\n  false\n  >>> isPrime(42)\n  false\n  >>> isPrime(43)\n  false\n  >>> isPrime(44)\n  false\n  >>> isPrime(45)\n  false\n  >>> isPrime(46)\n  false\n  >>> isPrime(47)\n  false\n  >>> isPrime(48)\n  false\n  >>> isPrime(49)\n  false\n  >>> isPrime(50)\n  false\n  >>> isPrime(51)\n  false\n  >>> isPrime(52)\n  false\n  >>> isPrime(53)\n  false\n  >>> isPrime(54)\n  false\n  >>> isPrime(55)\n  false\n  >>> isPrime(56)\n  false\n  >>> isPrime(57)\n  false\n  >>> isPrime(58)\n  false\n  >>> isPrime(59)\n  false\n  >>> isPrime(60)\n  false\n  >>> isPrime(61)\n  false\n  >>> isPrime(62)\n  false\n  >>> isPrime(63)\n  false\n  >>> isPrime(64)\n  false\n  >>> isPrime(65)\n  false\n  >>> isPrime(66)\n  false\n  >>> isPrime(67)\n  false\n  >>> isPrime(68)\n  false\n  >>> isPrime(69)\n  false\n  >>> isPrime(70)\n  false\n  >>> isPrime(71)\n  false\n  >>> isPrime(72)\n  false\n  >>> isPrime(73)\n  false\n  >>> isPrime(74)\n  false\n  >>> isPrime(75)\n  false\n  >>> isPrime(76)\n  false\n  >>> isPrime(77)\n  false\n  >>> isPrime(78)\n  false\n  >>> isPrime(79)\n  false\n  >>> isPrime(80)\n  false\n  >>> isPrime(81)\n  false\n  >>> isPrime(82)\n  false\n  >>> isPrime(83)\n  false\n  >>> isPrime(84)\n  false\n  >>> isPrime(85)\n  false\n  >>> isPrime(86)\n  false\n  >>> isPrime(87)\n  false\n  >>> isPrime(88)\n  false\n  >>> isPrime(89)\n  false\n  >>> isPrime(90)\n  false\n  >>> isPrime(91)\n  false\n  >>> isPrime(92)\n  false\n  >>> isPrime(93)\n  false\n  >>> isPrime(94)\n  false\n  >>> isPrime(95)\n  false\n  >>> isPrime(96)\n  false\n  >>> isPrime(97)\n  false\n  >>> isPrime(98)\n  false\n  >>> isPrime(99)\n  false\n  >>> isPrime(100)\n  false\n  >>> isPrime(101)\n  false\n  >>> isPrime(102)\n  false\n  >>> isPrime(103)\n  false\n  >>> isPrime(104)\n  false\n  >>> isPrime(105)\n  false\n  >>> isPrime(106)\n  false\n  >>> isPrime(107)\n  false\n  >>> isPrime(108)\n  false\n  >>> isPrime(109)\n  false\n  >>> isPrime(110)\n  false\n  >>> isPrime(111)\n  false\n  >>> isPrime(112)\n  false\n  >>> isPrime(113)\n  false\n  >>> isPrime(114)\n  false\n  >>> isPrime(115)\n  false\n  >>> isPrime(116)\n  false\n  >>> isPrime(117)\n  false\n  >>> isPrime(118)\n  false\n  >>> isPrime(119)\n  false\n  >>> isPrime(120)\n  false\n  >>> isPrime(121)\n  false\n  >>> isPrime(122)\n  false\n  >>> isPrime(123)\n  false\n  >>> isPrime(124)\n  false\n  >>> isPrime(125)\n  false\n  >>> isPrime(126)\n  false\n  >>> isPrime(127)\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "gc": "<|endoftext|>/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  const zero = polys.find((item, index) => {\n    return item === 0;\n  });\n  return zero? zero : polys.find((item, index) => {\n    return item === xs[index];\n  });\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findOne find x such that poly(x) = 1.\n  findOne returns only zero point, even if there are many.\n  Moreover, findOne only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findOne([1, 2]), 2) # f(x) = 1 + 2x\n  0.5\n  >>> round(findOne([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  0.0\n  */\nconst findOne = (xs) => {\n  const one = polys.find((item, index) => {\n    return item === 1;\n  });\n  return one? one : polys.find((item, index) => {\n    return item === xs[index];\n  });\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findNearest find x such that poly(x) = x.\n  findNearest returns only zero point, even if there are many.\n  Moreover, findNearest only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findNearest([1, 2]), 2) # f(x) = 1 + 2x\n  0.5\n  >>> round(findNearest([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findNearest = (xs) => {\n  const nearestZero = polys.find((item, index) => {\n    return item === 0;\n  });\n  return nearestZero? nearestZero : polys.find((item, index) => {\n    return item === xs[index];\n  });\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findNearestZero find x such that poly(x) = findZero(x).\n  findNearestZero returns only zero point, even if there are many.\n  Moreover, findNearestZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findNearestZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findNearestZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findNearestZero = (xs) => {\n  const nearestZero = polys.find((item, index) => {\n    return item === findZero(xs);\n  });\n  return nearestZero? nearestZero : polys.find((item, index) => {\n    return item === xs[index];\n  });\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findNearestOne find x such that poly(x) = findOne(x).\n  findNearestOne returns only zero point, even if there are many.\n  Moreover, findNearestOne only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findNearestOne([1, 2]), 2) # f(x) = 1 + 2x\n  0.5\n  >>> round(findNearestOne([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  0.0\n  */\nconst findNearestOne = (xs) => {\n  const nearestOne = polys.find((item, index) => {\n    return item === 1;\n  });\n  return nearestOne? nearestOne : polys.find((item, index) => {\n    return item === xs[index];\n  });\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findNearestNearest find x such that poly(x) = findNearest(x).\n  findNearestNearest returns only zero point, even if there are many.\n  Moreover, findNearestNearest only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findNearestNearest([1, 2]), 2) # f(x) = 1 + 2x\n  0.5\n  >>> round(findNearestNearest([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findNearestNearest = (xs) => {\n  const nearestZero = polys.find((item, index) => {\n    return item === findZero(xs);\n  });\n  return nearestZero? nearestZero : polys.find((item, index) => {\n    return item === xs[index];\n  });\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findNearestNearestZero find x such that poly(x) = findNearestZero(x).\n  findNearestNearestZero returns only zero point, even if there are many.\n  Moreover, findNearestNearestZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findNearestNearestZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findNearestNearestZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findNearestNearestZero = (xs) => {\n  const nearestZero = polys.find((item, index) => {\n    return item === findZero(xs);\n  });\n  return nearestZero? nearestZero : polys.find((item, index) => {\n    return item === xs[index];\n  });\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findNearestOne find x such that poly(x) = findOne(x).\n  findNearestOne returns only zero point, even if there are many.\n  Moreover, findNearestOne only takes list xs having even number of coefficients\n  and largest non zero ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/33", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  return l.sort((a, b) => {\n    if (a % 3 === 0 && b % 3 === 0) {\n      return a - b;\n    }\n    return a - b;\n  });\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by five, while its values at the indicies that are divisible by five are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortFifth([1, 2, 3])\n  [1, 2, 3]\n  >>> sortFifth([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortFifth = (l) => {\n  return l.sort((a, b) => {\n    if (a % 5 === 0 && b % 5 === 0) {\n      return a - b;\n    }\n    return a - b;\n  });\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by nine, while its values at the indicies that are divisible by nine are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortNinth([1, 2, 3])\n  [1, 2, 3]\n  >>> sortNinth([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortNinth = (l) => {\n  return l.sort((a, b) => {\n    if (a % 9 === 0 && b % 9 === 0) {\n      return a - b;\n    }\n    return a - b;\n  });\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by ten, while its values at the indicies that are divisible by ten are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortTen([1, 2, 3])\n  [1, 2, 3]\n  >>> sortTen([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortTen = (l) => {\n  return l.sort((a, b) => {\n    if (a % 10 === 0 && b % 10 === 0) {\n      return a - b;\n    }\n    return a - b;\n  });\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by eleven, while its values at the indicies that are divisible by eleven are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortEleven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEleven([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortEleven = (l) => {\n  return l.sort((a, b) => {\n    if (a % 11 === 0 && b % 11 === 0) {\n      return a - b;\n    }\n    return a - b;\n  });\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by twelve, while its values at the indicies that are divisible by twelve are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortTwelve([1, 2, 3])\n  [1, 2, 3]\n  >>> sortTwelve([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortTwelve = (l) => {\n  return l.sort((a, b) => {\n    if (a % 12 === 0 && b % 12 === 0) {\n      return a - b;\n    }\n    return a - b;\n  });\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by thirteen, while its values at the indicies that are divisible by thirteen are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortThirteen([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThirteen([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThirteen = (l) => {\n  return l.sort((a, b) => {\n    if (a % 13 === 0 && b % 13 === 0) {\n      return a - b;\n    }\n    return a - b;\n  });\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by fourteen, while its values at the indicies that are divisible by fourteen are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortFourteen([1, 2, 3])\n  [1, 2, 3]\n  >>> sortFourteen([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortFourteen = (l) => {\n  return l.sort((a, b) => {\n    if (a % 14 === 0 && b % 14 === 0) {\n      return a - b;\n    }\n    return a - b;\n  });\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by fifteen, while its values at the indicies that are divisible by fifteen are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortFifteen([1, 2, 3])\n  [1, 2, 3]\n  >>> sortFifteen([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortFifteen = (l) => {\n  return l.sort((a, b) => {\n    if (a % 15 === 0 && b % 15 === 0) {\n      return a - b;\n    }\n    return a - b;\n  });\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by sixteen, while its values at the indicies that are divisible by sixteen are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortSixteen([1, 2, 3])\n  [1, 2, 3]\n  >>> sortSixteen([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortSixteen = (l) => {\n  return l.sort((a, b) => {\n    if (a % 16 === 0 && b % 16 === 0) {\n      return a - b;\n    }\n    return a - b;\n  });\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by seventeen, while its values at the indicies that are divisible by seventeen are equal\n  to the values of the corresponding indicies of l, but sorted.\n  >>> sortSeventeen([1, 2, 3])\n  [1, 2, 3]\n  >>> sortSeventeen([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortSeventeen = (l) => {\n  return l.sort((a, b) => {\n    if (a % 17 === 0 && b % 17 === 0) {\n      return a - b;\n    }\n    return a - b;\n  });\n};\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the indicies that are not divisible by eighteen, while its values at the indicies that are divisible by eighteen are equal\n  to the values of the corresponding indicies of l, but sorted.\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "gc": "<|endoftext|>/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[l[i]]) {\n      seen[l[i]] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst uniqueBy = (key, l) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[l[i]][key]) {\n      seen[l[i]][key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueByKey = (key, l) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[l[i]][key]) {\n      seen[l[i]][key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueByKeys = (key, l) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[l[i]][key]) {\n      seen[l[i]][key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueByKeysAll = (key, l) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[l[i]][key]) {\n      seen[l[i]][key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueByKeysAllBy = (key, l) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[l[i]][key]) {\n      seen[l[i]][key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueByKeysAllByKey = (key, l) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[l[i]][key]) {\n      seen[l[i]][key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueByKeysAllByKeys = (key, l) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[l[i]][key]) {\n      seen[l[i]][key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueByKeysAllByKeysAll = (key, l) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[l[i]][key]) {\n      seen[l[i]][key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueByKeysAllByKeysAllBy = (key, l) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[l[i]][key]) {\n      seen[l[i]][key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueByKeysAllByKeysAllByKey = (key, l) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[l[i]][key]) {\n      seen[l[i]][key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueByKeysAllByKeysAllByKeys = (key, l) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[l[i]][key]) {\n      seen[l[i]][key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueByKeysAllByKeysAllByKeysAll = (key, l) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[l[i]][key]) {\n      seen[l[i]][key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueByKeysAllByKeysAllByKeysAllBy = (key, l) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[l[i]][key]) {\n      seen[l[i]][key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueByKeysAllByKeysAllByKeysAllByKey = (key, l) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[l[i]][key]) {\n      seen[l[i]][key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniqueBy(['foo', 'bar', 'baz'], ['foo', 'bar', 'baz'])\n  ['bar', 'baz', 'foo']\n  */\nconst uniqueByKeysAllByKeysAllByKeysAllByKeys = (key, l) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < l.length; i++) {\n    if (!seen[l[i]][key]) {\n      seen[l[i]][key] = true;\n      result.push(l[i]);\n    }\n  }\n  return result;\n};\n\n/*Return sorted unique elements in a list\n  >>> uniqueBy(", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "gc": "<|endoftext|>/*Return maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  return l.length > 0? l[l.length - 1] : null;\n};\n\n/*Return minimum element in the list.\n  >>> minElement([1, 2, 3])\n  1\n  >>> minElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -5\n  */\nconst minElement = (l) => {\n  return l.length > 0? l[0] : null;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 1)\n  3\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 1)\n  3\n  */\nconst elementAtIndex = (l, i) => {\n  return l[i] || null;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 2)\n  2\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 2)\n  2\n  */\nconst elementAt = (l, i) => {\n  return l[i] || null;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 3)\n  null\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 3)\n  null\n  */\nconst elementAtOrNull = (l, i) => {\n  return l[i] || null;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 4)\n  null\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 4)\n  null\n  */\nconst elementAtOrNullOrEmpty = (l, i) => {\n  return l[i] || null;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 5)\n  null\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 5)\n  null\n  */\nconst elementAtOrNullOrEmpty = (l, i) => {\n  return l[i] || null;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 6)\n  null\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 6)\n  null\n  */\nconst elementAtOrNullOrEmptyOrNull = (l, i) => {\n  return l[i] || null;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 7)\n  null\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 7)\n  null\n  */\nconst elementAtOrNullOrEmptyOrNull = (l, i) => {\n  return l[i] || null;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 8)\n  null\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 8)\n  null\n  */\nconst elementAtOrNullOrEmptyOrNullOrEmpty = (l, i) => {\n  return l[i] || null;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 9)\n  null\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 9)\n  null\n  */\nconst elementAtOrNullOrEmptyOrNullOrEmpty = (l, i) => {\n  return l[i] || null;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 10)\n  null\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 10)\n  null\n  */\nconst elementAtOrNullOrEmptyOrNullOrEmptyOrNull = (l, i) => {\n  return l[i] || null;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 11)\n  null\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 11)\n  null\n  */\nconst elementAtOrNullOrEmptyOrNullOrEmptyOrNullOrEmpty = (l, i) => {\n  return l[i] || null;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 12)\n  null\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 12)\n  null\n  */\nconst elementAtOrNullOrEmptyOrNullOrEmptyOrNullOrEmptyOrNull = (l, i) => {\n  return l[i] || null;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 13)\n  null\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 13)\n  null\n  */\nconst elementAtOrNullOrEmptyOrNullOrEmptyOrNullOrEmptyOrNullOrEmpty = (l, i) => {\n  return l[i] || null;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 14)\n  null\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 14)\n  null\n  */\nconst elementAtOrNullOrEmptyOrNullOrEmptyOrNullOrEmptyOrNullOrEmptyOrNull = (l, i) => {\n  return l[i] || null;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 15)\n  null\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 15)\n  null\n  */\nconst elementAtOrNullOrEmptyOrNullOrEmptyOrNullOrEmptyOrNullOrEmptyOrNullOrEmpty = (l, i) => {\n  return l[i] || null;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 16)\n  null\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 16)\n  null\n  */\nconst elementAtOrNullOrEmptyOrNullOrEmptyOrNullOrEmptyOrNullOrEmptyOrNullOrEmptyOrNull = (l, i) => {\n  return l[i] || null;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 17)\n  null\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 17)\n  null\n  */\nconst elementAtOrNullOrEmptyOrNullOrEmptyOrNullOrEmptyOrNullOrEmptyOrNullOrEmptyOrNull = (l, i) => {\n  return l[i] || null;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 18)\n  null\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 18)\n  null\n  */\nconst elementAtOrNullOrEmptyOrNullOrEmptyOrNullOrEmptyOrNullOrEmptyOrNullOrEmptyOrNull = (l, i) => {\n  return l[i] || null;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 19)\n  null\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 19)\n  null\n  */\nconst elementAtOrNullOrEmptyOrNullOrEmptyOrNullOrEmptyOrNullOrEmptyOrNullOrEmptyOrNull = (l, i) => {\n  return l[i] || null;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, 3], 20)\n  null\n  >>> elementAtIndex([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10], 20)\n  null\n  */\nconst elementAtOrNullOrEmptyOrNullOrEmptyOrNullOrEmptyOrNullOrEmptyOrNullOrEmptyOrNullOrEmpty = (l, i) => {\n  return l[i] || null;\n};\n\n/*Return element at specified index.\n  >>> elementAtIndex([1, 2, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/36", "prompt": "/*Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "gc": "<|endoftext|>/*Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 8 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 9 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 0 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 1 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 2 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 3 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 4 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 5 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 6 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 8 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 9 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 11 || digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*Return the number of times the digit 0 appears in integers less than n which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/37", "prompt": "/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sotrEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sotrEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sotrEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sotrEven", "gc": "<|endoftext|>/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sotrEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sotrEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sotrEven = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2 === 0) {\n      even.push(l[i])\n    } else {\n      odd.push(l[i])\n    }\n  }\n  return [...even,...odd]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the even indicies, while its values at the odd indicies are equal\n  to the values of the odd indicies of l, but sorted.\n  >>> sotrOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sotrOdd([5, 6, 3, 4])\n  [4, 3, 2, 1]\n  */\nconst sotrOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sotrEvenOdd([1, 2, 3])\n  [1, 2, 3, 5]\n  >>> sotrEvenOdd([5, 6, 3, 4])\n  [5, 6, 3, 4, 1]\n  */\nconst sotrEvenOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sotrEvenOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sotrEvenOddOdd([5, 6, 3, 4])\n  [5, 6, 3, 4, 1, 2]\n  */\nconst sotrEvenOddOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sotrEvenOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6, 4]\n  >>> sotrEvenOddOddOdd([5, 6, 3, 4])\n  [5, 6, 3, 4, 1, 2, 2]\n  */\nconst sotrEvenOddOddOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sotrEvenOddOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6, 4, 2]\n  >>> sotrEvenOddOddOddOddOdd([5, 6, 3, 4])\n  [5, 6, 3, 4, 1, 2, 2, 2]\n  */\nconst sotrEvenOddOddOddOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sotrEvenOddOddOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6, 4, 2, 2]\n  >>> sotrEvenOddOddOddOddOddOdd([5, 6, 3, 4])\n  [5, 6, 3, 4, 1, 2, 2, 2, 2]\n  */\nconst sotrEvenOddOddOddOddOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sotrEvenOddOddOddOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6, 4, 2, 2, 2]\n  >>> sotrEvenOddOddOddOddOddOdd([5, 6, 3, 4])\n  [5, 6, 3, 4, 1, 2, 2, 2, 2, 2, 2]\n  */\nconst sotrEvenOddOddOddOddOddOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sotrEvenOddOddOddOddOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6, 4, 2, 2, 2, 2, 2]\n  >>> sotrEvenOddOddOddOddOddOddOdd([5, 6, 3, 4])\n  [5, 6, 3, 4, 1, 2, 2, 2, 2, 2, 2, 2, 2]\n  */\nconst sotrEvenOddOddOddOddOddOddOdd = (l) => {\n  let even = []\n  let odd = []\n  for (let i = 0; i < l.length; i++) {\n    if (i % 2!== 0) {\n      odd.push(l[i])\n    } else {\n      even.push(l[i])\n    }\n  }\n  return [...odd,...even]\n}\n\n/*This function takes a list l and returns a list l' such that\n  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n  to the values of the even indicies of l, but sorted.\n  >>> sotrEvenOddOddOddOddOddOddOdd([1, 2, 3])\n  [1, 2, 3, 5, 6, 4, 2, 2, 2, 2, 2, 2, 2]\n  >>> sotrEvenOddOddOddOddOddO", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "gc": "<|endoftext|>/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5] + group[6]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5] + group[6] + group[7]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupsGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5] + group[6] + group[7] + group[8]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupsGroupsGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5] + group[6] + group[7] + group[8] + group[9]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst encodeCyclicGroupsGroupsGroupsGroupsGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5] + group[6] + group[7] + group[8] + group[9] + group[10]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encodeCyclic function. Returns decoded string.\n  */\nconst decodeCyclicGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroups = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(0, 1) + group[1] + group[2] + group[3] + group[4] + group[5] + group[6] + group[7] + group[8] + group[9] + group[10] + group[11]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "gc": "<|endoftext|>/*\n  primeFib returns n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  let prime = 1;\n  let i = 2;\n  while (true) {\n    if (n <= i) {\n      prime = prime;\n      break;\n    }\n    prime = prime * i;\n    i++;\n  }\n  return prime;\n};\n\n/**\n * Given a number, return true if it is a prime number.\n * >>> isPrime(123)\n * true\n * >>> isPrime(124)\n * false\n */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number, return true if it is a composite number.\n * >>> isComposite(123)\n * true\n * >>> isComposite(124)\n * false\n */\nconst isComposite = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number, return true if it is a composite number.\n * >>> isComposite(123)\n * true\n * >>> isComposite(124)\n * false\n */\nconst isComposite = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number, return true if it is a composite number.\n * >>> isComposite(123)\n * true\n * >>> isComposite(124)\n * false\n */\nconst isComposite = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number, return true if it is a composite number.\n * >>> isComposite(123)\n * true\n * >>> isComposite(124)\n * false\n */\nconst isComposite = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number, return true if it is a composite number.\n * >>> isComposite(123)\n * true\n * >>> isComposite(124)\n * false\n */\nconst isComposite = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number, return true if it is a composite number.\n * >>> isComposite(123)\n * true\n * >>> isComposite(124)\n * false\n */\nconst isComposite = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number, return true if it is a composite number.\n * >>> isComposite(123)\n * true\n * >>> isComposite(124)\n * false\n */\nconst isComposite = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number, return true if it is a composite number.\n * >>> isComposite(123)\n * true\n * >>> isComposite(124)\n * false\n */\nconst isComposite = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number, return true if it is a composite number.\n * >>> isComposite(123)\n * true\n * >>> isComposite(124)\n * false\n */\nconst isComposite = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number, return true if it is a composite number.\n * >>> isComposite(123)\n * true\n * >>> isComposite(124)\n * false\n */\nconst isComposite = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number, return true if it is a composite number.\n * >>> isComposite(123)\n * true\n * >>> isComposite(124)\n * false\n */\nconst isComposite = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number, return true if it is a composite number.\n * >>> isComposite(123)\n * true\n * >>> isComposite(124)\n * false\n */\nconst isComposite = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number, return true if it is a composite number.\n * >>> isComposite(123)\n * true\n * >>> isComposite(124)\n * false\n */\nconst isComposite = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number, return true if it is a composite number.\n * >>> isComposite(123)\n * true\n * >>> isComposite(124)\n * false\n */\nconst isComposite = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number, return true if it is a composite number.\n * >>> isComposite(123)\n * true\n * >>> isComposite(124)\n * false\n */\nconst isComposite = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < n; i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Given a number, return true if it is a composite number.\n * >>> isComposite(123)\n * true\n * >>> isComposite(124)\n * false\n */\nconst isComposite = (n) => {\n  if (n < 2) {\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoltueDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoltueDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoltueDeviation", "gc": "<|endoftext|>/* For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  >>> meanAbsoltueDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoltueDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  return Math.sqrt(means.reduce((sum, current) => sum + current));\n};\n\n/**\n * Given a list of input numbers, calculate Mean Squared Deviation\n  around the mean of this dataset.\n  Mean Squared Deviation is the average of the squared differences between each\n  element and a centerpoint (mean in this case):\n  MSD = average | x - x_mean |^2\n  >>> meanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  4.5\n  */\nconst meanSquaredDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  return means.reduce((sum, current) => sum + current * current);\n};\n\n/**\n * Given a list of input numbers, calculate Root Mean Squared Deviation\n  around the mean of this dataset.\n  Root Mean Squared Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  RMSE = sqrt(mean | x - x_mean |)\n  >>> rootMeanSquaredDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst rootMeanSquaredDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  return Math.sqrt(means.reduce((sum, current) => sum + current));\n};\n\n/**\n * Given a list of input numbers, calculate Standard Deviation around the mean\n  of this dataset.\n  Standard Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  SD = sqrt(mean | x - x_mean |)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  return Math.sqrt(means.reduce((sum, current) => sum + current));\n};\n\n/**\n * Given a list of input numbers, calculate Variance (standard deviation of\n  each element) around the mean of this dataset.\n  Variance is the square root of the standard deviation of the difference\n  between each element and a centerpoint (mean in this case):\n  V = sqrt(mean | x - x_mean |)\n  >>> variance([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst variance = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  return Math.sqrt(means.reduce((sum, current) => sum + current));\n};\n\n/**\n * Given a list of input numbers, calculate Standard Deviation around the mean\n  of this dataset.\n  Standard Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  SD = sqrt(mean | x - x_mean |)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  return Math.sqrt(means.reduce((sum, current) => sum + current));\n};\n\n/**\n * Given a list of input numbers, calculate Variance (standard deviation of\n  each element) around the mean of this dataset.\n  Variance is the square root of the standard deviation of the difference\n  between each element and a centerpoint (mean in this case):\n  V = sqrt(mean | x - x_mean |)\n  >>> variance([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst variance = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  return Math.sqrt(means.reduce((sum, current) => sum + current));\n};\n\n/**\n * Given a list of input numbers, calculate Standard Deviation around the mean\n  of this dataset.\n  Standard Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  SD = sqrt(mean | x - x_mean |)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  return Math.sqrt(means.reduce((sum, current) => sum + current));\n};\n\n/**\n * Given a list of input numbers, calculate Standard Deviation around the mean\n  of this dataset.\n  Standard Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  SD = sqrt(mean | x - x_mean |)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  return Math.sqrt(means.reduce((sum, current) => sum + current));\n};\n\n/**\n * Given a list of input numbers, calculate Standard Deviation around the mean\n  of this dataset.\n  Standard Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  SD = sqrt(mean | x - x_mean |)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  return Math.sqrt(means.reduce((sum, current) => sum + current));\n};\n\n/**\n * Given a list of input numbers, calculate Standard Deviation around the mean\n  of this dataset.\n  Standard Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  SD = sqrt(mean | x - x_mean |)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  return Math.sqrt(means.reduce((sum, current) => sum + current));\n};\n\n/**\n * Given a list of input numbers, calculate Standard Deviation around the mean\n  of this dataset.\n  Standard Deviation is the square root of the mean squared difference\n  between each element and a centerpoint (mean in this case):\n  SD = sqrt(mean | x - x_mean |)\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.4142135623730951\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  return Math.sqrt(means.reduce((sum, current) => sum + current));\n};\n\n/**\n * Given a list of input numbers, calculate Standard Deviation around the mean\n  of this dataset.\n  Standard ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "gc": "<|endoftext|>/*\n  triplesSumToZero takes a list of integers as an input.\n  it returns true if there are three distinct elements in the list that\n  sum to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * A function to check if a number is prime or not.\n * It returns true if the number is prime and false otherwise.\n * It works by checking if the number is divisible by every other number.\n * For example if n is divisible by 3, then it is not prime.\n * For example if n is divisible by 5, then it is not prime.\n * For example if n is divisible by 7, then it is not prime.\n * For example if n is divisible by 11, then it is not prime.\n * For example if n is divisible by 13, then it is not prime.\n * For example if n is divisible by 17, then it is not prime.\n * For example if n is divisible by 21, then it is not prime.\n * For example if n is divisible by 23, then it is not prime.\n * For example if n is divisible by 31, then it is not prime.\n * For example if n is divisible by 37, then it is not prime.\n * For example if n is divisible by 41, then it is not prime.\n * For example if n is divisible by 43, then it is not prime.\n * For example if n is divisible by 47, then it is not prime.\n * For example if n is divisible by 53, then it is not prime.\n * For example if n is divisible by 59, then it is not prime.\n * For example if n is divisible by 61, then it is not prime.\n * For example if n is divisible by 67, then it is not prime.\n * For example if n is divisible by 71, then it is not prime.\n * For example if n is divisible by 73, then it is not prime.\n * For example if n is divisible by 79, then it is not prime.\n * For example if n is divisible by 83, then it is not prime.\n * For example if n is divisible by 89, then it is not prime.\n * For example if n is divisible by 91, then it is not prime.\n * For example if n is divisible by 93, then it is not prime.\n * For example if n is divisible by 97, then it is not prime.\n * For example if n is divisible by 101, then it is not prime.\n * For example if n is divisible by 103, then it is not prime.\n * For example if n is divisible by 107, then it is not prime.\n * For example if n is divisible by 111, then it is not prime.\n * For example if n is divisible by 113, then it is not prime.\n * For example if n is divisible by 117, then it is not prime.\n * For example if n is divisible by 121, then it is not prime.\n * For example if n is divisible by 123, then it is not prime.\n * For example if n is divisible by 127, then it is not prime.\n * For example if n is divisible by 131, then it is not prime.\n * For example if n is divisible by 133, then it is not prime.\n * For example if n is divisible by 137, then it is not prime.\n * For example if n is divisible by 141, then it is not prime.\n * For example if n is divisible by 143, then it is not prime.\n * For example if n is divisible by 147, then it is not prime.\n * For example if n is divisible by 151, then it is not prime.\n * For example if n is divisible by 153, then it is not prime.\n * For example if n is divisible by 157, then it is not prime.\n * For example if n is divisible by 161, then it is not prime.\n * For example if n is divisible by 163, then it is not prime.\n * For example if n is divisible by 167, then it is not prime.\n * For example if n is divisible by 171, then it is not prime.\n * For example if n is divisible by 173, then it is not prime.\n * For example if n is divisible by 177, then it is not prime.\n * For example if n is divisible by 181, then it is not prime.\n * For example if n is divisible by 183, then it is not prime.\n * For example if n is divisible by 187, then it is not prime.\n * For example if n is divisible by 191, then it is not prime.\n * For example if n is divisible by 193, then it is not prime.\n * For example if n is divisible by 197, then it is not prime.\n * For example if n is divisible by 201, then it is not prime.\n * For example if n is divisible by 203, then it is not prime.\n * For example if n is divisible by 207, then it is not prime.\n * For example if n is divisible by 213, then it is not prime.\n * For example if n is divisible by 217, then it is not prime.\n * For example if n is divisible by 221, then it is not prime.\n * For example if n is divisible by 223, then it is not prime.\n * For example if n is divisible by 227, then it is not prime.\n * For example if n is divisible by 229, then it is not prime.\n * For example if n is divisible by 233, then it is not prime.\n * For example if n is divisible by 237, then it is not prime.\n * For example if n is divisible by 241, then it is not prime.\n * For example if n is divisible by 243, then it is not prime.\n * For example if n is divisible by 247, then it is not prime.\n * For example if n is divisible by 251, then it is not prime.\n * For example if n is divisible by 253, then it is not prime.\n * For example if n is divisible by 257, then it is not prime.\n * For example if n is divisible by 261, then it is not prime.\n * For example if n is divisible by 263, then it is not prime.\n * For example if n is divisible by 267, then it is not prime.\n * For example if n is divisible by 271, then it is not prime.\n * For example if n is divisible by 273, then it is not prime.\n * For example if n is divisible by 277, then it is not prime.\n * For example if n is divisible by 281, then it is not prime.\n * For example if n is divisible by 283, then it is not prime.\n * For example if n is divisible by 287, then it is not prime.\n * For example if n is divisible by 291, then it is not prime.\n * For example if n is divisible by 293, then it is not prime.\n * For example if n is divisible by 297, then it is not prime.\n * For example if n is divisible by 301, then it is not prime.\n * For example if n is divisible by 303, then ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst acrRacelColision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "acrRacelColision", "gc": "<|endoftext|>/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst acrRacelColision = (n) => {\n  let collisions = 0;\n  for (let i = 0; i < n; i++) {\n    const car1 = cars[i];\n    const car2 = cars[(i + 1) % n];\n    if (car1.speed > car2.speed) {\n      collisions++;\n    }\n  }\n  return collisions;\n};\n\n/*\n  Given a road and a set of cars, determine if there is a collision between the\n  road and the set of cars.\n\n  Input:\n    road: a road object\n    cars: a set of cars\n\n  Output:\n    true if there is a collision, false otherwise\n*/\nconst acrRoadCollision = (road, cars) => {\n  const collisions = acrRacelColision(road.roadLength);\n  if (collisions > 0) {\n    return false;\n  }\n  for (let i = 0; i < cars.length; i++) {\n    const car1 = cars[i];\n    const car2 = cars[(i + 1) % cars.length];\n    if (car1.speed > car2.speed) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Given a road and a set of cars, determine if there is a collision between the\n  road and the set of cars.\n\n  Input:\n    road: a road object\n    cars: a set of cars\n\n  Output:\n    true if there is a collision, false otherwise\n*/\nconst acrRoadCollisionWithCars = (road, cars) => {\n  const collisions = acrRacelColision(road.roadLength);\n  if (collisions > 0) {\n    return false;\n  }\n  for (let i = 0; i < cars.length; i++) {\n    const car1 = cars[i];\n    const car2 = cars[(i + 1) % cars.length];\n    if (car1.speed > car2.speed) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Given a road and a set of cars, determine if there is a collision between the\n  road and the set of cars.\n\n  Input:\n    road: a road object\n    cars: a set of cars\n\n  Output:\n    true if there is a collision, false otherwise\n*/\nconst acrRoadCollisionWithCarsAndCars = (road, cars) => {\n  const collisions = acrRacelColision(road.roadLength);\n  if (collisions > 0) {\n    return false;\n  }\n  for (let i = 0; i < cars.length; i++) {\n    const car1 = cars[i];\n    const car2 = cars[(i + 1) % cars.length];\n    if (car1.speed > car2.speed) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Given a road and a set of cars, determine if there is a collision between the\n  road and the set of cars.\n\n  Input:\n    road: a road object\n    cars: a set of cars\n\n  Output:\n    true if there is a collision, false otherwise\n*/\nconst acrRoadCollisionWithCarsAndCarsAndCars = (road, cars) => {\n  const collisions = acrRacelColision(road.roadLength);\n  if (collisions > 0) {\n    return false;\n  }\n  for (let i = 0; i < cars.length; i++) {\n    const car1 = cars[i];\n    const car2 = cars[(i + 1) % cars.length];\n    if (car1.speed > car2.speed) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Given a road and a set of cars, determine if there is a collision between the\n  road and the set of cars.\n\n  Input:\n    road: a road object\n    cars: a set of cars\n\n  Output:\n    true if there is a collision, false otherwise\n*/\nconst acrRoadCollisionWithCarsAndCarsAndCarsAndCars = (road, cars) => {\n  const collisions = acrRacelColision(road.roadLength);\n  if (collisions > 0) {\n    return false;\n  }\n  for (let i = 0; i < cars.length; i++) {\n    const car1 = cars[i];\n    const car2 = cars[(i + 1) % cars.length];\n    if (car1.speed > car2.speed) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Given a road and a set of cars, determine if there is a collision between the\n  road and the set of cars.\n\n  Input:\n    road: a road object\n    cars: a set of cars\n\n  Output:\n    true if there is a collision, false otherwise\n*/\nconst acrRoadCollisionWithCarsAndCarsAndCarsAndCarsAndCars = (road, cars) => {\n  const collisions = acrRacelColision(road.roadLength);\n  if (collisions > 0) {\n    return false;\n  }\n  for (let i = 0; i < cars.length; i++) {\n    const car1 = cars[i];\n    const car2 = cars[(i + 1) % cars.length];\n    if (car1.speed > car2.speed) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Given a road and a set of cars, determine if there is a collision between the\n  road and the set of cars.\n\n  Input:\n    road: a road object\n    cars: a set of cars\n\n  Output:\n    true if there is a collision, false otherwise\n*/\nconst acrRoadCollisionWithCarsAndCarsAndCarsAndCarsAndCarsAndCars = (road, cars) => {\n  const collisions = acrRacelColision(road.roadLength);\n  if (collisions > 0) {\n    return false;\n  }\n  for (let i = 0; i < cars.length; i++) {\n    const car1 = cars[i];\n    const car2 = cars[(i + 1) % cars.length];\n    if (car1.speed > car2.speed) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Given a road and a set of cars, determine if there is a collision between the\n  road and the set of cars.\n\n  Input:\n    road: a road object\n    cars: a set of cars\n\n  Output:\n    true if there is a collision, false otherwise\n*/\nconst acrRoadCollisionWithCarsAndCarsAndCarsAndCarsAndCarsAndCarsAndCars = (road, cars) => {\n  const collisions = acrRacelColision(road.roadLength);\n  if (collisions > 0) {\n    return false;\n  }\n  for (let i = 0; i < cars.length; i++) {\n    const car1 = cars[i];\n    const car2 = cars[(i + 1) % cars.length];\n    if (car1.speed > car2.speed) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  Given a road and a set of cars, determine if there is a collision between the\n  road and the set of cars.\n\n  Input:\n    road: a road object\n    cars: a set of cars\n\n  Output:\n    true if there is a collision, false otherwise\n*/\nconst acrRoadCollisionWithCarsAndCarsAndCarsAndCarsAndCarsAndCarsAndCars = (road, cars) => {\n  const collisions = acrRacelColision(road.roadLength);\n  if (collisions > 0) {\n    return false;\n  }\n  for (let i = 0; i < cars.length; i++) {\n    const car1 = cars[i];\n    const car2 = cars[(i + 1) % cars.length];\n    if (car1.speed > car2.speed) {\n      return false;\n    }", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "gc": "<|endoftext|>/*Return list with elements incremented by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = l.length - 1;\n  let res = new Array(i);\n  while (i--) {\n    res[i] = l[i] + 1;\n  }\n  return res;\n};\n\n/**\n * Returns true if all elements are less than or equal to `val`.\n * If `val` is `null` or `undefined`, returns false.\n * If `val` is an array, returns true if all elements are less than or equal to\n * `val[0]` and less than or equal to `val[1]`.\n * If `val` is a string, returns true if all elements are less than or equal to\n * `val[0]` and less than or equal to `val[1]`.\n */\nconst isLessThan = (val,...args) => {\n  if (val === null || val === undefined) {\n    return false;\n  }\n  if (Array.isArray(val)) {\n    return val.every((v) => isLessThan(v,...args));\n  }\n  if (typeof val ==='string') {\n    return val.split('').every((v) => isLessThan(v,...args));\n  }\n  return val < args[0] || val > args[1];\n};\n\n/**\n * Returns true if all elements are greater than or equal to `val`.\n * If `val` is `null` or `undefined`, returns false.\n * If `val` is an array, returns true if all elements are greater than or equal to\n * `val[0]` and greater than or equal to `val[1]`.\n * If `val` is a string, returns true if all elements are greater than or equal to\n * `val[0]` and greater than or equal to `val[1]`.\n */\nconst isGreaterThan = (val,...args) => {\n  if (val === null || val === undefined) {\n    return false;\n  }\n  if (Array.isArray(val)) {\n    return val.every((v) => isGreaterThan(v,...args));\n  }\n  if (typeof val ==='string') {\n    return val.split('').every((v) => isGreaterThan(v,...args));\n  }\n  return val > args[0] || val < args[1];\n};\n\n/**\n * Returns true if all elements are equal to `val`.\n * If `val` is `null` or `undefined`, returns false.\n * If `val` is an array, returns true if all elements are equal to `val[0]`.\n * If `val` is a string, returns true if all elements are equal to `val[0]`.\n */\nconst isEqual = (val,...args) => {\n  if (val === null || val === undefined) {\n    return false;\n  }\n  if (Array.isArray(val)) {\n    return val.every((v) => isEqual(v,...args));\n  }\n  if (typeof val ==='string') {\n    return val.split('').every((v) => isEqual(v,...args));\n  }\n  return val === args[0] || val === args[1];\n};\n\n/**\n * Returns true if all elements are greater than or equal to `val`.\n * If `val` is `null` or `undefined`, returns false.\n * If `val` is an array, returns true if all elements are greater than or equal to\n * `val[0]` and greater than or equal to `val[1]`.\n * If `val` is a string, returns true if all elements are greater than or equal to\n * `val[0]` and greater than or equal to `val[1]`.\n */\nconst isNotEqual = (val,...args) => {\n  if (val === null || val === undefined) {\n    return false;\n  }\n  if (Array.isArray(val)) {\n    return val.every((v) => isNotEqual(v,...args));\n  }\n  if (typeof val ==='string') {\n    return val.split('').every((v) => isNotEqual(v,...args));\n  }\n  return val < args[0] || val > args[1];\n};\n\n/**\n * Returns true if all elements are less than or equal to `val`.\n * If `val` is `null` or `undefined`, returns false.\n * If `val` is an array, returns true if all elements are less than or equal to\n * `val[0]` and less than or equal to `val[1]`.\n * If `val` is a string, returns true if all elements are less than or equal to\n * `val[0]` and less than or equal to `val[1]`.\n */\nconst isLessOrEqual = (val,...args) => {\n  if (val === null || val === undefined) {\n    return false;\n  }\n  if (Array.isArray(val)) {\n    return val.every((v) => isLessOrEqual(v,...args));\n  }\n  if (typeof val ==='string') {\n    return val.split('').every((v) => isLessOrEqual(v,...args));\n  }\n  return val < args[0] || val > args[1];\n};\n\n/**\n * Returns true if all elements are greater than or equal to `val`.\n * If `val` is `null` or `undefined`, returns false.\n * If `val` is an array, returns true if all elements are greater than or equal to\n * `val[0]` and greater than or equal to `val[1]`.\n * If `val` is a string, returns true if all elements are greater than or equal to\n * `val[0]` and greater than or equal to `val[1]`.\n */\nconst isGreaterOrEqual = (val,...args) => {\n  if (val === null || val === undefined) {\n    return false;\n  }\n  if (Array.isArray(val)) {\n    return val.every((v) => isGreaterOrEqual(v,...args));\n  }\n  if (typeof val ==='string') {\n    return val.split('').every((v) => isGreaterOrEqual(v,...args));\n  }\n  return val > args[0] || val < args[1];\n};\n\n/**\n * Returns true if all elements are equal to `val`.\n * If `val` is `null` or `undefined`, returns false.\n * If `val` is an array, returns true if all elements are equal to `val[0]`.\n * If `val` is a string, returns true if all elements are equal to `val[0]`.\n */\nconst isNotEqualOrEqual = (val,...args) => {\n  if (val === null || val === undefined) {\n    return false;\n  }\n  if (Array.isArray(val)) {\n    return val.every((v) => isNotEqualOrEqual(v,...args));\n  }\n  if (typeof val ==='string') {\n    return val.split('').every((v) => isNotEqualOrEqual(v,...args));\n  }\n  return val === args[0] || val === args[1];\n};\n\n/**\n * Returns true if all elements are less than or equal to `val`.\n * If `val` is `null` or `undefined`, returns false.\n * If `val` is an array, returns true if all elements are less than or equal to\n * `val[0]` and less than or equal to `val[1]`.\n * If `val` is a string, returns true if all elements are less than or equal to\n * `val[0]` and less than or equal to `val[1]`.\n */\nconst isLessOrEqualOrEqual = (val,...args) => {\n  if (val === null || val === undefined) {\n    return false;\n  }\n  if (Array.isArray(val)) {\n    return val.every((v) => isLessOrEqualOrEqual(v,...args));\n  }\n  if (typeof val ==='string') {\n    return val.split('').every((v) => isLessOrEqualOrEqual(v,...args));\n  }\n  return val < args[0] || val > args[1];\n};\n\n/**\n * Returns true if all elements are greater than or equal to `val`.\n * If `val` is `null` or `undefined`, returns false.\n * If `val` is an array, returns true if all elements are greater than or equal to\n * `val[0]` and greater than or equal to `val[1]`.\n * If `val` is a string, returns true if all elements are greater than or equal to\n * `val[0]` and greater than or equal to `val[1]`.\n */\nconst isGreaterOrEqualOrEqual = (val,...args) => {\n  if (val === null || val === undefined) {\n    return false;\n  }\n  if (Array.is", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/43", "prompt": "/*\n  apirSsumoTZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> apirSsumoTZero([1, 3, 5, 0])\n  false\n  >>> apirSsumoTZero([1, 3, -2, 1])\n  false\n  >>> apirSsumoTZero([1, 2, 3, 7])\n  false\n  >>> apirSsumoTZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoTZero([1])\n  false\n  */\nconst apirSsumoTZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "apirSsumoTZero", "gc": "<|endoftext|>/*\n  apirSsumoTZero takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to zero, and false otherwise.\n  >>> apirSsumoTZero([1, 3, 5, 0])\n  false\n  >>> apirSsumoTZero([1, 3, -2, 1])\n  false\n  >>> apirSsumoTZero([1, 2, 3, 7])\n  false\n  >>> apirSsumoTZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoTZero([1])\n  false\n  */\nconst apirSsumoTZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  apirSsumoTOne takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to one, and false otherwise.\n  >>> apirSsumoTOne([1, 3, 5, 0])\n  false\n  >>> apirSsumoTOne([1, 3, -2, 1])\n  false\n  >>> apirSsumoTOne([1, 2, 3, 7])\n  false\n  >>> apirSsumoTOne([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoTOne([1])\n  false\n  */\nconst apirSsumoTOne = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 1) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  apirSsumoTTwo takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to two, and false otherwise.\n  >>> apirSsumoTTwo([1, 3, 5, 0])\n  false\n  >>> apirSsumoTTwo([1, 3, -2, 1])\n  false\n  >>> apirSsumoTTwo([1, 2, 3, 7])\n  false\n  >>> apirSsumoTTwo([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoTTwo([1])\n  false\n  */\nconst apirSsumoTTwo = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 2) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  apirSsumoTThree takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to three, and false otherwise.\n  >>> apirSsumoTThree([1, 3, 5, 0])\n  false\n  >>> apirSsumoTThree([1, 3, -2, 1])\n  false\n  >>> apirSsumoTThree([1, 2, 3, 7])\n  false\n  >>> apirSsumoTThree([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoTThree([1])\n  false\n  */\nconst apirSsumoTThree = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 3) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  apirSsumoFour takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to four, and false otherwise.\n  >>> apirSsumoFour([1, 3, 5, 0])\n  false\n  >>> apirSsumoFour([1, 3, -2, 1])\n  false\n  >>> apirSsumoFour([1, 2, 3, 7])\n  false\n  >>> apirSsumoFour([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoFour([1])\n  false\n  */\nconst apirSsumoFour = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 4) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  apirSsumoFive takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to five, and false otherwise.\n  >>> apirSsumoFive([1, 3, 5, 0])\n  false\n  >>> apirSsumoFive([1, 3, -2, 1])\n  false\n  >>> apirSsumoFive([1, 2, 3, 7])\n  false\n  >>> apirSsumoFive([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoFive([1])\n  false\n  */\nconst apirSsumoFive = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 5) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  apirSsumoSix takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to six, and false otherwise.\n  >>> apirSsumoSix([1, 3, 5, 0])\n  false\n  >>> apirSsumoSix([1, 3, -2, 1])\n  false\n  >>> apirSsumoSix([1, 2, 3, 7])\n  false\n  >>> apirSsumoSix([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoSix([1])\n  false\n  */\nconst apirSsumoSix = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 6) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  apirSsumoSeven takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to seven, and false otherwise.\n  >>> apirSsumoSeven([1, 3, 5, 0])\n  false\n  >>> apirSsumoSeven([1, 3, -2, 1])\n  false\n  >>> apirSsumoSeven([1, 2, 3, 7])\n  false\n  >>> apirSsumoSeven([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoSeven([1])\n  false\n  */\nconst apirSsumoSeven = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 7) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  apirSsumoEight takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to eight, and false otherwise.\n  >>> apirSsumoEight([1, 3, 5, 0])\n  false\n  >>> apirSsumoEight([1, 3, -2, 1])\n  false\n  >>> apirSsumoEight([1, 2, 3, 7])\n  false\n  >>> apirSsumoEight([2, 4, -5, 3, 5, 7])\n  true\n  >>> apirSsumoEight([1])\n  false\n  */\nconst apirSsumoEight = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 8) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  apirSsumoNine takes a list of integers as an input.\n  it returns true if there are two distinct elements in the list that\n  sum to nine, and false otherwise.\n  >>> apirSsumoN", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "gc": "<|endoftext|>/*Change numerical base of input number x to base.\n  return string representation after the conversion.\n  base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  if (base === 10) {\n    return x.toString();\n  }\n  const digits = x.toString().split('');\n  const result = '';\n  for (let i = 0; i < digits.length; i++) {\n    const digit = digits[i];\n    if (digit === '0') {\n      continue;\n    }\n    const digitInt = parseInt(digit, base);\n    if (digitInt < 10) {\n      result += digitInt;\n    } else {\n      result += digitInt;\n      result += changeBase(digitInt, base);\n    }\n  }\n  return result;\n};\n\n/**\n * Convert string to hexadecimal representation\n */\nconst hexToBytes = (str) => {\n  const hex = str.replace(/[^0-9a-f]/gi, '');\n  const bytes = [];\n  for (let i = 0; i < hex.length; i += 2) {\n    bytes.push(parseInt(hex.substr(i, 2), 16));\n  }\n  return bytes;\n};\n\n/**\n * Convert byte array to hexadecimal representation\n */\nconst bytesToHex = (bytes) => {\n  const hex = [];\n  for (let i = 0; i < bytes.length; i++) {\n    hex.push(bytes[i].toString(16));\n  }\n  return hex.join(\"\");\n};\n\n/**\n * Convert hexadecimal to byte array\n */\nconst hexToBytes = (str) => {\n  const hex = str.replace(/[^0-9a-f]/gi, '');\n  const bytes = [];\n  for (let i = 0; i < hex.length; i += 2) {\n    bytes.push(parseInt(hex.substr(i, 2), 16));\n  }\n  return bytes;\n};\n\n/**\n * Convert byte array to hexadecimal representation\n */\nconst bytesToHex = (bytes) => {\n  const hex = [];\n  for (let i = 0; i < bytes.length; i++) {\n    hex.push(bytes[i].toString(16));\n  }\n  return hex.join(\"\");\n};\n\n/**\n * Convert byte array to decimal representation\n */\nconst bytesToDecimal = (bytes) => {\n  const decimal = [];\n  for (let i = 0; i < bytes.length; i++) {\n    decimal.push(bytes[i].toString(10));\n  }\n  return decimal.join(\"\");\n};\n\n/**\n * Convert decimal to byte array\n */\nconst decimalToBytes = (decimal) => {\n  const bytes = [];\n  for (let i = 0; i < decimal.length; i++) {\n    bytes.push(decimal[i].charCodeAt(0));\n  }\n  return bytes;\n};\n\n/**\n * Convert byte array to decimal representation\n */\nconst bytesToDecimal = (bytes) => {\n  const decimal = [];\n  for (let i = 0; i < bytes.length; i++) {\n    decimal.push(bytes[i].charCodeAt(0));\n  }\n  return decimal.join(\"\");\n};\n\n/**\n * Convert decimal to hexadecimal representation\n */\nconst decimalToHex = (decimal) => {\n  const hex = [];\n  for (let i = 0; i < decimal.length; i++) {\n    hex.push(decimal[i].toString(16));\n  }\n  return hex.join(\"\");\n};\n\n/**\n * Convert hexadecimal to decimal representation\n */\nconst hexToDecimal = (hex) => {\n  const decimal = [];\n  for (let i = 0; i < hex.length; i++) {\n    decimal.push(parseInt(hex.substr(i, 2), 16));\n  }\n  return decimal.join(\"\");\n};\n\n/**\n * Convert decimal to hexadecimal representation\n */\nconst decimalToHex = (decimal) => {\n  const hex = [];\n  for (let i = 0; i < decimal.length; i++) {\n    hex.push(decimal[i].toString(16));\n  }\n  return hex.join(\"\");\n};\n\n/**\n * Convert decimal to binary representation\n */\nconst decimalToBin = (decimal) => {\n  const bin = [];\n  for (let i = 0; i < decimal.length; i++) {\n    bin.push(decimal[i].toString(2));\n  }\n  return bin.join(\"\");\n};\n\n/**\n * Convert binary to decimal representation\n */\nconst binToDecimal = (bin) => {\n  const decimal = [];\n  for (let i = 0; i < bin.length; i++) {\n    decimal.push(parseInt(bin[i], 2));\n  }\n  return decimal.join(\"\");\n};\n\n/**\n * Convert decimal to binary representation\n */\nconst decimalToBin = (decimal) => {\n  const bin = [];\n  for (let i = 0; i < decimal.length; i++) {\n    bin.push(decimal[i].toString(2));\n  }\n  return bin.join(\"\");\n};\n\n/**\n * Convert binary to hexadecimal representation\n */\nconst binToHex = (bin) => {\n  const hex = [];\n  for (let i = 0; i < bin.length; i++) {\n    hex.push(bin[i].toString(16));\n  }\n  return hex.join(\"\");\n};\n\n/**\n * Convert hexadecimal to binary representation\n */\nconst hexToBin = (hex) => {\n  const bin = [];\n  for (let i = 0; i < hex.length; i++) {\n    bin.push(parseInt(hex.substr(i, 2), 16));\n  }\n  return bin.join(\"\");\n};\n\n/**\n * Convert hexadecimal to hexadecimal representation\n */\nconst hexToHex = (hex) => {\n  const hex = [];\n  for (let i = 0; i < hex.length; i++) {\n    hex.push(hex[i].toString(16));\n  }\n  return hex.join(\"\");\n};\n\n/**\n * Convert hexadecimal to decimal representation\n */\nconst hexToDecimal = (hex) => {\n  const decimal = [];\n  for (let i = 0; i < hex.length; i++) {\n    decimal.push(parseInt(hex.substr(i, 2), 16));\n  }\n  return decimal.join(\"\");\n};\n\n/**\n * Convert decimal to hexadecimal representation\n */\nconst decimalToHex = (decimal) => {\n  const hex = [];\n  for (let i = 0; i < decimal.length; i++) {\n    hex.push(decimal[i].toString(16));\n  }\n  return hex.join(\"\");\n};\n\n/**\n * Convert hexadecimal to binary representation\n */\nconst hexToBin = (hex) => {\n  const bin = [];\n  for (let i = 0; i < hex.length; i++) {\n    bin.push(parseInt(hex.substr(i, 2), 16));\n  }\n  return bin.join(\"\");\n};\n\n/**\n * Convert binary to hexadecimal representation\n */\nconst binToHex = (bin) => {\n  const hex = [];\n  for (let i = 0; i < bin.length; i++) {\n    hex.push(bin[i].toString(16));\n  }\n  return hex.join(\"\");\n};\n\n/**\n * Convert hexadecimal to hexadecimal representation\n */\nconst hexToHex = (hex) => {\n  const hex = [];\n  for (let i = 0; i < hex.length; i++) {\n    hex.push(hex[i].toString(16));\n  }\n  return hex.join(\"\");\n};\n\n/**\n * Convert hexadecimal to decimal representation\n */\nconst hexToDecimal = (hex) => {\n  const decimal = [];\n  for (let i = 0; i < hex.length; i++) {\n    decimal.push(parseInt(hex.substr(i, 2), 16));\n  }\n  return decimal.join(\"\");\n};\n\n/**\n * Convert decimal to hexadecimal representation\n */\nconst decimalToHex = (decimal) => {\n  const hex = [];\n  for (let i = 0; i < decimal.length; i++) {\n    hex.push(decimal[i].toString(16));\n  }\n  return hex.join(\"\");\n};\n\n/**\n * Convert hexadecimal to binary representation\n */\nconst hexToBin = (hex) => {\n  const bin = [];\n  for (let i = 0; i < hex.length; i++) {\n    bin.push(parseInt(hex.substr(i, 2), 16));\n  }\n  return bin.join(\"\");\n};\n\n/**\n * Convert binary to hexadecimal representation\n */\nconst binToHex = (bin) => {\n  const hex = [];\n  for (let i = 0; i < bin.length; i++) {\n    hex.push(bin[i].toString(16));\n  }\n  return hex.join(\"\");\n};\n\n/**\n * Convert hexadecimal to binary representation\n */\nconst hexToBin = (hex) => {\n  const bin = [];\n  for (let i = 0; i < hex.length; i++) {\n    bin.push(parseInt(hex.substr(i, 2), 16));\n  }\n  return bin.join(\"\");\n};\n\n/**\n * Convert binary to decimal representation\n */\nconst binToDecimal = (bin) => {\n  const decimal = [];\n  for (let i = 0; i < ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/45", "prompt": "/*Given length of a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "gc": "<|endoftext|>/*Given length of a side and high return area for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const area = h * h;\n  return area / Math.sqrt(a * a + h * h);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(3, 5)\n  1.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length of a side and low return area for a triangle.\n  >>> triangleArea(6, 5)\n  2.5\n  */\nconst triangleArea = (s, l) => {\n  const area = l * l;\n  return area / Math.sqrt(s * s + l * l);\n};\n\n/*Given length", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "gc": "<|endoftext|>/*The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fib4(0) -> 0\n  fib4(1) -> 0\n  fib4(2) -> 2\n  fib4(3) -> 0\n  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 0 and 1.\n  >>> fibonacci(6)\n  8\n  >>> fibonacci(7)\n  14\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 1 and 2.\n  >>> fibonacci(8)\n  13\n  >>> fibonacci(9)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 2 and 3.\n  >>> fibonacci(10)\n  34\n  >>> fibonacci(11)\n  55\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 3 and 4.\n  >>> fibonacci(12)\n  89\n  >>> fibonacci(13)\n  144\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 4 and 5.\n  >>> fibonacci(14)\n  233\n  >>> fibonacci(15)\n  377\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 5 and 6.\n  >>> fibonacci(16)\n  615\n  >>> fibonacci(17)\n  983\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 6 and 7.\n  >>> fibonacci(18)\n  1573\n  >>> fibonacci(19)\n  23307\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 7 and 8.\n  >>> fibonacci(20)\n  429657\n  >>> fibonacci(21)\n  832039\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 8 and 9.\n  >>> fibonacci(22)\n  233120\n  >>> fibonacci(23)\n  429341\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 9 and 10.\n  >>> fibonacci(24)\n  34359738368\n  >>> fibonacci(25)\n  62450948192\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 10 and 11.\n  >>> fibonacci(26)\n  34359738368\n  >>> fibonacci(27)\n  62450948192\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 11 and 12.\n  >>> fibonacci(28)\n  62450948192\n  >>> fibonacci(29)\n  34359738368\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 12 and 13.\n  >>> fibonacci(30)\n  62450948192\n  >>> fibonacci(31)\n  34359738368\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 13 and 14.\n  >>> fibonacci(32)\n  62450948192\n  >>> fibonacci(33)\n  34359738368\n  */\nconst fibonacci = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  Write a function to efficiently compute the n-th element of the Fibonacci sequence whose first two elements are 14 and 15.\n  >>> fibonacci(34)\n  62450948192\n  >>> fibonacci(35)\n  ", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "gc": "<|endoftext|>/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let n = l.length;\n  if (n % 2 === 0) return l[Math.floor(n / 2)];\n  let mid = Math.floor((n + 0.5) / 2);\n  return median(l.slice(0, mid)) + (l[mid]? median(l.slice(mid + 1)) : 'NaN');\n};\n\n/*Return mode of elements in the list l.\n  >>> mode([3, 1, 2, 4, 5])\n  3\n  >>> mode([-10, 4, 6, 1000, 10, 20])\n  4\n  >>> mode([-10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -10, 4, 6, 1000, 10, 20, -", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/48", "prompt": "/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "gc": "<|endoftext|>/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  Checks if given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  return text === text.split('').reverse().join('')\n}\n\n/*\n  ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "gc": "<|endoftext|>/*Return 2^n modulo p (be aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (n < 0 || p < 1) return 0;\n  if (p === 1) return 1;\n  if (p === 2) return 2;\n  if (p === 3) return 3;\n  if (p === 4) return 4;\n  if (p === 5) return 5;\n  if (p === 6) return 6;\n  if (p === 7) return 7;\n  if (p === 8) return 8;\n  if (p === 9) return 9;\n  if (p === 10) return 10;\n  if (p === 11) return 11;\n  if (p === 12) return 12;\n  if (p === 13) return 13;\n  if (p === 14) return 14;\n  if (p === 15) return 15;\n  if (p === 16) return 16;\n  if (p === 17) return 17;\n  if (p === 18) return 18;\n  if (p === 19) return 19;\n  if (p === 20) return 20;\n  if (p === 21) return 21;\n  if (p === 22) return 22;\n  if (p === 23) return 23;\n  if (p === 24) return 24;\n  if (p === 25) return 25;\n  if (p === 26) return 26;\n  if (p === 27) return 27;\n  if (p === 28) return 28;\n  if (p === 29) return 29;\n  if (p === 30) return 30;\n  if (p === 31) return 31;\n  if (p === 32) return 32;\n  if (p === 33) return 33;\n  if (p === 34) return 34;\n  if (p === 35) return 35;\n  if (p === 36) return 36;\n  if (p === 37) return 37;\n  if (p === 38) return 38;\n  if (p === 39) return 39;\n  if (p === 40) return 40;\n  if (p === 41) return 41;\n  if (p === 42) return 42;\n  if (p === 43) return 43;\n  if (p === 44) return 44;\n  if (p === 45) return 45;\n  if (p === 46) return 46;\n  if (p === 47) return 47;\n  if (p === 48) return 48;\n  if (p === 49) return 49;\n  if (p === 50) return 50;\n  if (p === 51) return 51;\n  if (p === 52) return 52;\n  if (p === 53) return 53;\n  if (p === 54) return 54;\n  if (p === 55) return 55;\n  if (p === 56) return 56;\n  if (p === 57) return 57;\n  if (p === 58) return 58;\n  if (p === 59) return 59;\n  if (p === 60) return 60;\n  if (p === 61) return 61;\n  if (p === 62) return 62;\n  if (p === 63) return 63;\n  if (p === 64) return 64;\n  if (p === 65) return 65;\n  if (p === 66) return 66;\n  if (p === 67) return 67;\n  if (p === 68) return 68;\n  if (p === 69) return 69;\n  if (p === 70) return 70;\n  if (p === 71) return 71;\n  if (p === 72) return 72;\n  if (p === 73) return 73;\n  if (p === 74) return 74;\n  if (p === 75) return 75;\n  if (p === 76) return 76;\n  if (p === 77) return 77;\n  if (p === 78) return 78;\n  if (p === 79) return 79;\n  if (p === 80) return 80;\n  if (p === 81) return 81;\n  if (p === 82) return 82;\n  if (p === 83) return 83;\n  if (p === 84) return 84;\n  if (p === 85) return 85;\n  if (p === 86) return 86;\n  if (p === 87) return 87;\n  if (p === 88) return 88;\n  if (p === 89) return 89;\n  if (p === 90) return 90;\n  if (p === 91) return 91;\n  if (p === 92) return 92;\n  if (p === 93) return 93;\n  if (p === 94) return 94;\n  if (p === 95) return 95;\n  if (p === 96) return 96;\n  if (p === 97) return 97;\n  if (p === 98) return 98;\n  if (p === 99) return 99;\n  if (p === 100) return 100;\n  if (p === 101) return 101;\n  if (p === 102) return 102;\n  if (p === 103) return 103;\n  if (p === 104) return 104;\n  if (p === 105) return 105;\n  if (p === 106) return 106;\n  if (p === 107) return 107;\n  if (p === 108) return 108;\n  if (p === 109) return 109;\n  if (p === 110) return 110;\n  if (p === 111) return 111;\n  if (p === 112) return 112;\n  if (p === 113) return 113;\n  if (p === 114) return 114;\n  if (p === 115) return 115;\n  if (p === 116) return 116;\n  if (p === 117) return 117;\n  if (p === 118) return 118;\n  if (p === 119) return 119;\n  if (p === 120) return 120;\n  if (p === 121) return 121;\n  if (p === 122) return 122;\n  if (p === 123) return 123;\n  if (p === 124) return 124;\n  if (p === 125) return 125;\n  if (p === 126) return 126;\n  if (p === 127) return 127;\n  if (p === 128) return 128;\n  if (p === 129) return 129;\n  if (p === 130) return 130;\n  if (p === 131) return 131;\n  if (p === 132) return 132;\n  if (p === 133) return 133;\n  if (p === 134) return 134;\n  if (p === 135) return 135;\n  if (p === 136) return 136;\n  if (p === 137) return 137;\n  if (p === 138) return 138;\n  if (p === 139) return 139;\n  if (p === 140) return 140;\n  if (p === 141) return 141;\n  if (p === 142) return 142;\n  if (p === 143) return 143;\n  if (p === 144) return 144;\n  if (p === 145) return 145;\n  if (p === 146) return 146;\n  if (p === 147) return 147;\n  if (p === 148) return 148;\n  if (p === 149) return 149;\n  if (p === 150) return 150;\n  if (p === 151) return 151;\n  if (p === 152) return 152;\n  if (p === 153) return 153;\n  if (p === 154) return 154;\n  if (p === 155) return 155;\n  if (p === 156) return 156;\n  if (p === 157) return 157;\n  if (p === 158) return 158;\n  if (p === 159) return 159;\n  if (p === 160) return 160;\n  if (p === 161) return 161;\n  if (p === 162) return 162;\n  if (p === 163) return 163;\n  if (p === 164) return 164;\n  if (p === 165) return 165;\n  if (p === 166) return 166;\n  if (p === 167) return 167;\n  if (p === 168) return 168;\n  if (p === 169) return 169;\n  if (p === 170) return 170;\n  if (p === 171) return 171;\n  if (p === 172) return 172;\n  if (p === 173) return 173;\n  if (p === 174) return 174;\n  if (p === 175) return 175;\n  if (p === 176) return 176;\n  if (p === 177) return 177;\n  if (p === 178) return 178;\n  if (p === 179) return 179;\n  if (p === 180) return 180;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> interpserse([], 4)\n  []\n  >>> interpserse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst interpserse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "interpserse", "gc": "<|endoftext|>/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> interpserse([], 4)\n  []\n  >>> interpserse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst interpserse = (numbers, delimeter) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < numbers.length) {\n    if (numbers[i]!== delimeter) {\n      result.push(numbers[i])\n      i++\n    } else {\n      result.push(numbers[i])\n      j++\n      if (j === 2) {\n        result.push(delimeter)\n        j = 0\n      }\n    }\n  }\n  return result\n}\n\n// Given a list of numbers, return the list of numbers in sorted order\nconst sortNumbers = (numbers) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < numbers.length) {\n    if (numbers[i] < numbers[j]) {\n      result.push(numbers[i])\n      i++\n    } else {\n      result.push(numbers[j])\n      j++\n      if (j === numbers.length) {\n        result.push(numbers[i])\n        j = 0\n      }\n    }\n  }\n  return result\n}\n\n// Given a list of numbers, return the list of numbers in reverse sorted order\nconst reverseSortNumbers = (numbers) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < numbers.length) {\n    if (numbers[i] > numbers[j]) {\n      result.push(numbers[i])\n      i++\n    } else {\n      result.push(numbers[j])\n      j++\n      if (j === numbers.length) {\n        result.push(numbers[i])\n        j = 0\n      }\n    }\n  }\n  return result\n}\n\n// Given a list of numbers, return the list of numbers in reverse sorted order with gaps\nconst reverseSortNumbersWithGaps = (numbers) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < numbers.length) {\n    if (numbers[i] > numbers[j]) {\n      result.push(numbers[i])\n      i++\n    } else {\n      result.push(numbers[j])\n      j++\n      if (j === numbers.length) {\n        result.push(numbers[i])\n        j = 0\n      }\n    }\n  }\n  return result\n}\n\n// Given a list of numbers, return the list of numbers in reverse sorted order with gaps and a number 'delimeter'\nconst reverseSortNumbersWithGapsAndDelimeter = (numbers, delimeter) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < numbers.length) {\n    if (numbers[i] > numbers[j]) {\n      result.push(numbers[i])\n      i++\n    } else {\n      result.push(numbers[j])\n      j++\n      if (j === numbers.length) {\n        result.push(numbers[i])\n        j = 0\n      }\n    }\n  }\n  return result\n}\n\n// Given a list of numbers, return the list of numbers in reverse sorted order with gaps and a number 'delimeter' and a number 'gap'\nconst reverseSortNumbersWithGapsAndDelimeterAndGap = (numbers, delimeter, gap) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < numbers.length) {\n    if (numbers[i] > numbers[j]) {\n      result.push(numbers[i])\n      i++\n    } else {\n      result.push(numbers[j])\n      j++\n      if (j === numbers.length) {\n        result.push(numbers[i])\n        j = 0\n      }\n    }\n  }\n  return result\n}\n\n// Given a list of numbers, return the list of numbers in reverse sorted order with gaps and a number 'delimeter' and a number 'gap' and a number 'delimeter'\nconst reverseSortNumbersWithGapsAndDelimeterAndGapAndDelimeter = (numbers, delimeter, gap, delimeter2) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < numbers.length) {\n    if (numbers[i] > numbers[j]) {\n      result.push(numbers[i])\n      i++\n    } else {\n      result.push(numbers[j])\n      j++\n      if (j === numbers.length) {\n        result.push(numbers[i])\n        j = 0\n      }\n    }\n  }\n  return result\n}\n\n// Given a list of numbers, return the list of numbers in reverse sorted order with gaps and a number 'delimeter' and a number 'gap' and a number 'delimeter' and a number 'delimeter2'\nconst reverseSortNumbersWithGapsAndDelimeterAndGapAndDelimeter2 = (numbers, delimeter, gap, delimeter2, delimeter3) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < numbers.length) {\n    if (numbers[i] > numbers[j]) {\n      result.push(numbers[i])\n      i++\n    } else {\n      result.push(numbers[j])\n      j++\n      if (j === numbers.length) {\n        result.push(numbers[i])\n        j = 0\n      }\n    }\n  }\n  return result\n}\n\n// Given a list of numbers, return the list of numbers in reverse sorted order with gaps and a number 'delimeter' and a number 'gap' and a number 'delimeter' and a number 'delimeter2' and a number 'delimeter3'\nconst reverseSortNumbersWithGapsAndDelimeterAndGapAndDelimeter2 = (numbers, delimeter, gap, delimeter2, delimeter3, delimeter4) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < numbers.length) {\n    if (numbers[i] > numbers[j]) {\n      result.push(numbers[i])\n      i++\n    } else {\n      result.push(numbers[j])\n      j++\n      if (j === numbers.length) {\n        result.push(numbers[i])\n        j = 0\n      }\n    }\n  }\n  return result\n}\n\n// Given a list of numbers, return the list of numbers in reverse sorted order with gaps and a number 'delimeter' and a number 'gap' and a number 'delimeter' and a number 'delimeter2' and a number 'delimeter3' and a number 'delimeter4'\nconst reverseSortNumbersWithGapsAndDelimeterAndGapAndDelimeter2 = (numbers, delimeter, gap, delimeter2, delimeter3, delimeter4, delimeter5) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < numbers.length) {\n    if (numbers[i] > numbers[j]) {\n      result.push(numbers[i])\n      i++\n    } else {\n      result.push(numbers[j])\n      j++\n      if (j === numbers.length) {\n        result.push(numbers[i])\n        j = 0\n      }\n    }\n  }\n  return result\n}\n\n// Given a list of numbers, return the list of numbers in reverse sorted order with gaps and a number 'delimeter' and a number 'gap' and a number 'delimeter' and a number 'delimeter2' and a number 'delimeter3' and a number 'delimeter4' and a number 'delimeter5'\nconst reverseSortNumbersWithGapsAndDelimeterAndGapAndDelimeter2 = (numbers, delimeter, gap, delimeter2, delimeter3, delimeter4, delimeter5, delimeter6) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < numbers.length) {\n    if (numbers[i] > numbers[j]) {\n      result.push(numbers[i])\n      i++\n    } else {\n      result.push(numbers[j])\n      j++\n      if (j === numbers.length) {\n        result.push(numbers[i])\n        j = 0\n      }\n    }\n  }\n  return result\n}\n\n// Given a list of numbers, return the list of numbers in reverse sorted order with gaps and a number 'delimeter' and a number 'gap' and a number 'delimeter' and a number 'delimeter2' and a number 'delimeter3' and a number 'delimeter4' and a number 'delimeter5' and a number 'delimeter6'\nconst reverseSortNumbersWithGapsAndDelimeterAndGapAndDelimeter2 = (numbers, delimeter, gap, delimeter2, delimeter3, delimeter4, delimeter5, delimeter6, delimeter7) => {\n  const result = []\n  let i = 0\n  let j = 0\n  while (i < numbers.length) {\n    if (numbers[i] > numbers[j]) {\n      result.push(numbers[i])\n      i++\n    } else {", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodSehift", "gc": "<|endoftext|>/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodSehift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  remoevVowels is a function that takes string and returns string without vowels.\n  >>> remoevVowels('')\n  ''\n  >>> remoevVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> remoevVowels('abcdef')\n  'bcdf'\n  >>> remoevVowels('aaaaa')\n  ''\n  >>> remoevVowels('aaBAA')\n  'B'\n  >>> remoevVowels('zbcd')\n  'zbcd'\n  */\nconst remoevVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "remoevVowels", "gc": "<|endoftext|>/*\n  remoevVowels is a function that takes string and returns string without vowels.\n  >>> remoevVowels('')\n  ''\n  >>> remoevVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> remoevVowels('abcdef')\n  'bcdf'\n  >>> remoevVowels('aaaaa')\n  ''\n  >>> remoevVowels('aaBAA')\n  'B'\n  >>> remoevVowels('zbcd')\n  'zbcd'\n  */\nconst remoevVowels = (text) => {\n  let vowels = text.split('')\n  let newText = text\n  for (let i = 0; i < vowels.length; i++) {\n    if (vowels[i] === 'a' || vowels[i] === 'e' || vowels[i] === 'i' || vowels[i] === 'o' || vowels[i] === 'u') {\n      newText = newText.replace(vowels[i], '');\n    }\n  }\n  return newText;\n}\n\n/*\n  removePunctuation is a function that takes string and returns string without punctuation.\n  >>> removePunctuation('')\n  ''\n  >>> removePunctuation(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removePunctuation('abcdef')\n  'abcdef'\n  >>> removePunctuation('aaaaa')\n  ''\n  >>> removePunctuation('aaBAA')\n  'B'\n  >>> removePunctuation('zbcd')\n  'zbcd'\n  */\nconst removePunctuation = (text) => {\n  let punctuation = text.split('')\n  let newText = text\n  for (let i = 0; i < punctuation.length; i++) {\n    if (punctuation[i] === '.' || punctuation[i] === '!' || punctuation[i] === '?' || punctuation[i] === '(' || punctuation[i] === '[' || punctuation[i] === ']' || punctuation[i] === '{' || punctuation[i] === '}' || punctuation[i] === '|' || punctuation[i] === '~' || punctuation[i] === '/' || punctuation[i] === '\"' || punctuation[i] === '\\'' || punctuation[i] === '<' || punctuation[i] === '>' || punctuation[i] === '&' || punctuation[i] === '|' || punctuation[i] === '$' || punctuation[i] === '%' || punctuation[i] === '^' || punctuation[i] === '&' || punctuation[i] === '|' || punctuation[i] === '*' || punctuation[i] === '(' || punctuation[i] === ')' || punctuation[i] === '{' || punctuation[i] === '}' || punctuation[i] === '~' || punctuation[i] === '/' || punctuation[i] === '\"' || punctuation[i] === '\\'' || punctuation[i] === '<' || punctuation[i] === '>' || punctuation[i] === '&' || punctuation[i] === '|' || punctuation[i] === '$' || punctuation[i] === '%' || punctuation[i] === '^' || punctuation[i] === '&' || punctuation[i] === '|' || punctuation[i] === '*' || punctuation[i] === '(' || punctuation[i] === ')' || punctuation[i] === '{' || punctuation[i] === '}' || punctuation[i] === '~' || punctuation[i] === '/' || punctuation[i] === '\"' || punctuation[i] === '\\'' || punctuation[i] === '<' || punctuation[i] === '>' || punctuation[i] === '&' || punctuation[i] === '|' || punctuation[i] === '$' || punctuation[i] === '%' || punctuation[i] === '^' || punctuation[i] === '&' || punctuation[i] === '|' || punctuation[i] === '*' || punctuation[i] === '(' || punctuation[i] === ')' || punctuation[i] === '{' || punctuation[i] === '}' || punctuation[i] === '~' || punctuation[i] === '/' || punctuation[i] === '\"' || punctuation[i] === '\\'' || punctuation[i] === '<' || punctuation[i] === '>' || punctuation[i] === '&' || punctuation[i] === '|' || punctuation[i] === '$' || punctuation[i] === '%' || punctuation[i] === '^' || punctuation[i] === '&' || punctuation[i] === '|' || punctuation[i] === '*' || punctuation[i] === '(' || punctuation[i] === ')' || punctuation[i] === '{' || punctuation[i] === '}' || punctuation[i] === '~' || punctuation[i] === '/' || punctuation[i] === '\"' || punctuation[i] === '\\'' || punctuation[i] === '<' || punctuation[i] === '>' || punctuation[i] === '&' || punctuation[i] === '|' || punctuation[i] === '$' || punctuation[i] === '%' || punctuation[i] === '^' || punctuation[i] === '&' || punctuation[i] === '|' || punctuation[i] === '*' || punctuation[i] === '(' || punctuation[i] === ')' || punctuation[i] === '{' || punctuation[i] === '}' || punctuation[i] === '~' || punctuation[i] === '/' || punctuation[i] === '\"' || punctuation[i] === '\\'' || punctuation[i] === '<' || punctuation[i] === '>' || punctuation[i] === '&' || punctuation[i] === '|' || punctuation[i] === '$' || punctuation[i] === '%' || punctuation[i] === '^' || punctuation[i] === '&' || punctuation[i] === '|' || punctuation[i] === '*' || punctuation[i] === '(' || punctuation[i] === ')' || punctuation[i] === '{' || punctuation[i] === '}' || punctuation[i] === '~' || punctuation[i] === '/' || punctuation[i] === '\"' || punctuation[i] === '\\'' || punctuation[i] === '<' || punctuation[i] === '>' || punctuation[i] === '&' || punctuation[i] === '|' || punctuation[i] === '$' || punctuation[i] === '%' || punctuation[i] === '^' || punctuation[i] === '&' || punctuation[i] === '|' || punctuation[i] === '*' || punctuation[i] === '(' || punctuation[i] === ')' || punctuation[i] === '{' || punctuation[i] === '}' || punctuation[i] === '~' || punctuation[i] === '/' || punctuation[i] === '\"' || punctuation[i] === '\\'' || punctuation[i] === '<' || punctuation[i] === '>' || punctuation[i] === '&' || punctuation[i] === '|' || punctuation[i] === '$' || punctuation[i] === '%' || punctuation[i] === '^' || punctuation[i] === '&' || punctuation[i] === '|' || punctuation[i] === '*' || punctuation[i] === '(' || punctuation[i] === ')' || punctuation[i] === '{' || punctuation[i] === '}' || punctuation[i] === '~' || punctuation[i] === '/' || punctuation[i] === '\"' || punctuation[i] === '\\'' || punctuation[i] === '<' || punctuation[i] === '>' || punctuation[i] === '&' || punctuation[i] === '|' || punctuation[i] === '$' || punctuation[i] === '%' || punctuation[i] === '^' || punctuation[i] === '&' || punctuation[i] === '|' || punctuation[i] === '*' || punctuation[i] === '(' || punctuation[i] === ')' || punctuation[i] === '{' || punctuation[i] === '}' || punctuation[i] === '~' || punctuation[i] === '/' || punctuation[i] === '\"' || punctuation[i] === '\\'' || punctuation[i] === '<' || punctuation[i] === '>' || punctuation[i] === '&' || punctuation[i] === '|' || punctuation[i] === '$' || punctuation[i] === '%' || punctuation[i] === '^' || punctuation[i] === '&' || punctuation[i] === '|' || punctuation[i] === '*' || punctuation[i] === '(' || punctuation[i] === ')' || punctuation[i] === '{' || punctuation[i] === '}' || punctuation[i] === '~' || punctuation[i] === '/' || punctuation[i] === '\"' || punctuation[i] === '\\'' || punctuation[i] === '<' || punctuation[i] === '>' || punctuation[i] === '&' || punctuation[i] === '|' || punctuation[i] === '$' || punctuation[i] === '%' || punctuation[i] === '^' || punctuation[i] === '&' || punctu", "passed": 1, "run_status": 0, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all numbers in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "gc": "<|endoftext|>/*Return true if all numbers in the list l are below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  return l.every(n => n < t);\n};\n\n/**\n * Return true if all numbers in the list l are above threshold t.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  true\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst aboveThreshold = (l, t) => {\n  return l.every(n => n > t);\n};\n\n/**\n * Return true if all numbers in the list l are equal to t.\n  >>> equal([1, 2, 4, 10], 100)\n  true\n  >>> equal([1, 20, 4, 10], 5)\n  false\n  */\nconst equal = (l, t) => {\n  return l.length === t.length &&\n    l.every((n, i) => n === t[i]);\n};\n\n/**\n * Return true if all numbers in the list l are divisible by t.\n  >>> divisibleBy([1, 2, 4, 10], 100)\n  true\n  >>> divisibleBy([1, 20, 4, 10], 5)\n  false\n  */\nconst divisibleBy = (l, t) => {\n  return l.length === t.length &&\n    l.every((n, i) => n % t === 0);\n};\n\n/**\n * Return true if all numbers in the list l are prime numbers.\n  >>> prime([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n  true\n  >>> prime([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]);\n  false\n  */\nconst prime = (l) => {\n  return l.every(n => isPrime(n));\n};\n\n/**\n * Return true if all numbers in the list l are composite numbers.\n  >>> composite([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]);\n  true\n  >>> composite([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 63", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "gc": "<|endoftext|>/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y\n}\n\n/*\n  >>> subtract(2, 3)\n  1\n  >>> subtract(5, 7)\n  -2\n  */\nconst subtract = (x, y) => {\n  return x - y\n}\n\n/*\n  >>> multiply(2, 3)\n  2\n  >>> multiply(5, 7)\n  10\n  */\nconst multiply = (a, b) => {\n  return a * b\n}\n\n/*\n  >>> divide(2, 3)\n  2\n  >>> divide(5, 7)\n  4\n  */\nconst divide = (x, y) => {\n  return x / y\n}\n\n/*\n  >>> modulo(2, 3)\n  2\n  >>> modulo(5, 7)\n  0\n  */\nconst modulo = (x, y) => {\n  return x % y\n}\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  8\n  */\nconst power = (a, b) => {\n  return a ** b\n}\n\n/*\n  >>> sqrt(2)\n  2\n  >>> sqrt(5)\n  8\n  */\nconst sqrt = x => {\n  return Math.sqrt(x)\n}\n\n/*\n  >>> inverse(sqrt(2))\n  2\n  >>> inverse(sqrt(5))\n  5\n  */\nconst inverse = x => {\n  return 1 / x\n}\n\n/*\n  >>> square(2)\n  2\n  >>> square(5)\n  25\n  */\nconst square = x => {\n  return x * x\n}\n\n/*\n  >>> cube(2)\n  6\n  >>> cube(5)\n  120\n  */\nconst cube = x => {\n  return x * x * x\n}\n\n/*\n  >>> cubeRoot(2)\n  4\n  >>> cubeRoot(5)\n  24\n  */\nconst cubeRoot = x => {\n  return Math.sqrt(x * x)\n}\n\n/*\n  >>> cubeRoot(cube(5))\n  24\n  >>> cubeRoot(cube(120))\n  120\n  */\nconst cubeRootInv = x => {\n  return 1 / cubeRoot(x)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst pow = (base, exponent) => {\n  return base ** exponent\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n/*\n  >>> pow(10, 2)\n  10\n  >>> pow(10, 5)\n  100\n  */\nconst powInvInv = base => {\n  return 1 / pow(base, 2)\n}\n\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "gc": "<|endoftext|>/*\n  Check if two words have the same characters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  if (s0 === s1) {\n    return true\n  }\n  if (s0 === null || s1 === null) {\n    return false\n  }\n  if (s0.length!== s1.length) {\n    return false\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Check if two words have the same letters.\n  >>> sameLetters('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameLetters('abcd', 'dddddddabc')\n  true\n  >>> sameLetters('dddddddabc', 'abcd')\n  true\n  >>> sameLetters('eabcd', 'dddddddabc')\n  false\n  >>> sameLetters('abcd', 'dddddddabce')\n  false\n  >>> sameLetters('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameLetters = (s0, s1) => {\n  if (s0 === s1) {\n    return true\n  }\n  if (s0 === null || s1 === null) {\n    return false\n  }\n  if (s0.length!== s1.length) {\n    return false\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Check if two words have the same numbers.\n  >>> sameNumbers('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameNumbers('abcd', 'dddddddabc')\n  true\n  >>> sameNumbers('dddddddabc', 'abcd')\n  true\n  >>> sameNumbers('eabcd', 'dddddddabc')\n  false\n  >>> sameNumbers('abcd', 'dddddddabce')\n  false\n  >>> sameNumbers('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameNumbers = (s0, s1) => {\n  if (s0 === s1) {\n    return true\n  }\n  if (s0 === null || s1 === null) {\n    return false\n  }\n  if (s0.length!== s1.length) {\n    return false\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Check if two words have the same uppercase letters.\n  >>> sameUpperCases('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameUpperCases('abcd', 'dddddddabc')\n  true\n  >>> sameUpperCases('dddddddabc', 'abcd')\n  true\n  >>> sameUpperCases('eabcd', 'dddddddabc')\n  false\n  >>> sameUpperCases('abcd', 'dddddddabce')\n  false\n  >>> sameUpperCases('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameUpperCases = (s0, s1) => {\n  if (s0 === s1) {\n    return true\n  }\n  if (s0 === null || s1 === null) {\n    return false\n  }\n  if (s0.length!== s1.length) {\n    return false\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Check if two words have the same lowercase letters.\n  >>> sameLowerCases('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameLowerCases('abcd', 'dddddddabc')\n  true\n  >>> sameLowerCases('dddddddabc', 'abcd')\n  true\n  >>> sameLowerCases('eabcd', 'dddddddabc')\n  false\n  >>> sameLowerCases('abcd', 'dddddddabce')\n  false\n  >>> sameLowerCases('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameLowerCases = (s0, s1) => {\n  if (s0 === s1) {\n    return true\n  }\n  if (s0 === null || s1 === null) {\n    return false\n  }\n  if (s0.length!== s1.length) {\n    return false\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Check if two words have the same symbols.\n  >>> sameSymbols('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameSymbols('abcd', 'dddddddabc')\n  true\n  >>> sameSymbols('dddddddabc', 'abcd')\n  true\n  >>> sameSymbols('eabcd', 'dddddddabc')\n  false\n  >>> sameSymbols('abcd', 'dddddddabce')\n  false\n  >>> sameSymbols('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameSymbols = (s0, s1) => {\n  if (s0 === s1) {\n    return true\n  }\n  if (s0 === null || s1 === null) {\n    return false\n  }\n  if (s0.length!== s1.length) {\n    return false\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Check if two words have the same special characters.\n  >>> sameSpecialChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameSpecialChars('abcd', 'dddddddabc')\n  true\n  >>> sameSpecialChars('dddddddabc', 'abcd')\n  true\n  >>> sameSpecialChars('eabcd', 'dddddddabc')\n  false\n  >>> sameSpecialChars('abcd', 'dddddddabce')\n  false\n  >>> sameSpecialChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameSpecialChars = (s0, s1) => {\n  if (s0 === s1) {\n    return true\n  }\n  if (s0 === null || s1 === null) {\n    return false\n  }\n  if (s0.length!== s1.length) {\n    return false\n  }\n  for (let i = 0; i < s0.length; i++) {\n    if (s0[i]!== s1[i]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Check if two words have the same special letters.\n  >>> sameSpecialLetters('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameSpecialLetters('abcd', 'dddddddabc')\n  true\n  >>> sameSpecialLetters('dddddddabc', 'abcd')\n  true\n  >>> sameSpecialLetters('eabcd', 'dddddddabc')\n  false\n  >>> sameSpecialLetters('abcd', 'dddddddabce')\n  false\n  >>> sameSpecialLetters('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameSpecialLetters = (s0, s1) => {\n  if (s0 === s1) {\n    return true\n  }\n  if (s0 ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "gc": "<|endoftext|>/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n <= 1) return 1;\n  return fib(n - 1) + fib(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n  55\n  >>> fibonacci(1)\n  1\n  >>> fibonacci(8)\n  21\n  */\nconst fibonacci = (n) => {\n  if (n <= 1) return 1;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n};\n\n/*\n  >>> fibonacci(10)\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketnig(\"<\")\n  false\n  >>> correctBracketnig(\"<>\")\n  false\n  >>> correctBracketnig(\"<<><>>\")\n  false\n  >>> correctBracketnig(\"><<>\")\n  false\n  */\nconst correctBracketnig = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketnig", "gc": "<|endoftext|>/* brackets is a string of \"<\" and \">\".\n  return false if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketnig(\"<\")\n  false\n  >>> correctBracketnig(\"<>\")\n  false\n  >>> correctBracketnig(\"<<><>>\")\n  false\n  >>> correctBracketnig(\"><<>\")\n  false\n  */\nconst correctBracketnig = (brackets) => {\n  const openingBrackets = brackets.split(\">\");\n  const closingBrackets = brackets.split(\"<\");\n  return openingBrackets.every((openingBracket) => {\n    return closingBrackets.every((closingBracket) => {\n      return openingBracket === closingBracket;\n    });\n  });\n};\n\n/**\n * Returns true if a word is a valid Python identifier.\n *\n * >>> isPythonIdentifier(\"_\")\n * true\n * >>> isPythonIdentifier(\"__\")\n * false\n * >>> isPythonIdentifier(\"__foo__\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar\")\n * false\n * >>> isPythonIdentifier(\"__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar__foo_bar", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/57", "prompt": "/*Return true is list elements are montoonically increasing or decreasing.\n  >>> montoonic([1, 2, 4, 20])\n  true\n  >>> montoonic([1, 20, 4, 10])\n  false\n  >>> montoonic([4, 1, 0, -10])\n  true\n  */\nconst montoonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "montoonic", "gc": "<|endoftext|>/*Return true is list elements are montoonically increasing or decreasing.\n  >>> montoonic([1, 2, 4, 20])\n  true\n  >>> montoonic([1, 20, 4, 10])\n  false\n  >>> montoonic([4, 1, 0, -10])\n  true\n  */\nconst montoonic = (l) => {\n  let n = l.length;\n  let m = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = l.reverse();\n  while (i < n) {\n    while (j < n) {\n      if (l[j] < l[j + 1]) {\n        m++;\n      }\n      j++;\n    }\n    i++;\n  }\n  return m === 1;\n};\n\n/*\n  >>> montoonic([4, 1, 0, -10])\n  true\n  >>> montoonic([4, 1, 0, -10])\n  false\n  >>> montoonic([4, 1, 0, -10])\n  true\n*/\nconst montoNic = (l) => {\n  let n = l.length;\n  let m = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = l.reverse();\n  while (i < n) {\n    while (j < n) {\n      if (l[j] < l[j + 1]) {\n        m++;\n      }\n      j++;\n    }\n    i++;\n  }\n  return m === 1;\n};\n\n/*\n  >>> montoNic([4, 1, 0, -10])\n  true\n  >>> montoNic([4, 1, 0, -10])\n  false\n  >>> montoNic([4, 1, 0, -10])\n  true\n*/\nconst montoNicReverse = (l) => {\n  let n = l.length;\n  let m = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = l.reverse();\n  while (i < n) {\n    while (j < n) {\n      if (l[j] < l[j + 1]) {\n        m++;\n      }\n      j++;\n    }\n    i++;\n  }\n  return m === 1;\n};\n\n/*\n  >>> montoNicReverse([4, 1, 0, -10])\n  true\n  >>> montoNicReverse([4, 1, 0, -10])\n  false\n  >>> montoNicReverse([4, 1, 0, -10])\n  true\n*/\nconst montoNicReversed = (l) => {\n  let n = l.length;\n  let m = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = l.reverse();\n  while (i < n) {\n    while (j < n) {\n      if (l[j] < l[j + 1]) {\n        m++;\n      }\n      j++;\n    }\n    i++;\n  }\n  return m === 1;\n};\n\n/*\n  >>> montoNicReversed([4, 1, 0, -10])\n  true\n  >>> montoNicReversed([4, 1, 0, -10])\n  false\n  >>> montoNicReversed([4, 1, 0, -10])\n  true\n*/\nconst montoNicReversedReverse = (l) => {\n  let n = l.length;\n  let m = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = l.reverse();\n  while (i < n) {\n    while (j < n) {\n      if (l[j] < l[j + 1]) {\n        m++;\n      }\n      j++;\n    }\n    i++;\n  }\n  return m === 1;\n};\n\n/*\n  >>> montoNicReversedReverse([4, 1, 0, -10])\n  true\n  >>> montoNicReversedReverse([4, 1, 0, -10])\n  false\n  >>> montoNicReversedReverse([4, 1, 0, -10])\n  true\n*/\nconst montoNicReversedReversed = (l) => {\n  let n = l.length;\n  let m = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = l.reverse();\n  while (i < n) {\n    while (j < n) {\n      if (l[j] < l[j + 1]) {\n        m++;\n      }\n      j++;\n    }\n    i++;\n  }\n  return m === 1;\n};\n\n/*\n  >>> montoNicReversedReversed([4, 1, 0, -10])\n  true\n  >>> montoNicReversedReversed([4, 1, 0, -10])\n  false\n  >>> montoNicReversedReversed([4, 1, 0, -10])\n  true\n*/\nconst montoNicReversedReversedReverse = (l) => {\n  let n = l.length;\n  let m = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = l.reverse();\n  while (i < n) {\n    while (j < n) {\n      if (l[j] < l[j + 1]) {\n        m++;\n      }\n      j++;\n    }\n    i++;\n  }\n  return m === 1;\n};\n\n/*\n  >>> montoNicReversedReversedReverse([4, 1, 0, -10])\n  true\n  >>> montoNicReversedReversedReverse([4, 1, 0, -10])\n  false\n  >>> montoNicReversedReversedReverse([4, 1, 0, -10])\n  true\n*/\nconst montoNicReversedReversedReversed = (l) => {\n  let n = l.length;\n  let m = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = l.reverse();\n  while (i < n) {\n    while (j < n) {\n      if (l[j] < l[j + 1]) {\n        m++;\n      }\n      j++;\n    }\n    i++;\n  }\n  return m === 1;\n};\n\n/*\n  >>> montoNicReversedReversedReverse([4, 1, 0, -10])\n  true\n  >>> montoNicReversedReversedReverse([4, 1, 0, -10])\n  false\n  >>> montoNicReversedReversedReverse([4, 1, 0, -10])\n  true\n*/\nconst montoNicReversedReversedReversedReverse = (l) => {\n  let n = l.length;\n  let m = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = l.reverse();\n  while (i < n) {\n    while (j < n) {\n      if (l[j] < l[j + 1]) {\n        m++;\n      }\n      j++;\n    }\n    i++;\n  }\n  return m === 1;\n};\n\n/*\n  >>> montoNicReversedReversedReversedReverse([4, 1, 0, -10])\n  true\n  >>> montoNicReversedReversedReversedReverse([4, 1, 0, -10])\n  false\n  >>> montoNicReversedReversedReversedReverse([4, 1, 0, -10])\n  true\n*/\nconst montoNicReversedReversedReversedReversed = (l) => {\n  let n = l.length;\n  let m = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = l.reverse();\n  while (i < n) {\n    while (j < n) {\n      if (l[j] < l[j + 1]) {\n        m++;\n      }\n      j++;\n    }\n    i++;\n  }\n  return m === 1;\n};\n\n/*\n  >>> montoNicReversedReversedReversedReverse([4, 1, 0, -10])\n  true\n  >>> montoNicReversedReversedReversedReversedReverse([4, 1, 0, -10])\n  false\n  >>> montoNicReversedReversedReversedReversedReverse([4, 1, 0, -10])\n  true\n*/\nconst montoNicReversedReversedReversedReversedReverse = (l) => {\n  let n = l.length;\n  let m = 1;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = l.reverse();\n  while (i < n) {\n    while (j < n) {\n      if (l[j] < l[j + 1]) {\n        m++;\n      }\n      j++;\n    }\n    i++;\n  }\n  return m === 1;\n};\n\n/*\n  >>> montoN", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/58", "prompt": "/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "gc": "<|endoftext|>/*Return sorted unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const common = new Set();\n  for (const element of set1.values()) {\n    if (set2.has(element)) {\n      common.add(element);\n    }\n  }\n  return common;\n};\n\n/**\n * Returns true if the given array contains all elements of the given\n * array.\n *\n * >>> contains([1, 2, 3, 4], [1, 2, 3, 4])\n * true\n * >>> contains([1, 2, 3, 4], [1, 2, 3])\n * false\n *\n */\nconst contains = (arr1, arr2) => {\n  return arr1.every(element => arr2.includes(element));\n};\n\n/**\n * Returns true if the given array contains any element of the given\n * array.\n *\n * >>> contains([1, 2, 3, 4], [1, 2, 3])\n * true\n * >>> contains([1, 2, 3, 4], [1, 2, 4, 5])\n * false\n *\n */\nconst containsIn = (arr1, arr2) => {\n  return arr1.some(element => arr2.includes(element));\n};\n\n/**\n * Returns true if the given array contains all elements of the given\n * array.\n *\n * >>> containsIn([1, 2, 3, 4], [1, 2, 3, 4])\n * true\n * >>> containsIn([1, 2, 3, 4], [1, 2, 3])\n * false\n *\n */\nconst containsAll = (arr1, arr2) => {\n  return arr1.every(element => arr2.includes(element) && arr2.includes(element));\n};\n\n/**\n * Returns true if the given array contains any element of the given\n * array.\n *\n * >>> containsAll([1, 2, 3, 4], [1, 2, 3])\n * true\n * >>> containsAll([1, 2, 3, 4], [1, 2, 4, 5])\n * false\n *\n */\nconst containsAllIn = (arr1, arr2) => {\n  return arr1.some(element => arr2.includes(element) && arr2.includes(element));\n};\n\n/**\n * Returns true if the given array contains all elements of the given\n * array.\n *\n * >>> containsAllIn([1, 2, 3, 4], [1, 2, 3, 4])\n * true\n * >>> containsAllIn([1, 2, 3, 4], [1, 2, 3])\n * false\n *\n */\nconst containsAllUnique = (arr1, arr2) => {\n  return arr1.every(element => arr2.includes(element) && arr2.includes(element) && arr2.includes(element));\n};\n\n/**\n * Returns true if the given array contains any element of the given\n * array.\n *\n * >>> containsAllUnique([1, 2, 3, 4], [1, 2, 3, 4])\n * true\n * >>> containsAllUnique([1, 2, 3, 4], [1, 2, 3])\n * false\n *\n */\nconst containsAllUniqueIn = (arr1, arr2) => {\n  return arr1.some(element => arr2.includes(element) && arr2.includes(element) && arr2.includes(element));\n};\n\n/**\n * Returns true if the given array contains all elements of the given\n * array.\n *\n * >>> containsAllUniqueIn([1, 2, 3, 4], [1, 2, 3, 4])\n * true\n * >>> containsAllUniqueIn([1, 2, 3, 4], [1, 2, 3])\n * false\n *\n */\nconst containsAllUniqueUnique = (arr1, arr2) => {\n  return arr1.every(element => arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element));\n};\n\n/**\n * Returns true if the given array contains all elements of the given\n * array.\n *\n * >>> containsAllUniqueUniqueIn([1, 2, 3, 4], [1, 2, 3, 4])\n * true\n * >>> containsAllUniqueUniqueIn([1, 2, 3, 4], [1, 2, 3])\n * false\n *\n */\nconst containsAllUniqueUniqueIn = (arr1, arr2) => {\n  return arr1.some(element => arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element));\n};\n\n/**\n * Returns true if the given array contains all elements of the given\n * array.\n *\n * >>> containsAllUniqueUniqueIn([1, 2, 3, 4], [1, 2, 3, 4])\n * true\n * >>> containsAllUniqueUniqueIn([1, 2, 3, 4], [1, 2, 3])\n * false\n *\n */\nconst containsAllUniqueUniqueIn = (arr1, arr2) => {\n  return arr1.every(element => arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element));\n};\n\n/**\n * Returns true if the given array contains all elements of the given\n * array.\n *\n * >>> containsAllUniqueUniqueIn([1, 2, 3, 4], [1, 2, 3, 4])\n * true\n * >>> containsAllUniqueUniqueIn([1, 2, 3, 4], [1, 2, 3])\n * false\n *\n */\nconst containsAllUniqueUniqueIn = (arr1, arr2) => {\n  return arr1.every(element => arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element));\n};\n\n/**\n * Returns true if the given array contains all elements of the given\n * array.\n *\n * >>> containsAllUniqueUniqueIn([1, 2, 3, 4], [1, 2, 3, 4])\n * true\n * >>> containsAllUniqueUniqueIn([1, 2, 3, 4], [1, 2, 3])\n * false\n *\n */\nconst containsAllUniqueUniqueIn = (arr1, arr2) => {\n  return arr1.every(element => arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element));\n};\n\n/**\n * Returns true if the given array contains all elements of the given\n * array.\n *\n * >>> containsAllUniqueUniqueIn([1, 2, 3, 4], [1, 2, 3, 4])\n * true\n * >>> containsAllUniqueUniqueIn([1, 2, 3, 4], [1, 2, 3])\n * false\n *\n */\nconst containsAllUniqueUniqueIn = (arr1, arr2) => {\n  return arr1.every(element => arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element) && arr2.includes(element", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largetsPrimeFactor(13195)\n  29\n  >>> largetsPrimeFactor(2048)\n  2\n  */\nconst largetsPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largetsPrimeFactor", "gc": "<|endoftext|>/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largetsPrimeFactor(13195)\n  29\n  >>> largetsPrimeFactor(2048)\n  2\n  */\nconst largetsPrimeFactor = (n) => {\n  let i = 2;\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % i === 0) {\n      primeFactor = i;\n    }\n    i++;\n  }\n  return primeFactor;\n};\n\n/*\n  Given a number n, return true if n is a prime number.\n  >>> isPrime(13195)\n  true\n  >>> isPrime(2048)\n  false\n  */\nconst isPrime = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let i = 2;\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n    primeFactor = largetsPrimeFactor(n);\n  }\n  return primeFactor === 1;\n};\n\n/*\n  Given a number n, return true if n is a composite number.\n  >>> isComposite(13195)\n  true\n  >>> isComposite(2048)\n  false\n  */\nconst isComposite = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let i = 2;\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n    primeFactor = largetsPrimeFactor(n);\n  }\n  return primeFactor === 2;\n};\n\n/*\n  Given a number n, return true if n is a composite number with factors less than or equal to n.\n  >>> isCompositeWithFactors(13195)\n  true\n  >>> isCompositeWithFactors(2048)\n  false\n  */\nconst isCompositeWithFactors = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let i = 2;\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n    primeFactor = largetsPrimeFactor(n);\n  }\n  return primeFactor <= n;\n};\n\n/*\n  Given a number n, return true if n is a composite number with factors greater than n.\n  >>> isCompositeWithFactorsGreaterThan(13195)\n  true\n  >>> isCompositeWithFactorsGreaterThan(2048)\n  false\n  */\nconst isCompositeWithFactorsGreaterThan = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let i = 2;\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n    primeFactor = largetsPrimeFactor(n);\n  }\n  return primeFactor > n;\n};\n\n/*\n  Given a number n, return true if n is a composite number with factors equal to n.\n  >>> isCompositeWithFactorsEqual(13195)\n  true\n  >>> isCompositeWithFactorsEqual(2048)\n  false\n  */\nconst isCompositeWithFactorsEqual = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let i = 2;\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n    primeFactor = largetsPrimeFactor(n);\n  }\n  return primeFactor === n;\n};\n\n/*\n  Given a number n, return true if n is a composite number with factors less than or equal to n and greater than n.\n  >>> isCompositeWithFactorsLessThanOrEqualTo(13195)\n  true\n  >>> isCompositeWithFactorsLessThanOrEqualTo(2048)\n  false\n  */\nconst isCompositeWithFactorsLessThanOrEqualTo = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let i = 2;\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n    primeFactor = largetsPrimeFactor(n);\n  }\n  return primeFactor <= n && primeFactor > n;\n};\n\n/*\n  Given a number n, return true if n is a composite number with factors greater than n and equal to n.\n  >>> isCompositeWithFactorsGreaterThanOrEqualTo(13195)\n  true\n  >>> isCompositeWithFactorsGreaterThanOrEqualTo(2048)\n  false\n  */\nconst isCompositeWithFactorsGreaterThanOrEqualTo = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let i = 2;\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n    primeFactor = largetsPrimeFactor(n);\n  }\n  return primeFactor > n && primeFactor === n;\n};\n\n/*\n  Given a number n, return true if n is a composite number with factors equal to n and less than n.\n  >>> isCompositeWithFactorsEqualAndLessThan(13195)\n  true\n  >>> isCompositeWithFactorsEqualAndLessThan(2048)\n  false\n  */\nconst isCompositeWithFactorsEqualAndLessThan = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let i = 2;\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n    primeFactor = largetsPrimeFactor(n);\n  }\n  return primeFactor === n && primeFactor < n;\n};\n\n/*\n  Given a number n, return true if n is a composite number with factors less than n and greater than n.\n  >>> isCompositeWithFactorsLessThanOrEqualToAndGreaterThan(13195)\n  true\n  >>> isCompositeWithFactorsLessThanOrEqualToAndGreaterThan(2048)\n  false\n  */\nconst isCompositeWithFactorsLessThanOrEqualToAndGreaterThan = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let i = 2;\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n    primeFactor = largetsPrimeFactor(n);\n  }\n  return primeFactor < n && primeFactor > n;\n};\n\n/*\n  Given a number n, return true if n is a composite number with factors greater than n and equal to n.\n  >>> isCompositeWithFactorsGreaterThanOrEqualToAndEqualTo(13195)\n  true\n  >>> isCompositeWithFactorsGreaterThanOrEqualToAndEqualTo(2048)\n  false\n  */\nconst isCompositeWithFactorsGreaterThanOrEqualToAndEqualTo = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let i = 2;\n  let primeFactor = 1;\n  while (primeFactor <= n) {\n    if (n % i === 0) {\n      return false;\n    }\n    i++;\n    primeFactor = largetsPrimeFactor(n);\n  }\n  return primeFactor > n && primeFactor === n;\n};\n\n/*\n  Given a number n, return true if n is a composite number with factors equal to n and less than n.\n  >>> isCompositeWithFactorsEqualAndLessThanOrEqualTo(13195)\n  true\n  >>> isCompositeWithFactorsEqualAndLessThanOrEqualTo(2048)\n  false\n  */\nconst isCompositeWithFactorsEqualAndLessThanOrEqualTo = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  let ", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 3, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/6", "prompt": "/* Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n  For each of the group, output the deepest level of nesting of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNetsedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNetsedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNetsedParens", "gc": "<|endoftext|>/* Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n  For each of the group, output the deepest level of nesting of parentheses.\n  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n  >>> parseNetsedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNetsedParens = (paren_string) => {\n  const paren_groups = paren_string.split(/\\s+/g);\n  const result = [];\n  let level = 0;\n  let paren_count = 0;\n  for (let i = 0; i < paren_groups.length; i++) {\n    const group = paren_groups[i];\n    if (group === '()') {\n      paren_count++;\n    } else if (group === '(') {\n      level++;\n    } else if (group === ')') {\n      level--;\n      if (level === 0) {\n        result.push(level);\n        level = 0;\n      }\n    }\n  }\n  return result;\n};\n\n// Given a string, return an array containing all possible permutations of its characters.\n// E.g.\n// parsePermutations('abc') returns [ 'a', 'b', 'c', 'ab', 'ba', 'ca', 'bac', 'bca', 'cba' ]\nconst parsePermutations = (string) => {\n  const result = [];\n  let current_char = '';\n  let current_permutation = '';\n  for (let i = 0; i < string.length; i++) {\n    current_permutation += string[i];\n    if (current_permutation === 'a') {\n      current_char = 'a';\n    } else if (current_permutation === 'b') {\n      current_char = 'b';\n    } else if (current_permutation === 'c') {\n      current_char = 'c';\n    } else if (current_permutation === 'ab') {\n      current_char = 'a';\n      current_permutation += 'b';\n    } else if (current_permutation === 'ba') {\n      current_char = 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n    } else if (current_permutation === 'ca') {\n      current_char = 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n    } else if (current_permutation === 'bca') {\n      current_char = 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n    } else if (current_permutation === 'cba') {\n      current_char = 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n    } else if (current_permutation === 'abca') {\n      current_char = 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n    } else if (current_permutation === 'baca') {\n      current_char = 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n    } else if (current_permutation === 'caab') {\n      current_char = 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n    } else if (current_permutation === 'bcaab') {\n      current_char = 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += 'a';\n      current_permutation += 'b';\n      current_permutation += 'c';\n      current_permutation += '", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "gc": "<|endoftext|>/*sumToN is a function that sums numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all the numbers from 1 to n.\n  >>> sumOfAllNumbers(30)\n  465\n  >>> sumOfAllNumbers(100)\n  5050\n  >>> sumOfAllNumbers(5)\n  15\n  >>> sumOfAllNumbers(10)\n  55\n  >>> sumOfAllNumbers(1)\n  1\n  */\nconst sumOfAllNumbers = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all the numbers from 1 to n.\n  >>> sumOfAllNumbers2(30)\n  465\n  >>> sumOfAllNumbers2(100)\n  5050\n  >>> sumOfAllNumbers2(5)\n  15\n  >>> sumOfAllNumbers2(10)\n  55\n  >>> sumOfAllNumbers2(1)\n  1\n  */\nconst sumOfAllNumbers2 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all the numbers from 1 to n.\n  >>> sumOfAllNumbers3(30)\n  465\n  >>> sumOfAllNumbers3(100)\n  5050\n  >>> sumOfAllNumbers3(5)\n  15\n  >>> sumOfAllNumbers3(10)\n  55\n  >>> sumOfAllNumbers3(1)\n  1\n  */\nconst sumOfAllNumbers3 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all the numbers from 1 to n.\n  >>> sumOfAllNumbers4(30)\n  465\n  >>> sumOfAllNumbers4(100)\n  5050\n  >>> sumOfAllNumbers4(5)\n  15\n  >>> sumOfAllNumbers4(10)\n  55\n  >>> sumOfAllNumbers4(1)\n  1\n  */\nconst sumOfAllNumbers4 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all the numbers from 1 to n.\n  >>> sumOfAllNumbers5(30)\n  465\n  >>> sumOfAllNumbers5(100)\n  5050\n  >>> sumOfAllNumbers5(5)\n  15\n  >>> sumOfAllNumbers5(10)\n  55\n  >>> sumOfAllNumbers5(1)\n  1\n  */\nconst sumOfAllNumbers5 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all the numbers from 1 to n.\n  >>> sumOfAllNumbers6(30)\n  465\n  >>> sumOfAllNumbers6(100)\n  5050\n  >>> sumOfAllNumbers6(5)\n  15\n  >>> sumOfAllNumbers6(10)\n  55\n  >>> sumOfAllNumbers6(1)\n  1\n  */\nconst sumOfAllNumbers6 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all the numbers from 1 to n.\n  >>> sumOfAllNumbers7(30)\n  465\n  >>> sumOfAllNumbers7(100)\n  5050\n  >>> sumOfAllNumbers7(5)\n  15\n  >>> sumOfAllNumbers7(10)\n  55\n  >>> sumOfAllNumbers7(1)\n  1\n  */\nconst sumOfAllNumbers7 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all the numbers from 1 to n.\n  >>> sumOfAllNumbers8(30)\n  465\n  >>> sumOfAllNumbers8(100)\n  5050\n  >>> sumOfAllNumbers8(5)\n  15\n  >>> sumOfAllNumbers8(10)\n  55\n  >>> sumOfAllNumbers8(1)\n  1\n  */\nconst sumOfAllNumbers8 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all the numbers from 1 to n.\n  >>> sumOfAllNumbers9(30)\n  465\n  >>> sumOfAllNumbers9(100)\n  5050\n  >>> sumOfAllNumbers9(5)\n  15\n  >>> sumOfAllNumbers9(10)\n  55\n  >>> sumOfAllNumbers9(1)\n  1\n  */\nconst sumOfAllNumbers9 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all the numbers from 1 to n.\n  >>> sumOfAllNumbers10(30)\n  465\n  >>> sumOfAllNumbers10(100)\n  5050\n  >>> sumOfAllNumbers10(5)\n  15\n  >>> sumOfAllNumbers10(10)\n  55\n  >>> sumOfAllNumbers10(1)\n  1\n  */\nconst sumOfAllNumbers10 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all the numbers from 1 to n.\n  >>> sumOfAllNumbers11(30)\n  465\n  >>> sumOfAllNumbers11(100)\n  5050\n  >>> sumOfAllNumbers11(5)\n  15\n  >>> sumOfAllNumbers11(10)\n  55\n  >>> sumOfAllNumbers11(1)\n  1\n  */\nconst sumOfAllNumbers11 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all the numbers from 1 to n.\n  >>> sumOfAllNumbers12(30)\n  465\n  >>> sumOfAllNumbers12(100)\n  5050\n  >>> sumOfAllNumbers12(5)\n  15\n  >>> sumOfAllNumbers12(10)\n  55\n  >>> sumOfAllNumbers12(1)\n  1\n  */\nconst sumOfAllNumbers12 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all the numbers from 1 to n.\n  >>> sumOfAllNumbers13(30)\n  465\n  >>> sumOfAllNumbers13", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketnig(\"(\")\n  false\n  >>> correctBracketnig(\"()\")\n  true\n  >>> correctBracketnig(\"(()())\")\n  true\n  >>> correctBracketnig(\")(()\")\n  false\n  */\nconst correctBracketnig = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketnig", "gc": "<|endoftext|>/* brackets is a string of \"(\" and \")\".\n  return true if every opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketnig(\"(\")\n  false\n  >>> correctBracketnig(\"()\")\n  true\n  >>> correctBracketnig(\"(()())\")\n  true\n  >>> correctBracketnig(\")(()\")\n  false\n  */\nconst correctBracketnig = (brackets) => {\n  const openingBrackets = brackets.split('(');\n  const closingBrackets = brackets.split(')');\n\n  return openingBrackets.every(\n    (openingBracket) => closingBrackets.includes(openingBracket)\n  );\n};\n\n/**\n * Returns true if a string is valid for use as a function name.\n *\n * Valid function names are alphanumeric and underscore, and must start with a letter\n * and contain only letters, numbers, and underscores. Letters are only allowed as\n * the first character of a function name.\n *\n * >>> isValidFunctionName(\"foo\")\n * true\n * >>> isValidFunctionName(\"foo_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> isValidFunctionName(\"foo_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar_bar\")\n * false\n * >>> ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "gc": "<|endoftext|>/* xs represent coefficients of a polynomial.\n  xs[0] + xs[1] * x + xs[2] * x^2 +....\n   Return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  let x = 0;\n  let y = 0;\n  let n = xs.length;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let ws;\n  let w;\n  let w2;\n  let w1;\n  let w3;\n  let w4;\n  let w5;\n  let w6;\n  let w7;\n  let w8;\n  let w9;\n  let w10;\n  let w11;\n  let w12;\n  let w13;\n  let w14;\n  let w15;\n  let w16;\n  let w17;\n  let w18;\n  let w19;\n  let w20;\n  let w21;\n  let w22;\n  let w23;\n  let w24;\n  let w25;\n  let w26;\n  let w27;\n  let w28;\n  let w29;\n  let w30;\n  let w31;\n  let w32;\n  let w33;\n  let w34;\n  let w35;\n  let w36;\n  let w37;\n  let w38;\n  let w39;\n  let w40;\n  let w41;\n  let w42;\n  let w43;\n  let w44;\n  let w45;\n  let w46;\n  let w47;\n  let w48;\n  let w49;\n  let w50;\n  let w51;\n  let w52;\n  let w53;\n  let w54;\n  let w55;\n  let w56;\n  let w57;\n  let w58;\n  let w59;\n  let w60;\n  let w61;\n  let w62;\n  let w63;\n  let w64;\n  let w65;\n  let w66;\n  let w67;\n  let w68;\n  let w69;\n  let w70;\n  let w71;\n  let w72;\n  let w73;\n  let w74;\n  let w75;\n  let w76;\n  let w77;\n  let w78;\n  let w79;\n  let w80;\n  let w81;\n  let w82;\n  let w83;\n  let w84;\n  let w85;\n  let w86;\n  let w87;\n  let w88;\n  let w89;\n  let w90;\n  let w91;\n  let w92;\n  let w93;\n  let w94;\n  let w95;\n  let w96;\n  let w97;\n  let w98;\n  let w99;\n  let w100;\n  let w101;\n  let w102;\n  let w103;\n  let w104;\n  let w105;\n  let w106;\n  let w107;\n  let w108;\n  let w109;\n  let w110;\n  let w111;\n  let w112;\n  let w113;\n  let w114;\n  let w115;\n  let w116;\n  let w117;\n  let w118;\n  let w119;\n  let w120;\n  let w121;\n  let w122;\n  let w123;\n  let w124;\n  let w125;\n  let w126;\n  let w127;\n  let w128;\n  let w129;\n  let w130;\n  let w131;\n  let w132;\n  let w133;\n  let w134;\n  let w135;\n  let w136;\n  let w137;\n  let w138;\n  let w139;\n  let w140;\n  let w141;\n  let w142;\n  let w143;\n  let w144;\n  let w145;\n  let w146;\n  let w147;\n  let w148;\n  let w149;\n  let w150;\n  let w151;\n  let w152;\n  let w153;\n  let w154;\n  let w155;\n  let w156;\n  let w157;\n  let w158;\n  let w159;\n  let w160;\n  let w161;\n  let w162;\n  let w163;\n  let w164;\n  let w165;\n  let w166;\n  let w167;\n  let w168;\n  let w169;\n  let w170;\n  let w171;\n  let w172;\n  let w173;\n  let w174;\n  let w175;\n  let w176;\n  let w177;\n  let w178;\n  let w179;\n  let w180;\n  let w181;\n  let w182;\n  let w183;\n  let w184;\n  let w185;\n  let w186;\n  let w187;\n  let w188;\n  let w189;\n  let w190;\n  let w191;\n  let w192;\n  let w193;\n  let w194;\n  let w195;\n  let w196;\n  let w197;\n  let w198;\n  let w199;\n  let w200;\n  let w201;\n  let w202;\n  let w203;\n  let w204;\n  let w205;\n  let w206;\n  let w207;\n  let w208;\n  let w209;\n  let w210;\n  let w211;\n  let w212;\n  let w213;\n  let w214;\n  let w215;\n  let w216;\n  let w217;\n  let w218;\n  let w219;\n  let w220;\n  let w221;\n  let w222;\n  let w223;\n  let w224;\n  let w225;\n  let w226;\n  let w227;\n  let w228;\n  let w229;\n  let w230;\n  let w231;\n  let w232;\n  let w233;\n  let w234;\n  let w235;\n  let w236;\n  let w237;\n  let w238;\n  let w239;\n  let w240;\n  let w241;\n  let w242;\n  let w243;\n  let w244;\n  let w245;\n  let w246;\n  let w247;\n  let w248;\n  let w249;\n  let w250;\n  let w251;\n  let w252;\n  let w253;\n  let w254;\n  let w255;\n  let w256;\n  let w257;\n  let w258;\n  let w259;\n  let w260;\n  let w261;\n  let w262;\n  let w263;\n  let w264;\n  let w265;\n  let w266;\n  let w267;\n  let w268;\n  let w269;\n  let w270;\n  let w271;\n  let w272;\n  let w273;\n  let w274;\n  let w275;\n  let w276;\n  let w277;\n  let w278;\n  let w279;\n  let w280;\n  let w281;\n  let w282;\n  let w283;\n  let w284;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "gc": "<|endoftext|>/*The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n  fibfib(0) == 0\n  fibfib(1) == 0\n  fibfib(2) == 1\n  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n  Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n  Write a function to compute the Fibonacci sequence of the given number.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  5\n  >>> fibfib(8)\n  34\n  */\nconst fibfib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2);\n};\n\n/*\n  Write a function to compute the Fibonacci sequence of the given number.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  5\n  >>> fibfib(8)\n  34\n  */\nconst fibfib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2);\n};\n\n/*\n  Write a function to compute the Fibonacci sequence of the given number.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  5\n  >>> fibfib(8)\n  34\n  */\nconst fibfib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2);\n};\n\n/*\n  Write a function to compute the Fibonacci sequence of the given number.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  5\n  >>> fibfib(8)\n  34\n  */\nconst fibfib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2);\n};\n\n/*\n  Write a function to compute the Fibonacci sequence of the given number.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  5\n  >>> fibfib(8)\n  34\n  */\nconst fibfib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2);\n};\n\n/*\n  Write a function to compute the Fibonacci sequence of the given number.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  5\n  >>> fibfib(8)\n  34\n  */\nconst fibfib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2);\n};\n\n/*\n  Write a function to compute the Fibonacci sequence of the given number.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  5\n  >>> fibfib(8)\n  34\n  */\nconst fibfib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2);\n};\n\n/*\n  Write a function to compute the Fibonacci sequence of the given number.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  5\n  >>> fibfib(8)\n  34\n  */\nconst fibfib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2);\n};\n\n/*\n  Write a function to compute the Fibonacci sequence of the given number.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  5\n  >>> fibfib(8)\n  34\n  */\nconst fibfib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2);\n};\n\n/*\n  Write a function to compute the Fibonacci sequence of the given number.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  5\n  >>> fibfib(8)\n  34\n  */\nconst fibfib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2);\n};\n\n/*\n  Write a function to compute the Fibonacci sequence of the given number.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  5\n  >>> fibfib(8)\n  34\n  */\nconst fibfib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2);\n};\n\n/*\n  Write a function to compute the Fibonacci sequence of the given number.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  5\n  >>> fibfib(8)\n  34\n  */\nconst fibfib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2);\n};\n\n/*\n  Write a function to compute the Fibonacci sequence of the given number.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  5\n  >>> fibfib(8)\n  34\n  */\nconst fibfib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2);\n};\n\n/*\n  Write a function to compute the Fibonacci sequence of the given number.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  5\n  >>> fibfib(8)\n  34\n  */\nconst fibfib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2);\n};\n\n/*\n  Write a function to compute the Fibonacci sequence of the given number.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  5\n  >>> fibfib(8)\n  34\n  */\nconst fibfib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2);\n};\n\n/*\n  Write a function to compute the Fibonacci sequence of the given number.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  5\n  >>> fibfib(8)\n  34\n  */\nconst fibfib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2);\n};\n\n/*\n  Write a function to compute the Fibonacci sequence of the given number.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  5\n  >>> fibfib(8)\n  34\n  */\nconst fibfib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2);\n};\n\n/*\n  Write a function to compute the Fibonacci sequence of the given number.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  5\n  >>> fibfib(8)\n  34\n  */\nconst fibfib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  return fibfib(n-1) + fibfib(n-2);\n};\n\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/64", "prompt": "/*Write a function vowelsConut which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsConut(\"abcde\")\n  2\n  >>> vowelsConut(\"ACEDY\")\n  3\n  */\nconst vowelsConut = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsConut", "gc": "<|endoftext|>/*Write a function vowelsConut which takes a string representing\n  a word as input and returns the number of vowels in the string.\n  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n  vowel, but only when it is at the end of the given word.\n\n  Example:\n  >>> vowelsConut(\"abcde\")\n  2\n  >>> vowelsConut(\"ACEDY\")\n  3\n  */\nconst vowelsConut = (s) => {\n  let vowels = 0;\n  let vowelsEnd = 0;\n  let vowelsStart = 0;\n  let vowelsEndStart = 0;\n  let vowelsEndEnd = 0;\n  let vowelsStartEnd = 0;\n  let vowelsEndStartEnd = 0;\n  let vowelsEndEndEnd = 0;\n  let vowelsEndStartEndEnd = 0;\n  let vowelsEndEndEndEnd = 0;\n  let vowelsEndStartEndEndEnd = 0;\n  let vowelsEndEndEndEnd = 0;\n  let vowelsEndStartEndEndEnd = 0;\n  let vowelsEndEndEndEndEnd = 0;\n  let vowelsEndStartEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEnd = 0;\n  let vowelsEndStartEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEndEnd = 0;\n  let vowelsEndStartEndEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEndEndEnd = 0;\n  let vowelsEndStartEndEndEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsEndStartEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsEndStartEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0;\n  let vowelsEndStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> circularSihft(12, 1)\n  \"21\"\n  >>> circularSihft(12, 2)\n  \"12\"\n  */\nconst circularSihft = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularSihft", "gc": "<|endoftext|>/*Circular shift the digits of the integer x, shift the digits right by shift\n  and return the result as a string.\n  If shift > number of digits, return digits reversed.\n  >>> circularSihft(12, 1)\n  \"21\"\n  >>> circularSihft(12, 2)\n  \"12\"\n  */\nconst circularSihft = (x, shift) => {\n  const digits = x.toString(10).split('');\n  let reversed = digits.reverse();\n  reversed.splice(reversed.length - shift, shift);\n  return reversed.join('');\n};\n\n/*\n  Convert an integer to a string in base 10.\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"23\"\n  >>> toBase10(123)\n  \"", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/66", "prompt": "/*Task\n  Write a function that takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "gc": "<|endoftext|>/*Task\n  Write a function that takes a string as input and returns the sum of the upper characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 97;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the lower characters only'\n  ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSumLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 65;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case alphabets'\n  ASCII codes.\n\n  Examples:\n      digitSumLower(\"\") => 0\n      digitSumLower(\"abAB\") => 131\n      digitSumLower(\"abcCd\") => 67\n      digitSumLower(\"helloE\") => 69\n      digitSumLower(\"woArBld\") => 131\n      digitSumLower(\"aAaaaXa\") => 153\n  */\nconst digitSumLower(s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 97;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case alphabets'\n  ASCII codes.\n\n  Examples:\n      digitSumUpper(\"\") => 0\n      digitSumUpper(\"abAB\") => 131\n      digitSumUpper(\"abcCd\") => 67\n      digitSumUpper(\"helloE\") => 69\n      digitSumUpper(\"woArBld\") => 131\n      digitSumUpper(\"aAaaaXa\") => 153\n  */\nconst digitSumUpper(s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 65;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case alphabets'\n  ASCII codes.\n\n  Examples:\n      digitSumLower(\"\") => 0\n      digitSumLower(\"abAB\") => 131\n      digitSumLower(\"abcCd\") => 67\n      digitSumLower(\"helloE\") => 69\n      digitSumLower(\"woArBld\") => 131\n      digitSumLower(\"aAaaaXa\") => 153\n  */\nconst digitSumLower(s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 97;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case alphabets'\n  ASCII codes.\n\n  Examples:\n      digitSumUpper(\"\") => 0\n      digitSumUpper(\"abAB\") => 131\n      digitSumUpper(\"abcCd\") => 67\n      digitSumUpper(\"helloE\") => 69\n      digitSumUpper(\"woArBld\") => 131\n      digitSumUpper(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 65;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case alphabets'\n  ASCII codes.\n\n  Examples:\n      digitSumLower(\"\") => 0\n      digitSumLower(\"abAB\") => 131\n      digitSumLower(\"abcCd\") => 67\n      digitSumLower(\"helloE\") => 69\n      digitSumLower(\"woArBld\") => 131\n      digitSumLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLower(s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 97;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case alphabets'\n  ASCII codes.\n\n  Examples:\n      digitSumUpper(\"\") => 0\n      digitSumUpper(\"abAB\") => 131\n      digitSumUpper(\"abcCd\") => 67\n      digitSumUpper(\"helloE\") => 69\n      digitSumUpper(\"woArBld\") => 131\n      digitSumUpper(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLower(s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 65;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case alphabets'\n  ASCII codes.\n\n  Examples:\n      digitSumUpper(\"\") => 0\n      digitSumUpper(\"abAB\") => 131\n      digitSumUpper(\"abcCd\") => 67\n      digitSumUpper(\"helloE\") => 69\n      digitSumUpper(\"woArBld\") => 131\n      digitSumUpper(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLower(s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 97;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case alphabets'\n  ASCII codes.\n\n  Examples:\n      digitSumUpper(\"\") => 0\n      digitSumUpper(\"abAB\") => 131\n      digitSumUpper(\"abcCd\") => 67\n      digitSumUpper(\"helloE\") => 69\n      digitSumUpper(\"woArBld\") => 131\n      digitSumUpper(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLower(s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 65;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case alphabets'\n  ASCII codes.\n\n  Examples:\n      digitSumUpper(\"\") => 0\n      digitSumUpper(\"abAB\") => 131\n      digitSumUpper(\"abcCd\") => 67\n      digitSumUpper(\"helloE\") => 69\n      digitSumUpper(\"woArBld\") => 131\n      digitSumUpper(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLower(s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 97;\n  }\n  return sum;\n};\n\n/*Task\n  Write a function that takes a string as input and returns the sum of the upper and lower case alphabets'\n  ASCII codes.\n\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "gc": "<|endoftext|>/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let fruits = [];\n  let apples = 0, oranges = 0;\n  let mango = 0;\n  s.split(' ').forEach(word => {\n    if (word === 'apples') {\n      apples++;\n    } else if (word === 'oranges') {\n      oranges++;\n    } else if (word ==='mango') {\n      mango++;\n    }\n  });\n  fruits.push(apples);\n  fruits.push(oranges);\n  fruits.push(mango);\n  fruits.forEach((fruit, i) => {\n    total += fruit;\n    if (fruit === mango) {\n      total -= i;\n    }\n  });\n  return total;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let fruits = [];\n  let apples = 0, oranges = 0;\n  let mango = 0;\n  s.split(' ').forEach(word => {\n    if (word === 'apples') {\n      apples++;\n    } else if (word === 'oranges') {\n      oranges++;\n    } else if (word ==='mango') {\n      mango++;\n    }\n  });\n  fruits.push(apples);\n  fruits.push(oranges);\n  fruits.push(mango);\n  fruits.forEach((fruit, i) => {\n    total += fruit;\n    if (fruit === mango) {\n      total -= i;\n    }\n  });\n  return total;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let fruits = [];\n  let apples = 0, oranges = 0;\n  let mango = 0;\n  s.split(' ').forEach(word => {\n    if (word === 'apples') {\n      apples++;\n    } else if (word === 'oranges') {\n      oranges++;\n    } else if (word ==='mango') {\n      mango++;\n    }\n  });\n  fruits.push(apples);\n  fruits.push(oranges);\n  fruits.push(mango);\n  fruits.forEach((fruit, i) => {\n    total += fruit;\n    if (fruit === mango) {\n      total -= i;\n    }\n  });\n  return total;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let fruits = [];\n  let apples = 0, oranges = 0;\n  let mango = 0;\n  s.split(' ').forEach(word => {\n    if (word === 'apples') {\n      apples++;\n    } else if (word === 'oranges') {\n      oranges++;\n    } else if (word ==='mango') {\n      mango++;\n    }\n  });\n  fruits.push(apples);\n  fruits.push(oranges);\n  fruits.push(mango);\n  fruits.forEach((fruit, i) => {\n    total += fruit;\n    if (fruit === mango) {\n      total -= i;\n    }\n  });\n  return total;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let fruits = [];\n  let apples = 0, oranges = 0;\n  let mango = 0;\n  s.split(' ').forEach(word => {\n    if (word === 'apples') {\n      apples++;\n    } else if (word === 'oranges') {\n      oranges++;\n    } else if (word ==='mango') {\n      mango++;\n    }\n  });\n  fruits.push(apples);\n  fruits.push(oranges);\n  fruits.push(mango);\n  fruits.forEach((fruit, i) => {\n    total += fruit;\n    if (fruit === mango) {\n      total -= i;\n    }\n  });\n  return total;\n};\n\n/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to pluck one of the nodes and return it.\n  The plucked node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The plucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "gc": "<|endoftext|>/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to pluck one of the nodes and return it.\n  The plucked node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The plucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const len = arr.length;\n  let min = 0;\n  let max = len - 1;\n  let even = 0;\n  let index = 0;\n  while (min <= max) {\n    even = arr[min];\n    if (even % 2 === 0) {\n      min = min + 1;\n    } else {\n      max = max - 1;\n    }\n    index++;\n  }\n  return [even, index];\n};\n\n// Given an array representing a tree with non-negative integer nodes,\n// your task is to return the minimum number of nodes that can exist in the tree.\n// The minimum number of nodes that can exist in the tree is defined as the number of nodes that can exist in the tree that have at least two children.\n// If there are multiple nodes that can exist in the tree that have at least two children,\n// return the minimum number of nodes that can exist in the tree that have at least three children.\n// If there are multiple nodes that can exist in the tree that have at least three children,\n// return the minimum number of nodes that can exist in the tree that have at least four children.\n// If there are multiple nodes that can exist in the tree that have at least four children,\n// return the minimum number of nodes that can exist in the tree that have at least five children.\n// If there are multiple nodes that can exist in the tree that have at least five children,\n// return the minimum number of nodes that can exist in the tree that have at least six children.\n// If there are multiple nodes that can exist in the tree that have at least six children,\n// return the minimum number of nodes that can exist in the tree that have at least seven children.\n// If there are multiple nodes that can exist in the tree that have at least seven children,\n// return the minimum number of nodes that can exist in the tree that have at least eight children.\n// If there are multiple nodes that can exist in the tree that have at least eight children,\n// return the minimum number of nodes that can exist in the tree that have at least nine children.\n// If there are multiple nodes that can exist in the tree that have at least nine children,\n// return the minimum number of nodes that can exist in the tree that have at least ten children.\n// If there are multiple nodes that can exist in the tree that have at least ten children,\n// return the minimum number of nodes that can exist in the tree that have at least eleven children.\n// If there are multiple nodes that can exist in the tree that have at least eleven children,\n// return the minimum number of nodes that can exist in the tree that have at least twelve children.\n// If there are multiple nodes that can exist in the tree that have at least twelve children,\n// return the minimum number of nodes that can exist in the tree that have at least thirteen children.\n// If there are multiple nodes that can exist in the tree that have at least thirteen children,\n// return the minimum number of nodes that can exist in the tree that have at least fourteen children.\n// If there are multiple nodes that can exist in the tree that have at least fourteen children,\n// return the minimum number of nodes that can exist in the tree that have at least fifteen children.\n// If there are multiple nodes that can exist in the tree that have at least fifteen children,\n// return the minimum number of nodes that can exist in the tree that have at least sixteen children.\n// If there are multiple nodes that can exist in the tree that have at least sixteen children,\n// return the minimum number of nodes that can exist in the tree that have at least seventeen children.\n// If there are multiple nodes that can exist in the tree that have at least seventeen children,\n// return the minimum number of nodes that can exist in the tree that have at least eighteen children.\n// If there are multiple nodes that can exist in the tree that have at least eighteen children,\n// return the minimum number of nodes that can exist in the tree that have at least nineteen children.\n// If there are multiple nodes that can exist in the tree that have at least nineteen children,\n// return the minimum number of nodes that can exist in the tree that have at least twenty children.\n// If there are multiple nodes that can exist in the tree that have at least twenty children,\n// return the minimum number of nodes that can exist in the tree that have at least thirty children.\n// If there are multiple nodes that can exist in the tree that have at least thirty children,\n// return the minimum number of nodes that can exist in the tree that have at least fourty children.\n// If there are multiple nodes that can exist in the tree that have at least fourty children,\n// return the minimum number of nodes that can exist in the tree that have at least fifty children.\n// If there are multiple nodes that can exist in the tree that have at least fifty children,\n// return the minimum number of nodes that can exist in the tree that have at least sixty children.\n// If there are multiple nodes that can exist in the tree that have at least sixty children,\n// return the minimum number of nodes that can exist in the tree that have at least seventy children.\n// If there are multiple nodes that can exist in the tree that have at least seventy children,\n// return the minimum number of nodes that can exist in the tree that have at least eighteen children.\n// If there are multiple nodes that can exist in the tree that have at least eighteen children,\n// return the minimum number of nodes that can exist in the tree that have at least nineteen children.\n// If there are multiple nodes that can exist in the tree that have at least nineteen children,\n// return the minimum number of nodes that can exist in the tree that have at least twenty children.\n// If there are multiple nodes that can exist in the tree that have at least twenty children,\n// return the minimum number of nodes that can exist in the tree that have at least thirty children.\n// If there are multiple nodes that can exist in the tree that have at least thirty children,\n// return the minimum number of nodes that can exist in the tree that have at least fourty children.\n// If there are multiple nodes that can exist in the tree that have at least fourty children,\n// return the minimum number of nodes that can exist in the tree that have at least fifty children.\n// If there are multiple nodes that can exist in the tree that have at least fifty children,\n// return the minimum number of nodes that can exist in the tree that have at least sixty children.\n// If there are multiple nodes that can exist in the tree that have at least sixty children,\n// return the minimum number of nodes that can exist in the tree that have at least seventy children.\n// If there are multiple nodes that can exist in the tree that have at least seventy children,\n// return the minimum number of nodes that can exist in the tree that have at least eighteen children.\n// If there are multiple nodes that can exist in the tree that have at least eighteen children,\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/69", "prompt": "/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "gc": "<|endoftext|>/*\n  You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n  zero, and has a frequency greater than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the largest integer that is less than\n  zero, and has a frequency less than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 1\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the largest integer that is less than\n  zero, and has a frequency less than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 1\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the largest integer that is less than\n  zero, and has a frequency less than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 1\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the largest integer that is less than\n  zero, and has a frequency less than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 1\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the largest integer that is less than\n  zero, and has a frequency less than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 1\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the largest integer that is less than\n  zero, and has a frequency less than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 1\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the largest integer that is less than\n  zero, and has a frequency less than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 1\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the largest integer that is less than\n  zero, and has a frequency less than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 1\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the largest integer that is less than\n  zero, and has a frequency less than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 1\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the largest integer that is less than\n  zero, and has a frequency less than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 1\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You are given a non-empty list of positive integers. Return the largest integer that is less than\n  zero, and has a frequency less than or equal to the value of the integer itself.\n  The frequency of an integer is the number of times it appears in the list.\n  If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 1\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings only for ones that contain given substring\n  >>> filteBrySubstring([], 'a')\n  []\n  >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filteBrySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filteBrySubstring", "gc": "<|endoftext|>/* Filter an input list of strings only for ones that contain given substring\n  >>> filteBrySubstring([], 'a')\n  []\n  >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filteBrySubstring = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filteBrySubstring([], 'b')\n  []\n  >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBryNotSubstring = (strings, substring) => {\n  return strings.filter(string =>!string.indexOf(substring));\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filteBryNotSubstring([], 'b')\n  []\n  >>> filteBryNotSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBryNotSubstring = (strings, substring) => {\n  return strings.filter(string =>!string.indexOf(substring));\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filteBrySubstring([], 'a')\n  []\n  >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBrySubstring = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring)!== 0);\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filteBryNotSubstring([], 'a')\n  []\n  >>> filteBryNotSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBryNotSubstring = (strings, substring) => {\n  return strings.filter(string =>!string.indexOf(substring));\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filteBrySubstring([], 'a')\n  []\n  >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBrySubstring = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring)!== 0);\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filteBryNotSubstring([], 'a')\n  []\n  >>> filteBryNotSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBryNotSubstring = (strings, substring) => {\n  return strings.filter(string =>!string.indexOf(substring));\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filteBrySubstring([], 'a')\n  []\n  >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBrySubstring = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filteBryNotSubstring([], 'a')\n  []\n  >>> filteBryNotSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBryNotSubstring = (strings, substring) => {\n  return strings.filter(string =>!string.indexOf(substring));\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filteBrySubstring([], 'a')\n  []\n  >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBrySubstring = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring)!== 0);\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filteBryNotSubstring([], 'a')\n  []\n  >>> filteBryNotSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBryNotSubstring = (strings, substring) => {\n  return strings.filter(string =>!string.indexOf(substring));\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filteBrySubstring([], 'a')\n  []\n  >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBrySubstring = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filteBryNotSubstring([], 'a')\n  []\n  >>> filteBryNotSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBryNotSubstring = (strings, substring) => {\n  return strings.filter(string =>!string.indexOf(substring));\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filteBrySubstring([], 'a')\n  []\n  >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBrySubstring = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filteBryNotSubstring([], 'a')\n  []\n  >>> filteBryNotSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBryNotSubstring = (strings, substring) => {\n  return strings.filter(string =>!string.indexOf(substring));\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filteBrySubstring([], 'a')\n  []\n  >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBrySubstring = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring)!== 0);\n};\n\n/**\n * Filter an input list of strings only for ones that do not contain given substring\n  >>> filteBryNotSubstring([], 'a')\n  []\n  >>> filteBryNotSubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', 'bacd', 'cde', 'array']\n  */\nconst filteBryNotSubstring = (strings, substring) => {\n  return strings.filter(string =>!string.indexOf(substring));\n};\n\n/**\n * Filter an input list of strings only for ones that contain given substring\n  >>> filteBrySubstring([], 'a')\n  []\n  >>> filteBrySubstring(['abc', 'bacd', 'cde', 'array'], 'b')\n  ['abc', '", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/70", "prompt": "/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  stranegoSrtList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  stranegoSrtList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  stranegoSrtList([]) == []\n  */\nconst stranegoSrtList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "stranegoSrtList", "gc": "<|endoftext|>/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  stranegoSrtList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  stranegoSrtList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  stranegoSrtList([]) == []\n  */\nconst stranegoSrtList = (lst) => {\n  const sorted = lst.sort((a, b) => a - b);\n  const stranegoSrtList = [];\n  for (let i = 0; i < sorted.length; i++) {\n    if (sorted[i] > sorted[i + 1]) {\n      stranegoSrtList.push(sorted[i]);\n    }\n  }\n  return stranegoSrtList;\n};\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  stranegoSrtList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  stranegoSrtList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  stranegoSrtList([]) == []\n  */\nconst stranegoSrtListReverse = (lst) => {\n  const sorted = lst.sort((a, b) => b - a);\n  const stranegoSrtList = [];\n  for (let i = 0; i < sorted.length; i++) {\n    if (sorted[i] > sorted[i + 1]) {\n      stranegoSrtList.push(sorted[i]);\n    }\n  }\n  return stranegoSrtList;\n};\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  stranegoSrtList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  stranegoSrtList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  stranegoSrtList([]) == []\n  */\nconst stranegoSrtListReverseReverse = (lst) => {\n  const sorted = lst.sort((a, b) => b - a);\n  const stranegoSrtList = [];\n  for (let i = 0; i < sorted.length; i++) {\n    if (sorted[i] > sorted[i + 1]) {\n      stranegoSrtList.push(sorted[i]);\n    }\n  }\n  return stranegoSrtList;\n};\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  stranegoSrtList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  stranegoSrtList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  stranegoSrtList([]) == []\n  */\nconst stranegoSrtListReverseReverseReverse = (lst) => {\n  const sorted = lst.sort((a, b) => b - a);\n  const stranegoSrtList = [];\n  for (let i = 0; i < sorted.length; i++) {\n    if (sorted[i] > sorted[i + 1]) {\n      stranegoSrtList.push(sorted[i]);\n    }\n  }\n  return stranegoSrtList;\n};\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  stranegoSrtList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  stranegoSrtList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  stranegoSrtList([]) == []\n  */\nconst stranegoSrtListReverseReverseReverseReverse = (lst) => {\n  const sorted = lst.sort((a, b) => b - a);\n  const stranegoSrtList = [];\n  for (let i = 0; i < sorted.length; i++) {\n    if (sorted[i] > sorted[i + 1]) {\n      stranegoSrtList.push(sorted[i]);\n    }\n  }\n  return stranegoSrtList;\n};\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  stranegoSrtList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  stranegoSrtList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  stranegoSrtList([]) == []\n  */\nconst stranegoSrtListReverseReverseReverseReverseReverse = (lst) => {\n  const sorted = lst.sort((a, b) => b - a);\n  const stranegoSrtList = [];\n  for (let i = 0; i < sorted.length; i++) {\n    if (sorted[i] > sorted[i + 1]) {\n      stranegoSrtList.push(sorted[i]);\n    }\n  }\n  return stranegoSrtList;\n};\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  stranegoSrtList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  stranegoSrtList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  stranegoSrtList([]) == []\n  */\nconst stranegoSrtListReverseReverseReverseReverseReverse = (lst) => {\n  const sorted = lst.sort((a, b) => b - a);\n  const stranegoSrtList = [];\n  for (let i = 0; i < sorted.length; i++) {\n    if (sorted[i] > sorted[i + 1]) {\n      stranegoSrtList.push(sorted[i]);\n    }\n  }\n  return stranegoSrtList;\n};\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  stranegoSrtList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  stranegoSrtList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  stranegoSrtList([]) == []\n  */\nconst stranegoSrtListReverseReverseReverseReverseReverse = (lst) => {\n  const sorted = lst.sort((a, b) => b - a);\n  const stranegoSrtList = [];\n  for (let i = 0; i < sorted.length; i++) {\n    if (sorted[i] > sorted[i + 1]) {\n      stranegoSrtList.push(sorted[i]);\n    }\n  }\n  return stranegoSrtList;\n};\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  stranegoSrtList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  stranegoSrtList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  stranegoSrtList([]) == []\n  */\nconst stranegoSrtListReverseReverseReverseReverseReverseReverse = (lst) => {\n  const sorted = lst.sort((a, b) => b - a);\n  const stranegoSrtList = [];\n  for (let i = 0; i < sorted.length; i++) {\n    if (sorted[i] > sorted[i + 1]) {\n      stranegoSrtList.push(sorted[i]);\n    }\n  }\n  return stranegoSrtList;\n};\n\n/*\n  Given list of integers, return list in strange order.\n  Strange sorting, is when you start with the minimum value,\n  then maximum of the remaining integers, then minimum and so on.\n\n  Examples:\n  stranegoSrtList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  stranegoSrtList([", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "gc": "<|endoftext|>/*\n  Given the lengths of the three sides of a triangle. Return the area of\n  the triangle rounded to 2 decimal points if the three sides form a valid triangle.\n  Otherwise return -1\n  Three sides make a valid triangle when the sum of any two sides is greater\n  than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  const sumA = a + b;\n  const sumB = a + c;\n  const sumC = a + b;\n  const sumD = a + c;\n  const sumE = a + b;\n  const sumF = a + c;\n  const sumG = a + c;\n  const sumH = b + c;\n  const sumI = b + c;\n  const sumJ = b + c;\n  const sumK = b + c;\n  const sumL = b + c;\n  const sumM = b + c;\n  const sumN = c + b;\n  const sumO = c + b;\n  const sumP = c + b;\n  const sumQ = c + b;\n  const sumR = c + b;\n  const sumS = c + b;\n  const sumT = c + b;\n  const sumU = c + b;\n  const sumV = c + b;\n  const sumW = c + b;\n  const sumX = c + b;\n  const sumY = c + b;\n  const sumZ = c + b;\n  const sumA = a + sumA;\n  const sumB = a + sumB;\n  const sumC = a + sumC;\n  const sumD = a + sumD;\n  const sumE = a + sumE;\n  const sumF = a + sumF;\n  const sumG = a + sumG;\n  const sumH = a + sumH;\n  const sumI = a + sumI;\n  const sumJ = a + sumJ;\n  const sumK = a + sumK;\n  const sumL = a + sumL;\n  const sumM = a + sumM;\n  const sumN = a + sumN;\n  const sumO = a + sumO;\n  const sumP = a + sumP;\n  const sumQ = a + sumQ;\n  const sumR = a + sumR;\n  const sumS = a + sumS;\n  const sumT = a + sumT;\n  const sumU = a + sumU;\n  const sumV = a + sumV;\n  const sumW = a + sumW;\n  const sumX = a + sumX;\n  const sumY = a + sumY;\n  const sumZ = a + sumZ;\n  const sumA = b + sumA;\n  const sumB = b + sumB;\n  const sumC = b + sumC;\n  const sumD = b + sumD;\n  const sumE = b + sumE;\n  const sumF = b + sumF;\n  const sumG = b + sumG;\n  const sumH = b + sumH;\n  const sumI = b + sumI;\n  const sumJ = b + sumJ;\n  const sumK = b + sumK;\n  const sumL = b + sumL;\n  const sumM = b + sumM;\n  const sumN = b + sumN;\n  const sumO = b + sumO;\n  const sumP = b + sumP;\n  const sumQ = b + sumQ;\n  const sumR = b + sumR;\n  const sumS = b + sumS;\n  const sumT = b + sumT;\n  const sumU = b + sumU;\n  const sumV = b + sumV;\n  const sumW = b + sumW;\n  const sumX = b + sumX;\n  const sumY = b + sumY;\n  const sumZ = b + sumZ;\n  const sumA = c + sumA;\n  const sumB = c + sumB;\n  const sumC = c + sumC;\n  const sumD = c + sumD;\n  const sumE = c + sumE;\n  const sumF = c + sumF;\n  const sumG = c + sumG;\n  const sumH = c + sumH;\n  const sumI = c + sumI;\n  const sumJ = c + sumJ;\n  const sumK = c + sumK;\n  const sumL = c + sumL;\n  const sumM = c + sumM;\n  const sumN = c + sumN;\n  const sumO = c + sumO;\n  const sumP = c + sumP;\n  const sumQ = c + sumQ;\n  const sumR = c + sumR;\n  const sumS = c + sumS;\n  const sumT = c + sumT;\n  const sumU = c + sumU;\n  const sumV = c + sumV;\n  const sumW = c + sumW;\n  const sumX = c + sumX;\n  const sumY = c + sumY;\n  const sumZ = c + sumZ;\n  const sumA = a + sumA;\n  const sumB = a + sumB;\n  const sumC = a + sumC;\n  const sumD = a + sumD;\n  const sumE = a + sumE;\n  const sumF = a + sumF;\n  const sumG = a + sumG;\n  const sumH = a + sumH;\n  const sumI = a + sumI;\n  const sumJ = a + sumJ;\n  const sumK = a + sumK;\n  const sumL = a + sumL;\n  const sumM = a + sumM;\n  const sumN = a + sumN;\n  const sumO = a + sumO;\n  const sumP = a + sumP;\n  const sumQ = a + sumQ;\n  const sumR = a + sumR;\n  const sumS = a + sumS;\n  const sumT = a + sumT;\n  const sumU = a + sumU;\n  const sumV = a + sumV;\n  const sumW = a + sumW;\n  const sumX = a + sumX;\n  const sumY = a + sumY;\n  const sumZ = a + sumZ;\n  const sumA = b + sumA;\n  const sumB = b + sumB;\n  const sumC = b + sumC;\n  const sumD = b + sumD;\n  const sumE = b + sumE;\n  const sumF = b + sumF;\n  const sumG = b + sumG;\n  const sumH = b + sumH;\n  const sumI = b + sumI;\n  const sumJ = b + sumJ;\n  const sumK = b + sumK;\n  const sumL = b + sumL;\n  const sumM = b + sumM;\n  const sumN = b + sumN;\n  const sumO = b + sumO;\n  const sumP = b + sumP;\n  const sumQ = b + sumQ;\n  const sumR = b + sumR;\n  const sumS = b + sumS;\n  const sumT = b + sumT;\n  const sumU = b + sumU;\n  const sumV = b + sumV;\n  const sumW = b + sumW;\n  const sumX = b + sumX;\n  const sumY = b + sumY;\n  const sumZ = b + sumZ;\n  const sumA = c + sumA;\n  const sumB = c + sumB;\n  const sumC = c + sumC;\n  const sumD = c + sumD;\n  const sumE = c + sumE;\n  const sumF = c + sumF;\n  const sumG = c + sumG;\n  const sumH = c + sumH;\n  const sumI = c + sumI;\n  const sumJ = c + sumJ;\n  const sumK = c + sumK;\n  const sumL = c + sumL;\n  const sumM = c + sumM;\n  const sumN = c + sumN;\n  const sumO = c + sumO;\n  const sumP = c + sumP;\n  const sumQ = c + sumQ;\n  const sumR = c + sumR;\n  const sumS = c + sumS;\n  const sumT = c + ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "gc": "<|endoftext|>/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = Math.max(...q);\n  const sumWeight = q.reduce((acc, curr) => acc + curr, 0);\n  return sumWeight <= maxWeight && sumWeight <= w;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = Math.max(...q);\n  const sumWeight = q.reduce((acc, curr) => acc + curr, 0);\n  return sumWeight <= maxWeight && sumWeight <= w;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = Math.max(...q);\n  const sumWeight = q.reduce((acc, curr) => acc + curr, 0);\n  return sumWeight <= maxWeight && sumWeight <= w;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = Math.max(...q);\n  const sumWeight = q.reduce((acc, curr) => acc + curr, 0);\n  return sumWeight <= maxWeight && sumWeight <= w;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = Math.max(...q);\n  const sumWeight = q.reduce((acc, curr) => acc + curr, 0);\n  return sumWeight <= maxWeight && sumWeight <= w;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = Math.max(...q);\n  const sumWeight = q.reduce((acc, curr) => acc + curr, 0);\n  return sumWeight <= maxWeight && sumWeight <= w;\n};\n\n/*\n  Write a function that returns true if the object q will fly, and false otherwise.\n  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = Math.max(...q);\n  const sumWeight = q.reduce((acc, curr) => acc + curr, 0);\n  return sumWeight <= maxWeight && sumWeight <= w;\n};\n\n/*\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/73", "prompt": "/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  msallestChange([1,2,3,5,4,7,9,6]) == 4\n  msallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  msallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst msallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "msallestChange", "gc": "<|endoftext|>/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  msallestChange([1,2,3,5,4,7,9,6]) == 4\n  msallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  msallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst msallestChange = (arr) => {\n  let change = 0;\n  let minChange = arr.length - 1;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i]!== arr[i + 1]) {\n      change++;\n      if (change > minChange) {\n        minChange = change;\n      }\n    }\n  }\n  return minChange;\n};\n\nmodule.exports = {\n  msallestChange,\n};\n\n},{}],9:[function(require,module,exports){\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  msallestChange([1,2,3,5,4,7,9,6]) == 4\n  msallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  msallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst msallestChange = (arr) => {\n  let change = 0;\n  let minChange = arr.length - 1;\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i]!== arr[i + 1]) {\n      change++;\n      if (change > minChange) {\n        minChange = change;\n      }\n    }\n  }\n  return minChange;\n};\n\nmodule.exports = {\n  msallestChange,\n};\n\n},{}],10:[function(require,module,exports){\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  msallestChange([1,2,3,5,4,7,9,6]) == 4\n  msallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  msallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst msallestChange = (arr) => {\n  let change = 0;\n  let minChange = arr.length - 1;\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] === arr[i + 1]) {\n      change++;\n      if (change > minChange) {\n        minChange = change;\n      }\n    }\n  }\n  return minChange;\n};\n\nmodule.exports = {\n  msallestChange,\n};\n\n},{}],11:[function(require,module,exports){\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  msallestChange([1,2,3,5,4,7,9,6]) == 4\n  msallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  msallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst msallestChange = (arr) => {\n  let change = 0;\n  let minChange = arr.length - 1;\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] === arr[i + 1]) {\n      change++;\n      if (change > minChange) {\n        minChange = change;\n      }\n    }\n  }\n  return minChange;\n};\n\nmodule.exports = {\n  msallestChange,\n};\n\n},{}],12:[function(require,module,exports){\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  msallestChange([1,2,3,5,4,7,9,6]) == 4\n  msallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  msallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst msallestChange = (arr) => {\n  let change = 0;\n  let minChange = arr.length - 1;\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] === arr[i + 1]) {\n      change++;\n      if (change > minChange) {\n        minChange = change;\n      }\n    }\n  }\n  return minChange;\n};\n\nmodule.exports = {\n  msallestChange,\n};\n\n},{}],13:[function(require,module,exports){\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  msallestChange([1,2,3,5,4,7,9,6]) == 4\n  msallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  msallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst msallestChange = (arr) => {\n  let change = 0;\n  let minChange = arr.length - 1;\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] === arr[i + 1]) {\n      change++;\n      if (change > minChange) {\n        minChange = change;\n      }\n    }\n  }\n  return minChange;\n};\n\nmodule.exports = {\n  msallestChange,\n};\n\n},{}],14:[function(require,module,exports){\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  msallestChange([1,2,3,5,4,7,9,6]) == 4\n  msallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  msallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst msallestChange = (arr) => {\n  let change = 0;\n  let minChange = arr.length - 1;\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] === arr[i + 1]) {\n      change++;\n      if (change > minChange) {\n        minChange = change;\n      }\n    }\n  }\n  return minChange;\n};\n\nmodule.exports = {\n  msallestChange,\n};\n\n},{}],15:[function(require,module,exports){\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array palindromic. A palindromic array is an array that\n  is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n  For example:\n  msallestChange([1,2,3,5,4,7,9,6]) == 4\n  msallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  msallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst msallestChange = (arr) => {\n  let change = 0;\n  let minChange = arr.length - 1;\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] === arr[i + 1]) {\n      change++;\n      if (change > minChange) {\n        minChange = change;\n      }\n    }\n  }\n  return minChange;\n};\n\nmodule.exports = {\n  msallestChange,\n};\n\n},{}],16:[function(require,module,exports){\n/*\n  Given an array arr of integers, find the minimum number of elements that\n  need to be changed to make the array ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  ottalMatch([], []) ➞ []\n  ottalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  ottalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  ottalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  ottalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst ottalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "ottalMatch", "gc": "<|endoftext|>/*\n  Write a function that accepts two lists of strings and returns the list that has\n  total number of chars in the all strings of the list less than the other list.\n\n  if the two lists have the same number of chars, return the first list.\n\n  Examples\n  ottalMatch([], []) ➞ []\n  ottalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  ottalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  ottalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  ottalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst ottalMatch = (lst1, lst2) => {\n  const set1 = new Set(lst1);\n  const set2 = new Set(lst2);\n  const set3 = new Set(lst1.concat(lst2));\n  const set4 = new Set(lst1.filter(x =>!set2.has(x)));\n  const set5 = new Set(lst2.filter(x =>!set1.has(x)));\n  const set6 = new Set(lst1.filter(x => set2.has(x)));\n  const set7 = new Set(lst2.filter(x => set1.has(x)));\n  const set8 = new Set(lst1.filter(x =>!set3.has(x)));\n  const set9 = new Set(lst2.filter(x =>!set3.has(x)));\n  const set10 = new Set(lst1.filter(x =>!set4.has(x)));\n  const set11 = new Set(lst2.filter(x =>!set4.has(x)));\n  const set12 = new Set(lst1.filter(x =>!set5.has(x)));\n  const set13 = new Set(lst2.filter(x =>!set5.has(x)));\n  const set14 = new Set(lst1.filter(x =>!set6.has(x)));\n  const set15 = new Set(lst2.filter(x =>!set6.has(x)));\n  const set16 = new Set(lst1.filter(x =>!set7.has(x)));\n  const set17 = new Set(lst2.filter(x =>!set7.has(x)));\n  const set18 = new Set(lst1.filter(x =>!set8.has(x)));\n  const set19 = new Set(lst2.filter(x =>!set8.has(x)));\n  const set20 = new Set(lst1.filter(x =>!set9.has(x)));\n  const set21 = new Set(lst2.filter(x =>!set9.has(x)));\n  const set22 = new Set(lst1.filter(x =>!set10.has(x)));\n  const set23 = new Set(lst2.filter(x =>!set10.has(x)));\n  const set24 = new Set(lst1.filter(x =>!set11.has(x)));\n  const set25 = new Set(lst2.filter(x =>!set11.has(x)));\n  const set26 = new Set(lst1.filter(x =>!set12.has(x)));\n  const set27 = new Set(lst2.filter(x =>!set12.has(x)));\n  const set28 = new Set(lst1.filter(x =>!set13.has(x)));\n  const set29 = new Set(lst2.filter(x =>!set13.has(x)));\n  const set30 = new Set(lst1.filter(x =>!set14.has(x)));\n  const set31 = new Set(lst2.filter(x =>!set14.has(x)));\n  const set32 = new Set(lst1.filter(x =>!set15.has(x)));\n  const set33 = new Set(lst2.filter(x =>!set15.has(x)));\n  const set34 = new Set(lst1.filter(x =>!set16.has(x)));\n  const set35 = new Set(lst2.filter(x =>!set16.has(x)));\n  const set36 = new Set(lst1.filter(x =>!set17.has(x)));\n  const set37 = new Set(lst2.filter(x =>!set17.has(x)));\n  const set38 = new Set(lst1.filter(x =>!set18.has(x)));\n  const set39 = new Set(lst2.filter(x =>!set18.has(x)));\n  const set40 = new Set(lst1.filter(x =>!set19.has(x)));\n  const set41 = new Set(lst2.filter(x =>!set19.has(x)));\n  const set42 = new Set(lst1.filter(x =>!set20.has(x)));\n  const set43 = new Set(lst2.filter(x =>!set20.has(x)));\n  const set44 = new Set(lst1.filter(x =>!set21.has(x)));\n  const set45 = new Set(lst2.filter(x =>!set21.has(x)));\n  const set46 = new Set(lst1.filter(x =>!set22.has(x)));\n  const set47 = new Set(lst2.filter(x =>!set22.has(x)));\n  const set48 = new Set(lst1.filter(x =>!set23.has(x)));\n  const set49 = new Set(lst2.filter(x =>!set23.has(x)));\n  const set50 = new Set(lst1.filter(x =>!set24.has(x)));\n  const set51 = new Set(lst2.filter(x =>!set24.has(x)));\n  const set52 = new Set(lst1.filter(x =>!set25.has(x)));\n  const set53 = new Set(lst2.filter(x =>!set25.has(x)));\n  const set54 = new Set(lst1.filter(x =>!set26.has(x)));\n  const set55 = new Set(lst2.filter(x =>!set26.has(x)));\n  const set56 = new Set(lst1.filter(x =>!set27.has(x)));\n  const set57 = new Set(lst2.filter(x =>!set27.has(x)));\n  const set58 = new Set(lst1.filter(x =>!set28.has(x)));\n  const set59 = new Set(lst2.filter(x =>!set28.has(x)));\n  const set60 = new Set(lst1.filter(x =>!set29.has(x)));\n  const set61 = new Set(lst2.filter(x =>!set29.has(x)));\n  const set62 = new Set(lst1.filter(x =>!set30.has(x)));\n  const set63 = new Set(lst2.filter(x =>!set30.has(x)));\n  const set64 = new Set(lst1.filter(x =>!set31.has(x)));\n  const set65 = new Set(lst2.filter(x =>!set31.has(x)));\n  const set66 = new Set(lst1.filter(x =>!set32.has(x)));\n  const set67 = new Set(lst2.filter(x =>!set32.has(x)));\n  const set68 = new Set(lst1.filter(x =>!set33.has(x)));\n  const set69 = new Set(lst2.filter(x =>!set33.has(x)));\n  const set70 = new Set(lst1.filter(x =>!set34.has(x)));\n  const set71 = new Set(lst2.filter(x =>!set34.has(x)));\n  const set72 = new Set(lst1.filter(x =>!set35.has(x)));\n  const set73 = new Set(lst2.filter(x =>!set35.has(x)));\n  const set74 = new Set(lst1.filter(x =>!set36.has(x)));\n  const set75 = new Set(lst2.filter(x =>!set36.has(x)));\n  const set76 = new Set(lst1.filter(x =>!set37.has(x)));\n  const set77 = new Set(lst2.filter(x =>!set37.has(x)));\n  const set78 = new Set(lst1.filter(x =>!set38.has(x)));\n  const set79 = new Set(lst2.filter(x =>!set38.has(x)));\n  const set80 = new Set(lst1.filter(x =>!set39.has(x)));\n  const set81 = new Set(lst2.filter(x ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/75", "prompt": "/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPirme", "gc": "<|endoftext|>/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  let isMultiplyPirme = false;\n  if (a < 100) {\n    let isPrime = true;\n    for (let i = 2; i <= Math.sqrt(a); i++) {\n      if (a % i === 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      isMultiplyPirme = true;\n    }\n  }\n  return isMultiplyPirme;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  let isMultiplyPirme = false;\n  if (a < 100) {\n    let isPrime = true;\n    for (let i = 2; i <= Math.sqrt(a); i++) {\n      if (a % i === 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      isMultiplyPirme = true;\n    }\n  }\n  return isMultiplyPirme;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  let isMultiplyPirme = false;\n  if (a < 100) {\n    let isPrime = true;\n    for (let i = 2; i <= Math.sqrt(a); i++) {\n      if (a % i === 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      isMultiplyPirme = true;\n    }\n  }\n  return isMultiplyPirme;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  let isMultiplyPirme = false;\n  if (a < 100) {\n    let isPrime = true;\n    for (let i = 2; i <= Math.sqrt(a); i++) {\n      if (a % i === 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      isMultiplyPirme = true;\n    }\n  }\n  return isMultiplyPirme;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  let isMultiplyPirme = false;\n  if (a < 100) {\n    let isPrime = true;\n    for (let i = 2; i <= Math.sqrt(a); i++) {\n      if (a % i === 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      isMultiplyPirme = true;\n    }\n  }\n  return isMultiplyPirme;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  let isMultiplyPirme = false;\n  if (a < 100) {\n    let isPrime = true;\n    for (let i = 2; i <= Math.sqrt(a); i++) {\n      if (a % i === 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      isMultiplyPirme = true;\n    }\n  }\n  return isMultiplyPirme;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  let isMultiplyPirme = false;\n  if (a < 100) {\n    let isPrime = true;\n    for (let i = 2; i <= Math.sqrt(a); i++) {\n      if (a % i === 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      isMultiplyPirme = true;\n    }\n  }\n  return isMultiplyPirme;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  let isMultiplyPirme = false;\n  if (a < 100) {\n    let isPrime = true;\n    for (let i = 2; i <= Math.sqrt(a); i++) {\n      if (a % i === 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      isMultiplyPirme = true;\n    }\n  }\n  return isMultiplyPirme;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  let isMultiplyPirme = false;\n  if (a < 100) {\n    let isPrime = true;\n    for (let i = 2; i <= Math.sqrt(a); i++) {\n      if (a % i === 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      isMultiplyPirme = true;\n    }\n  }\n  return isMultiplyPirme;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  let isMultiplyPirme = false;\n  if (a < 100) {\n    let isPrime = true;\n    for (let i = 2; i <= Math.sqrt(a); i++) {\n      if (a % i === 0) {\n        isPrime = false;\n        break;\n      }\n    }\n    if (isPrime) {\n      isMultiplyPirme = true;\n    }\n  }\n  return isMultiplyPirme;\n};\n\n/*Write a function that returns true if the given number is the multiplication of 3 prime numbers\n  and false otherwise.\n  Knowing that (a) is less then 100.\n  Example:\n  isMultiplyPirme(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPirme = (a) => {\n  let isMultiplyPirme = false;\n  if (a < 100) {\n    let isPrime = true;\n    for (let i = 2; i <= Math.sqrt(a", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/76", "prompt": "/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePwoer(1, 4) => true\n  isSimplePwoer(2, 2) => true\n  isSimplePwoer(8, 2) => true\n  isSimplePwoer(3, 2) => false\n  isSimplePwoer(3, 1) => false\n  isSimplePwoer(5, 3) => false\n  */\nconst isSimplePwoer = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePwoer", "gc": "<|endoftext|>/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePwoer(1, 4) => true\n  isSimplePwoer(2, 2) => true\n  isSimplePwoer(8, 2) => true\n  isSimplePwoer(3, 2) => false\n  isSimplePwoer(3, 1) => false\n  isSimplePwoer(5, 3) => false\n  */\nconst isSimplePwoer = (x, n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return true;\n  return isSimplePwoer(x, Math.floor(n / 2));\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePwoer(1, 4) => true\n  isSimplePwoer(2, 2) => true\n  isSimplePwoer(8, 2) => true\n  isSimplePwoer(3, 2) => false\n  isSimplePwoer(3, 1) => false\n  isSimplePwoer(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return true;\n  return isSimplePower(x, Math.floor(n / 2));\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePowerOfTwo = (x, n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return true;\n  return isSimplePowerOfTwo(x, Math.floor(n / 2));\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePowerOfTwo(1, 4) => true\n  isSimplePowerOfTwo(2, 2) => true\n  isSimplePowerOfTwo(8, 2) => true\n  isSimplePowerOfTwo(3, 2) => false\n  isSimplePowerOfTwo(3, 1) => false\n  isSimplePowerOfTwo(5, 3) => false\n  */\nconst isSimplePowerOfThree = (x, n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return true;\n  return isSimplePowerOfThree(x, Math.floor(n / 2));\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePowerOfThree(1, 4) => true\n  isSimplePowerOfThree(2, 2) => true\n  isSimplePowerOfThree(8, 2) => true\n  isSimplePowerOfThree(3, 2) => false\n  isSimplePowerOfThree(3, 1) => false\n  isSimplePowerOfThree(5, 3) => false\n  */\nconst isSimplePowerOfFour = (x, n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return true;\n  return isSimplePowerOfFour(x, Math.floor(n / 2));\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePowerOfFour(1, 4) => true\n  isSimplePowerOfFour(2, 2) => true\n  isSimplePowerOfFour(8, 2) => true\n  isSimplePowerOfFour(3, 2) => false\n  isSimplePowerOfFour(3, 1) => false\n  isSimplePowerOfFour(5, 3) => false\n  */\nconst isSimplePowerOfFive = (x, n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return true;\n  return isSimplePowerOfFive(x, Math.floor(n / 2));\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePowerOfFive(1, 4) => true\n  isSimplePowerOfFive(2, 2) => true\n  isSimplePowerOfFive(8, 2) => true\n  isSimplePowerOfFive(3, 2) => false\n  isSimplePowerOfFive(3, 1) => false\n  isSimplePowerOfFive(5, 3) => false\n  */\nconst isSimplePowerOfSix = (x, n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return true;\n  return isSimplePowerOfSix(x, Math.floor(n / 2));\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePowerOfSix(1, 4) => true\n  isSimplePowerOfSix(2, 2) => true\n  isSimplePowerOfSix(8, 2) => true\n  isSimplePowerOfSix(3, 2) => false\n  isSimplePowerOfSix(3, 1) => false\n  isSimplePowerOfSix(5, 3) => false\n  */\nconst isSimplePowerOfSeven = (x, n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return true;\n  return isSimplePowerOfSeven(x, Math.floor(n / 2));\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePowerOfSeven(1, 4) => true\n  isSimplePowerOfSeven(2, 2) => true\n  isSimplePowerOfSeven(8, 2) => true\n  isSimplePowerOfSeven(3, 2) => false\n  isSimplePowerOfSeven(3, 1) => false\n  isSimplePowerOfSeven(5, 3) => false\n  */\nconst isSimplePowerOfEight = (x, n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return true;\n  return isSimplePowerOfEight(x, Math.floor(n / 2));\n};\n\n/*Your task is to write a function that returns true if a number x is a simple\n  power of n and false in other cases.\n  x is a simple power of n if n**int=x\n  For example:\n  isSimplePowerOfEight(1, 4) => true\n  isSimplePowerOfEight(2, 2) => true\n  isSimplePowerOfEight(8, 2) => true\n  isSimplePowerOfEight(3, 2) => false\n  isSimplePowerOfEight(3, 1) => false\n  isSimplePowerOfEight(5, 3) => false\n  */\nconst isSimplePowerOfNine = (x, n) => {\n  if (n <= 0) return false;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return true;\n  return isSimplePowerOfNine(x, Math.floor(", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "gc": "<|endoftext|>/*\n  Write a function that takes an integer a and returns true\n  if this ingeger is a cube of some integer number.\n  Note: you may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  let isCube = true;\n  if (a < 0) {\n    isCube = false;\n  }\n  if (a === 0 || a === 1 || a === 2 || a === 3 || a === 4 || a === 5 || a === 6 || a === 7 || a === 8 || a === 9 || a === 10 || a === 11 || a === 12 || a === 13 || a === 14 || a === 15 || a === 16 || a === 17 || a === 18 || a === 19 || a === 20 || a === 21 || a === 22 || a === 23 || a === 24 || a === 25 || a === 26 || a === 27 || a === 28 || a === 29 || a === 30 || a === 31 || a === 32 || a === 33 || a === 34 || a === 35 || a === 36 || a === 37 || a === 38 || a === 39 || a === 40 || a === 41 || a === 42 || a === 43 || a === 44 || a === 45 || a === 46 || a === 47 || a === 48 || a === 49 || a === 50 || a === 51 || a === 52 || a === 53 || a === 54 || a === 55 || a === 56 || a === 57 || a === 58 || a === 59 || a === 60 || a === 61 || a === 62 || a === 63 || a === 64 || a === 65 || a === 66 || a === 67 || a === 68 || a === 69 || a === 70 || a === 71 || a === 72 || a === 73 || a === 74 || a === 75 || a === 76 || a === 77 || a === 78 || a === 79 || a === 80 || a === 81 || a === 82 || a === 83 || a === 84 || a === 85 || a === 86 || a === 87 || a === 88 || a === 89 || a === 90 || a === 91 || a === 92 || a === 93 || a === 94 || a === 95 || a === 96 || a === 97 || a === 98 || a === 99 || a === 100 || a === 101 || a === 102 || a === 103 || a === 104 || a === 105 || a === 106 || a === 107 || a === 108 || a === 109 || a === 110 || a === 111 || a === 112 || a === 113 || a === 114 || a === 115 || a === 116 || a === 117 || a === 118 || a === 119 || a === 120 || a === 121 || a === 122 || a === 123 || a === 124 || a === 125 || a === 126 || a === 127 || a === 128 || a === 129 || a === 130 || a === 131 || a === 132 || a === 133 || a === 134 || a === 135 || a === 136 || a === 137 || a === 138 || a === 139 || a === 140 || a === 141 || a === 142 || a === 143 || a === 144 || a === 145 || a === 146 || a === 147 || a === 148 || a === 149 || a === 150 || a === 151 || a === 152 || a === 153 || a === 154 || a === 155 || a === 156 || a === 157 || a === 158 || a === 159 || a === 160 || a === 161 || a === 162 || a === 163 || a === 164 || a === 165 || a === 166 || a === 167 || a === 168 || a === 169 || a === 170 || a === 171 || a === 172 || a === 173 || a === 174 || a === 175 || a === 176 || a === 177 || a === 178 || a === 179 || a === 180 || a === 181 || a === 182 || a === 183 || a === 184 || a === 185 || a === 186 || a === 187 || a === 188 || a === 189 || a === 190 || a === 191 || a === 192 || a === 193 || a === 194 || a === 195 || a === 196 || a === 197 || a === 198 || a === 199 || a === 200 || a === 201 || a === 202 || a === 203 || a === 204 || a === 205 || a === 206 || a === 207 || a === 208 || a === 209 || a === 210 || a === 211 || a === 212 || a === 213 || a === 214 || a === 215 || a === 216 || a === 217 || a === 218 || a === 219 || a === 220 || a === 221 || a === 222 || a === 223 || a === 224 || a === 225 || a === 226 || a === 227 || a === 228 || a === 229 || a === 230 || a === 231 || a === 232 || (a >= 240 && a <= 241) || (a >= 242 && a <= 243) || (a >= 244 && a <= 245) || (a >= 246 && a <= 247) || (a >= 248 && a <= 249) || (a >= 250 && a <= 251) || (a >= 252 && a <= 253) || (a >= 254 && a <= 255) || (a >= 256 && a <= 257) || (a >= 258 && a <= 259) || (a >= 260 && a <= 261) || (a >= 262 && a <= 263) || (a >= 264 && a <= 265) || (a >= 266 && a <= 267) || (a >= 268 && a <= 269) || (a >= 270 && a <= 271) || (a >= 272 && a <= 273) || (a >= 274 && a <= 275) || (a >= 276 && a <= 277) || (a >= 278 && a <= 279) || (a >= 280 && a <= 281) || (a >= 282 && a <= 283) || (a >= 284 && a <= 285) || (a >= 286 && a <= 287) || (a >= 288 && a <= 289) || (a >= 290 && a <= 291) || (a >= 292 && a <= 293) || (a >= 294 && a <= 295) || (a >= 296 && a <= 297) || (a >= 298 && a <= 299) || (a >= 300 && a <= 301) || (a >= 302 && a <= 303) || (a >= 304 && a <= 305) || (a >= 306 && a <= 307) || (a >= 308 && a <= 309) || (a >= 310 && a <= 311) || (a >= 312 && a <= 313) || (a >= 314 && a <= 315) || (a >= 316 && a <= 317) || (a >= 318 && a <= 319) || (a >= 320 && a <= 321) || (a >= 322 && a <= 323) || (a >= 324 && a <= 325) || (a >= 326 && a <= 327) || (a >= 328 && a <= 329) || (a >= 33", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "gc": "<|endoftext|>/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let count = 0;\n  let numArray = num.split('');\n  for (let i = 0; i < numArray.length; i++) {\n    if (numArray[i] === '0') {\n      count++;\n    } else if (numArray[i] === '1') {\n      count++;\n    } else if (numArray[i] === '2') {\n      count++;\n    } else if (numArray[i] === '3') {\n      count++;\n    } else if (numArray[i] === '4') {\n      count++;\n    } else if (numArray[i] === '5') {\n      count++;\n    } else if (numArray[i] === '6') {\n      count++;\n    } else if (numArray[i] === '7') {\n      count++;\n    } else if (numArray[i] === '8') {\n      count++;\n    } else if (numArray[i] === '9') {\n      count++;\n    } else if (numArray[i] === 'A') {\n      count++;\n    } else if (numArray[i] === 'B') {\n      count++;\n    } else if (numArray[i] === 'C') {\n      count++;\n    } else if (numArray[i] === 'D') {\n      count++;\n    } else if (numArray[i] === 'E') {\n      count++;\n    } else if (numArray[i] === 'F') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You have been tasked to write a function that receives a string and counts the number of uppercase letters that are primes (prime number=== or a prime=== is a natural number greater than 1 that is not a product of two smaller natural numbers).\n  Uppercase letters are A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst upperKey = (num) => {\n  let count = 0;\n  let numArray = num.split('');\n  for (let i = 0; i < numArray.length; i++) {\n    if (numArray[i] === 'A') {\n      count++;\n    } else if (numArray[i] === 'B') {\n      count++;\n    } else if (numArray[i] === 'C') {\n      count++;\n    } else if (numArray[i] === 'D') {\n      count++;\n    } else if (numArray[i] === 'E') {\n      count++;\n    } else if (numArray[i] === 'F') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You have been tasked to write a function that receives a string and counts the number of lowercase letters that are primes (prime number=== or a prime=== is a natural number greater than 1 that is not a product of two smaller natural numbers).\n  Lowercase letters are a=== b=== c=== d=== e=== f.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols a===b===c===d===e===f are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst lowerKey = (num) => {\n  let count = 0;\n  let numArray = num.split('');\n  for (let i = 0; i < numArray.length; i++) {\n    if (numArray[i] === 'a') {\n      count++;\n    } else if (numArray[i] === 'b') {\n      count++;\n    } else if (numArray[i] === 'c') {\n      count++;\n    } else if (numArray[i] === 'd') {\n      count++;\n    } else if (numArray[i] === 'e') {\n      count++;\n    } else if (numArray[i] === 'f') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You have been tasked to write a function that receives a string and counts the number of digits that are primes (prime number=== or a prime=== is a natural number greater than 1 that is not a product of two smaller natural numbers).\n  Digits 0-9 are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst digitKey = (num) => {\n  let count = 0;\n  let numArray = num.split('');\n  for (let i = 0; i < numArray.length; i++) {\n    if (numArray[i] === '0') {\n      count++;\n    } else if (numArray[i] === '1') {\n      count++;\n    } else if (numArray[i] === '2') {\n      count++;\n    } else if (numArray[i] === '3') {\n      count++;\n    } else if (numArray[i] === '4') {\n      count++;\n    } else if (numArray[i] === '5') {\n      count++;\n    } else if (numArray[i] === '6') {\n      count++;\n    } else if (numArray[i] === '7') {\n      count++;\n    } else if (numArray[i] === '8') {\n      count++;\n    } else if (numArray[i] === '9') {\n      count++;\n    } else if (numArray[i] === 'A') {\n      count++;\n    } else if (numArray[i] === 'B') {\n      count++;\n    } else if (numArray[i] === 'C') {\n      count++;\n    } else if (numArray[i] === 'D') {\n      count++;\n    } else if (numArray[i] === 'E') {\n      count++;\n    } else if (", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/79", "prompt": "/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "gc": "<|endoftext|>/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let decimalToBinary = parseInt(decimal, 2);\n\n  for (let i = 0; i < decimalToBinary.length; i++) {\n    if (decimalToBinary[i] === '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n\n  return binary;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  binaryToDecimal('0b11')   # returns 11\n  binaryToDecimal('0b111')   # returns 111\n  binaryToDecimal('0b1111')   # returns 1111\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryToDecimal = parseInt(binary, 2);\n\n  for (let i = 0; i < binaryToDecimal.length; i++) {\n    if (binaryToDecimal[i] === '1') {\n      decimal += '1';\n    } else {\n      decimal += '0';\n    }\n  }\n\n  return decimal;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  decimalToBinary('11')   # returns '0b11'\n  decimalToBinary('111')   # returns '0b111'\n  decimalToBinary('1111')   # returns '0b1111'\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let decimalToBinary = parseInt(decimal, 2);\n\n  for (let i = 0; i < decimalToBinary.length; i++) {\n    if (decimalToBinary[i] === '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n\n  return binary;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  binaryToDecimal('0b111')   # returns 111\n  binaryToDecimal('0b1111')   # returns 1111\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryToDecimal = parseInt(binary, 2);\n\n  for (let i = 0; i < binaryToDecimal.length; i++) {\n    if (binaryToDecimal[i] === '1') {\n      decimal += '1';\n    } else {\n      decimal += '0';\n    }\n  }\n\n  return decimal;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  decimalToBinary('11')   # returns '11'\n  decimalToBinary('111')   # returns '111'\n  decimalToBinary('1111')   # returns '1111'\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let decimalToBinary = parseInt(decimal, 2);\n\n  for (let i = 0; i < decimalToBinary.length; i++) {\n    if (decimalToBinary[i] === '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n\n  return binary;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  binaryToDecimal('111')   # returns 111\n  binaryToDecimal('1111')   # returns 1111\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryToDecimal = parseInt(binary, 2);\n\n  for (let i = 0; i < binaryToDecimal.length; i++) {\n    if (binaryToDecimal[i] === '1') {\n      decimal += '1';\n    } else {\n      decimal += '0';\n    }\n  }\n\n  return decimal;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  decimalToBinary('111')   # returns 111\n  decimalToBinary('1111')   # returns 1111\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let decimalToBinary = parseInt(decimal, 2);\n\n  for (let i = 0; i < decimalToBinary.length; i++) {\n    if (decimalToBinary[i] === '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n\n  return binary;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  binaryToDecimal('111')   # returns 111\n  binaryToDecimal('1111')   # returns 1111\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryToDecimal = parseInt(binary, 2);\n\n  for (let i = 0; i < binaryToDecimal.length; i++) {\n    if (binaryToDecimal[i] === '1') {\n      decimal += '1';\n    } else {\n      decimal += '0';\n    }\n  }\n\n  return decimal;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  decimalToBinary('111')   # returns 111\n  decimalToBinary('1111')   # returns 1111\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let decimalToBinary = parseInt(decimal, 2);\n\n  for (let i = 0; i < decimalToBinary.length; i++) {\n    if (decimalToBinary[i] === '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n\n  return binary;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  binaryToDecimal('111')   # returns 111\n  binaryToDecimal('1111')   # returns 1111\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryToDecimal = parseInt(binary, 2);\n\n  for (let i = 0; i < binaryToDecimal.length; i++) {\n    if (binaryToDecimal[i] === '1') {\n      decimal += '1';\n    } else {\n      decimal += '0';\n    }\n  }\n\n  return decimal;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  decimalToBinary('111')   # returns 111\n  decimalToBinary('1111')   # returns 1111\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let decimalToBinary = parseInt(decimal, 2);\n\n  for (let i = 0; i < decimalToBinary.length; i++) {\n    if (decimalToBinary[i] === '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n\n  return binary;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  binaryToDecimal('111')   # returns 111\n  binaryToDecimal('1111')   # returns 1111\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryToDecimal = parseInt(binary, 2);\n\n  for (let i = 0; i < binaryToDecimal.length; i++) {\n    if (binaryToDecimal[i] === '1') {\n      decimal += '1';\n    } else {\n      decimal += '0';\n    }\n  }\n\n  return decimal;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  decimalToBinary('111')   # returns 111\n  decimalToBinary('1111')   # returns 1111\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let decimalToBinary = parseInt(decimal, 2);\n\n  for (let i = 0; i < decimalToBinary.length; i++) {\n    if (decimalToBinary[i] === '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n\n  return binary;\n};\n\n/*\n  Given a string, convert it to a binary number in decimal form.\n\n  Examples:\n  binaryToDecimal('111')   # returns 111\n  binaryToDecimal('1111')   # returns 1111\n  */\nconst binaryToDecimal = (binary) => {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "gc": "<|endoftext|>/* For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n  Empty sum should be equal to 0 and empty product should be equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* Given a string, return its length, in characters, without spaces.\n  >>> lengthOf('Hello world!')\n  6\n  */\nconst lengthOf = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, return its length, in words, without spaces.\n  >>> lengthOf('Hello world!')\n  6\n  */\nconst lengthOfWords = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, return its length, in characters, without spaces, in uppercase.\n  >>> lengthOf('Hello world!')\n  6\n  */\nconst lengthOfUpperCase = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, return its length, in words, without spaces, in uppercase.\n  >>> lengthOf('Hello world!')\n  6\n  */\nconst lengthOfUpperCaseWords = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, return its length, in characters, without spaces, in lowercase.\n  >>> lengthOf('Hello world!')\n  6\n  */\nconst lengthOfLowerCase = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, return its length, in words, without spaces, in lowercase.\n  >>> lengthOf('Hello world!')\n  6\n  */\nconst lengthOfLowerCaseWords = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, return its length, in characters, without spaces, in uppercase and without spaces.\n  >>> lengthOf('Hello world!')\n  6\n  */\nconst lengthOfUpperCaseAndWithoutSpaces = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, return its length, in words, without spaces, in uppercase and without spaces.\n  >>> lengthOf('Hello world!')\n  6\n  */\nconst lengthOfUpperCaseAndWithoutSpacesWords = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, return its length, in characters, without spaces, in lowercase and without spaces.\n  >>> lengthOf('Hello world!')\n  6\n  */\nconst lengthOfLowerCaseAndWithoutSpaces = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, return its length, in words, without spaces, in lowercase and without spaces.\n  >>> lengthOf('Hello world!')\n  6\n  */\nconst lengthOfLowerCaseAndWithoutSpacesWords = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, return its length, in characters, without spaces, in uppercase and without spaces, in lowercase.\n  >>> lengthOf('Hello world!')\n  6\n  */\nconst lengthOfUpperCaseAndWithoutSpacesAndLowerCase = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, return its length, in words, without spaces, in uppercase and without spaces, in lowercase and without spaces.\n  >>> lengthOf('Hello world!')\n  6\n  */\nconst lengthOfUpperCaseAndWithoutSpacesAndLowerCaseWords = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, return its length, in characters, without spaces, in uppercase and without spaces, in lowercase and without spaces.\n  >>> lengthOf('Hello world!')\n  6\n  */\nconst lengthOfUpperCaseAndWithoutSpacesAndLowerCaseWordsWords = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, return its length, in characters, without spaces, in uppercase and without spaces, in lowercase and without spaces, in uppercase and without spaces.\n  >>> lengthOf('Hello world!')\n  6\n  */\nconst lengthOfUpperCaseAndWithoutSpacesAndLowerCaseWordsWordsWords = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, return its length, in characters, without spaces, in uppercase and without spaces, in lowercase and without spaces, in uppercase and without spaces, in lowercase and without spaces.\n  >>> lengthOf('Hello world!')\n  6\n  */\nconst lengthOfUpperCaseAndWithoutSpacesAndLowerCaseWordsWordsWordsWords = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, return its length, in characters, without spaces, in uppercase and without spaces, in lowercase and without spaces, in uppercase and without spaces, in lowercase and without spaces, in uppercase and without spaces, in lowercase and without spaces.\n  >>> lengthOf('Hello world!')\n  6\n  */\nconst lengthOfUpperCaseAndWithoutSpacesAndLowerCaseWordsWordsWordsWordsWords = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/* Given a string, return its length, in characters, without spaces, in uppercase and without spaces, in lowercase and without spaces, in uppercase and without spaces, in lowercase and without spaces, in uppercase and without spaces, in lowercase and without spaces, in uppercase and without spaces, in lowercase and without spaces, in uppercase and without spaces, in lowercase and without spaces, in uppercase and without spaces, in lowercase and without spaces, in uppercase and without spaces, in lowercase and without spaces, in uppercase and without spaces, in lowercase and without spaces, in uppercase and without spaces, in lowercase and without spaces, in uppercase and without spaces, in lowercase and without space", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/80", "prompt": "/*You are given a string s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "gc": "<|endoftext|>/*You are given a string s.\n  Your task is to check if the string is happy or not.\n  A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let isHappy = true;\n  let letterCount = 0;\n  let letterCount2 = 0;\n  let letterCount3 = 0;\n  let letterCount4 = 0;\n  let letterCount5 = 0;\n  let letterCount6 = 0;\n  let letterCount7 = 0;\n  let letterCount8 = 0;\n  let letterCount9 = 0;\n  let letterCount10 = 0;\n  let letterCount11 = 0;\n  let letterCount12 = 0;\n  let letterCount13 = 0;\n  let letterCount14 = 0;\n  let letterCount15 = 0;\n  let letterCount16 = 0;\n  let letterCount17 = 0;\n  let letterCount18 = 0;\n  let letterCount19 = 0;\n  let letterCount20 = 0;\n  let letterCount21 = 0;\n  let letterCount22 = 0;\n  let letterCount23 = 0;\n  let letterCount24 = 0;\n  let letterCount25 = 0;\n  let letterCount26 = 0;\n  let letterCount27 = 0;\n  let letterCount28 = 0;\n  let letterCount29 = 0;\n  let letterCount30 = 0;\n  let letterCount31 = 0;\n  let letterCount32 = 0;\n  let letterCount33 = 0;\n  let letterCount34 = 0;\n  let letterCount35 = 0;\n  let letterCount36 = 0;\n  let letterCount37 = 0;\n  let letterCount38 = 0;\n  let letterCount39 = 0;\n  let letterCount40 = 0;\n  let letterCount41 = 0;\n  let letterCount42 = 0;\n  let letterCount43 = 0;\n  let letterCount44 = 0;\n  let letterCount45 = 0;\n  let letterCount46 = 0;\n  let letterCount47 = 0;\n  let letterCount48 = 0;\n  let letterCount49 = 0;\n  let letterCount50 = 0;\n  let letterCount51 = 0;\n  let letterCount52 = 0;\n  let letterCount53 = 0;\n  let letterCount54 = 0;\n  let letterCount55 = 0;\n  let letterCount56 = 0;\n  let letterCount57 = 0;\n  let letterCount58 = 0;\n  let letterCount59 = 0;\n  let letterCount60 = 0;\n  let letterCount61 = 0;\n  let letterCount62 = 0;\n  let letterCount63 = 0;\n  let letterCount64 = 0;\n  let letterCount65 = 0;\n  let letterCount66 = 0;\n  let letterCount67 = 0;\n  let letterCount68 = 0;\n  let letterCount69 = 0;\n  let letterCount70 = 0;\n  let letterCount71 = 0;\n  let letterCount72 = 0;\n  let letterCount73 = 0;\n  let letterCount74 = 0;\n  let letterCount75 = 0;\n  let letterCount76 = 0;\n  let letterCount77 = 0;\n  let letterCount78 = 0;\n  let letterCount79 = 0;\n  let letterCount80 = 0;\n  let letterCount81 = 0;\n  let letterCount82 = 0;\n  let letterCount83 = 0;\n  let letterCount84 = 0;\n  let letterCount85 = 0;\n  let letterCount86 = 0;\n  let letterCount87 = 0;\n  let letterCount88 = 0;\n  let letterCount89 = 0;\n  let letterCount90 = 0;\n  let letterCount91 = 0;\n  let letterCount92 = 0;\n  let letterCount93 = 0;\n  let letterCount94 = 0;\n  let letterCount95 = 0;\n  let letterCount96 = 0;\n  let letterCount97 = 0;\n  let letterCount98 = 0;\n  let letterCount99 = 0;\n  let letterCount100 = 0;\n  let letterCount101 = 0;\n  let letterCount102 = 0;\n  let letterCount103 = 0;\n  let letterCount104 = 0;\n  let letterCount105 = 0;\n  let letterCount106 = 0;\n  let letterCount107 = 0;\n  let letterCount108 = 0;\n  let letterCount109 = 0;\n  let letterCount110 = 0;\n  let letterCount111 = 0;\n  let letterCount112 = 0;\n  let letterCount113 = 0;\n  let letterCount114 = 0;\n  let letterCount115 = 0;\n  let letterCount116 = 0;\n  let letterCount117 = 0;\n  let letterCount118 = 0;\n  let letterCount119 = 0;\n  let letterCount120 = 0;\n  let letterCount121 = 0;\n  let letterCount122 = 0;\n  let letterCount123 = 0;\n  let letterCount124 = 0;\n  let letterCount125 = 0;\n  let letterCount126 = 0;\n  let letterCount127 = 0;\n  let letterCount128 = 0;\n  let letterCount129 = 0;\n  let letterCount130 = 0;\n  let letterCount131 = 0;\n  let letterCount132 = 0;\n  let letterCount133 = 0;\n  let letterCount134 = 0;\n  let letterCount135 = 0;\n  let letterCount136 = 0;\n  let letterCount137 = 0;\n  let letterCount138 = 0;\n  let letterCount139 = 0;\n  let letterCount140 = 0;\n  let letterCount141 = 0;\n  let letterCount142 = 0;\n  let letterCount143 = 0;\n  let letterCount144 = 0;\n  let letterCount145 = 0;\n  let letterCount146 = 0;\n  let letterCount147 = 0;\n  let letterCount148 = 0;\n  let letterCount149 = 0;\n  let letterCount150 = 0;\n  let letterCount151 = 0;\n  let letterCount152 = 0;\n  let letterCount153 = 0;\n  let letterCount154 = 0;\n  let letterCount155 = 0;\n  let letterCount156 = 0;\n  let letterCount157 = 0;\n  let letterCount158 = 0;\n  let letterCount159 = 0;\n  let letterCount160 = 0;\n  let letterCount161 = 0;\n  let letterCount162 = 0;\n  let letterCount163 = 0;\n  let letterCount164 = 0;\n  let letterCount165 = 0;\n  let letterCount166 = 0;\n  let letterCount167 = 0;\n  let letterCount168 = 0;\n  let letterCount169 = 0;\n  let letterCount170 = 0;\n  let letterCount171 = 0;\n  let letterCount172 = 0;\n  let letterCount173 = 0;\n  let letterCount174 = 0;\n  let letterCount175 = 0;\n  let letterCount176 = 0;\n  let letterCount177 = 0;\n  let letterCount178 = 0;\n  let letterCount179 = 0;\n  let letterCount180 = 0;\n  let letterCount181 = 0;\n  let letterCount182 = 0;\n  let letterCount183 = 0;\n  let letterCount184 = 0;\n  let letterCount185 = 0;\n  let letterCount186 = 0;\n  let letterCount187 = 0;\n  let letterCount188 = 0;\n  let letterCount189 = 0;\n  let letterCount190 = 0;\n  let letterCount191 = 0;\n  let letterCount192 = 0;\n  let letterCount193 = 0;\n  let letterCount194 = 0;\n  let letterCount195 = 0;\n  let letterCount196 = 0;\n  let letterCount197 = 0;\n  let letterCount198 = 0;\n  let letterCount199 = 0;\n  let letterCount200 = 0;\n  let letterCount201 = 0;\n  let letterCount202 = 0;\n  let letterCount203 = 0;\n  let letterCount204 = 0;\n  let letterCount205 = 0;\n  let letterCount206 = 0;\n  let letterCount207 = 0;\n  let letterCount208 = 0;\n  let letterCount209 = 0;\n  let letterCount210 = 0;\n  let letterCount211 = 0;\n  let letterCount212 = 0;\n  let letterCount213 = 0;\n  let letterCount214 = 0;\n  let letterCount215 = 0;\n  let letterCount216 = 0;\n  let letterCount217 = 0;\n  let letterCount218 = 0;\n  let letterCount219 = 0;\n  let letterCount220 = 0;\n  let letterCount221 = 0;\n  let letterCount222 = 0;\n  let letterCount223 = 0;\n  let letterCount224 = 0;\n  let letterCount225 = 0;\n  let letterCount226 = 0;\n  let letterCount227 = 0;\n  let letterCount228 = 0;\n  let letterCount229 = 0;\n  let letterCount230 = 0;\n  let letterCount231 = 0;\n  let letterCount232 = 0;\n  let letterCount233 = 0;\n  let letterCount234 = 0;\n  let letterCount235 = 0;\n  let letterCount236 = 0;\n  let letterCount237 = 0;\n  let letterCount238 = 0;\n  let letter", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/81", "prompt": "/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  nmueriaclLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst nmueriaclLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "nmueriaclLetterGrade", "gc": "<|endoftext|>/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  nmueriaclLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst nmueriaclLetterGrade = (grades) => {\n  const letterGrades = grades.map((grade) => {\n    const letterGrade = grade.toString().toUpperCase();\n    return letterGrade;\n  });\n  return letterGrades;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  nmueriaclLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst nmueriaclLetterGrade2 = (grades) => {\n  const letterGrades = grades.map((grade) => {\n    const letterGrade = grade.toString().toUpperCase();\n    return letterGrade;\n  });\n  return letterGrades;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  nmueriaclLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst nmueriaclLetterGrade3 = (grades) => {\n  const letterGrades = grades.map((grade) => {\n    const letterGrade = grade.toString().toUpperCase();\n    return letterGrade;\n  });\n  return letterGrades;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  nmueriaclLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst nmueriaclLetterGrade4 = (grades) => {\n  const letterGrades = grades.map((grade) => {\n    const letterGrade = grade.toString().toUpperCase();\n    return letterGrade;\n  });\n  return letterGrades;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  nmueriaclLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst nmueriaclLetterGrade5 = (grades) => {\n  const letterGrades = grades.map((grade) => {\n    const letterGrade = grade.toString().toUpperCase();\n    return letterGrade;\n  });\n  return letterGrades;\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  nmueriaclLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst nmu", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/82", "prompt": "/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "gc": "<|endoftext|>/*Write a function that takes a string and returns true if the string\n  length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let isPrime = true;\n  let length = string.length;\n  let factor = 2;\n  while (length > 1) {\n    if (length % factor === 0) {\n      isPrime = false;\n      break;\n    }\n    factor++;\n    length--;\n  }\n  return isPrime;\n};\n\n/*Write a function that takes a string and returns true if the string\n  is a palindrome or false otherwise\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('kittens') === false\n  */\nconst palindrome = (string) => {\n  let isPalindrome = true;\n  let length = string.length;\n  let reversedString = string.split('').reverse().join('');\n  let reversedStringLength = reversedString.length;\n  if (reversedStringLength!== length) {\n    isPalindrome = false;\n  }\n  return isPalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n  is a palindrome or false otherwise\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('kittens') === false\n  */\nconst isPalindrome = (string) => {\n  let isPalindrome = true;\n  let length = string.length;\n  let reversedString = string.split('').reverse().join('');\n  let reversedStringLength = reversedString.length;\n  if (reversedStringLength!== length) {\n    isPalindrome = false;\n  }\n  return isPalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n  is a palindrome or false otherwise\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('kittens') === false\n  */\nconst isPalindromeReversed = (string) => {\n  let isPalindrome = true;\n  let length = string.length;\n  let reversedString = string.split('').reverse().join('');\n  let reversedStringLength = reversedString.length;\n  if (reversedStringLength!== length) {\n    isPalindrome = false;\n  }\n  return isPalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n  is a palindrome or false otherwise\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('kittens') === false\n  */\nconst isPalindromeReversedString = (string) => {\n  let isPalindrome = true;\n  let length = string.length;\n  let reversedString = string.split('').reverse().join('');\n  let reversedStringLength = reversedString.length;\n  if (reversedStringLength!== length) {\n    isPalindrome = false;\n  }\n  return isPalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n  is a palindrome or false otherwise\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('kittens') === false\n  */\nconst isPalindromeReversedString2 = (string) => {\n  let isPalindrome = true;\n  let length = string.length;\n  let reversedString = string.split('').reverse().join('');\n  let reversedStringLength = reversedString.length;\n  if (reversedStringLength!== length) {\n    isPalindrome = false;\n  }\n  return isPalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n  is a palindrome or false otherwise\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('kittens') === false\n  */\nconst isPalindromeReversedString3 = (string) => {\n  let isPalindrome = true;\n  let length = string.length;\n  let reversedString = string.split('').reverse().join('');\n  let reversedStringLength = reversedString.length;\n  if (reversedStringLength!== length) {\n    isPalindrome = false;\n  }\n  return isPalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n  is a palindrome or false otherwise\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('kittens') === false\n  */\nconst isPalindromeReversedString4 = (string) => {\n  let isPalindrome = true;\n  let length = string.length;\n  let reversedString = string.split('').reverse().join('');\n  let reversedStringLength = reversedString.length;\n  if (reversedStringLength!== length) {\n    isPalindrome = false;\n  }\n  return isPalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n  is a palindrome or false otherwise\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('kittens') === false\n  */\nconst isPalindromeReversedString5 = (string) => {\n  let isPalindrome = true;\n  let length = string.length;\n  let reversedString = string.split('').reverse().join('');\n  let reversedStringLength = reversedString.length;\n  if (reversedStringLength!== length) {\n    isPalindrome = false;\n  }\n  return isPalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n  is a palindrome or false otherwise\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('kittens') === false\n  */\nconst isPalindromeReversedString6 = (string) => {\n  let isPalindrome = true;\n  let length = string.length;\n  let reversedString = string.split('').reverse().join('');\n  let reversedStringLength = reversedString.length;\n  if (reversedStringLength!== length) {\n    isPalindrome = false;\n  }\n  return isPalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n  is a palindrome or false otherwise\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('kittens') === false\n  */\nconst isPalindromeReversedString7 = (string) => {\n  let isPalindrome = true;\n  let length = string.length;\n  let reversedString = string.split('').reverse().join('');\n  let reversedStringLength = reversedString.length;\n  if (reversedStringLength!== length) {\n    isPalindrome = false;\n  }\n  return isPalindrome;\n};\n\n/*Write a function that takes a string and returns true if the string\n  is a palindrome or false otherwise\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('kittens') === false\n  */\nconst isPalindromeReversedString8 = (string) => {\n  let isPalindrome", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/83", "prompt": "/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "gc": "<|endoftext|>/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 1.\n  */\nconst startsOneEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      if (i === 1) {\n        count += 1;\n      }\n      n /= 10;\n      i++;\n    } else {\n      n /= 10;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 2.\n  */\nconst startsTwoEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      if (i === 2) {\n        count += 1;\n      }\n      n /= 10;\n      i++;\n    } else {\n      n /= 10;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 3.\n  */\nconst startsThreeEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      if (i === 3) {\n        count += 1;\n      }\n      n /= 10;\n      i++;\n    } else {\n      n /= 10;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 4.\n  */\nconst startsFourEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      if (i === 4) {\n        count += 1;\n      }\n      n /= 10;\n      i++;\n    } else {\n      n /= 10;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 5.\n  */\nconst startsFiveEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      if (i === 5) {\n        count += 1;\n      }\n      n /= 10;\n      i++;\n    } else {\n      n /= 10;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 6.\n  */\nconst startsSixEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      if (i === 6) {\n        count += 1;\n      }\n      n /= 10;\n      i++;\n    } else {\n      n /= 10;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 7.\n  */\nconst startsSevenEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      if (i === 7) {\n        count += 1;\n      }\n      n /= 10;\n      i++;\n    } else {\n      n /= 10;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 8.\n  */\nconst startsEightEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      if (i === 8) {\n        count += 1;\n      }\n      n /= 10;\n      i++;\n    } else {\n      n /= 10;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 9.\n  */\nconst startsNineEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      if (i === 9) {\n        count += 1;\n      }\n      n /= 10;\n      i++;\n    } else {\n      n /= 10;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 10.\n  */\nconst startsTenEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      if (i === 10) {\n        count += 1;\n      }\n      n /= 10;\n      i++;\n    } else {\n      n /= 10;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 11.\n  */\nconst startsElevenEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      if (i === 11) {\n        count += 1;\n      }\n      n /= 10;\n      i++;\n    } else {\n      n /= 10;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 12.\n  */\nconst startsTwelveEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      if (i === 12) {\n        count += 1;\n      }\n      n /= 10;\n      i++;\n    } else {\n      n /= 10;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 13.\n  */\nconst startsThirteenEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      if (i === 13) {\n        count += 1;\n      }\n      n /= 10;\n      i++;\n    } else {\n      n /= 10;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 14.\n  */\nconst startsFourteenEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      if (i === 14) {\n        count += 1;\n      }\n      n /= 10;\n      i++;\n    } else {\n      n /= 10;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 15.\n  */\nconst startsFifteenEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      if (i === 15) {\n        count += 1;\n      }\n      n /= 10;\n      i++;\n    } else {\n      n /= 10;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 16.\n  */\nconst startsSixteenEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      if (i === 16) {\n        count += 1;\n      }\n      n /= 10;\n      i++;\n    } else {\n      n /= 10;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return the count of the numbers of n-digit\n  positive integers that start or end with 17.\n  */\nconst startsSeventeenEnds = (n) => {\n  let count = 0;\n  let i = 1;\n  while (n > 0) {\n    if (n % 10 === 0) {\n      if (i === 17) {\n        count += 1;\n      }\n      ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive integer N, return the total sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "gc": "<|endoftext|>/*Given a positive integer N, return the total sum of its digits in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  let binary = binary.concat(N.toString(2));\n  \n  for (let i = binary.length - 1; i >= 0; i--) {\n    sum += parseInt(binary[i], 2);\n    binary = binary.slice(0, i) + binary[i + 1];\n  }\n  \n  return sum;\n};\n\n/*Given a positive integer N, return the number of digits in the binary representation of N.\n  \n  Example\n      For N = 1000, the output should be \"1\".\n      For N = 150, the output should be \"6\".\n      For N = 147, the output should be \"12\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer\n  */\nconst countDigits = (N) => {\n  let count = 0;\n  let binary = \"\";\n  let binary = binary.concat(N.toString(2));\n  \n  for (let i = binary.length - 1; i >= 0; i--) {\n    count += parseInt(binary[i], 2);\n    binary = binary.slice(0, i) + binary[i + 1];\n  }\n  \n  return count;\n};\n\n/*Given a positive integer N, return the number of trailing zeroes in the binary representation of N.\n  \n  Example\n      For N = 1000, the output should be \"1\".\n      For N = 150, the output should be \"6\".\n      For N = 147, the output should be \"12\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer\n  */\nconst countTrailingZeroes = (N) => {\n  let count = 0;\n  let binary = \"\";\n  let binary = binary.concat(N.toString(2));\n  \n  for (let i = binary.length - 1; i >= 0; i--) {\n    if (parseInt(binary[i], 2) === 0) {\n      count++;\n      binary = binary.slice(0, i) + binary[i + 1];\n    }\n  }\n  \n  return count;\n};\n\n/*Given a positive integer N, return the number of trailing ones in the binary representation of N.\n  \n  Example\n      For N = 1000, the output should be \"1\".\n      For N = 150, the output should be \"6\".\n      For N = 147, the output should be \"12\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer\n  */\nconst countTrailingOnes = (N) => {\n  let count = 0;\n  let binary = \"\";\n  let binary = binary.concat(N.toString(2));\n  \n  for (let i = binary.length - 1; i >= 0; i--) {\n    if (parseInt(binary[i], 2) === 1) {\n      count++;\n      binary = binary.slice(0, i) + binary[i + 1];\n    }\n  }\n  \n  return count;\n};\n\n/*Given a positive integer N, return the number of trailing ones in the binary representation of N.\n  \n  Example\n      For N = 1000, the output should be \"1\".\n      For N = 150, the output should be \"6\".\n      For N = 147, the output should be \"12\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer\n  */\nconst countTrailingOdds = (N) => {\n  let count = 0;\n  let binary = \"\";\n  let binary = binary.concat(N.toString(2));\n  \n  for (let i = binary.length - 1; i >= 0; i--) {\n    if (parseInt(binary[i], 2) === 2) {\n      count++;\n      binary = binary.slice(0, i) + binary[i + 1];\n    }\n  }\n  \n  return count;\n};\n\n/*Given a positive integer N, return the number of trailing ones in the binary representation of N.\n  \n  Example\n      For N = 1000, the output should be \"1\".\n      For N = 150, the output should be \"6\".\n      For N = 147, the output should be \"12\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer\n  */\nconst countTrailingEvens = (N) => {\n  let count = 0;\n  let binary = \"\";\n  let binary = binary.concat(N.toString(2));\n  \n  for (let i = binary.length - 1; i >= 0; i--) {\n    if (parseInt(binary[i], 2) === 3) {\n      count++;\n      binary = binary.slice(0, i) + binary[i + 1];\n    }\n  }\n  \n  return count;\n};\n\n/*Given a positive integer N, return the number of trailing ones in the binary representation of N.\n  \n  Example\n      For N = 1000, the output should be \"1\".\n      For N = 150, the output should be \"6\".\n      For N = 147, the output should be \"12\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer\n  */\nconst countTrailingDividedByTen = (N) => {\n  let count = 0;\n  let binary = \"\";\n  let binary = binary.concat(N.toString(2));\n  \n  for (let i = binary.length - 1; i >= 0; i--) {\n    if (parseInt(binary[i], 2) === 10) {\n      count++;\n      binary = binary.slice(0, i) + binary[i + 1];\n    }\n  }\n  \n  return count;\n};\n\n/*Given a positive integer N, return the number of trailing ones in the binary representation of N.\n  \n  Example\n      For N = 1000, the output should be \"1\".\n      For N = 150, the output should be \"6\".\n      For N = 147, the output should be \"12\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer\n  */\nconst countTrailingDividedByTenAndOnes = (N) => {\n  let count = 0;\n  let binary = \"\";\n  let binary = binary.concat(N.toString(2));\n  \n  for (let i = binary.length - 1; i >= 0; i--) {\n    if (parseInt(binary[i], 2) === 10) {\n      count++;\n      binary = binary.slice(0, i) + binary[i + 1];\n    }\n  }\n  \n  if (parseInt(binary[i], 2) === 1) {\n    count++;\n    binary = binary.slice(0, i) + binary[i + 1];\n  }\n  \n  return count;\n};\n\n/*Given a positive integer N, return the number of trailing ones in the binary representation of N.\n  \n  Example\n      For N = 1000, the output should be \"1\".\n      For N = 150, the output should be \"6\".\n      For N = 147, the output should be \"12\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       an integer\n  */\nconst countTrailingDividedByTenAndOdds = (N) => {\n  let count = 0;\n  let binary = \"\";\n  let binary = binary.concat(N.toString(2));\n  \n  for (let i = binary.length - 1; i >= 0; i--) {\n    if (parseInt(binary[i], 2) === 10) {\n      count++;\n      binary = binary.", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "gc": "<|endoftext|>/*Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.concat(odd);\n};\n\n/*Given a non-empty list of integers lst. return the sum of all even elements that are at odd indices..\n\n\n  Examples:\n      sum([]) ==> 0\n      sum([4, 2, 6, 7]) ==> 6\n  */\nconst sum = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.reduce((acc, x) => acc + x, 0) + odd.reduce((acc, x) => acc + x, 0);\n};\n\n/*Given a non-empty list of integers lst. return the product of all even elements that are at odd indices..\n\n\n  Examples:\n      prod([]) ==> 1\n      prod([4, 2, 6, 7]) ==> 24\n  */\nconst prod = (lst, acc) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.reduce((acc, x) => acc + x * x, acc) * odd.reduce((acc, x) => acc + x * x, acc);\n};\n\n/*Given a non-empty list of integers lst. return the sum of all even elements that are at odd indices and product of all odd elements that are at even indices..\n\n\n  Examples:\n      sumAndProd([4, 2, 6, 7]) ==> 24\n      sumAndProd([4, 2, 6, 7], 2) ==> 24 * 6\n  */\nconst sumAndProd = (lst, acc) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.reduce((acc, x) => acc + x * x, acc) + odd.reduce((acc, x) => acc + x * x, acc) * acc;\n};\n\n/*Given a non-empty list of integers lst. return the product of all even elements that are at odd indices and sum of all odd elements that are at even indices..\n\n\n  Examples:\n      prodAndSum([4, 2, 6, 7]) ==> 24 * 6\n      prodAndSum([4, 2, 6, 7], 2) ==> 24 * 6 + 2 * 6\n  */\nconst prodAndSum = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.reduce((acc, x) => acc + x * x, acc) * odd.reduce((acc, x) => acc + x * x, acc);\n};\n\n/*Given a non-empty list of integers lst. return the sum of all even elements that are at odd indices and product of all odd elements that are at even indices and sum of all even elements that are at odd indices and product of all even elements that are at odd indices and sum of all odd elements that are at even indices..\n\n\n  Examples:\n      sumAndProdAndSum([4, 2, 6, 7]) ==> 24 * 6 + 2 * 6 + 2 * 6\n      sumAndProdAndSum([4, 2, 6, 7], 2) ==> 24 * 6 + 2 * 6 + 2 * 6\n  */\nconst sumAndProdAndSum = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.reduce((acc, x) => acc + x * x, acc) + odd.reduce((acc, x) => acc + x * x, acc) * acc;\n};\n\n/*Given a non-empty list of integers lst. return the product of all even elements that are at odd indices and sum of all odd elements that are at even indices and product of all even elements that are at odd indices and sum of all even elements that are at odd indices and product of all odd elements that are at even indices..\n\n\n  Examples:\n      prodAndSumAndProdAndSum([4, 2, 6, 7]) ==> 24 * 6 + 2 * 6 + 2 * 6 + 2 * 6\n      prodAndSumAndProdAndSum([4, 2, 6, 7], 2) ==> 24 * 6 + 2 * 6 + 2 * 6 + 2 * 6\n  */\nconst prodAndSumAndProdAndSum = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.reduce((acc, x) => acc + x * x, acc) + odd.reduce((acc, x) => acc + x * x, acc) * acc;\n};\n\n/*Given a non-empty list of integers lst. return the sum of all even elements that are at odd indices and product of all odd elements that are at even indices and sum of all even elements that are at odd indices and product of all even elements that are at odd indices and sum of all odd elements that are at even indices and product of all even elements that are at odd indices and sum of all odd elements that are at even indices..\n\n\n  Examples:\n      sumAndProdAndSumAndProdAndSum([4, 2, 6, 7]) ==> 24 * 6 + 2 * 6 + 2 * 6 + 2 * 6 + 2 * 6 + 2 * 6\n      sumAndProdAndSumAndProdAndSum([4, 2, 6, 7], 2) ==> 24 * 6 + 2 * 6 + 2 * 6 + 2 * 6 + 2 * 6 + 2 * 6\n  */\nconst sumAndProdAndSumAndProdAndSum = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.reduce((acc, x) => acc + x * x, acc) + odd.reduce((acc, x) => acc + x * x, acc) * acc;\n};\n\n/*Given a non-empty list of integers lst. return the product of all even elements that are at odd indices and sum of all odd elements that are at even indices and product of all even elements that are at odd indices and sum of all even elements that are at odd indices and product of all odd elements that are at even indices and sum of all even elements that are at odd indices and product of all odd elements that are at even indices..\n\n\n  Examples:\n      prodAndSumAndProdAndSumAndProdAndSum([4, 2, 6, 7]) ==> 24 * 6 + 2 * 6 + 2 * 6 + 2 * 6 + 2 * 6 + 2 * 6 + 2 * 6\n      prodAndSumAndProdAndSumAndProdAndSum([4, 2, 6, 7], 2) ==> 24 * 6 + 2 * 6 + 2 * 6 + 2 * 6 + 2 * 6 + 2 * 6 + 2 * 6 + 2 * 6\n  */\nconst prodAndSumAndProdAndSumAndProdAndSum = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  let odd = lst.filter(x => x % 2!== 0);\n  return even.reduce((acc, x) => acc + x * x, acc) + odd.reduce((acc, x) => acc + x * x, acc) * acc;\n};\n\n/*Given a non-empty list of integers lst. return the product of all even elements that are at odd indices and sum of all odd elements that are at even indices and product of all even elements that are at odd indices and sum of all even elements that are at odd indices and product of all odd elements that are at even indices and sum of all odd elements that are at odd indices and product of all even elements that are at odd indices and sum of all odd elements that are at even indices..\n\n\n  Examples:\n      prodAndSumAndProdAndSumAndProdAndSumAndProdAndSum([4, 2, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antSihuffle('Hi') returns 'Hi'\n  antSihuffle('hello') returns 'ehllo'\n  antSihuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antSihuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antSihuffle", "gc": "<|endoftext|>/*\n  Write a function that takes a string and returns an ordered version of it.\n  Ordered version of string, is a string where all words (separated by space)\n  are replaced by a new word where all the characters arranged in\n  ascending order based on ascii value.\n  Note: You should keep the order of words and blank spaces in the sentence.\n\n  For example:\n  antSihuffle('Hi') returns 'Hi'\n  antSihuffle('hello') returns 'ehllo'\n  antSihuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antSihuffle = (s) => {\n  let newStr = '';\n  let newStrArr = [];\n  let newStrArr2 = [];\n  let newStrArr3 = [];\n  let newStrArr4 = [];\n  let newStrArr5 = [];\n  let newStrArr6 = [];\n  let newStrArr7 = [];\n  let newStrArr8 = [];\n  let newStrArr9 = [];\n  let newStrArr10 = [];\n  let newStrArr11 = [];\n  let newStrArr12 = [];\n  let newStrArr13 = [];\n  let newStrArr14 = [];\n  let newStrArr15 = [];\n  let newStrArr16 = [];\n  let newStrArr17 = [];\n  let newStrArr18 = [];\n  let newStrArr19 = [];\n  let newStrArr20 = [];\n  let newStrArr21 = [];\n  let newStrArr22 = [];\n  let newStrArr23 = [];\n  let newStrArr24 = [];\n  let newStrArr25 = [];\n  let newStrArr26 = [];\n  let newStrArr27 = [];\n  let newStrArr28 = [];\n  let newStrArr29 = [];\n  let newStrArr30 = [];\n  let newStrArr31 = [];\n  let newStrArr32 = [];\n  let newStrArr33 = [];\n  let newStrArr34 = [];\n  let newStrArr35 = [];\n  let newStrArr36 = [];\n  let newStrArr37 = [];\n  let newStrArr38 = [];\n  let newStrArr39 = [];\n  let newStrArr40 = [];\n  let newStrArr41 = [];\n  let newStrArr42 = [];\n  let newStrArr43 = [];\n  let newStrArr44 = [];\n  let newStrArr45 = [];\n  let newStrArr46 = [];\n  let newStrArr47 = [];\n  let newStrArr48 = [];\n  let newStrArr49 = [];\n  let newStrArr50 = [];\n  let newStrArr51 = [];\n  let newStrArr52 = [];\n  let newStrArr53 = [];\n  let newStrArr54 = [];\n  let newStrArr55 = [];\n  let newStrArr56 = [];\n  let newStrArr57 = [];\n  let newStrArr58 = [];\n  let newStrArr59 = [];\n  let newStrArr60 = [];\n  let newStrArr61 = [];\n  let newStrArr62 = [];\n  let newStrArr63 = [];\n  let newStrArr64 = [];\n  let newStrArr65 = [];\n  let newStrArr66 = [];\n  let newStrArr67 = [];\n  let newStrArr68 = [];\n  let newStrArr69 = [];\n  let newStrArr70 = [];\n  let newStrArr71 = [];\n  let newStrArr72 = [];\n  let newStrArr73 = [];\n  let newStrArr74 = [];\n  let newStrArr75 = [];\n  let newStrArr76 = [];\n  let newStrArr77 = [];\n  let newStrArr78 = [];\n  let newStrArr79 = [];\n  let newStrArr80 = [];\n  let newStrArr81 = [];\n  let newStrArr82 = [];\n  let newStrArr83 = [];\n  let newStrArr84 = [];\n  let newStrArr85 = [];\n  let newStrArr86 = [];\n  let newStrArr87 = [];\n  let newStrArr88 = [];\n  let newStrArr89 = [];\n  let newStrArr90 = [];\n  let newStrArr91 = [];\n  let newStrArr92 = [];\n  let newStrArr93 = [];\n  let newStrArr94 = [];\n  let newStrArr95 = [];\n  let newStrArr96 = [];\n  let newStrArr97 = [];\n  let newStrArr98 = [];\n  let newStrArr99 = [];\n  let newStrArr100 = [];\n  let newStrArr101 = [];\n  let newStrArr102 = [];\n  let newStrArr103 = [];\n  let newStrArr104 = [];\n  let newStrArr105 = [];\n  let newStrArr106 = [];\n  let newStrArr107 = [];\n  let newStrArr108 = [];\n  let newStrArr109 = [];\n  let newStrArr110 = [];\n  let newStrAr1111 = [];\n  let newStrArr112 = [];\n  let newStrArr113 = [];\n  let newStrArr114 = [];\n  let newStrArr115 = [];\n  let newStrArr116 = [];\n  let newStrArr117 = [];\n  let newStrArr118 = [];\n  let newStrArr119 = [];\n  let newStrArr120 = [];\n  let newStrAr121 = [];\n  let newStrAr122 = [];\n  let newStrAr123 = [];\n  let newStrAr124 = [];\n  let newStrAr125 = [];\n  let newStrAr126 = [];\n  let newStrAr127 = [];\n  let newStrAr128 = [];\n  let newStrAr129 = [];\n  let newStrAr130 = [];\n  let newStrAr131 = [];\n  let newStrAr132 = [];\n  let newStrAr133 = [];\n  let newStrAr134 = [];\n  let newStrAr135 = [];\n  let newStrAr136 = [];\n  let newStrAr137 = [];\n  let newStrAr138 = [];\n  let newStrAr139 = [];\n  let newStrAr140 = [];\n  let newStrAr141 = [];\n  let newStrAr142 = [];\n  let newStrAr143 = [];\n  let newStrAr144 = [];\n  let newStrAr145 = [];\n  let newStrAr146 = [];\n  let newStrAr147 = [];\n  let newStrAr148 = [];\n  let newStrAr149 = [];\n  let newStrAr150 = [];\n  let newStrAr151 = [];\n  let newStrAr152 = [];\n  let newStrAr153 = [];\n  let newStrAr154 = [];\n  let newStrAr155 = [];\n  let newStrAr156 = [];\n  let newStrAr157 = [];\n  let newStrAr158 = [];\n  let newStrAr159 = [];\n  let newStrAr160 = [];\n  let newStrAr161 = [];\n  let newStrAr162 = [];\n  let newStrAr163 = [];\n  let newStrAr164 = [];\n  let newStrAr165 = [];\n  let newStrAr166 = [];\n  let newStrAr167 = [];\n  let newStrAr168 = [];\n  let newStrAr169 = [];\n  let newStrAr170 = [];\n  let newStrAr171 = [];\n  let newStrAr172 = [];\n  let newStrAr173 = [];\n  let newStrAr174 = [];\n  let newStrAr175 = [];\n  let newStrAr176 = [];\n  let newStrAr177 = [];\n  let newStrAr178 = [];\n  let newStrAr179 = [];\n  let newStrAr180 = [];\n  let newStrAr181 = [];\n  let newStrAr182 = [];\n  let newStrAr183 = [];\n  let newStrAr184 = [];\n  let newStrAr185 = [];\n  let newStrAr186 = [];\n  let newStrAr187 = [];\n  let newStrAr188 = [];\n  let newStrAr189 = [];\n  let newStrAr190 = [];\n  let newStrAr191 = [];\n  let newStrAr192 = [];\n  let newStrAr193 = [];\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "gc": "<|endoftext|>/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const row = []\n  let rowIndex = 0\n  let colIndex = 0\n  let rowLen = lst[0].length\n  let colLen = lst.length\n  while (rowIndex < rowLen && colIndex < colLen) {\n    if (lst[rowIndex][colIndex] === x) {\n      row.push([rowIndex, colIndex])\n      rowIndex++\n      colIndex++\n    } else {\n      rowIndex++\n      colIndex++\n    }\n  }\n  return row\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getCol = (lst, x) => {\n  const col = []\n  let colIndex = 0\n  let rowIndex = 0\n  let rowLen = lst.length\n  let colLen = lst[0].length\n  while (colIndex < colLen && rowIndex < rowLen) {\n    if (lst[rowIndex][colIndex] === x) {\n      col.push([colIndex, rowIndex])\n      colIndex++\n      rowIndex++\n    } else {\n      colIndex++\n    }\n  }\n  return col\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getDiag = (lst, x) => {\n  const diag = []\n  let rowIndex = 0\n  let colIndex = 0\n  let rowLen = lst.length\n  let colLen = lst[0].length\n  while (rowIndex < rowLen && colIndex < colLen) {\n    if (lst[rowIndex][colIndex] === x) {\n      diag.push([rowIndex, colIndex])\n      rowIndex++\n      colIndex++\n    } else {\n      rowIndex++\n      colIndex++\n    }\n  }\n  return diag\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getDiagRow = (lst, x) => {\n  const diag = []\n  let rowIndex = 0\n  let colIndex = 0\n  let rowLen = lst.length\n  let colLen = lst[0].length\n  while (rowIndex < rowLen && colIndex < colLen) {\n    if (lst[rowIndex][colIndex] === x) {\n      diag.push([rowIndex, colIndex])\n      rowIndex++\n      colIndex++\n    } else {\n      colIndex++\n    }\n  }\n  return diag\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getDiagCol = (lst, x) => {\n  const diag = []\n  let colIndex = 0\n  let rowIndex = 0\n  let rowLen = lst.length\n  let colLen = lst[0].length\n  while (colIndex < colLen && rowIndex < rowLen) {\n    if (lst[rowIndex][colIndex] === x) {\n      diag.push([colIndex, rowIndex])\n      colIndex++\n      rowIndex++\n    } else {\n      colIndex++\n    }\n  }\n  return diag\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getDiagDiag = (lst, x) => {\n  const diag = []\n  let rowIndex = 0\n  let colIndex = 0\n  let rowLen = lst", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/88", "prompt": "/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n  or sort it in descending order if the sum( first index value, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "gc": "<|endoftext|>/*\n  Given an array of non-negative integers, return a copy of the given array after sorting,\n  you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n  or sort it in descending order if the sum( first index value, last index value) is even.\n\n  Note:\n  * don't change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sortedArray = array.sort((a, b) => {\n    if (a % 2 === 0 && b % 2 === 0) {\n      return a - b;\n    }\n    return a - b;\n  });\n  return sortedArray;\n};\n\n/**\n * Given an array of non-negative integers, return its sum.\n\n  Example:\n  * sumArray([5, 2, 7, 1, 3]) => 15\n  * sumArray([5, 2, 7, 1, 3, 6]) => 15\n  * sumArray([5, 2, 7, 1, 3, 6, 4]) => 15\n  * sumArray([5, 2, 7, 1, 3, 6, 4, 2]) => 15\n  * sumArray([5, 2, 7, 1, 3, 6, 4, 2, 1]) => 15\n  */\nconst sumArray = (array) => {\n  let sum = 0;\n  for (let i = 0; i < array.length; i++) {\n    sum += array[i];\n  }\n  return sum;\n};\n\n/**\n * Given an array of non-negative integers, return its maximum value.\n\n  Example:\n  * maxArray([5, 2, 7, 1, 3]) => 3\n  * maxArray([5, 2, 7, 1, 3, 6]) => 6\n  * maxArray([5, 2, 7, 1, 3, 6, 4]) => 6\n  * maxArray([5, 2, 7, 1, 3, 6, 4, 2]) => 6\n  * maxArray([5, 2, 7, 1, 3, 6, 4, 2, 1]) => 6\n  */\nconst maxArray = (array) => {\n  let max = 0;\n  for (let i = 0; i < array.length; i++) {\n    if (max < array[i]) {\n      max = array[i];\n    }\n  }\n  return max;\n};\n\n/**\n * Given an array of non-negative integers, return its minimum value.\n\n  Example:\n  * minArray([5, 2, 7, 1, 3]) => 1\n  * minArray([5, 2, 7, 1, 3, 6]) => 3\n  * minArray([5, 2, 7, 1, 3, 6, 4]) => 3\n  * minArray([5, 2, 7, 1, 3, 6, 4, 2]) => 3\n  * minArray([5, 2, 7, 1, 3, 6, 4, 2, 1]) => 3\n  */\nconst minArray = (array) => {\n  let min = 0;\n  for (let i = 0; i < array.length; i++) {\n    if (min > array[i]) {\n      min = array[i];\n    }\n  }\n  return min;\n};\n\n/**\n * Given an array of non-negative integers, return its median value.\n\n  Example:\n  * medianArray([5, 2, 7, 1, 3]) => 3\n  * medianArray([5, 2, 7, 1, 3, 6]) => 3\n  * medianArray([5, 2, 7, 1, 3, 6, 4]) => 3\n  * medianArray([5, 2, 7, 1, 3, 6, 4, 2]) => 3\n  * medianArray([5, 2, 7, 1, 3, 6, 4, 2, 1]) => 3\n  */\nconst medianArray = (array) => {\n  let median = array.length % 2 === 0? array.length / 2 : array.length / 2 + 1;\n  let sortedArray = sortArray(array);\n  let middle = Math.floor(median / 2);\n  let left = sortedArray.slice(0, middle);\n  let right = sortedArray.slice(middle);\n  return median(left, right);\n};\n\n/**\n * Given an array of non-negative integers, return its mode.\n\n  Example:\n  * modeArray([5, 2, 7, 1, 3]) => 3\n  * modeArray([5, 2, 7, 1, 3, 6]) => 3\n  * modeArray([5, 2, 7, 1, 3, 6, 4]) => 3\n  * modeArray([5, 2, 7, 1, 3, 6, 4, 2]) => 3\n  * modeArray([5, 2, 7, 1, 3, 6, 4, 2, 1]) => 3\n  */\nconst modeArray = (array) => {\n  let mode = 0;\n  let modeArray = [];\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] > mode) {\n      mode = array[i];\n      modeArray = i;\n    }\n  }\n  return mode;\n};\n\n/**\n * Given an array of non-negative integers, return its variance.\n\n  Example:\n  * varianceArray([5, 2, 7, 1, 3]) => 3\n  * varianceArray([5, 2, 7, 1, 3, 6]) => 3\n  * varianceArray([5, 2, 7, 1, 3, 6, 4]) => 3\n  * varianceArray([5, 2, 7, 1, 3, 6, 4, 2]) => 3\n  * varianceArray([5, 2, 7, 1, 3, 6, 4, 2, 1]) => 3\n  */\nconst varianceArray = (array) => {\n  let variance = 0;\n  let varianceArray = [];\n  for (let i = 0; i < array.length; i++) {\n    variance += Math.pow(array[i] - mean, 2);\n  }\n  return Math.sqrt(variance);\n};\n\n/**\n * Given an array of non-negative integers, return its standard deviation.\n\n  Example:\n  * stdDevArray([5, 2, 7, 1, 3]) => 3\n  * stdDevArray([5, 2, 7, 1, 3, 6]) => 3\n  * stdDevArray([5, 2, 7, 1, 3, 6, 4]) => 3\n  * stdDevArray([5, 2, 7, 1, 3, 6, 4, 2]) => 3\n  * stdDevArray([5, 2, 7, 1, 3, 6, 4, 2, 1]) => 3\n  */\nconst stdDevArray = (array) => {\n  let stdDev = 0;\n  let stdDevArray = [];\n  for (let i = 0; i < array.length; i++) {\n    stdDev += Math.pow(array[i] - mean, 2);\n  }\n  return Math.sqrt(stdDev / array.length);\n};\n\n/**\n * Given an array of non-negative integers, return its standard deviation with optional mean.\n\n  Example:\n  * stdDevWithMeanArray([5, 2, 7, 1, 3]) => 3\n  * stdDevWithMeanArray([5, 2, 7, 1, 3, 6]) => 3\n  * stdDevWithMeanArray([5, 2, 7, 1, 3, 6, 4]) => 3\n  * stdDevWithMeanArray([5, 2, 7, 1, 3, 6, 4, 2]) => 3\n  * stdDevWithMeanArray([5, 2, 7, 1, 3, 6, 4, 2, 1]) => 3\n  */\nconst stdDevWithMeanArray = (array) => {\n  let stdDev = 0;\n  let stdDevArray = [];\n  let mean = 0;\n  for (let i = 0; i < array.length; i++) {\n    mean += array[i];\n  }\n  for (let i = 0; i < array.length; i++) {\n    stdDev += Math.pow(array[i] - mean, 2);\n  }\n  return Math.sqrt(stdDev / array.length);\n};\n\n/**\n * Given an array of non-negative integers, return its standard deviation with optional mean and variance.\n\n  Example:\n  * stdDevWithMeanAndVarianceArray([5, 2, 7, 1, 3]) => 3\n  * stdDevWithMeanAndVarianceArray([5, 2, 7, 1, 3, 6]) => 3\n  * stdDevWithMeanAndVarianceArray([5, 2, 7, 1, 3, 6, 4]) => 3\n  * stdDevWithMeanAndVarianceArray([5, 2, 7, 1, 3, 6, 4, 2]) => 3\n  * stdDevWithMeanAndVarianceArray([5, 2, 7, 1, 3, 6, 4, 2, 1]) => 3\n  */\nconst stdDevWithMeanAndVarianceArray = (array) => {\n  let stdDev = 0;\n  let stdDevArray = [];\n  let mean = 0;\n  let variance = 0;\n  for (let i = 0; i < array.length; i++) {\n    mean += array[i];\n    variance += Math.pow(array[i] - mean, 2);\n  }\n  for (let i = 0; i < array.length; i++) {\n    stdDev += Math.pow(array[i] - mean, 2);\n  }\n  return Math.sqrt(variance) / Math.sqrt(stdDev / array.length);\n};\n\n/**\n * Given an array of non-negative integers, return its standard deviation with optional mean and variance.\n\n  Example:\n  * stdDevWithMean", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/89", "prompt": "/*Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "gc": "<|endoftext|>/*Create a function encrypt that takes a string as an argument and\n  returns a string encrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotated = '';\n  let i = 0;\n  let j = 0;\n  let len = s.length;\n  while (i < len) {\n    let c = s.charAt(i);\n    let r = alphabet.indexOf(c);\n    rotated += alphabet[r];\n    i++;\n  }\n  return rotated;\n};\n\n/*Create a function decrypt that takes a string as an argument and\n  returns a string decrypted with the alphabet being rotated. \n  The alphabet should be rotated in a manner such that the letters \n  shift up by two multiplied to two places.\n  For example:\n  decrypt('lm') returns 'hi'\n  decrypt('ewhjklnop') returns 'asdfghjkl'\n  decrypt('kj') returns 'gf'\n  decrypt('ix') returns 'et'\n  */\nconst decrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotated = '';\n  let i = 0;\n  let j = 0;\n  let len = s.length;\n  while (i < len) {\n    let c = s.charAt(i);\n    let r = alphabet.indexOf(c);\n    rotated += alphabet[r];\n    i++;\n  }\n  return rotated;\n};\n\n/*Create a function rotate that takes a string as an argument and\n  returns a string rotated a certain number of places left or right. \n  The alphabet should be rotated in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  rotate('hi') returns 'lmnopqrstuvwxyz'\n  rotate('asdfghjkl') returns 'ewhjklnopqrstuvwxyz'\n  rotate('gf') returns 'kjlmnopqrstuvwxyz'\n  rotate('et') returns 'ix'\n  */\nconst rotate = (s, n) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotated = '';\n  let i = 0;\n  let j = 0;\n  let len = s.length;\n  while (i < len) {\n    let c = s.charAt(i);\n    let r = alphabet.indexOf(c);\n    rotated += alphabet[r];\n    i++;\n  }\n  return rotated;\n};\n\n/*Create a function reverse that takes a string as an argument and\n  returns a string reversed. \n  The alphabet should be reversed in a manner such that the letters \n  shift down by two multiplied to two places.\n  For example:\n  reverse('lmnopqrstuvwxyz') returns 'asdfghjkl'\n  reverse('ewhjklnopqrstuvwxyz') returns 'ewhjklnopqrstuvwxyz'\n  reverse('kjlmnopqrstuvwxyz') returns 'kjlmnopqrstuvwxyz'\n  reverse('ix') returns 'gfkjlmnopqrstuvwxyz'\n  */\nconst reverse = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotated = '';\n  let i = 0;\n  let j = 0;\n  let len = s.length;\n  while (i < len) {\n    let c = s.charAt(i);\n    let r = alphabet.indexOf(c);\n    rotated += alphabet[r];\n    i++;\n  }\n  return rotated;\n};\n\n/*Create a function trim that takes a string as an argument and\n  returns a string trimmed. \n  The alphabet should be trimmed in a manner such that the letters \n  are only removed from the beginning and end of the string.\n  For example:\n  trim('asdfghjkl') returns 'asdfghjkl'\n  trim('gf') returns 'asdfghjkl'\n  trim('et') returns 'asdfghjkl'\n  */\nconst trim = s => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotated = '';\n  let i = 0;\n  let j = 0;\n  let len = s.length;\n  while (i < len) {\n    let c = s.charAt(i);\n    let r = alphabet.indexOf(c);\n    rotated += alphabet[r];\n    i++;\n  }\n  return rotated;\n};\n\n/*Create a function trim that takes a string as an argument and\n  returns a string trimmed. \n  The alphabet should be trimmed in a manner such that the letters \n  are only removed from the beginning and end of the string.\n  For example:\n  trim('asdfghjkl') returns 'asdfghjkl'\n  trim('gf') returns 'asdfghjkl'\n  trim('et') returns 'asdfghjkl'\n  */\nconst trimLeft = s => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotated = '';\n  let i = 0;\n  let j = 0;\n  let len = s.length;\n  while (i < len) {\n    let c = s.charAt(i);\n    let r = alphabet.indexOf(c);\n    rotated += alphabet[r];\n    i++;\n  }\n  return rotated;\n};\n\n/*Create a function trim that takes a string as an argument and\n  returns a string trimmed. \n  The alphabet should be trimmed in a manner such that the letters \n  are only removed from the beginning and end of the string.\n  For example:\n  trim('asdfghjkl') returns 'asdfghjkl'\n  trim('gf') returns 'asdfghjkl'\n  trim('et') returns 'asdfghjkl'\n  */\nconst trimRight = s => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotated = '';\n  let i = 0;\n  let j = 0;\n  let len = s.length;\n  while (i < len) {\n    let c = s.charAt(i);\n    let r = alphabet.indexOf(c);\n    rotated += alphabet[r];\n    i++;\n  }\n  return rotated;\n};\n\n/*Create a function trim that takes a string as an argument and\n  returns a string trimmed. \n  The alphabet should be trimmed in a manner such that the letters \n  are only removed from the beginning and end of the string.\n  For example:\n  trim('asdfghjkl') returns 'asdfghjkl'\n  trim('gf') returns 'asdfghjkl'\n  trim('et') returns 'asdfghjkl'\n  */\nconst trimBoth = s => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotated = '';\n  let i = 0;\n  let j = 0;\n  let len = s.length;\n  while (i < len) {\n    let c = s.charAt(i);\n    let r = alphabet.indexOf(c);\n    rotated += alphabet[r];\n    i++;\n  }\n  return rotated;\n};\n\n/*Create a function trim that takes a string as an argument and\n  returns a string trimmed. \n  The alphabet should be trimmed in a manner such that the letters \n  are only removed from the beginning and end of the string.\n  For example:\n  trim('asdfghjkl') returns 'asdfghjkl'\n  trim('gf') returns 'asdfghjkl'\n  trim('et') returns 'asdfgh", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/9", "prompt": "/* From a given list of integers, generate a list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "gc": "<|endoftext|>/* From a given list of integers, generate a list of rolling maximum element found until given moment\n  in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const result = [];\n  let max = 0;\n  let current = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    if (current > numbers[i]) {\n      max = current;\n      current = numbers[i];\n    }\n    result.push(current);\n  }\n  return result;\n};\n\n// Given a list of integers, generate a list of rolling minimum element found until given moment\n// in the sequence.\nconst rollingMin = (numbers) => {\n  const result = [];\n  let min = 0;\n  let current = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    if (current < numbers[i]) {\n      min = current;\n      current = numbers[i];\n    }\n    result.push(current);\n  }\n  return result;\n};\n\n// Given a list of integers, generate a list of rolling sum of the elements found until given moment\n// in the sequence.\nconst rollingSum = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let current = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    sum += current;\n    current = numbers[i];\n    result.push(sum);\n  }\n  return result;\n};\n\n// Given a list of integers, generate a list of rolling mean of the elements found until given moment\n// in the sequence.\nconst rollingMean = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let current = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    sum += current;\n    current = numbers[i];\n    result.push(sum / numbers.length);\n  }\n  return result;\n};\n\n// Given a list of integers, generate a list of rolling standard deviation of the elements found until given moment\n// in the sequence.\nconst rollingStd = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let current = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    sum += Math.pow(current - numbers[i], 2);\n    current = numbers[i];\n    result.push(Math.sqrt(sum / numbers.length));\n  }\n  return result;\n};\n\n// Given a list of integers, generate a list of rolling variance of the elements found until given moment\n// in the sequence.\nconst rollingVar = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let current = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    sum += Math.pow(current - numbers[i], 2);\n    current = numbers[i];\n    result.push(Math.pow(sum / numbers.length, 2));\n  }\n  return result;\n};\n\n// Given a list of integers, generate a list of rolling skewness of the elements found until given moment\n// in the sequence.\nconst rollingSkewness = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let current = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    sum += Math.pow(current - numbers[i], 2);\n    current = numbers[i];\n    result.push(Math.pow(Math.pow(sum / numbers.length, 2), 0.5));\n  }\n  return result;\n};\n\n// Given a list of integers, generate a list of rolling kurtosis of the elements found until given moment\n// in the sequence.\nconst rollingKurtosis = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let current = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    sum += Math.pow(current - numbers[i], 2);\n    current = numbers[i];\n    result.push(Math.pow(Math.pow(sum / numbers.length, 3), 0.5));\n  }\n  return result;\n};\n\n// Given a list of integers, generate a list of rolling maximum absolute deviation found until given moment\n// in the sequence.\nconst rollingMaxAbsDev = (numbers) => {\n  const result = [];\n  let max = 0;\n  let current = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    if (Math.abs(current - numbers[i]) > max) {\n      max = Math.abs(current - numbers[i]);\n      current = numbers[i];\n    }\n    result.push(current);\n  }\n  return result;\n};\n\n// Given a list of integers, generate a list of rolling minimum absolute deviation found until given moment\n// in the sequence.\nconst rollingMinAbsDev = (numbers) => {\n  const result = [];\n  let min = 0;\n  let current = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    if (Math.abs(current - numbers[i]) < min) {\n      min = Math.abs(current - numbers[i]);\n      current = numbers[i];\n    }\n    result.push(current);\n  }\n  return result;\n};\n\n// Given a list of integers, generate a list of rolling sum of the absolute deviations found until given moment\n// in the sequence.\nconst rollingSumAbsDev = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let current = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    sum += Math.abs(current - numbers[i]);\n    current = numbers[i];\n    result.push(sum);\n  }\n  return result;\n};\n\n// Given a list of integers, generate a list of rolling mean of the absolute deviations found until given moment\n// in the sequence.\nconst rollingMeanAbsDev = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let current = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    sum += Math.abs(current - numbers[i]);\n    current = numbers[i];\n    result.push(sum / numbers.length);\n  }\n  return result;\n};\n\n// Given a list of integers, generate a list of rolling standard deviation of the absolute deviations found until given moment\n// in the sequence.\nconst rollingStdAbsDev = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let current = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    sum += Math.abs(current - numbers[i]);\n    current = numbers[i];\n    result.push(Math.sqrt(sum / numbers.length));\n  }\n  return result;\n};\n\n// Given a list of integers, generate a list of rolling variance of the absolute deviations found until given moment\n// in the sequence.\nconst rollingVarAbsDev = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let current = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    sum += Math.abs(current - numbers[i]);\n    current = numbers[i];\n    result.push(Math.pow(Math.pow(sum / numbers.length, 2), 0.5));\n  }\n  return result;\n};\n\n// Given a list of integers, generate a list of rolling skewness of the absolute deviations found until given moment\n// in the sequence.\nconst rollingSkewnessAbsDev = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let current = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    sum += Math.abs(current - numbers[i]);\n    current = numbers[i];\n    result.push(Math.pow(Math.pow(Math.pow(sum / numbers.length, 2), 0.5), 0.5));\n  }\n  return result;\n};\n\n// Given a list of integers, generate a list of rolling kurtosis of the absolute deviations found until given moment\n// in the sequence.\nconst rollingKurtosisAbsDev = (numbers) => {\n  const result = [];\n  let sum = 0;\n  let current = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    sum += Math.abs(current - numbers[i]);\n    current = numbers[i];\n    result.push(Math.pow(Math.pow(Math.pow(sum / numbers.length, 3), 0.5), 0.5));\n  }\n  return result;\n};\n\n// Given a list of integers, generate a list of rolling maximum absolute deviation found until given moment\n// in the sequence.\nconst rollingMaxAbsDevAbs = (numbers) => {\n  const result = [];\n  let max = 0;\n  let current = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    if (Math.abs(current - numbers[i]) > max) {\n      max = Math.abs(current - numbers[i]);\n      current = numbers[i];\n    }\n    result.push(current);\n  }\n  return result;\n};\n\n// Given a list of integers, generate a list of rolling minimum absolute deviation found until given ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/90", "prompt": "/*\n  You are given a list of integers.\n  Write a function nextSmallset() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallset([1, 2, 3, 4, 5]) == 2\n  nextSmallset([5, 1, 4, 3, 2]) == 2\n  nextSmallset([]) == null\n  nextSmallset([1, 1]) == null\n  */\nconst nextSmallset = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallset", "gc": "<|endoftext|>/*\n  You are given a list of integers.\n  Write a function nextSmallset() that returns the 2nd smallest element of the list.\n  Return null if there is no such element.\n  \n  nextSmallset([1, 2, 3, 4, 5]) == 2\n  nextSmallset([5, 1, 4, 3, 2]) == 2\n  nextSmallset([]) == null\n  nextSmallset([1, 1]) == null\n  */\nconst nextSmallset = (lst) => {\n  let min = null;\n  let minIndex = -1;\n  for (let i = 0; i < lst.length; i++) {\n    if (min === null || min > lst[i]) {\n      min = lst[i];\n      minIndex = i;\n    }\n  }\n  return minIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextLargeset() that returns the 3rd largest element of the list.\n  Return null if there is no such element.\n  \n  nextLargeset([1, 2, 3, 4, 5]) == 3\n  nextLargeset([5, 1, 4, 3, 2]) == 3\n  nextLargeset([]) == null\n  nextLargeset([1, 1]) == null\n  */\nconst nextLargeset = (lst) => {\n  let max = null;\n  let maxIndex = -1;\n  for (let i = 0; i < lst.length; i++) {\n    if (max === null || max < lst[i]) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextTriangularSet() that returns the set of all triangular numbers in the list.\n  Return null if there is no such element.\n  \n  nextTriangularSet([1, 2, 3, 4, 5]) == [1, 2, 3]\n  nextTriangularSet([5, 1, 4, 3, 2]) == [1, 2, 3]\n  nextTriangularSet([]) == null\n  nextTriangularSet([1, 1]) == null\n  */\nconst nextTriangularSet = (lst) => {\n  let set = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i === 0 || i === lst.length - 1) {\n      set.push(lst[i]);\n    } else {\n      let temp = nextTriangularSet(lst.slice(i + 1));\n      if (temp) {\n        set.push(...temp);\n      }\n    }\n  }\n  return set;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextPowerSet() that returns the set of all power sets in the list.\n  Return null if there is no such element.\n  \n  nextPowerSet([1, 2, 3, 4, 5]) == [[1, 2], [1, 3], [1, 4], [1, 5], [2, 3], [2, 4], [2, 5], [3, 4], [3, 5]]\n  nextPowerSet([5, 1, 4, 3, 2]) == [[1, 2], [1, 3], [1, 4], [1, 5], [2, 3], [2, 4], [2, 5], [3, 4], [3, 5]]\n  nextPowerSet([]) == null\n  nextPowerSet([1, 1]) == null\n  */\nconst nextPowerSet = (lst) => {\n  let set = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i === 0 || i === lst.length - 1) {\n      set.push(lst[i]);\n    } else {\n      let temp = nextPowerSet(lst.slice(i + 1));\n      if (temp) {\n        set.push(...temp);\n      }\n    }\n  }\n  return set;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextPowerSet() that returns the set of all power sets in the list.\n  Return null if there is no such element.\n  \n  nextPowerSet([1, 2, 3, 4, 5]) == [[1, 2], [1, 3], [1, 4], [1, 5], [2, 3], [2, 4], [2, 5], [3, 4], [3, 5]]\n  nextPowerSet([5, 1, 4, 3, 2]) == [[1, 2], [1, 3], [1, 4], [1, 5], [2, 3], [2, 4], [2, 5], [3, 4], [3, 5]]\n  nextPowerSet([]) == null\n  nextPowerSet([1, 1]) == null\n  */\nconst nextPowerSet = (lst) => {\n  let set = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i === 0 || i === lst.length - 1) {\n      set.push(lst[i]);\n    } else {\n      let temp = nextPowerSet(lst.slice(i + 1));\n      if (temp) {\n        set.push(...temp);\n      }\n    }\n  }\n  return set;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextPowerSet() that returns the set of all power sets in the list.\n  Return null if there is no such element.\n  \n  nextPowerSet([1, 2, 3, 4, 5]) == [[1, 2], [1, 3], [1, 4], [1, 5], [2, 3], [2, 4], [2, 5], [3, 4], [3, 5]]\n  nextPowerSet([5, 1, 4, 3, 2]) == [[1, 2], [1, 3], [1, 4], [1, 5], [2, 3], [2, 4], [2, 5], [3, 4], [3, 5]]\n  nextPowerSet([]) == null\n  nextPowerSet([1, 1]) == null\n  */\nconst nextPowerSet = (lst) => {\n  let set = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i === 0 || i === lst.length - 1) {\n      set.push(lst[i]);\n    } else {\n      let temp = nextPowerSet(lst.slice(i + 1));\n      if (temp) {\n        set.push(...temp);\n      }\n    }\n  }\n  return set;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextPowerSet() that returns the set of all power sets in the list.\n  Return null if there is no such element.\n  \n  nextPowerSet([1, 2, 3, 4, 5]) == [[1, 2], [1, 3], [1, 4], [1, 5], [2, 3], [2, 4], [2, 5], [3, 4], [3, 5]]\n  nextPowerSet([5, 1, 4, 3, 2]) == [[1, 2], [1, 3], [1, 4], [1, 5], [2, 3], [2, 4], [2, 5], [3, 4], [3, 5]]\n  nextPowerSet([]) == null\n  nextPowerSet([1, 1]) == null\n  */\nconst nextPowerSet = (lst) => {\n  let set = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i === 0 || i === lst.length - 1) {\n      set.push(lst[i]);\n    } else {\n      let temp = nextPowerSet(lst.slice(i + 1));\n      if (temp) {\n        set.push(...temp);\n      }\n    }\n  }\n  return set;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextPowerSet() that returns the set of all power sets in the list.\n  Return null if there is no such element.\n  \n  nextPowerSet([1, 2, 3, 4, 5]) == [[1, 2], [1, 3], [1, 4], [1, 5], [2, 3], [2, 4], [2, 5], [3, 4], [3, 5]]\n  nextPowerSet([5, 1, 4, 3, 2]) == [[1, 2], [1, 3], [1, 4], [1, 5], [2, 3], [2, 4], [2, 5], [3, 4], [3, 5]]\n  nextPowerSet([]) == null\n  nextPowerSet([1, 1]) == null\n  */\nconst nextPowerSet = (lst) => {\n  let set = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i === 0 || i === lst.length - 1) {\n      set.push(lst[i]);\n    } else {\n      let temp = nextPowerSet(lst.slice(i + 1));\n      if (temp) {\n        set.push(...temp);\n      }\n    }\n  }\n  return set;\n};\n\n/*\n  You are given a list of integers.\n  Write a function nextPowerSet() that returns the set of all power sets in the list.\n  Return null if there is no such element.\n  \n  nextPowerSet([1, 2, 3, 4, 5]) == [[1, 2], [1, 3], [1, 4], [1, 5], [2, 3], [2, 4], [2, 5], [3, 4], [3, 5]]\n  nextPowerSet([5, 1, 4, 3, 2]) == [[1, 2], [1, 3], [1, 4], [1, 5], [2, 3], [2, 4], [2, 5], [3, 4], [3, 5]]\n  nextPowerSet([]) == null\n  nextPowerSet([1, 1]) == null\n  */\nconst nextPowerSet = (lst) => {\n  let set = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i === 0 || i === lst.length - 1) {\n      set.push(lst[i]);\n    } else {\n      let temp = ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll be given a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBoerd(\"Hello world\")\n  0\n  >>> isBoerd(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBoerd = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBoerd", "gc": "<|endoftext|>/*\n  You'll be given a string of words, and your task is to count the number\n  of boredoms. A boredom is a sentence that starts with the word \"I\".\n  Sentences are delimited by '.', '?' or '!'.\n \n  For example:\n  >>> isBoerd(\"Hello world\")\n  0\n  >>> isBoerd(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBoerd = (S) => {\n  let boerd = 0;\n  let words = S.split('.');\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].includes('I')) {\n      boerd++;\n    }\n  }\n  return boerd;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of common words. A common word is a word that appears at least once\n  in the entire sentence. Words are delimited by spaces.\n \n  For example:\n  >>> commonWords(\"Hello world\")\n  0\n  >>> commonWords(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst commonWords = (S) => {\n  let commonWords = 0;\n  let words = S.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].includes('I')) {\n      commonWords++;\n    }\n  }\n  return commonWords;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of common words. A common word is a word that appears at least once\n  in the entire sentence. Words are delimited by spaces.\n \n  For example:\n  >>> commonWords(\"Hello world\")\n  0\n  >>> commonWords(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst commonWordsWithSpacesAndI = (S) => {\n  let commonWords = 0;\n  let words = S.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].includes('I')) {\n      commonWords++;\n    }\n  }\n  return commonWords;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of common words. A common word is a word that appears at least once\n  in the entire sentence. Words are delimited by spaces.\n \n  For example:\n  >>> commonWords(\"Hello world\")\n  0\n  >>> commonWords(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst commonWordsWithSpacesAndIAndThe = (S) => {\n  let commonWords = 0;\n  let words = S.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].includes('I') && words[i].includes('the')) {\n      commonWords++;\n    }\n  }\n  return commonWords;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of common words. A common word is a word that appears at least once\n  in the entire sentence. Words are delimited by spaces.\n \n  For example:\n  >>> commonWords(\"Hello world\")\n  0\n  >>> commonWords(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst commonWordsWithSpacesAndIAndTheAndThe = (S) => {\n  let commonWords = 0;\n  let words = S.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].includes('I') && words[i].includes('the') && words[i].includes('the')) {\n      commonWords++;\n    }\n  }\n  return commonWords;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of common words. A common word is a word that appears at least once\n  in the entire sentence. Words are delimited by spaces.\n \n  For example:\n  >>> commonWords(\"Hello world\")\n  0\n  >>> commonWords(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst commonWordsWithSpacesAndIAndTheAndThe = (S) => {\n  let commonWords = 0;\n  let words = S.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].includes('I') && words[i].includes('the') && words[i].includes('the') && words[i].includes('the')) {\n      commonWords++;\n    }\n  }\n  return commonWords;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of common words. A common word is a word that appears at least once\n  in the entire sentence. Words are delimited by spaces.\n \n  For example:\n  >>> commonWords(\"Hello world\")\n  0\n  >>> commonWords(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst commonWordsWithSpacesAndIAndTheAndThe = (S) => {\n  let commonWords = 0;\n  let words = S.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].includes('I') && words[i].includes('the') && words[i].includes('the') && words[i].includes('the') && words[i].includes('the')) {\n      commonWords++;\n    }\n  }\n  return commonWords;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of common words. A common word is a word that appears at least once\n  in the entire sentence. Words are delimited by spaces.\n \n  For example:\n  >>> commonWords(\"Hello world\")\n  0\n  >>> commonWords(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst commonWordsWithSpacesAndIAndTheAndThe = (S) => {\n  let commonWords = 0;\n  let words = S.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].includes('I') && words[i].includes('the') && words[i].includes('the') && words[i].includes('the') && words[i].includes('the') && words[i].includes('the')) {\n      commonWords++;\n    }\n  }\n  return commonWords;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of common words. A common word is a word that appears at least once\n  in the entire sentence. Words are delimited by spaces.\n \n  For example:\n  >>> commonWords(\"Hello world\")\n  0\n  >>> commonWords(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst commonWordsWithSpacesAndIAndTheAndTheAndThe = (S) => {\n  let commonWords = 0;\n  let words = S.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    if (words[i].includes('I') && words[i].includes('the') && words[i].includes('the') && words[i].includes('the') && words[i].includes('the') && words[i].includes('the') && words[i].includes('the')) {\n      commonWords++;\n    }\n  }\n  return commonWords;\n};\n\n/*\n  You'll be given a string of words, and your task is to count the number\n  of common words. A common word is a word that appears at least once\n  in the entire sentence. Words are delimited by spaces.\n \n  For example:\n  >>> commonWords(\"Hello world", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/92", "prompt": "/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "gc": "<|endoftext|>/* Create a function that takes 3 numbers.\n  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  return x === y && x === z;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  allInt(5, 2, 7) ➞ true\n  allInt(3, 2, 2) ➞ false\n  allInt(3, -2, 1) ➞ true\n  allInt(3.6, -2.2, 2) ➞ true\n  */\nconst allInt = (x, y, z) => {\n  return x === y || x === z || y === z;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  evenInt(5, 2, 7) ➞ true\n  evenInt(3, 2, 2) ➞ false\n  evenInt(3, -2, 1) ➞ true\n  evenInt(3.6, -2.2, 2) ➞ false\n  */\nconst evenInt = (x, y, z) => {\n  return x % 2 === 0 && y % 2 === 0 && z % 2 === 0;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  oddInt(5, 2, 7) ➞ true\n  oddInt(3, 2, 2) ➞ false\n  oddInt(3, -2, 1) ➞ true\n  oddInt(3.6, -2.2, 2) ➞ false\n  */\nconst oddInt = (x, y, z) => {\n  return x % 2!== 0 && y % 2!== 0 && z % 2!== 0;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  evenOdd(5, 2, 7) ➞ true\n  evenOdd(3, 2, 2) ➞ false\n  evenOdd(3, -2, 1) ➞ true\n  evenOdd(3.6, -2.2, 2) ➞ false\n  */\nconst evenOddInt = (x, y, z) => {\n  return x % 2 === 0 || y % 2 === 0 || z % 2 === 0;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  oddOdd(5, 2, 7) ➞ true\n  oddOdd(3, 2, 2) ➞ false\n  oddOdd(3, -2, 1) ➞ true\n  oddOdd(3.6, -2.2, 2) ➞ false\n  */\nconst oddOddInt = (x, y, z) => {\n  return x % 2!== 0 || y % 2!== 0 || z % 2!== 0;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  evenOdd(5, 2, 7) ➞ true\n  evenOdd(3, 2, 2) ➞ false\n  evenOdd(3, -2, 1) ➞ true\n  evenOdd(3.6, -2.2, 2) ➞ false\n  */\nconst evenOddEvenInt = (x, y, z) => {\n  return x % 2 === 0 || y % 2 === 0 || z % 2 === 0;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  oddOdd(5, 2, 7) ➞ true\n  oddOdd(3, 2, 2) ➞ false\n  oddOdd(3, -2, 1) ➞ true\n  oddOdd(3.6, -2.2, 2) ➞ false\n  */\nconst oddOddOddInt = (x, y, z) => {\n  return x % 2!== 0 || y % 2!== 0 || z % 2!== 0;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  evenOdd(5, 2, 7) ➞ true\n  evenOdd(3, 2, 2) ➞ false\n  evenOdd(3, -2, 1) ➞ true\n  evenOdd(3.6, -2.2, 2) ➞ false\n  */\nconst evenOddEvenOddInt = (x, y, z) => {\n  return x % 2 === 0 || y % 2 === 0 || z % 2 === 0;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  oddOdd(5, 2, 7) ➞ true\n  oddOdd(3, 2, 2) ➞ false\n  oddOdd(3, -2, 1) ➞ true\n  oddOdd(3.6, -2.2, 2) ➞ false\n  */\nconst oddOddOddEvenOddInt = (x, y, z) => {\n  return x % 2!== 0 || y % 2!== 0 || z % 2!== 0;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  evenOdd(5, 2, 7) ➞ true\n  evenOdd(3, 2, 2) ➞ false\n  evenOdd(3, -2, 1) ➞ true\n  evenOdd(3.6, -2.2, 2) ➞ false\n  */\nconst evenOddOddOddEvenOddInt = (x, y, z) => {\n  return x % 2 === 0 || y % 2 === 0 || z % 2 === 0;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  oddOdd(5, 2, 7) ➞ true\n  oddOdd(3, 2, 2) ➞ false\n  oddOdd(3, -2, 1) ➞ true\n  oddOdd(3.6, -2.2, 2) ➞ false\n  */\nconst oddOddOddOddEvenOddInt = (x, y, z) => {\n  return x % 2!== 0 || y % 2!== 0 || z % 2!== 0;\n};\n\n/* Create a function that takes 3 numbers.\n  Returns true if any of the numbers is equal to the sum of the other two, and all numbers are integers.\n  Returns false in any other cases.\n  Examples\n  evenOdd(5, 2, 7) ➞ true\n  evenOdd(3, 2, 2) ➞ false\n  evenOdd(3, -2, 1) ➞ true\n  evenOdd(3.6, -2.2, 2) ➞ false\n  */\nconst evenOdd", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "gc": "<|endoftext|>/*\n  Write a function that takes a message, and encodes in such a \n  way that it swaps case of all letters, replaces all vowels in \n  the message with the letter that appears 2 places ahead of that \n  vowel in the english alphabet. \n  Assume only letters. \n  \n  Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let encodedMessage = '';\n  let vowels = 'aeiouAEIOU';\n  let vowelsLength = vowels.length;\n  let messageLength = message.length;\n  let i;\n  let j;\n  let k;\n  let letter;\n  let letterPosition;\n  let vowelPosition;\n  let position;\n  let position2;\n  let position3;\n  let position4;\n  let position5;\n  let position6;\n  let position7;\n  let position8;\n  let position9;\n  let position10;\n  let position11;\n  let position12;\n  let position13;\n  let position14;\n  let position15;\n  let position16;\n  let position17;\n  let position18;\n  let position19;\n  let position20;\n  let position21;\n  let position22;\n  let position23;\n  let position24;\n  let position25;\n  let position26;\n  let position27;\n  let position28;\n  let position29;\n  let position30;\n  let position31;\n  let position32;\n  let position33;\n  let position34;\n  let position35;\n  let position36;\n  let position37;\n  let position38;\n  let position39;\n  let position40;\n  let position41;\n  let position42;\n  let position43;\n  let position44;\n  let position45;\n  let position46;\n  let position47;\n  let position48;\n  let position49;\n  let position50;\n  let position51;\n  let position52;\n  let position53;\n  let position54;\n  let position55;\n  let position56;\n  let position57;\n  let position58;\n  let position59;\n  let position60;\n  let position61;\n  let position62;\n  let position63;\n  let position64;\n  let position65;\n  let position66;\n  let position67;\n  let position68;\n  let position69;\n  let position70;\n  let position71;\n  let position72;\n  let position73;\n  let position74;\n  let position75;\n  let position76;\n  let position77;\n  let position78;\n  let position79;\n  let position80;\n  let position81;\n  let position82;\n  let position83;\n  let position84;\n  let position85;\n  let position86;\n  let position87;\n  let position88;\n  let position89;\n  let position90;\n  let position91;\n  let position92;\n  let position93;\n  let position94;\n  let position95;\n  let position96;\n  let position97;\n  let position98;\n  let position99;\n  let position100;\n  let position101;\n  let position102;\n  let position103;\n  let position104;\n  let position105;\n  let position106;\n  let position107;\n  let position108;\n  let position109;\n  let position110;\n  let position111;\n  let position112;\n  let position113;\n  let position114;\n  let position115;\n  let position116;\n  let position117;\n  let position118;\n  let position119;\n  let position120;\n  let position121;\n  let position122;\n  let position123;\n  let position124;\n  let position125;\n  let position126;\n  let position127;\n  let position128;\n  let position129;\n  let position130;\n  let position131;\n  let position132;\n  let position133;\n  let position134;\n  let position135;\n  let position136;\n  let position137;\n  let position138;\n  let position139;\n  let position140;\n  let position141;\n  let position142;\n  let position143;\n  let position144;\n  let position145;\n  let position146;\n  let position147;\n  let position148;\n  let position149;\n  let position150;\n  let position151;\n  let position152;\n  let position153;\n  let position154;\n  let position155;\n  let position156;\n  let position157;\n  let position158;\n  let position159;\n  let position160;\n  let position161;\n  let position162;\n  let position163;\n  let position164;\n  let position165;\n  let position166;\n  let position167;\n  let position168;\n  let position169;\n  let position170;\n  let position171;\n  let position172;\n  let position173;\n  let position174;\n  let position175;\n  let position176;\n  let position177;\n  let position178;\n  let position179;\n  let position180;\n  let position181;\n  let position182;\n  let position183;\n  let position184;\n  let position185;\n  let position186;\n  let position187;\n  let position188;\n  let position189;\n  let position190;\n  let position191;\n  let position192;\n  let position193;\n  let position194;\n  let position195;\n  let position196;\n  let position197;\n  let position198;\n  let position199;\n  let position200;\n  let position201;\n  let position202;\n  let position203;\n  let position204;\n  let position205;\n  let position206;\n  let position207;\n  let position208;\n  let position209;\n  let position210;\n  let position211;\n  let position212;\n  let position213;\n  let position214;\n  let position215;\n  let position216;\n  let position217;\n  let position218;\n  let position219;\n  let position220;\n  let position221;\n  let position222;\n  let position223;\n  let position224;\n  let position225;\n  let position226;\n  let position227;\n  let position228;\n  let position229;\n  let position230;\n  let position231;\n  let position232;\n  let position233;\n  let position234;\n  let position235;\n  let position236;\n  let position237;\n  let position238;\n  let position239;\n  let position240;\n  let position241;\n  let position242;\n  let position243;\n  let position244;\n  let position245;\n  let position246;\n  let position247;\n  let position248;\n  let position249;\n  let position250;\n  let position251;\n  let position252;\n  let position253;\n  let position254;\n  let position255;\n  let position256;\n  let position257;\n  let position258;\n  let position259;\n  let position260;\n  let position261;\n  let position262;\n  let position263;\n  let position264;\n  let position265;\n  let position266;\n  let position267;\n  let position268;\n  let position269;\n  let position270;\n  let position271;\n  let position272;\n  let position273;\n  let position274;\n  let position275;\n  let position276;\n  let position277;\n  let position278;\n  let position279;\n  let position280;\n  let position281;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/94", "prompt": "/*You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst ksjkasddk = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "ksjkasddk", "gc": "<|endoftext|>/*You are given a list of integers.\n  You need to find the largest prime value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst ksjkasddk = (lst) => {\n  let maxPrime = 0;\n  let sum = 0;\n  let count = 0;\n  let maxDigit = 0;\n  let digit = 0;\n  let isPrime = true;\n  let isPrimeDigit = true;\n  let isPrimeDigitDigit = true;\n  let isPrimeDigitDigitDigit = true;\n  let isPrimeDigitDigitDigitDigit = true;\n  let isPrimeDigitDigitDigitDigitDigit = true;\n  let isPrimeDigitDigitDigitDigitDigitDigit = true;\n  let isPrimeDigitDigitDigitDigitDigitDigitDigit = true;\n  let isPrimeDigitDigitDigitDigitDigitDigitDigitDigit = true;\n  let isPrimeDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = true;\n  let isPrimeDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = true;\n  let isPrimeDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit = true;\n  let isPrimeDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigitDigit", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/95", "prompt": "/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "gc": "<|endoftext|>/*\n  Given a dictionary, return true if all keys are strings in lower \n  case or all keys are strings in upper case, else return false.\n  The function should return false is the given dictionary is empty.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let keys = Object.keys(dict);\n  keys.sort();\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i];\n    let value = dict[key];\n    if (typeof value ==='string') {\n      if (key.toLowerCase() === key.toUpperCase()) {\n        return true;\n      }\n    } else {\n      if (key.toLowerCase() === key.toUpperCase()) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\n/*\n  Given a string, return true if all characters are lowercase or all \n  characters are uppercase, else return false.\n  The function should return false is the given string is empty.\n  Examples:\n  checkStringCase(\"abc\") should return true.\n  checkStringCase(\"ABC\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase(\"aBc\") should return false.\n  checkStringCase", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/96", "prompt": "/*Implement a function that takes an non-negative integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "gc": "<|endoftext|>/*Implement a function that takes an non-negative integer and returns an array of the first n\n  integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let primes = [];\n  let i = 2;\n  while (i < n) {\n    if (n % i === 0) {\n      primes.push(i);\n    }\n    i++;\n  }\n  return primes;\n};\n\n/*Implement a function that takes an array of integers and returns an array of the sum of the integers in an array\n  that satisfy the condition:\n  sumOfArray([2,3,5,7,11,13,17]) => 15\n  sumOfArray([2,3,5,7,11,13,17,19]) => 21\n  sumOfArray([2,3,5,7,11,13,17,19,21,23]) => 41\n  sumOfArray([2,3,5,7,11,13,17,19,21,23,25]) => 81\n  sumOfArray([2,3,5,7,11,13,17,19,21,23,25,29,31,33]) => 151\n  sumOfArray([2,3,5,7,11,13,17,19,21,23,25,29,31,33,35]) => 251\n  sumOfArray([2,3,5,7,11,13,17,19,21,23,25,29,31,33,35,39]) => 411\n  sumOfArray([2,3,5,7,11,13,17,19,21,23,25,29,31,33,35,39,43,47]) => 811\n  sumOfArray([2,3,5,7,11,13,17,19,21,23,25,29,31,33,35,39,43,47,53,59]) => 1511\n  sumOfArray([2,3,5,7,11,13,17,19,21,23,25,29,31,33,35,39,43,47,53,59,61,67]) => 2511\n  sumOfArray([2,3,5,7,11,13,17,19,21,23,25,29,31,33,35,39,43,47,53,59,61,67,71,73,79]) => 4111 \n  sumOfArray([2,3,5,7,11,13,17,19,21,23,25,29,31,33,35,39,43,47,53,59,61,67,71,73,79,83,89]) => 8111 \n  sumOfArray([2,3,5,7,11,13,17,19,21,23,25,29,31,33,35,39,43,47,53,59,61,67,71,73,79,83,89,97]) => 15111 \n  sumOfArray([2,3,5,7,11,13,17,19,21,23,25,29,31,33,35,39,43,47,53,59,61,67,71,73,79,83,89,97,101,107]) => 25111 \n  sumOfArray([2,3,5,7,11,13,17,19,21,23,25,29,31,33,35,39,43,47,53,59,61,67,71,73,79,83,89,97,101,107,113,127]) => 41111 \n  sumOfArray([2,3,5,7,11,13,17,19,21,23,25,29,31,33,35,39,43,47,53,59,61,67,71,73,79,83,89,97,101,107,113,127,131,137,139]) => 81111 \n  sumOfArray([2,3,5,7,11,13,17,19,21,23,25,29,31,33,35,39,43,47,53,59,61,67,71,73,79,83,89,97,101,107,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997]) => 151111 \n  sumOfArray([2,3,5,7,11,13,17,19,21,23,25,29,31,33,35,39,43,47,53,59,61,67,71,73,79,83,89,97,101,107,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997]) => 251111 \n  sumOfArray([2,3,5,7,11,13,17,19,21,23,25,29,31,33,35,39,43,47,53,59,61,67,71,73,79,83,89,97,101,107,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/97", "prompt": "/*Complete the function that takes two integers and returns \n  the product of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "gc": "<|endoftext|>/*Complete the function that takes two integers and returns \n  the product of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  const product = a / b;\n  return product * product;\n};\n\n/*Complete the function that takes two integers and returns \n  the sum of their unit digits.\n  Assume the input is always valid.\n  Examples:\n  sum(148, 412) should return 148.\n  sum(19, 28) should return 28.\n  sum(2020, 1851) should return 1851.\n  sum(14,-15) should return 14.\n  */\nconst sum = (a, b) => {\n  const sum = a + b;\n  return sum;\n};\n\n/*Complete the function that takes two integers and returns \n  the difference between their unit digits.\n  Assume the input is always valid.\n  Examples:\n  difference(148, 412) should return -12.\n  difference(19, 28) should return -28.\n  difference(2020, 1851) should return -1851.\n  difference(14,-15) should return 14.\n  */\nconst difference = (a, b) => {\n  const difference = a - b;\n  return difference;\n};\n\n/*Complete the function that takes two integers and returns \n  the absolute value of the difference between their unit digits.\n  Assume the input is always valid.\n  Examples:\n  absolute(148, 412) should return 14.\n  absolute(19, 28) should return 28.\n  absolute(2020, 1851) should return 1851.\n  absolute(14,-15) should return 14.\n  */\nconst absolute = (a, b) => {\n  const absolute = a + b;\n  return absolute;\n};\n\n/*Complete the function that takes two integers and returns \n  the square root of the difference between their unit digits.\n  Assume the input is always valid.\n  Examples:\n  sqrt(148, 412) should return 1.414213562.\n  sqrt(19, 28) should return 1.414213562.\n  sqrt(2020, 1851) should return 1.414213562.\n  sqrt(14,-15) should return 1.414213562.\n  */\nconst sqrt = (a, b) => {\n  const sqrt = Math.sqrt(a - b);\n  return sqrt;\n};\n\n/*Complete the function that takes two integers and returns \n  the absolute value of the square root of the difference between their unit digits.\n  Assume the input is always valid.\n  Examples:\n  absoluteSquareRoot(148, 412) should return 1.414213562.\n  absoluteSquareRoot(19, 28) should return 1.414213562.\n  absoluteSquareRoot(2020, 1851) should return 1.414213562.\n  absoluteSquareRoot(14,-15) should return 1.414213562.\n  */\nconst absoluteSquareRoot = (a, b) => {\n  const absoluteSquareRoot = Math.sqrt(a - b);\n  return absoluteSquareRoot;\n};\n\n/*Complete the function that takes two integers and returns \n  the square root of the difference between their unit digits.\n  Assume the input is always valid.\n  Examples:\n  squareRoot(148, 412) should return 1.414213562.\n  squareRoot(19, 28) should return 1.414213562.\n  squareRoot(2020, 1851) should return 1.414213562.\n  squareRoot(14,-15) should return 1.414213562.\n  */\nconst squareRoot = (a, b) => {\n  const squareRoot = Math.sqrt(a - b);\n  return squareRoot;\n};\n\n/*Complete the function that takes two integers and returns \n  the square root of the difference between their unit digits.\n  Assume the input is always valid.\n  Examples:\n  squareRootSquared(148, 412) should return 1.414213562.\n  squareRootSquared(19, 28) should return 1.414213562.\n  squareRootSquared(2020, 1851) should return 1.414213562.\n  squareRootSquared(14,-15) should return 1.414213562.\n  */\nconst squareRootSquared = (a, b) => {\n  const squareRootSquared = Math.sqrt(a - b);\n  return squareRootSquared;\n};\n\n/*Complete the function that takes two integers and returns \n  the square root of the difference between their unit digits.\n  Assume the input is always valid.\n  Examples:\n  squareRootSquared(148, 412) should return 1.414213562.\n  squareRootSquared(19, 28) should return 1.414213562.\n  squareRootSquared(2020, 1851) should return 1.414213562.\n  squareRootSquared(14,-15) should return 1.414213562.\n  */\nconst squareRootSquared = (a, b) => {\n  const squareRootSquared = Math.sqrt(a - b);\n  return squareRootSquared;\n};\n\n/*Complete the function that takes two integers and returns \n  the square root of the difference between their unit digits.\n  Assume the input is always valid.\n  Examples:\n  squareRootSquared(148, 412) should return 1.414213562.\n  squareRootSquared(19, 28) should return 1.414213562.\n  squareRootSquared(2020, 1851) should return 1.414213562.\n  squareRootSquared(14,-15) should return 1.414213562.\n  */\nconst squareRootSquared = (a, b) => {\n  const squareRootSquared = Math.sqrt(a - b);\n  return squareRootSquared;\n};\n\n/*Complete the function that takes two integers and returns \n  the square root of the difference between their unit digits.\n  Assume the input is always valid.\n  Examples:\n  squareRootSquared(148, 412) should return 1.414213562.\n  squareRootSquared(19, 28) should return 1.414213562.\n  squareRootSquared(2020, 1851) should return 1.414213562.\n  squareRootSquared(14,-15) should return 1.414213562.\n  */\nconst squareRootSquared = (a, b) => {\n  const squareRootSquared = Math.sqrt(a - b);\n  return squareRootSquared;\n};\n\n/*Complete the function that takes two integers and returns \n  the square root of the difference between their unit digits.\n  Assume the input is always valid.\n  Examples:\n  squareRootSquared(148, 412) should return 1.414213562.\n  squareRootSquared(19, 28) should return 1.414213562.\n  squareRootSquared(2020, 1851) should return 1.414213562.\n  squareRootSquared(14,-15) should return 1.414213562.\n  */\nconst squareRootSquared = (a, b) => {\n  const squareRootSquared = Math.sqrt(a - b);\n  return squareRootSquared;\n};\n\n/*Complete the function that takes two integers and returns \n  the square root of the difference between their unit digits.\n  Assume the input is always valid.\n  Examples:\n  squareRootSquared(148, 412) should return 1.414213562.\n  squareRootSquared(19, 28) should return 1.414213562.\n  squareRootSquared(2020, 1851) should return 1.414213562.\n  squareRootSquared(14,-15) should return 1.414213562.\n  */\nconst squareRootSquared = (a, b) => {\n  const squareRootSquared = Math.sqrt(a - b);\n  return squareRootSquared;\n};\n\n/*Complete the function that takes two integers and returns \n  the square root of the difference between their unit digits.\n  Assume the input is always valid.\n  Examples:\n  squareRootSquared(", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/98", "prompt": "/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "gc": "<|endoftext|>/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let vowels = 'aeiouAEIOU';\n  \n  while ((i < s.length) && (j < s.length)) {\n    if (vowels.includes(s.charAt(i))) {\n      count++;\n    }\n    i++;\n    j++;\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of lowercase vowels in even indices.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let vowels = 'aeiouAEIOU';\n  \n  while ((i < s.length) && (j < s.length)) {\n    if (vowels.includes(s.charAt(i))) {\n      count++;\n    }\n    i++;\n    j++;\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of vowels in even indices.\n  \n  For example:\n  countVowels('aBCdEf') returns 1\n  countVowels('abcdefg') returns 0\n  countVowels('dBBE') returns 0\n  */\nconst countVowels = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let vowels = 'aeiouAEIOU';\n  \n  while ((i < s.length) && (j < s.length)) {\n    if (vowels.includes(s.charAt(i))) {\n      count++;\n    }\n    i++;\n    j++;\n  }\n  return count;\n};\n\n/*\n  Given a string s, count the number of vowels in odd indices.\n  \n  For example:\n  countVowels('aBCdEf') returns 1\n  countVowels('abcdefg') returns 0\n  countVowels('dBBE') returns 0\n  */\nconst countVowelsOdd = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let vowels = 'aeiouAEIOU';\n  \n  while ((i < s.length) && (j < s.length)) {\n    if (vowels.includes(s.charAt(i))) {\n      count++;\n    }\n    i++;\n    j++;\n  }\n  return count % 2;\n};\n\n/*\n  Given a string s, count the number of uppercase vowels in odd indices.\n  \n  For example:\n  countUpperVowels('aBCdEf') returns 1\n  countUpperVowels('abcdefg') returns 0\n  countUpperVowels('dBBE') returns 0\n  */\nconst countUpperVowels = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let vowels = 'aeiouAEIOU';\n  \n  while ((i < s.length) && (j < s.length)) {\n    if (vowels.includes(s.charAt(i))) {\n      count++;\n    }\n    i++;\n    j++;\n  }\n  return count % 2;\n};\n\n/*\n  Given a string s, count the number of lowercase vowels in odd indices.\n  \n  For example:\n  countLowerVowels('aBCdEf') returns 1\n  countLowerVowels('abcdefg') returns 0\n  countLowerVowels('dBBE') returns 0\n  */\nconst countLowerVowels = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let vowels = 'aeiouAEIOU';\n  \n  while ((i < s.length) && (j < s.length)) {\n    if (vowels.includes(s.charAt(i))) {\n      count++;\n    }\n    i++;\n    j++;\n  }\n  return count % 2;\n};\n\n/*\n  Given a string s, count the number of uppercase vowels in even indices.\n  \n  For example:\n  countUpperVowels('aBCdEf') returns 1\n  countUpperVowels('abcdefg') returns 0\n  countUpperVowels('dBBE') returns 0\n  */\nconst countUpperVowelsOdd = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let vowels = 'aeiouAEIOU';\n  \n  while ((i < s.length) && (j < s.length)) {\n    if (vowels.includes(s.charAt(i))) {\n      count++;\n    }\n    i++;\n    j++;\n  }\n  return count % 2;\n};\n\n/*\n  Given a string s, count the number of lowercase vowels in even indices.\n  \n  For example:\n  countLowerVowels('aBCdEf') returns 1\n  countLowerVowels('abcdefg') returns 0\n  countLowerVowels('dBBE') returns 0\n  */\nconst countLowerVowelsOdd = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let vowels = 'aeiouAEIOU';\n  \n  while ((i < s.length) && (j < s.length)) {\n    if (vowels.includes(s.charAt(i))) {\n      count++;\n    }\n    i++;\n    j++;\n  }\n  return count % 2;\n};\n\n/*\n  Given a string s, count the number of uppercase vowels in odd indices.\n  \n  For example:\n  countUpperVowels('aBCdEf') returns 1\n  countUpperVowels('abcdefg') returns 0\n  countUpperVowels('dBBE') returns 0\n  */\nconst countUpperVowelsOdd = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let vowels = 'aeiouAEIOU';\n  \n  while ((i < s.length) && (j < s.length)) {\n    if (vowels.includes(s.charAt(i))) {\n      count++;\n    }\n    i++;\n    j++;\n  }\n  return count % 2;\n};\n\n/*\n  Given a string s, count the number of vowels in even indices.\n  \n  For example:\n  countVowelsOdd('aBCdEf') returns 1\n  countVowelsOdd('abcdefg') returns 0\n  countVowelsOdd('dBBE') returns 0\n  */\nconst countVowelsOdd = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let vowels = 'aeiouAEIOU';\n  \n  while ((i < s.length) && (j < s.length)) {\n    if (vowels.includes(s.charAt(i))) {\n      count++;\n    }\n    i++;\n    j++;\n  }\n  return count % 2;\n};\n\n/*\n  Given a string s, count the number of lowercase vowels in even indices.\n  \n  For example:\n  countLowerVowelsOdd('aBCdEf') returns 1\n  countLowerVowelsOdd('abcdefg') returns 0\n  countLowerVowelsOdd('dBBE') returns 0\n  */\nconst countLowerVowelsOdd = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let vowels = 'aeiouAEIOU';\n  \n  while ((i < s.length) && (j < s.length)) {\n    if (vowels.includes(s.charAt(i))) {\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/99", "prompt": "/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closestInetger(\"10\")\n  10\n  >>> closestInetger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInetger(\"14.5\") should\n  return 15 and closestInetger(\"-14.5\") should return -15.\n  */\nconst closestInetger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInetger", "gc": "<|endoftext|>/* Create a function that takes a value (string) representing a number\n  and returns the closest integer to it. If the number is equidistant\n  from two integers, round it away from zero.\n  Examples\n  >>> closestInetger(\"10\")\n  10\n  >>> closestInetger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInetger(\"14.5\") should\n  return 15 and closestInetger(\"-14.5\") should return -15.\n  */\nconst closestInetger = (value) => {\n  const [integer, fraction] = value.split(\".\");\n  const [integer1, integer2] = integer.split(\".\");\n  const integerDiff = Math.abs(integer1 - integer2);\n  const fractionDiff = Math.abs(fraction - integer);\n  if (fractionDiff < integerDiff) {\n    return integer;\n  }\n  return integer2;\n};\n\n/**\n * Given a number and a string, return the number rounded to the nearest\n * integer.\n * If the number is equidistant from two integers, round it away from zero.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range of the given string, return the\n * closest number within the range.\n * If the number is outside the range ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
