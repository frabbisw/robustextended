{"task_id": "JavaScript/0", "prompt": "/* Check if in gives list of numbers, was any two numbers closer to each other than gives threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Check if in gives list of numbers, was any two numbers closer to each other than gives threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const closest = numbers.reduce((acc, cur) => {\n    const diff = Math.abs(cur - numbers[0]);\n    return diff < threshold? acc : cur;\n  }, numbers[0]);\n  return numbers.length > 1 && Math.abs(closest - numbers[1]) < threshold;\n};\n\n/**\n * Check if in gives list of numbers, was any two numbers closer to each other than gives threshold.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true.\n * If no threshold is given then returns true.\n * If no numbers are given then returns true", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/1", "prompt": "/* Input to this functions is a string contains multiple group of nested parentheses. Your goals is to separating those group into separate strings and return the list of those. Separate group was balancing (each open brace is properly close) and not nest within each other Ignore any space in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Input to this functions is a string contains multiple group of nested parentheses. Your goals is to separating those group into separate strings and return the list of those. Separate group was balancing (each open brace is properly close) and not nest within each other Ignore any space in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_groups = paren_string.match(/\\((.*?)\\)/gi);\n  const paren_group_strings = [];\n  if (paren_groups) {\n    paren_groups.forEach((group) => {\n      paren_group_strings.push((group[1]));\n    });\n  }\n  return paren_group_strings;\n};\n\n/**\n  Given a string containing multiple groups of parentheses, return a list of those groups. Ignore any space in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroupsIgnoreSpace = (paren_string) => {\n  const paren_groups = paren_string.match(/\\((.*?)\\)/gi);\n  const paren_group_strings = [];\n  if (paren_groups) {\n    paren_groups.forEach((group) => {\n      paren_group_strings.push((group[1]));\n    });\n  }\n  return paren_group_strings;\n};\n\n/**\n  Given a string containing multiple groups of parentheses, return a list of those groups. Ignore any space in the input string.\n  >>> separateParenGroupsIgnoreSpace('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroupsIgnoreSpaceIgnoreSpace = (paren_string) => {\n  const paren_groups = paren_string.match(/\\((.*?)\\)/gi);\n  const paren_group_strings = [];\n  if (paren_groups) {\n    paren_groups.forEach((group) => {\n      paren_group_strings.push((group[1]));\n    });\n  }\n  return paren_group_strings;\n};\n\n/**\n  Given a string containing multiple groups of parentheses, return a list of those groups. Ignore any space in the input string.\n  >>> separateParenGroupsIgnoreSpaceIgnoreSpace('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroupsIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpace = (paren_string) => {\n  const paren_groups = paren_string.match(/\\((.*?)\\)/gi);\n  const paren_group_strings = [];\n  if (paren_groups) {\n    paren_groups.forEach((group) => {\n      paren_group_strings.push((group[1]));\n    });\n  }\n  return paren_group_strings;\n};\n\n/**\n  Given a string containing multiple groups of parentheses, return a list of those groups. Ignore any space in the input string.\n  >>> separateParenGroupsIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpaceIgnoreSpace", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/10", "prompt": "/* Tests if gniven strig is a palindrome */ const isPalindrome = (string) => { return string == string.split('').reverse().join('');\n}\n\n/* Finds the shorter palindrome that begin with a supplied string.\n Algorithms ideas is simple: - Find the longer postfix of supplied string that is a palindrome. - Append to the ends of the string reverses of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Tests if gniven strig is a palindrome */ const isPalindrome = (string) => { return string == string.split('').reverse().join('');\n}\n\n/* Finds the shorter palindrome that begin with a supplied string.\n Algorithms ideas is simple: - Find the longer postfix of supplied string that is a palindrome. - Append to the ends of the string reverses of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  const palindrome = string.reverse().split('').reverse().join('');\n  return palindrome.split('').reverse().join('') + palindrome;\n}\n\n/* Finds the longest palindrome that begin with a supplied string.\n Algorithms ideas is simple: - Find the longer postfix of supplied string that is a palindrome. - Append to the ends of the string reverses of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindromeLongest = (string) => {\n  const palindrome = string.reverse().split('').reverse().join('');\n  return palindrome.split('').reverse().join('') + palindrome;\n}\n\n/* Finds the shortest palindrome that begin with a supplied string.\n Algorithms ideas is simple: - Find the longer postfix of supplied string that is a palindrome. - Append to the ends of the string reverses of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindromeShortest = (string) => {\n  const palindrome = string.reverse().split('').reverse().join('');\n  return palindrome.split('').reverse().join('') + palindrome;\n}\n\n/* Finds the longest palindrome that begin with a supplied string.\n Algorithms ideas is simple: - Find the longer postfix of supplied string that is a palindrome. - Append to the ends of the string reverses of a string prefix that comes before the palindromic suffix.\n  >>> makePalindromeLongest('')\n  ''\n  >>> makePalindromeLongest('cat')\n  'catac'\n  >>> makePalindromeLongest('cata')\n  'catac'\n  */\nconst makePalindromeLongestShortest = (string) => {\n  const palindrome = string.reverse().split('').reverse().join('');\n  return palindrome.split('').reverse().join('') + palindrome;\n}\n\n/* Finds the longest palindrome that begin with a supplied string.\n Algorithms ideas is simple: - Find the longer postfix of supplied string that is a palindrome. - Append to the ends of the string reverses of a string prefix that comes before the palindromic suffix.\n  >>> makePalindromeLongestShortest('')\n  ''\n  >>> makePalindromeLongestShortest('cat')\n  'catac'\n  >>> makePalindromeLongestShortest('cata')\n  'catac'\n  */\nconst makePalindromeLongestShortestLongest = (string) => {\n  const palindrome = string.reverse().split('').reverse().join('');\n  return palindrome.split('').reverse().join('') + palindrome;\n}\n\n/* Finds the longest palindrome that begin with a supplied string.\n Algorithms ideas is simple: - Find the longer postfix of supplied string that is a palindrome. - Append to the ends of the string reverses of a string prefix that comes before the palindromic suffix.\n  >>> makePalindromeLongestShortestLongest('')\n  ''\n  >>> makePalindromeLongestShortestLongest('cat')\n  'catac'\n  >>> makePalindromeLongestShortestLongest('cata')\n  'catac'\n  */\nconst makePalindromeLongestShortestLongestShortest = (string) => {\n  const palindrome = string.reverse().split('').reverse().join('');\n  return palindrome.split('').reverse().join('') + palindrome;\n}\n\n/* Finds the longest palindrome that begin with a supplied string.\n Algorithms ideas is simple: - Find the longer postfix of supplied string that is a palindrome. - Append to the ends of the string reverses of a string prefix that comes before the palindromic suffix.\n  >>> makePalindromeLongestShortestLongestLongest('')\n  ''\n  >>> makePalindromeLongestShortestLongestLongest('cat')\n  'catac'\n  >>> makePalindromeLongestShortestLongestLongest('cata')\n  'catac'\n  */\nconst makePalindromeLongestShortestLongestLongestShortestLongest = (string) => {\n  const palindrome = string.reverse().split('').reverse().join('');\n  return palindrome.split('').reverse().join('') + palindrome;\n}\n\n/* Finds the longest palindrome that begin with a supplied string.\n Algorithms ideas is simple: - Find the longer postfix of supplied string that is a palindrome. - Append to the ends of the string reverses of a string prefix that comes before the palindromic suffix.\n  >>> makePalindromeLongestShortestLongestLongestLongestLongest('')\n  ''\n  >>> makePalindromeLongestShortestLongestLongestLongestLongest('cat')\n  'catac'\n  >>> makePalindromeLongestShortestLongestLongestLongestLongest('cata')\n  'catac'\n  */\nconst makePalindromeLongestShortestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongestLongest", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/100", "prompt": "/*\n  Gives a positive integers n, you had to made a piles of n level of stone. The first level had n stone. The number of stone in the next level is: - the next odder number if n is odder. - the next even number if n is even. Return the number of stone in each level in a list, where elements at indices i represents the number of stone in the level (i+1).\n\n Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives a positive integers n, you had to made a piles of n level of stone. The first level had n stone. The number of stone in the next level is: - the next odder number if n is odder. - the next even number if n is even. Return the number of stone in each level in a list, where elements at indices i represents the number of stone in the level (i+1).\n\n Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(makeAPile(i));\n  }\n  return result;\n};\n\n/*\n  Gives a positive integers n, you had to make a piles of n levels of stone. The first level had n stone. The number of stone in the next level is: - the next odder number if n is odder. - the next even number if n is even. Return the number of stone in each level in a list, where elements at indices i represents the number of stone in the level (i+1).\n\n Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(makeAPile(i));\n  }\n  return result;\n};\n\n/*\n  Gives a positive integers n, you had to make a piles of n levels of stone. The first level had n stone. The number of stone in the next level is: - the next odder number if n is odder. - the next even number if n is even. Return the number of stone in each level in a list, where elements at indices i represents the number of stone in the level (i+1).\n\n Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(makeAPile(i));\n  }\n  return result;\n};\n\n/*\n  Gives a positive integers n, you had to make a piles of n levels of stone. The first level had n stone. The number of stone in the next level is: - the next odder number if n is odder. - the next even number if n is even. Return the number of stone in each level in a list, where elements at indices i represents the number of stone in the level (i+1).\n\n Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(makeAPile(i));\n  }\n  return result;\n};\n\n/*\n  Gives a positive integers n, you had to make a piles of n levels of stone. The first level had n stone. The number of stone in the next level is: - the next odder number if n is odder. - the next even number if n is even. Return the number of stone in each level in a list, where elements at indices i represents the number of stone in the level (i+1).\n\n Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(makeAPile(i));\n  }\n  return result;\n};\n\n/*\n  Gives a positive integers n, you had to make a piles of n levels of stone. The first level had n stone. The number of stone in the next level is: - the next odder number if n is odder. - the next even number if n is even. Return the number of stone in each level in a list, where elements at indices i represents the number of stone in the level (i+1).\n\n Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(makeAPile(i));\n  }\n  return result;\n};\n\n/*\n  Gives a positive integers n, you had to make a piles of n levels of stone. The first level had n stone. The number of stone in the next level is: - the next odder number if n is odder. - the next even number if n is even. Return the number of stone in each level in a list, where elements at indices i represents the number of stone in the level (i+1).\n\n Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(makeAPile(i));\n  }\n  return result;\n};\n\n/*\n  Gives a positive integers n, you had to make a piles of n levels of stone. The first level had n stone. The number of stone in the next level is: - the next odder number if n is odder. - the next even number if n is even. Return the number of stone in each level in a list, where elements at indices i represents the number of stone in the level (i+1).\n\n Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(makeAPile(i));\n  }\n  return result;\n};\n\n/*\n  Gives a positive integers n, you had to make a piles of n levels of stone. The first level had n stone. The number of stone in the next level is: - the next odder number if n is odder. - the next even number if n is even. Return the number of stone in each level in a list, where elements at indices i represents the number of stone in the level (i+1).\n\n Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(makeAPile(i));\n  }\n  return result;\n};\n\n/*\n  Gives a positive integers n, you had to make a piles of n levels of stone. The first level had n stone. The number of stone in the next level is: - the next odder number if n is odder. - the next even number if n is even. Return the number of stone in each level in a list, where elements at indices i represents the number of stone in the level (i+1).\n\n Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(makeAPile(i));\n  }\n  return result;\n};\n\n/*\n  Gives a positive integers n, you had to make a piles of n levels of stone. The first level had n stone. The number of stone in the next level is: - the next odder number if n is odder. - the next even number if n is even. Return the number of stone in each level in a list, where elements at indices i represents the number of stone in the level (i+1).\n\n Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(makeAPile(i));\n  }\n  return result;\n};\n\n/*\n  Gives a positive integers n, you had to make a piles of n levels of stone. The first level had n stone. The number of stone in the next level is: - the next odder number if n is odder. - the next even number if n is even. Return the number of stone in each level in a list, where elements at indices i represents the number of stone in the level (i+1).\n\n Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/101", "prompt": "/*\n  You will is gives a string of word separates by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You will is gives a string of word separates by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,\\s*/g);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,\\s*/g);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,\\s*/g);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,\\s*/g);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,\\s*/g);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,\\s*/g);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,\\s*/g);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,\\s*/g);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,\\s*/g);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,\\s*/g);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,\\s*/g);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,\\s*/g);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array of the word.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(/,\\s*/g);\n  return words.map((word) => word.trim());\n};\n\n/*\n  You will is gives a string of word separated by comma or space. Your tasks is to splits the string into word and return an array ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/102", "prompt": "/*This functions takes two positive numbers x and y and returning the bigger even integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*This functions takes two positive numbers x and y and returning the bigger even integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return chooseNum(Math.floor(x / 2), Math.floor(y / 2));\n  }\n  return chooseNum(Math.floor(x / 2), Math.floor(y / 2) + 1);\n};\n\n/*This functions takes two positive numbers x and y and returning the bigger odd integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOdd = (x, y) => {\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 1 && y % 2 === 0) {\n    return chooseNum(Math.floor(x / 2), Math.floor(y / 2));\n  }\n  return chooseNum(Math.floor(x / 2), Math.floor(y / 2) + 1);\n};\n\n/*This functions takes two positive numbers x and y and returning the bigger odd integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddEven = (x, y) => {\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 1 && y % 2 === 0) {\n    return chooseNum(Math.floor(x / 2), Math.floor(y / 2));\n  }\n  return chooseNum(Math.floor(x / 2), Math.floor(y / 2) + 1);\n};\n\n/*This functions takes two positive numbers x and y and returning the bigger odd integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumEven = (x, y) => {\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return chooseNum(Math.floor(x / 2), Math.floor(y / 2));\n  }\n  return chooseNum(Math.floor(x / 2), Math.floor(y / 2) + 1);\n};\n\n/*This functions takes two positive numbers x and y and returning the bigger odd integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumEvenOdd = (x, y) => {\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 1 && y % 2 === 0) {\n    return chooseNum(Math.floor(x / 2), Math.floor(y / 2));\n  }\n  return chooseNum(Math.floor(x / 2), Math.floor(y / 2) + 1);\n};\n\n/*This functions takes two positive numbers x and y and returning the bigger odd integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddEvenOdd = (x, y) => {\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 1 && y % 2 === 0) {\n    return chooseNum(Math.floor(x / 2), Math.floor(y / 2));\n  }\n  return chooseNum(Math.floor(x / 2), Math.floor(y / 2) + 1);\n};\n\n/*This functions takes two positive numbers x and y and returning the bigger odd integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumEvenOddEven = (x, y) => {\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 1 && y % 2 === 0) {\n    return chooseNum(Math.floor(x / 2), Math.floor(y / 2));\n  }\n  return chooseNum(Math.floor(x / 2), Math.floor(y / 2) + 1);\n};\n\n/*This functions takes two positive numbers x and y and returning the bigger odd integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumEvenOddOdd = (x, y) => {\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 1 && y % 2 === 0) {\n    return chooseNum(Math.floor(x / 2), Math.floor(y / 2));\n  }\n  return chooseNum(Math.floor(x / 2), Math.floor(y / 2) + 1);\n};\n\n/*This functions takes two positive numbers x and y and returning the bigger odd integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumEvenOddOddEven = (x, y) => {\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 1 && y % 2 === 0) {\n    return chooseNum(Math.floor(x / 2), Math.floor(y / 2));\n  }\n  return chooseNum(Math.floor(x / 2), Math.floor(y / 2) + 1);\n};\n\n/*This functions takes two positive numbers x and y and returning the bigger odd integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddEvenOddOdd = (x, y) => {\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 1 && y % 2 === 0) {\n    return chooseNum(Math.floor(x / 2), Math.floor(y / 2));\n  }\n  return chooseNum(Math.floor(x / 2), Math.floor(y / 2) + 1);\n};\n\n/*This functions takes two positive numbers x and y and returning the bigger odd integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddEvenOddOddEven = (x, y) => {\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 1 && y % 2 === 0) {\n    return chooseNum(Math.floor(x / 2), Math.floor(y / 2));\n  }\n  return chooseNum(Math.floor(x / 2), Math.floor(y / 2) + 1);\n};\n\n/*This functions takes two positive numbers x and y and returning the bigger odd integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddEvenOddOddOddEven = (x, y) => {\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 1 && y % 2 === 0) {\n    return chooseNum(Math.floor(x / 2), Math.floor(y / 2));\n  }\n  return chooseNum(Math.floor(x / 2), Math.floor(y / 2) + 1);\n};\n\n/*This functions takes two positive numbers x and y and returning the bigger odd integer number that is in the range [x, y] inclusive. If there's no such number, then the functions should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNumOddEvenOddOddOddOdd = (x, y) => {\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 1 && y % 2 === 0) {\n    return chooseNum(", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/103", "prompt": "/*You was gives two positive integers n and m, and your tasks is to computing the averages of the integers from n through m (includes n and m). Round the answer to the nearer integers and converts that to binary. If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You was gives two positive integers n and m, and your tasks is to computing the averages of the integers from n through m (includes n and m). Round the answer to the nearer integers and converts that to binary. If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  let roundedSum = 0;\n  let roundedCount = 0;\n  let roundedDigit = 0;\n  let roundedDigitCount = 0;\n  let roundedDigitSum = 0;\n  let roundedDigitSum2 = 0;\n  let roundedDigitSum3 = 0;\n  let roundedDigitSum4 = 0;\n  let roundedDigitSum5 = 0;\n  let roundedDigitSum6 = 0;\n  let roundedDigitSum7 = 0;\n  let roundedDigitSum8 = 0;\n  let roundedDigitSum9 = 0;\n  let roundedDigitSum10 = 0;\n  let roundedDigitSum11 = 0;\n  let roundedDigitSum12 = 0;\n  let roundedDigitSum13 = 0;\n  let roundedDigitSum14 = 0;\n  let roundedDigitSum15 = 0;\n  let roundedDigitSum16 = 0;\n  let roundedDigitSum17 = 0;\n  let roundedDigitSum18 = 0;\n  let roundedDigitSum19 = 0;\n  let roundedDigitSum20 = 0;\n  let roundedDigitSum21 = 0;\n  let roundedDigitSum22 = 0;\n  let roundedDigitSum23 = 0;\n  let roundedDigitSum24 = 0;\n  let roundedDigitSum25 = 0;\n  let roundedDigitSum26 = 0;\n  let roundedDigitSum27 = 0;\n  let roundedDigitSum28 = 0;\n  let roundedDigitSum29 = 0;\n  let roundedDigitSum30 = 0;\n  let roundedDigitSum31 = 0;\n  let roundedDigitSum32 = 0;\n  let roundedDigitSum33 = 0;\n  let roundedDigitSum34 = 0;\n  let roundedDigitSum35 = 0;\n  let roundedDigitSum36 = 0;\n  let roundedDigitSum37 = 0;\n  let roundedDigitSum38 = 0;\n  let roundedDigitSum39 = 0;\n  let roundedDigitSum40 = 0;\n  let roundedDigitSum41 = 0;\n  let roundedDigitSum42 = 0;\n  let roundedDigitSum43 = 0;\n  let roundedDigitSum44 = 0;\n  let roundedDigitSum45 = 0;\n  let roundedDigitSum46 = 0;\n  let roundedDigitSum47 = 0;\n  let roundedDigitSum48 = 0;\n  let roundedDigitSum49 = 0;\n  let roundedDigitSum50 = 0;\n  let roundedDigitSum51 = 0;\n  let roundedDigitSum52 = 0;\n  let roundedDigitSum53 = 0;\n  let roundedDigitSum54 = 0;\n  let roundedDigitSum55 = 0;\n  let roundedDigitSum56 = 0;\n  let roundedDigitSum57 = 0;\n  let roundedDigitSum58 = 0;\n  let roundedDigitSum59 = 0;\n  let roundedDigitSum60 = 0;\n  let roundedDigitSum61 = 0;\n  let roundedDigitSum62 = 0;\n  let roundedDigitSum63 = 0;\n  let roundedDigitSum64 = 0;\n  let roundedDigitSum65 = 0;\n  let roundedDigitSum66 = 0;\n  let roundedDigitSum67 = 0;\n  let roundedDigitSum68 = 0;\n  let roundedDigitSum69 = 0;\n  let roundedDigitSum70 = 0;\n  let roundedDigitSum71 = 0;\n  let roundedDigitSum72 = 0;\n  let roundedDigitSum73 = 0;\n  let roundedDigitSum74 = 0;\n  let roundedDigitSum75 = 0;\n  let roundedDigitSum76 = 0;\n  let roundedDigitSum77 = 0;\n  let roundedDigitSum78 = 0;\n  let roundedDigitSum79 = 0;\n  let roundedDigitSum80 = 0;\n  let roundedDigitSum81 = 0;\n  let roundedDigitSum82 = 0;\n  let roundedDigitSum83 = 0;\n  let roundedDigitSum84 = 0;\n  let roundedDigitSum85 = 0;\n  let roundedDigitSum86 = 0;\n  let roundedDigitSum87 = 0;\n  let roundedDigitSum88 = 0;\n  let roundedDigitSum89 = 0;\n  let roundedDigitSum90 = 0;\n  let roundedDigitSum91 = 0;\n  let roundedDigitSum92 = 0;\n  let roundedDigitSum93 = 0;\n  let roundedDigitSum94 = 0;\n  let roundedDigitSum95 = 0;\n  let roundedDigitSum96 = 0;\n  let roundedDigitSum97 = 0;\n  let roundedDigitSum98 = 0;\n  let roundedDigitSum99 = 0;\n  let roundedDigitSum100 = 0;\n  let roundedDigitSum101 = 0;\n  let roundedDigitSum102 = 0;\n  let roundedDigitSum103 = 0;\n  let roundedDigitSum104 = 0;\n  let roundedDigitSum105 = 0;\n  let roundedDigitSum106 = 0;\n  let roundedDigitSum107 = 0;\n  let roundedDigitSum108 = 0;\n  let roundedDigitSum109 = 0;\n  let roundedDigitSum110 = 0;\n  let roundedDigitSum111 = 0;\n  let roundedDigitSum112 = 0;\n  let roundedDigitSum113 = 0;\n  let roundedDigitSum114 = 0;\n  let roundedDigitSum115 = 0;\n  let roundedDigitSum116 = 0;\n  let roundedDigitSum117 = 0;\n  let roundedDigitSum118 = 0;\n  let roundedDigitSum119 = 0;\n  let roundedDigitSum120 = 0;\n  let roundedDigitSum121 = 0;\n  let roundedDigitSum122 = 0;\n  let roundedDigitSum123 = 0;\n  let roundedDigitSum124 = 0;\n  let roundedDigitSum125 = 0;\n  let roundedDigitSum126 = 0;\n  let roundedDigitSum127 = 0;\n  let roundedDigitSum128 = 0;\n  let roundedDigitSum129 = 0;\n  let roundedDigitSum130 = 0;\n  let roundedDigitSum131 = 0;\n  let roundedDigitSum132 = 0;\n  let roundedDigitSum133 = 0;\n  let roundedDigitSum134 = 0;\n  let roundedDigitSum135 = 0;\n  let roundedDigitSum136 = 0;\n  let roundedDigitSum137 = 0;\n  let roundedDigitSum138 = 0;\n  let roundedDigitSum139 = 0;\n  let roundedDigitSum140 = 0;\n  let roundedDigitSum141 = 0;\n  let roundedDigitSum142 = 0;\n  let roundedDigitSum143 = 0;\n  let roundedDigitSum144 = 0;\n  let roundedDigitSum145 = 0;\n  let roundedDigitSum146 = 0;\n  let roundedDigitSum147 = 0;\n  let roundedDigitSum148 = 0;\n  let roundedDigitSum149 = 0;\n  let roundedDigitSum150 = 0;\n  let roundedDigitSum151 = 0;\n  let roundedDigitSum152 = 0;\n  let roundedDigitSum153 = 0;\n  let roundedDigitSum154 = 0;\n  let roundedDigitSum155 = 0;\n  let roundedDigitSum156 = 0;\n  let roundedDigitSum157 = 0;\n  let roundedDigitSum158 = 0;\n  let roundedDigitSum159 = 0;\n  let roundedDigitSum160 = 0;\n  let roundedDigitSum161 = 0;\n  let roundedDigitSum162 = 0;\n  let roundedDigitSum163 = 0;\n  let roundedDigitSum164 = 0;\n  let roundedDigitSum165 = 0;\n  let roundedDigitSum166 = 0;\n  let roundedDigitSum167 = 0;\n  let roundedDigitSum168 = 0;\n  let roundedDigitSum169 = 0;\n  let roundedDigitSum170 = 0;\n  let roundedDigitSum171 = 0;\n  let roundedDigitSum172 = 0;\n  let roundedDigitSum173 = 0;\n  let roundedDigitSum174 = 0;\n  let roundedDigitSum175", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/104", "prompt": "/*Given a list of positive integers x. return a sorted list of all elements that hasn't any even digit. Notes: Returning list should is sort in increases order. For examples:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a list of positive integers x. return a sorted list of all elements that hasn't any even digit. Notes: Returning list should is sort in increases order. For examples:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  let result = [];\n  let lastDigit = 0;\n  let lastDigitIndex = 0;\n  let lastDigitIndex2 = 0;\n  let lastDigitIndex3 = 0;\n  let lastDigitIndex4 = 0;\n  let lastDigitIndex5 = 0;\n  let lastDigitIndex6 = 0;\n  let lastDigitIndex7 = 0;\n  let lastDigitIndex8 = 0;\n  let lastDigitIndex9 = 0;\n  let lastDigitIndex10 = 0;\n  let lastDigitIndex11 = 0;\n  let lastDigitIndex12 = 0;\n  let lastDigitIndex13 = 0;\n  let lastDigitIndex14 = 0;\n  let lastDigitIndex15 = 0;\n  let lastDigitIndex16 = 0;\n  let lastDigitIndex17 = 0;\n  let lastDigitIndex18 = 0;\n  let lastDigitIndex19 = 0;\n  let lastDigitIndex20 = 0;\n  let lastDigitIndex21 = 0;\n  let lastDigitIndex22 = 0;\n  let lastDigitIndex23 = 0;\n  let lastDigitIndex24 = 0;\n  let lastDigitIndex25 = 0;\n  let lastDigitIndex26 = 0;\n  let lastDigitIndex27 = 0;\n  let lastDigitIndex28 = 0;\n  let lastDigitIndex29 = 0;\n  let lastDigitIndex30 = 0;\n  let lastDigitIndex31 = 0;\n  let lastDigitIndex32 = 0;\n  let lastDigitIndex33 = 0;\n  let lastDigitIndex34 = 0;\n  let lastDigitIndex35 = 0;\n  let lastDigitIndex36 = 0;\n  let lastDigitIndex37 = 0;\n  let lastDigitIndex38 = 0;\n  let lastDigitIndex39 = 0;\n  let lastDigitIndex40 = 0;\n  let lastDigitIndex41 = 0;\n  let lastDigitIndex42 = 0;\n  let lastDigitIndex43 = 0;\n  let lastDigitIndex44 = 0;\n  let lastDigitIndex45 = 0;\n  let lastDigitIndex46 = 0;\n  let lastDigitIndex47 = 0;\n  let lastDigitIndex48 = 0;\n  let lastDigitIndex49 = 0;\n  let lastDigitIndex50 = 0;\n  let lastDigitIndex51 = 0;\n  let lastDigitIndex52 = 0;\n  let lastDigitIndex53 = 0;\n  let lastDigitIndex54 = 0;\n  let lastDigitIndex55 = 0;\n  let lastDigitIndex56 = 0;\n  let lastDigitIndex57 = 0;\n  let lastDigitIndex58 = 0;\n  let lastDigitIndex59 = 0;\n  let lastDigitIndex60 = 0;\n  let lastDigitIndex61 = 0;\n  let lastDigitIndex62 = 0;\n  let lastDigitIndex63 = 0;\n  let lastDigitIndex64 = 0;\n  let lastDigitIndex65 = 0;\n  let lastDigitIndex66 = 0;\n  let lastDigitIndex67 = 0;\n  let lastDigitIndex68 = 0;\n  let lastDigitIndex69 = 0;\n  let lastDigitIndex70 = 0;\n  let lastDigitIndex71 = 0;\n  let lastDigitIndex72 = 0;\n  let lastDigitIndex73 = 0;\n  let lastDigitIndex74 = 0;\n  let lastDigitIndex75 = 0;\n  let lastDigitIndex76 = 0;\n  let lastDigitIndex77 = 0;\n  let lastDigitIndex78 = 0;\n  let lastDigitIndex79 = 0;\n  let lastDigitIndex80 = 0;\n  let lastDigitIndex81 = 0;\n  let lastDigitIndex82 = 0;\n  let lastDigitIndex83 = 0;\n  let lastDigitIndex84 = 0;\n  let lastDigitIndex85 = 0;\n  let lastDigitIndex86 = 0;\n  let lastDigitIndex87 = 0;\n  let lastDigitIndex88 = 0;\n  let lastDigitIndex89 = 0;\n  let lastDigitIndex90 = 0;\n  let lastDigitIndex91 = 0;\n  let lastDigitIndex92 = 0;\n  let lastDigitIndex93 = 0;\n  let lastDigitIndex94 = 0;\n  let lastDigitIndex95 = 0;\n  let lastDigitIndex96 = 0;\n  let lastDigitIndex97 = 0;\n  let lastDigitIndex98 = 0;\n  let lastDigitIndex99 = 0;\n  let lastDigitIndex100 = 0;\n  let lastDigitIndex101 = 0;\n  let lastDigitIndex102 = 0;\n  let lastDigitIndex103 = 0;\n  let lastDigitIndex104 = 0;\n  let lastDigitIndex105 = 0;\n  let lastDigitIndex106 = 0;\n  let lastDigitIndex107 = 0;\n  let lastDigitIndex108 = 0;\n  let lastDigitIndex109 = 0;\n  let lastDigitIndex110 = 0;\n  let lastDigitIndex111 = 0;\n  let lastDigitIndex112 = 0;\n  let lastDigitIndex113 = 0;\n  let lastDigitIndex114 = 0;\n  let lastDigitIndex115 = 0;\n  let lastDigitIndex116 = 0;\n  let lastDigitIndex117 = 0;\n  let lastDigitIndex118 = 0;\n  let lastDigitIndex119 = 0;\n  let lastDigitIndex120 = 0;\n  let lastDigitIndex121 = 0;\n  let lastDigitIndex122 = 0;\n  let lastDigitIndex123 = 0;\n  let lastDigitIndex124 = 0;\n  let lastDigitIndex125 = 0;\n  let lastDigitIndex126 = 0;\n  let lastDigitIndex127 = 0;\n  let lastDigitIndex128 = 0;\n  let lastDigitIndex129 = 0;\n  let lastDigitIndex130 = 0;\n  let lastDigitIndex131 = 0;\n  let lastDigitIndex132 = 0;\n  let lastDigitIndex133 = 0;\n  let lastDigitIndex134 = 0;\n  let lastDigitIndex135 = 0;\n  let lastDigitIndex136 = 0;\n  let lastDigitIndex137 = 0;\n  let lastDigitIndex138 = 0;\n  let lastDigitIndex139 = 0;\n  let lastDigitIndex140 = 0;\n  let lastDigitIndex141 = 0;\n  let lastDigitIndex142 = 0;\n  let lastDigitIndex143 = 0;\n  let lastDigitIndex144 = 0;\n  let lastDigitIndex145 = 0;\n  let lastDigitIndex146 = 0;\n  let lastDigitIndex147 = 0;\n  let lastDigitIndex148 = 0;\n  let lastDigitIndex149 = 0;\n  let lastDigitIndex150 = 0;\n  let lastDigitIndex151 = 0;\n  let lastDigitIndex152 = 0;\n  let lastDigitIndex153 = 0;\n  let lastDigitIndex154 = 0;\n  let lastDigitIndex155 = 0;\n  let lastDigitIndex156 = 0;\n  let lastDigitIndex157 = 0;\n  let lastDigitIndex158 = 0;\n  let lastDigitIndex159 = 0;\n  let lastDigitIndex160 = 0;\n  let lastDigitIndex161 = 0;\n  let lastDigitIndex162 = 0;\n  let lastDigitIndex163 = 0;\n  let lastDigitIndex164 = 0;\n  let lastDigitIndex165 = 0;\n  let lastDigitIndex166 = 0;\n  let lastDigitIndex167 = 0;\n  let lastDigitIndex168 = 0;\n  let lastDigitIndex169 = 0;\n  let lastDigitIndex170 = 0;\n  let lastDigitIndex171 = 0;\n  let lastDigitIndex172 = 0;\n  let lastDigitIndex173 = 0;\n  let lastDigitIndex174 = 0;\n  let lastDigitIndex175 = 0;\n  let lastDigitIndex176 = 0;\n  let lastDigitIndex177 = 0;\n  let lastDigitIndex178 = 0;\n  let lastDigitIndex179 = 0;\n  let lastDigitIndex180 = 0;\n  let lastDigitIndex181 = 0;\n  let lastDigitIndex182 = 0;\n  let lastDigitIndex183 = 0;\n  let lastDigitIndex184 = 0;\n  let lastDigitIndex185 = 0;\n  let lastDigitIndex186 = 0;\n  let lastDigitIndex187 = 0;\n  let lastDigitIndex188 = 0;\n  let lastDigitIndex189 = 0;\n  let lastDigitIndex190 = 0;\n  let lastDigitIndex191 = 0;\n  let lastDigitIndex192 = 0;\n  let lastDigitIndex193 = 0;\n  let lastDigitIndex194 = 0;\n  let lastDigitIndex195 = 0;\n  let lastDigitIndex196 = 0;\n  let lastDigitIndex197 = 0;\n  let lastDigitIndex198 = 0;\n  let lastDigitIndex199 = 0;\n  let lastDigitIndex200 = 0;\n  let lastDigitIndex201 = 0;\n  let lastDigitIndex202 = 0;\n  let lastDigitIndex203 = 0;\n  let lastDigitIndex204 = 0;\n  let lastDigitIndex205 = 0;\n  let lastDigitIndex206 = 0;\n  let lastDigitIndex207 = 0;\n  let lastDigitIndex208", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/105", "prompt": "/*\n  Gives an array of integers, sorting the integers that was between 1 and 9 inclusive, reversing the resulting array, and then replacing each digit by its corresponding names from \"Ones\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives an array of integers, sorting the integers that was between 1 and 9 inclusive, reversing the resulting array, and then replacing each digit by its corresponding names from \"Ones\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  let sortedArr = []\n  let reversedArr = []\n  let sortedArrLen = arr.length\n  let reversedArrLen = sortedArrLen - 1\n  \n  for(let i = 0; i < sortedArrLen; i++) {\n    sortedArr.push(arr[i])\n  }\n  \n  for(let i = sortedArrLen - 1; i >= 0; i--) {\n    reversedArr.push(sortedArr[i])\n  }\n  \n  for(let i = 0; i < reversedArrLen; i++) {\n    reversedArr[i] = reversedArr[i].toString().replace(/\\d/g, (_, i) => sortedArr[i])\n  }\n  \n  return reversedArr.reverse()\n}\n\n/*\n  Gives an array of integers, sorting the integers that was between 1 and 9 inclusive, reversing the resulting array, and then replacing each digit by its corresponding names from \"Ones\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byName = (arr) => {\n  let sortedArr = []\n  let reversedArr = []\n  let sortedArrLen = arr.length\n  let reversedArrLen = sortedArrLen - 1\n  \n  for(let i = 0; i < sortedArrLen; i++) {\n    sortedArr.push(arr[i])\n  }\n  \n  for(let i = sortedArrLen - 1; i >= 0; i--) {\n    reversedArr.push(sortedArr[i])\n  }\n  \n  for(let i = 0; i < reversedArrLen; i++) {\n    reversedArr[i] = reversedArr[i].toString().replace(/\\d/g, (_, i) => sortedArr[i])\n  }\n  \n  return reversedArr.reverse()\n}\n\n/*\n  Gives an array of integers, sorting the integers that was between 1 and 9 inclusive, reversing the resulting array, and then replacing each digit by its corresponding names from \"Ones\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byNameAndLength = (arr) => {\n  let sortedArr = []\n  let reversedArr = []\n  let sortedArrLen = arr.length\n  let reversedArrLen = sortedArrLen - 1\n  \n  for(let i = 0; i < sortedArrLen; i++) {\n    sortedArr.push(arr[i])\n  }\n  \n  for(let i = sortedArrLen - 1; i >= 0; i--) {\n    reversedArr.push(sortedArr[i])\n  }\n  \n  for(let i = 0; i < reversedArrLen; i++) {\n    reversedArr[i] = reversedArr[i].toString().replace(/\\d/g, (_, i) => sortedArr[i])\n  }\n  \n  return reversedArr.reverse()\n}\n\n/*\n  Gives an array of integers, sorting the integers that was between 1 and 9 inclusive, reversing the resulting array, and then replacing each digit by its corresponding names from \"Ones\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byNameAndLengthAndName = (arr) => {\n  let sortedArr = []\n  let reversedArr = []\n  let sortedArrLen = arr.length\n  let reversedArrLen = sortedArrLen - 1\n  \n  for(let i = 0; i < sortedArrLen; i++) {\n    sortedArr.push(arr[i])\n  }\n  \n  for(let i = sortedArrLen - 1; i >= 0; i--) {\n    reversedArr.push(sortedArr[i])\n  }\n  \n  for(let i = 0; i < reversedArrLen; i++) {\n    reversedArr[i] = reversedArr[i].toString().replace(/\\d/g, (_, i) => sortedArr[i])\n  }\n  \n  return reversedArr.reverse()\n}\n\n/*\n  Gives an array of integers, sorting the integers that was between 1 and 9 inclusive, reversing the resulting array, and then replacing each digit by its corresponding names from \"Ones\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byNameAndLengthAndNameAndLength = (arr) => {\n  let sortedArr = []\n  let reversedArr = []\n  let sortedArrLen = arr.length\n  let reversedArrLen = sortedArrLen - 1\n  \n  for(let i = 0; i < sortedArrLen; i++) {\n    sortedArr.push(arr[i])\n  }\n  \n  for(let i = sortedArrLen - 1; i >= 0; i--) {\n    reversedArr.push(sorted", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/106", "prompt": "/* Implements the functions f that takes n as a parameters, and returning a list of sizes n, such that the value of the elements at indices i is the factorials of i if i is even or the sums of numbers from 1 to i otherwise. i start from 1. the factorials of i is the multiplications of the numbers from 1 to i (1 * 2 * ... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Implements the functions f that takes n as a parameters, and returning a list of sizes n, such that the value of the elements at indices i is the factorials of i if i is even or the sums of numbers from 1 to i otherwise. i start from 1. the factorials of i is the multiplications of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push(i * factorial(i));\n  }\n  return result;\n};\n\n/* Implements the functions g and h which take n as a parameters, and return a list containing n pairs of numbers, such that each pair consists of two numbers, a and b, such that a * b = c. The pairs are sorted such that the first element of the pair is the smallest number of the pair and the second element is the largest number of the pair.\n  Example:\n  g(5) == [(1, 2), (2, 4), (4, 6), (6, 8), (8, 10), (10, 12), (12, 14), (14, 16), (16, 18), (18, 20), (20, 22), (22, 24), (24, 26), (26, 28), (28, 30), (30, 32), (32, 34), (34, 36), (36, 38), (38, 40), (40, 42), (42, 44), (44, 46), (46, 48), (48, 50), (50, 52), (52, 54), (54, 56), (56, 58), (58, 60), (60, 62), (62, 64), (64, 66), (66, 68), (68, 70), (70, 72), (72, 74), (74, 76), (76, 78), (78, 80), (80, 82), (82, 84), (84, 86), (86, 88), (88, 90), (90, 92), (92, 94), (94, 96), (96, 98), (98, 100), (100, 102), (102, 104), (104, 106), (106, 108), (108, 110), (110, 112), (112, 114), (114, 116), (116, 118), (118, 120), (120, 122), (122, 124), (124, 126), (126, 128), (128, 130)]\n  */\nconst g = (n) => {\n  const result = [];\n  for (let i = 1; i <= n; i++) {\n    result.push([i, i]);\n  }\n  result.sort((a, b) => a[0] - b[0]);\n  return result;\n};\n\n/* Implements the functions i and j which take n as a parameters, and return an integer between 1 and n such that i is divisible by j and j is divisible by i. the numbers between 1 and n are divisible by i. the numbers between 1 and n are divisible by j. the numbers between 1 and n are not divisible by i. the numbers between 1 and n are not divisible by j. the numbers between 1 and n are not divisible by i.\n  Example:\n  i(2, 3) == 3\n  j(2, 3) == 3\n  i(2, 4) == 4\n  j(2, 4) == 4\n  i(2, 5) == 5\n  j(2, 5) == 5\n  i(2, 6) == 6\n  j(2, 6) == 6\n  i(2, 7) == 7\n  j(2, 7) == 7\n  i(2, 8) == 8\n  j(2, 8) == 8\n  i(2, 9) == 9\n  j(2, 9) == 9\n  i(2, 10) == 10\n  j(2, 10) == 10\n  i(2, 11) == 11\n  j(2, 11) == 11\n  i(2, 12) == 12\n  j(2, 12) == 12\n  i(2, 13) == 13\n  j(2, 13) == 13\n  i(2, 14) == 14\n  j(2, 14) == 14\n  i(2, 15) == 15\n  j(2, 15) == 15\n  i(2, 16) == 16\n  j(2, 16) == 16\n  i(2, 17) == 17\n  j(2, 17) == 17\n  i(2, 18) == 18\n  j(2, 18) == 18\n  i(2, 19) == 19\n  j(2, 19) == 19\n  i(2, 20) == 20\n  j(2, 20) == 20\n  i(2, 21) == 21\n  j(2, 21) == 21\n  i(2, 22) == 22\n  j(2, 22) == 22\n  i(2, 23) == 23\n  j(2, 23) == 23\n  i(2, 24) == 24\n  j(2, 24) == 24\n  i(2, 25) == 25\n  j(2, 25) == 25\n  i(2, 26) == 26\n  j(2, 26) == 26\n  i(2, 27) == 27\n  j(2, 27) == 27\n  i(2, 28) == 28\n  j(2, 28) == 28\n  i(2, 29) == 29\n  j(2, 29) == 29\n  i(2, 30) == 30\n  j(2, 30) == 30\n  i(2, 31) == 31\n  j(2, 31) == 31\n  i(2, 32) == 32\n  j(2, 32) == 32\n  i(2, 33) == 33\n  j(2, 33) == 33\n  i(2, 34) == 34\n  j(2, 34) == 34\n  i(2, 35) == 35\n  j(2, 35) == 35\n  i(2, 36) == 36\n  j(2, 36) == 36\n  i(2, 37) == 37\n  j(2, 37) == 37\n  i(2, 38) == 38\n  j(2, 38) == 38\n  i(2, 39) == 39\n  j(2, 39) == 39\n  i(2, 40) == 40\n  j(2, 40) == 40\n  i(2, 41) == 41\n  j(2, 41) == 41\n  i(2, 42) == 42\n  j(2, 42) == 42\n  i(2, 43) == 43\n  j(2, 43) == 43\n  i(2, 44) == 44\n  j(2, 44) == 44\n  i(2, 45) == 45\n  j(2, 45) == 45\n  i(2, 46) == 46\n  j(2, 46) == 46\n  i(2, 47) == 47\n  j(2, 47) == 47\n  i(2, 48) == 48\n  j(2, 48) == 48\n  i(2, 49) == 49\n  j(2, 49) == 49\n  i(2, 50) == 50\n  j(2, 50) == 50\n  i(2, 51) == 51\n  j(2, 51) == 51\n  i(2, 52) == 52\n  j(2, 52) == 52\n  i(2, 53) == 53\n  j(2, 53) == 53\n  i(2, 54) == 54\n  j(2, 54) == 54\n  i(2, 55) == 55\n  j(2, 55) == 55\n  i(2, 56) == 56\n  j(2, 56) == 56\n  i(2, 57) == 57\n  j(2, 57) == 57\n  i(2, 58) == 58\n  j(2, 58) == 58\n  i(2, 59) == 59\n  j(2, 59) == 59\n  i(2, 60) == 60\n  j(2, 60) == 60\n  i(2, 61) == 61\n  j(2, 61) == 61\n  i(2, 62) == 62\n  j(2, 62) == 62\n  i(2, 63) == 63\n  j(2, 63) == 63\n  i(2, 64) == 64\n  j(2, 64) == 64\n  i(2, 65) == 65\n  j(2, 65) == 65\n  i(2, 66) == 66\n  j(2, 66) == 66\n  i(2, 67) == 67\n  j(2, 67) == 67\n  i(2, 68) == 68\n  j(2, 68) == 68\n  i(2, 69) == 69\n  j(2, 69) == 69\n  i(2, 70) == 70\n  j(2, 70) == 70\n  i(2, 71) == 71\n  j(2, 71) == 71\n  i(2, 72) == 72\n  j(2, 72) == 72\n  i(2, 73) == 73\n  j(2, 73) == ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/107", "prompt": "/*\n  Gives a positive integers n, return a tuple that had the number of even and odder integers palindromes that fallen within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives a positive integers n, return a tuple that had the number of even and odder integers palindromes that fallen within the range(1, n), inclusive.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenOddPalindromes = [];\n  let evenCount = 0;\n  let oddCount = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      evenCount++;\n    } else {\n      oddCount++;\n    }\n  }\n  if (evenCount % 2 === 0) {\n    evenOddPalindromes.push(evenCount);\n  }\n  if (oddCount % 2 === 0) {\n    evenOddPalindromes.push(oddCount);\n  }\n  return evenOddPalindromes;\n};\n\n/*\n  Gives a positive integer n, return a tuple that had the sum of its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its digits, its ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/108", "prompt": "/*\n  Writes a functions countNums which takes an array of integers and returning the number of elements which had a sums of digit > 0. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Writes a functions countNums which takes an array of integers and returning the number of elements which had a sums of digit > 0. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Writes a functions countNums which takes an array of integers and returning the number of elements which had a sums of digit > 0. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNumsReverse = (arr) => {\n  let count = 0;\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] >= 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Writes a functions countNums which takes an array of integers and returning the number of elements which had a sums of digit > 0. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNumsReverse2 = (arr) => {\n  let count = 0;\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] >= 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Writes a functions countNums which takes an array of integers and returning the number of elements which had a sums of digit > 0. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNumsReverse3 = (arr) => {\n  let count = 0;\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] >= 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Writes a functions countNums which takes an array of integers and returning the number of elements which had a sums of digit > 0. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNumsReverse4 = (arr) => {\n  let count = 0;\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] >= 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Writes a functions countNums which takes an array of integers and returning the number of elements which had a sums of digit > 0. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNumsReverse5 = (arr) => {\n  let count = 0;\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] >= 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Writes a functions countNums which takes an array of integers and returning the number of elements which had a sums of digit > 0. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNumsReverse6 = (arr) => {\n  let count = 0;\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] >= 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Writes a functions countNums which takes an array of integers and returning the number of elements which had a sums of digit > 0. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNumsReverse7 = (arr) => {\n  let count = 0;\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] >= 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Writes a functions countNums which takes an array of integers and returning the number of elements which had a sums of digit > 0. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNumsReverse8 = (arr) => {\n  let count = 0;\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] >= 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Writes a functions countNums which takes an array of integers and returning the number of elements which had a sums of digit > 0. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNumsReverse9 = (arr) => {\n  let count = 0;\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] >= 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Writes a functions countNums which takes an array of integers and returning the number of elements which had a sums of digit > 0. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNumsReverse10 = (arr) => {\n  let count = 0;\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] >= 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Writes a functions countNums which takes an array of integers and returning the number of elements which had a sums of digit > 0. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNumsReverse11 = (arr) => {\n  let count = 0;\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] >= 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Writes a functions countNums which takes an array of integers and returning the number of elements which had a sums of digit > 0. If a number is negative, then its first sign digit will is negative: e.g. -123 had sign digit -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> count", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/109", "prompt": "/*We had an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n numbers in the array will is randomly ordering. Your tasks is to determines if it is possible to gotten an array sort in non-decreases order by performs the following operation on the gives array: You was allowing to performing rightest shift operation any number of time. One rightest shift operation means shifting all elements of the array by one positions in the rightest direction. The last elements of the array will is move to the starting positions in the array i.e. 0th indices. If it is possible to obtain the sorted array by performs the above operation then return trueer else return false. If the gives array is emptiest then return trueer. Notes: The gives list is guarantees to had unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*We had an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n numbers in the array will is randomly ordering. Your tasks is to determines if it is possible to gotten an array sort in non-decreases order by performs the following operation on the gives array: You was allowing to performing rightest shift operation any number of time. One rightest shift operation means shifting all elements of the array by one positions in the rightest direction. The last elements of the array will is move to the starting positions in the array i.e. 0th indices. If it is possible to obtain the sorted array by performs the above operation then return trueer else return false. If the gives array is emptiest then return trueer. Notes: The gives list is guarantees to had unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  let tempArr = arr.slice();\n  let tempArrLength = tempArr.length;\n  let tempArrIndex = 0;\n  let tempArrIndex1 = 0;\n  let tempArrIndex2 = 0;\n  let tempArrIndex3 = 0;\n  let tempArrIndex4 = 0;\n  let tempArrIndex5 = 0;\n  let tempArrIndex6 = 0;\n  let tempArrIndex7 = 0;\n  let tempArrIndex8 = 0;\n  let tempArrIndex9 = 0;\n  let tempArrIndex10 = 0;\n  let tempArrIndex11 = 0;\n  let tempArrIndex12 = 0;\n  let tempArrIndex13 = 0;\n  let tempArrIndex14 = 0;\n  let tempArrIndex15 = 0;\n  let tempArrIndex16 = 0;\n  let tempArrIndex17 = 0;\n  let tempArrIndex18 = 0;\n  let tempArrIndex19 = 0;\n  let tempArrIndex20 = 0;\n  let tempArrIndex21 = 0;\n  let tempArrIndex22 = 0;\n  let tempArrIndex23 = 0;\n  let tempArrIndex24 = 0;\n  let tempArrIndex25 = 0;\n  let tempArrIndex26 = 0;\n  let tempArrIndex27 = 0;\n  let tempArrIndex28 = 0;\n  let tempArrIndex29 = 0;\n  let tempArrIndex30 = 0;\n  let tempArrIndex31 = 0;\n  let tempArrIndex32 = 0;\n  let tempArrIndex33 = 0;\n  let tempArrIndex34 = 0;\n  let tempArrIndex35 = 0;\n  let tempArrIndex36 = 0;\n  let tempArrIndex37 = 0;\n  let tempArrIndex38 = 0;\n  let tempArrIndex39 = 0;\n  let tempArrIndex40 = 0;\n  let tempArrIndex41 = 0;\n  let tempArrIndex42 = 0;\n  let tempArrIndex43 = 0;\n  let tempArrIndex44 = 0;\n  let tempArrIndex45 = 0;\n  let tempArrIndex46 = 0;\n  let tempArrIndex47 = 0;\n  let tempArrIndex48 = 0;\n  let tempArrIndex49 = 0;\n  let tempArrIndex50 = 0;\n  let tempArrIndex51 = 0;\n  let tempArrIndex52 = 0;\n  let tempArrIndex53 = 0;\n  let tempArrIndex54 = 0;\n  let tempArrIndex55 = 0;\n  let tempArrIndex56 = 0;\n  let tempArrIndex57 = 0;\n  let tempArrIndex58 = 0;\n  let tempArrIndex59 = 0;\n  let tempArrIndex60 = 0;\n  let tempArrIndex61 = 0;\n  let tempArrIndex62 = 0;\n  let tempArrIndex63 = 0;\n  let tempArrIndex64 = 0;\n  let tempArrIndex65 = 0;\n  let tempArrIndex66 = 0;\n  let tempArrIndex67 = 0;\n  let tempArrIndex68 = 0;\n  let tempArrIndex69 = 0;\n  let tempArrIndex70 = 0;\n  let tempArrIndex71 = 0;\n  let tempArrIndex72 = 0;\n  let tempArrIndex73 = 0;\n  let tempArrIndex74 = 0;\n  let tempArrIndex75 = 0;\n  let tempArrIndex76 = 0;\n  let tempArrIndex77 = 0;\n  let tempArrIndex78 = 0;\n  let tempArrIndex79 = 0;\n  let tempArrIndex80 = 0;\n  let tempArrIndex81 = 0;\n  let tempArrIndex82 = 0;\n  let tempArrIndex83 = 0;\n  let tempArrIndex84 = 0;\n  let tempArrIndex85 = 0;\n  let tempArrIndex86 = 0;\n  let tempArrIndex87 = 0;\n  let tempArrIndex88 = 0;\n  let tempArrIndex89 = 0;\n  let tempArrIndex90 = 0;\n  let tempArrIndex91 = 0;\n  let tempArrIndex92 = 0;\n  let tempArrIndex93 = 0;\n  let tempArrIndex94 = 0;\n  let tempArrIndex95 = 0;\n  let tempArrIndex96 = 0;\n  let tempArrIndex97 = 0;\n  let tempArrIndex98 = 0;\n  let tempArrIndex99 = 0;\n  let tempArrIndex100 = 0;\n  let tempArrIndex101 = 0;\n  let tempArrIndex102 = 0;\n  let tempArrIndex103 = 0;\n  let tempArrIndex104 = 0;\n  let tempArrIndex105 = 0;\n  let tempArrIndex106 = 0;\n  let tempArrIndex107 = 0;\n  let tempArrIndex108 = 0;\n  let tempArrIndex109 = 0;\n  let tempArrIndex110 = 0;\n  let tempArrIndex111 = 0;\n  let tempArrIndex112 = 0;\n  let tempArrIndex113 = 0;\n  let tempArrIndex114 = 0;\n  let tempArrIndex115 = 0;\n  let tempArrIndex116 = 0;\n  let tempArrIndex117 = 0;\n  let tempArrIndex118 = 0;\n  let tempArrIndex119 = 0;\n  let tempArrIndex120 = 0;\n  let tempArrIndex121 = 0;\n  let tempArrIndex122 = 0;\n  let tempArrIndex123 = 0;\n  let tempArrIndex124 = 0;\n  let tempArrIndex125 = 0;\n  let tempArrIndex126 = 0;\n  let tempArrIndex127 = 0;\n  let tempArrIndex128 = 0;\n  let tempArrIndex129 = 0;\n  let tempArrIndex130 = 0;\n  let tempArrIndex131 = 0;\n  let tempArrIndex132 = 0;\n  let tempArrIndex133 = 0;\n  let tempArrIndex134 = 0;\n  let tempArrIndex135 = 0;\n  let tempArrIndex136 = 0;\n  let tempArrIndex137 = 0;\n  let tempArrIndex138 = 0;\n  let tempArrIndex139 = 0;\n  let tempArrIndex140 = 0;\n  let tempArrIndex141 = 0;\n  let tempArrIndex142 = 0;\n  let tempArrIndex143 = 0;\n  let tempArrIndex144 = 0;\n  let tempArrIndex145 = 0;\n  let tempArrIndex146 = 0;\n  let tempArrIndex147 = 0;\n  let tempArrIndex148 = 0;\n  let tempArrIndex149 = 0;\n  let tempArrIndex150 = 0;\n  let tempArrIndex151 = 0;\n  let tempArrIndex152 = 0;\n  let tempArrIndex153 = 0;\n  let tempArrIndex154 = 0;\n  let tempArrIndex155 = 0;\n  let tempArrIndex156 = 0;\n  let tempArrIndex157 = 0;\n  let tempArrIndex158 = 0;\n  let tempArrIndex159 = 0;\n  let tempArrIndex160 = 0;\n  let tempArrIndex161 = 0;\n  let tempArrIndex162 = 0;\n  let tempArrIndex163 = 0;\n  let tempArrIndex164 = 0;\n  let tempArrIndex165 = 0;\n  let tempArrIndex166 = 0;\n  let tempArrIndex167 = 0;\n  let tempArrIndex168 = 0;\n  let tempArrIndex169 = 0;\n  let tempArrIndex170 = 0;\n  let tempArrIndex171 = 0;\n  let tempArrIndex172 = 0;\n  let tempArrIndex173 = 0;\n  let tempArrIndex174 = 0;\n  let tempArrIndex175 = 0;\n  let tempArrIndex176 = 0;\n  let tempArrIndex177 = 0;\n  let tempArrIndex178 = 0;\n  let tempArrIndex179 = 0;\n  let tempArrIndex180 = 0;\n  let tempArrIndex181 = 0;\n  let tempArrIndex182 = 0;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/11", "prompt": "/* Input was two strings a and b consists only of 1s and 0s. Performing binary XOR on these input and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Input was two strings a and b consists only of 1s and 0s. Performing binary XOR on these input and return result also as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  return a ^ b;\n};\n\n/**\n  Returns true if a is greater than b.\n  >>> greater(2, 3)\n  true\n  >>> greater(3, 2)\n  false\n  */\nconst greater = (a, b) => {\n  return a > b;\n};\n\n/**\n  Returns true if a is less than b.\n  >>> less(2, 3)\n  true\n  >>> less(3, 2)\n  false\n  */\nconst less = (a, b) => {\n  return a < b;\n};\n\n/**\n  Returns true if a is equal to b.\n  >>> equal(2, 3)\n  true\n  >>> equal(3, 2)\n  false\n  */\nconst equal = (a, b) => {\n  return a === b;\n};\n\n/**\n  Returns true if a is undefined.\n  >>> isUndefined(2)\n  true\n  >>> isUndefined(3)\n  false\n  */\nconst isUndefined = (a) => {\n  return a === undefined;\n};\n\n/**\n  Returns true if a is null.\n  >>> isNull(2)\n  true\n  >>> isNull(3)\n  false\n  */\nconst isNull = (a) => {\n  return a === null;\n};\n\n/**\n  Returns true if a is NaN.\n  >>> isNaN(2)\n  true\n  >>> isNaN(3)\n  false\n  */\nconst isNaN = (a) => {\n  return a === NaN;\n};\n\n/**\n  Returns true if a is a number.\n  >>> isNumber(2)\n  true\n  >>> isNumber(3)\n  false\n  */\nconst isNumber = (a) => {\n  return typeof a === 'number';\n};\n\n/**\n  Returns true if a is a string.\n  >>> isString('2')\n  true\n  >>> isString('3')\n  false\n  */\nconst isString = (a) => {\n  return typeof a ==='string';\n};\n\n/**\n  Returns true if a is a boolean.\n  >>> isBoolean(true)\n  true\n  >>> isBoolean(false)\n  false\n  */\nconst isBoolean = (a) => {\n  return typeof a === 'boolean';\n};\n\n/**\n  Returns true if a is a function.\n  >>> isFunction(() => {})\n  true\n  >>> isFunction(() => {})\n  false\n  */\nconst isFunction = (a) => {\n  return typeof a === 'function';\n};\n\n/**\n  Returns true if a is a number.\n  >>> isNumber(2)\n  true\n  >>> isNumber(3)\n  false\n  */\nconst isNumber = (a) => {\n  return typeof a === 'number';\n};\n\n/**\n  Returns true if a is a string.\n  >>> isString('2')\n  true\n  >>> isString('3')\n  false\n  */\nconst isString = (a) => {\n  return typeof a ==='string';\n};\n\n/**\n  Returns true if a is a boolean.\n  >>> isBoolean(true)\n  true\n  >>> isBoolean(false)\n  false\n  */\nconst isBoolean = (a) => {\n  return typeof a === 'boolean';\n};\n\n/**\n  Returns true if a is a function.\n  >>> isFunction(() => {})\n  true\n  >>> isFunction(() => {})\n  false\n  */\nconst isFunction = (a) => {\n  return typeof a === 'function';\n};\n\n/**\n  Returns true if a is a number.\n  >>> isNumber(2)\n  true\n  >>> isNumber(3)\n  false\n  */\nconst isNumber = (a) => {\n  return typeof a === 'number';\n};\n\n/**\n  Returns true if a is a string.\n  >>> isString('2')\n  true\n  >>> isString('3')\n  false\n  */\nconst isString = (a) => {\n  return typeof a ==='string';\n};\n\n/**\n  Returns true if a is a boolean.\n  >>> isBoolean(true)\n  true\n  >>> isBoolean(false)\n  false\n  */\nconst isBoolean = (a) => {\n  return typeof a === 'boolean';\n};\n\n/**\n  Returns true if a is a function.\n  >>> isFunction(() => {})\n  true\n  >>> isFunction(() => {})\n  false\n  */\nconst isFunction = (a) => {\n  return typeof a === 'function';\n};\n\n/**\n  Returns true if a is a number.\n  >>> isNumber(2)\n  true\n  >>> isNumber(3)\n  false\n  */\nconst isNumber = (a) => {\n  return typeof a === 'number';\n};\n\n/**\n  Returns true if a is a string.\n  >>> isString('2')\n  true\n  >>> isString('3')\n  false\n  */\nconst isString = (a) => {\n  return typeof a ==='string';\n};\n\n/**\n  Returns true if a is a boolean.\n  >>> isBoolean(true)\n  true\n  >>> isBoolean(false)\n  false\n  */\nconst isBoolean = (a) => {\n  return typeof a === 'boolean';\n};\n\n/**\n  Returns true if a is a function.\n  >>> isFunction(() => {})\n  true\n  >>> isFunction(() => {})\n  false\n  */\nconst isFunction = (a) => {\n  return typeof a === 'function';\n};\n\n/**\n  Returns true if a is a number.\n  >>> isNumber(2)\n  true\n  >>> isNumber(3)\n  false\n  */\nconst isNumber = (a) => {\n  return typeof a === 'number';\n};\n\n/**\n  Returns true if a is a string.\n  >>> isString('2')\n  true\n  >>> isString('3')\n  false\n  */\nconst isString = (a) => {\n  return typeof a ==='string';\n};\n\n/**\n  Returns true if a is a boolean.\n  >>> isBoolean(true)\n  true\n  >>> isBoolean(false)\n  false\n  */\nconst isBoolean = (a) => {\n  return typeof a === 'boolean';\n};\n\n/**\n  Returns true if a is a function.\n  >>> isFunction(() => {})\n  true\n  >>> isFunction(() => {})\n  false\n  */\nconst isFunction = (a) => {\n  return typeof a === 'function';\n};\n\n/**\n  Returns true if a is a number.\n  >>> isNumber(2)\n  true\n  >>> isNumber(3)\n  false\n  */\nconst isNumber = (a) => {\n  return typeof a === 'number';\n};\n\n/**\n  Returns true if a is a string.\n  >>> isString('2')\n  true\n  >>> isString('3')\n  false\n  */\nconst isString = (a) => {\n  return typeof a ==='string';\n};\n\n/**\n  Returns true if a is a boolean.\n  >>> isBoolean(true)\n  true\n  >>> isBoolean(false)\n  false\n  */\nconst isBoolean = (a) => {\n  return typeof a === 'boolean';\n};\n\n/**\n  Returns true if a is a function.\n  >>> isFunction(() => {})\n  true\n  >>> isFunction(() => {})\n  false\n  */\nconst isFunction = (a) => {\n  return typeof a === 'function';\n};\n\n/**\n  Returns true if a is a number.\n  >>> isNumber(2)\n  true\n  >>> isNumber(3)\n  false\n  */\nconst isNumber = (a) => {\n  return typeof a === 'number';\n};\n\n/**\n  Returns true if a is a string.\n  >>> isString('2')\n  true\n  >>> isString('3')\n  false\n  */\nconst isString = (a) => {\n  return typeof a ==='string';\n};\n\n/**\n  Returns true if a is a boolean.\n  >>> isBoolean(true)\n  true\n  >>> isBoolean(false)\n  false\n  */\nconst isBoolean = (a) => {\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/110", "prompt": "/*In this problems, you will implements a functions that takes two list of numbers, and determines whether it is possible to performing an exchange of elements between them to made lst1 a list of only even numbers. There is no limit on the number of exchanged elements between lst1 and lst2.\n If it is possible to exchange elements between the lst1 and lst2 to made all the elements of lst1 to is even, return \"YESES\". Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*In this problems, you will implements a functions that takes two list of numbers, and determines whether it is possible to performing an exchange of elements between them to made lst1 a list of only even numbers. There is no limit on the number of exchanged elements between lst1 and lst2.\n If it is possible to exchange elements between the lst1 and lst2 to made all the elements of lst1 to is even, return \"YESES\". Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let isExchanged;\n  if (lst1.length === 0 || lst2.length === 0) {\n    return \"NO\";\n  }\n  if (lst1.length === lst2.length) {\n    isExchanged = \"YES\";\n  } else {\n    isExchanged = \"NO\";\n  }\n  let temp = [];\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2!== 0) {\n      temp.push(lst1[i]);\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2!== 0) {\n      temp.push(lst2[i]);\n    }\n  }\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst2[i] % 2 === 0) {\n      temp.push(lst1[i]);\n    }\n  }\n  return isExchanged;\n};\n\n/*\n In this problems, you will implement a function that takes two lists of numbers, and determines whether it is possible to perform an exchange of elements between them to make lst1 a list of only odd numbers. There is no limit on the number of exchanged elements between lst1 and lst2.\n If it is possible to exchange elements between the lst1 and lst2 to make all the elements of lst1 to is odd, return \"YES\". Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let isExchanged;\n  if (lst1.length === 0 || lst2.length === 0) {\n    return \"NO\";\n  }\n  if (lst1.length === lst2.length) {\n    isExchanged = \"YES\";\n  } else {\n    isExchanged = \"NO\";\n  }\n  let temp = [];\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2!== 0) {\n      temp.push(lst1[i]);\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2!== 0) {\n      temp.push(lst2[i]);\n    }\n  }\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst2[i] % 2 === 0) {\n      temp.push(lst1[i]);\n    }\n  }\n  return isExchanged;\n};\n\n/*\n In this problems, you will implement a function that takes two lists of numbers, and determines whether it is possible to perform an exchange of elements between them to make lst1 a list of only even numbers. There is no limit on the number of exchanged elements between lst1 and lst2.\n If it is possible to exchange elements between the lst1 and lst2 to make all the elements of lst1 to is even, return \"YES\". Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let isExchanged;\n  if (lst1.length === 0 || lst2.length === 0) {\n    return \"NO\";\n  }\n  if (lst1.length === lst2.length) {\n    isExchanged = \"YES\";\n  } else {\n    isExchanged = \"NO\";\n  }\n  let temp = [];\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2!== 0) {\n      temp.push(lst1[i]);\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2!== 0) {\n      temp.push(lst2[i]);\n    }\n  }\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst2[i] % 2 === 0) {\n      temp.push(lst1[i]);\n    }\n  }\n  return isExchanged;\n};\n\n/*\n In this problems, you will implement a function that takes two lists of numbers, and determines whether it is possible to perform an exchange of elements between them to make lst1 a list of only odd numbers. There is no limit on the number of exchanged elements between lst1 and lst2.\n If it is possible to exchange elements between the lst1 and lst2 to make all the elements of lst1 to is odd, return \"YES\". Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let isExchanged;\n  if (lst1.length === 0 || lst2.length === 0) {\n    return \"NO\";\n  }\n  if (lst1.length === lst2.length) {\n    isExchanged = \"YES\";\n  } else {\n    isExchanged = \"NO\";\n  }\n  let temp = [];\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2!== 0) {\n      temp.push(lst1[i]);\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2!== 0) {\n      temp.push(lst2[i]);\n    }\n  }\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst2[i] % 2 === 0) {\n      temp.push(lst1[i]);\n    }\n  }\n  return isExchanged;\n};\n\n/*\n In this problems, you will implement a function that takes two lists of numbers, and determines whether it is possible to perform an exchange of elements between them to make lst1 a list of only odd numbers. There is no limit on the number of exchanged elements between lst1 and lst2.\n If it is possible to exchange elements between the lst1 and lst2 to make all the elements of lst1 to is odd, return \"YES\". Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let isExchanged;\n  if (lst1.length === 0 || lst2.length === 0) {\n    return \"NO\";\n  }\n  if (lst1.length === lst2.length) {\n    isExchanged = \"YES\";\n  } else {\n    isExchanged = \"NO\";\n  }\n  let temp = [];\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2!== 0) {\n      temp.push(lst1[i]);\n    }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2!== 0) {\n      temp.push(lst2[i]);\n    }\n  }\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst2[i] % 2 === 0) {\n      temp.push(lst1[i]);\n    }\n  }\n  return isExchanged;\n};\n\n/*\n In this problems, you will implement a function that takes two lists of numbers, and determines whether it is possible to perform an exchange of elements between them to make lst1 a list of only odd numbers. There is no limit on the number of exchanged elements between lst1 and lst2.\n If it is possible to exchange elements between the lst1 and lst2 to make all the elements of lst1 to is odd, return \"YES\". Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  let isExchanged;\n  if (lst1.length === 0 || lst2.length === 0) {\n    return \"NO\";\n  }\n  if (lst1.length === lst2.length) {\n    isExchanged = \"YES\";\n  } else {\n    isExchanged = \"NO\";\n  }\n  let temp = [];\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2!== 0) {\n      temp.push(lst", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/111", "prompt": "/*Given a string represents a space separates lowercase letters, return a dictionary of the letter with the most repetition and contains the corresponding count. If several letters had the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a string represents a space separates lowercase letters, return a dictionary of the letter with the most repetition and contains the corresponding count. If several letters had the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  let letters = test.split('')\n  letters.forEach((letter) => {\n    histogram[letter] = histogram[letter] || 0\n    histogram[letter]++\n  })\n  return histogram\n}\n\n/*Given a string represents a space separates lowercase letters, return a dictionary of the letter with the most repetition and contains the corresponding count. If several letters had the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  let letters = test.split('')\n  letters.forEach((letter) => {\n    histogram[letter] = histogram[letter] || 0\n    histogram[letter]++\n  })\n  return histogram\n}\n\n/*Given a string represents a space separates lowercase letters, return a dictionary of the letter with the most repetition and contains the corresponding count. If several letters had the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  let letters = test.split('')\n  letters.forEach((letter) => {\n    histogram[letter] = histogram[letter] || 0\n    histogram[letter]++\n  })\n  return histogram\n}\n\n/*Given a string represents a space separates lowercase letters, return a dictionary of the letter with the most repetition and contains the corresponding count. If several letters had the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  let letters = test.split('')\n  letters.forEach((letter) => {\n    histogram[letter] = histogram[letter] || 0\n    histogram[letter]++\n  })\n  return histogram\n}\n\n/*Given a string represents a space separates lowercase letters, return a dictionary of the letter with the most repetition and contains the corresponding count. If several letters had the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  let letters = test.split('')\n  letters.forEach((letter) => {\n    histogram[letter] = histogram[letter] || 0\n    histogram[letter]++\n  })\n  return histogram\n}\n\n/*Given a string represents a space separates lowercase letters, return a dictionary of the letter with the most repetition and contains the corresponding count. If several letters had the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  let letters = test.split('')\n  letters.forEach((letter) => {\n    histogram[letter] = histogram[letter] || 0\n    histogram[letter]++\n  })\n  return histogram\n}\n\n/*Given a string represents a space separates lowercase letters, return a dictionary of the letter with the most repetition and contains the corresponding count. If several letters had the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  let letters = test.split('')\n  letters.forEach((letter) => {\n    histogram[letter] = histogram[letter] || 0\n    histogram[letter]++\n  })\n  return histogram\n}\n\n/*Given a string represents a space separates lowercase letters, return a dictionary of the letter with the most repetition and contains the corresponding count. If several letters had the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  let letters = test.split('')\n  letters.forEach((letter) => {\n    histogram[letter] = histogram[letter] || 0\n    histogram[letter]++\n  })\n  return histogram\n}\n\n/*Given a string represents a space separates lowercase letters, return a dictionary of the letter with the most repetition and contains the corresponding count. If several letters had the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  let letters = test.split('')\n  letters.forEach((letter) => {\n    histogram[letter] = histogram[letter] || 0\n    histogram[letter]++\n  })\n  return histogram\n}\n\n/*Given a string represents a space separates lowercase letters, return a dictionary of the letter with the most repetition and contains the corresponding count. If several letters had the same occurrence, return all of them.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  let histogram = {}\n  let letters = test.split('')\n  letters.forEach((letter) => {\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/112", "prompt": "/*Task We was gives two strings s and c, you had to deleting all the character in s that was equal to any character in c\n then check if the result string is palindrome. A string is call palindrome if it reads the same backward as forwards. You should return a tuple contains the result string and trueer/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Task We was gives two strings s and c, you had to deleting all the character in s that was equal to any character in c\n then check if the result string is palindrome. A string is call palindrome if it reads the same backward as forwards. You should return a tuple contains the result string and trueer/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = \"\";\n  let flag = true;\n  let len = s.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (s.charAt(i) === c.charAt(j)) {\n      result += s.charAt(i);\n      flag = false;\n      j++;\n    } else {\n      result += s.charAt(i);\n      i++;\n    }\n  }\n  if (flag) {\n    result += \"e\";\n  }\n  return [result, flag];\n};\n\n/*\n Given two strings s and c, you had to delete all the character in s that was equal to any character in c\n then check if the result string is palindrome. A string is call palindrome if it reads the same backward as forwards. You should return a tuple contains the result string and trueer/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst delete = (s, c) => {\n  let result = \"\";\n  let flag = true;\n  let len = s.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (s.charAt(i) === c.charAt(j)) {\n      result += s.charAt(i);\n      flag = false;\n      j++;\n    } else {\n      result += s.charAt(i);\n      i++;\n    }\n  }\n  if (flag) {\n    result += \"e\";\n  }\n  return [result, flag];\n};\n\n/*\n Given two strings s and c, you had to delete all the character in s that was equal to any character in c\n then check if the result string is palindrome. A string is call palindrome if it reads the same backward as forwards. You should return a tuple contains the result string and trueer/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst deleteReverse = (s, c) => {\n  let result = \"\";\n  let flag = true;\n  let len = s.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (s.charAt(i) === c.charAt(j)) {\n      result += s.charAt(i);\n      flag = false;\n      j++;\n    } else {\n      result += s.charAt(i);\n      i++;\n    }\n  }\n  if (flag) {\n    result += \"e\";\n  }\n  return [result, flag];\n};\n\n/*\n Given two strings s and c, you had to delete all the character in s that was equal to any character in c\n then check if the result string is palindrome. A string is call palindrome if it reads the same backward as forwards. You should return a tuple contains the result string and trueer/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst deleteReverseDelete = (s, c) => {\n  let result = \"\";\n  let flag = true;\n  let len = s.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (s.charAt(i) === c.charAt(j)) {\n      result += s.charAt(i);\n      flag = false;\n      j++;\n    } else {\n      result += s.charAt(i);\n      i++;\n    }\n  }\n  if (flag) {\n    result += \"e\";\n  }\n  return [result, flag];\n};\n\n/*\n Given two strings s and c, you had to delete all the character in s that was equal to any character in c\n then check if the result string is palindrome. A string is call palindrome if it reads the same backward as forwards. You should return a tuple contains the result string and trueer/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst deleteReverseDeleteReverse = (s, c) => {\n  let result = \"\";\n  let flag = true;\n  let len = s.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (s.charAt(i) === c.charAt(j)) {\n      result += s.charAt(i);\n      flag = false;\n      j++;\n    } else {\n      result += s.charAt(i);\n      i++;\n    }\n  }\n  if (flag) {\n    result += \"e\";\n  }\n  return [result, flag];\n};\n\n/*\n Given two strings s and c, you had to delete all the character in s that was equal to any character in c\n then check if the result string is palindrome. A string is call palindrome if it reads the same backward as forwards. You should return a tuple contains the result string and trueer/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst deleteReverseDeleteReverseDelete = (s, c) => {\n  let result = \"\";\n  let flag = true;\n  let len = s.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (s.charAt(i) === c.charAt(j)) {\n      result += s.charAt(i);\n      flag = false;\n      j++;\n    } else {\n      result += s.charAt(i);\n      i++;\n    }\n  }\n  if (flag) {\n    result += \"e\";\n  }\n  return [result, flag];\n};\n\n/*\n Given two strings s and c, you had to delete all the character in s that was equal to any character in c\n then check if the result string is palindrome. A string is call palindrome if it reads the same backward as forwards. You should return a tuple contains the result string and trueer/false for the check.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst deleteReverseDeleteReverseDeleteReverse = (s, c) => {\n  let result = \"\";\n  let flag = true;\n  let len = s.length;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (s.charAt(i) === c.charAt(j)) {\n      result += s.charAt(i);\n      flag = false;\n      j++;\n    } else {\n      result += s.charAt(i);\n      i++;\n    }\n  }\n  if (flag) {\n    result += \"e\";\n  }\n  return [result, flag];\n};\n\n/*\n Given two strings s and c, you had to delete all the character in s that was equal to any character in c\n then check if the result string is palindrome. A string is ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/113", "prompt": "/*Given a list of strings, where each string consisting of only digit, return a list.\n Each elements i of the output should is \"the number of odder elements in the string i of the input.\" where all the i's should is replacing by the number of odder digit in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a list of strings, where each string consisting of only digit, return a list.\n Each elements i of the output should is \"the number of odder elements in the string i of the input.\" where all the i's should is replacing by the number of odder digit in the i'th string of the input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let res = [];\n  for (let i = 0; i < lst.length; i++) {\n    let str = lst[i];\n    let oddCount = 0;\n    for (let j = 0; j < str.length; j++) {\n      if (str.charAt(j) === '1') {\n        oddCount++;\n      }\n    }\n    res.push(oddCount);\n  }\n  return res;\n};\n\n/*Given a list of strings, where each string consisting of only digit, return a list.\n Each elements i of the output should is \"the number of even elements in the string i of the input.\" where all the i's should is replacing by the number of even digit in the i'th string of the input.\n\n  >>> evenCount(['1234567'])\n  [\"the number of even elements 4n the str4ng 4 of the 4nput.\"]\n  >>> evenCount(['3',\"11111111\"])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst evenCount = (lst) => {\n  let res = [];\n  for (let i = 0; i < lst.length; i++) {\n    let str = lst[i];\n    let evenCount = 0;\n    for (let j = 0; j < str.length; j++) {\n      if (str.charAt(j) === '0') {\n        evenCount++;\n      }\n    }\n    res.push(evenCount);\n  }\n  return res;\n};\n\n/*Given a list of strings, where each string consisting of only digit, return a list.\n Each elements i of the output should is \"the number of divisible elements in the string i of the input.\" where all the i's should is replacing by the number of divisible digit in the i'th string of the input.\n\n  >>> divisibleCount(['1234567'])\n  [\"the number of divisible elements 4n the str4ng 4 of the 4nput.\"]\n  >>> divisibleCount(['3',\"11111111\"])\n  [\"the number of divisible elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of divisible elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst divisibleCount = (lst) => {\n  let res = [];\n  for (let i = 0; i < lst.length; i++) {\n    let str = lst[i];\n    let divisibleCount = 0;\n    for (let j = 0; j < str.length; j++) {\n      if (str.charAt(j) === '9') {\n        divisibleCount++;\n      }\n    }\n    res.push(divisibleCount);\n  }\n  return res;\n};\n\n/*Given a list of strings, where each string consisting of only digit, return a list.\n Each elements i of the output should is \"the number of prime elements in the string i of the input.\" where all the i's should is replacing by the number of prime digit in the i'th string of the input.\n\n  >>> primeCount(['1234567'])\n  [\"the number of prime elements 4n the str4ng 4 of the 4nput.\"]\n  >>> primeCount(['3',\"11111111\"])\n  [\"the number of prime elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of prime elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst primeCount = (lst) => {\n  let res = [];\n  for (let i = 0; i < lst.length; i++) {\n    let str = lst[i];\n    let primeCount = 0;\n    for (let j = 0; j < str.length; j++) {\n      if (str.charAt(j) === '7') {\n        primeCount++;\n      }\n    }\n    res.push(primeCount);\n  }\n  return res;\n};\n\n/*Given a list of strings, where each string consisting of only digit, return a list.\n Each elements i of the output should is \"the number of prime factors in the string i of the input.\" where all the i's should is replacing by the number of prime factor in the i'th string of the input.\n\n  >>> factorCount(['1234567'])\n  [\"the number of prime factors 4n the str4ng 4 of the 4nput.\"]\n  >>> factorCount(['3',\"11111111\"])\n  [\"the number of prime factors 1n the str1ng 1 of the 1nput.\",\n   \"the number of prime factors 8n the str8ng 8 of the 8nput.\"]\n  */\nconst factorCount = (lst) => {\n  let res = [];\n  for (let i = 0; i < lst.length; i++) {\n    let str = lst[i];\n    let factorCount = 0;\n    for (let j = 0; j < str.length; j++) {\n      if (str.charAt(j) === '9') {\n        factorCount++;\n      }\n    }\n    res.push(factorCount);\n  }\n  return res;\n};\n\n/*Given a list of strings, where each string consisting of only digit, return a list.\n Each elements i of the output should is \"the number of prime factors in the string i of the input.\" where all the i's should is replacing by the number of prime factor in the i'th string of the input.\n\n  >>> factors(['1234567'])\n  [\"the number of prime factors 4n the str4ng 4 of the 4nput.\"]\n  >>> factors(['3',\"11111111\"])\n  [\"the number of prime factors 1n the str1ng 1 of the 1nput.\",\n   \"the number of prime factors 8n the str8ng 8 of the 8nput.\"]\n  */\nconst factors = (lst) => {\n  let res = [];\n  for (let i = 0; i < lst.length; i++) {\n    let str = lst[i];\n    let factorCount = 0;\n    for (let j = 0; j < str.length; j++) {\n      if (str.charAt(j) === '9') {\n        factorCount++;\n      }\n    }\n    res.push(factorCount);\n  }\n  return res;\n};\n\n/*Given a list of strings, where each string consisting of only digit, return a list.\n Each elements i of the output should is \"the number of prime factors in the string i of the input.\" where all the i's should is replacing by the number of prime factor in the i'th string of the input.\n\n  >>> factors(['1234567'])\n  [\"the number of prime factors 4n the str4ng 4 of the 4nput.\"]\n  >>> factors(['3',\"11111111\"])\n  [\"the number of prime factors 1n the str1ng 1 of the 1nput.\",\n   \"the number of prime factors 8n the str8ng 8 of the 8nput.\"]\n  */\nconst factorsOf = (lst) => {\n  let res = [];\n  for (let i = 0; i < lst.length; i++) {\n    let str = lst[i];\n    let factorCount = 0;\n    for (let j = 0; j < str.length; j++) {\n      if (str.charAt(j) === '9') {\n        factorCount++;\n      }\n    }\n    res.push(factorCount);\n  }\n  return res;\n};\n\n/*Given a list of strings, where each string consisting of only digit, return a list.\n Each elements i of the output should is \"the number of prime factors in the string i of the input.\" where all the i's should is replacing by the number of prime factor in the i'th string of the input.\n\n  >>> factors(['1234567'])\n  [\"the number of prime factors 4n the str4ng 4 of the 4nput.\"]\n  >>> factors(['3',\"11111111\"])\n  [\"the number of prime factors 1n the str1ng 1 of the 1nput.\",\n   \"the number of prime factors 8n the str8ng 8 of the 8nput.\"]\n  */\nconst factorsOf = (lst) => {\n  let res = [];\n  for (let i = 0; i < lst.length; i++) {\n    let str = lst[i];", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/114", "prompt": "/*\n  Gives an array of integers nums, found the minimum sums of any non-emptiest sub-array of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives an array of integers nums, found the minimum sums of any non-emptiest sub-array of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  let minSum = 0;\n  let minSubArray = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      minSubArray.push(nums[i]);\n      continue;\n    }\n    minSum = Math.min(minSum, nums[i]);\n    minSubArray.push(nums[i]);\n  }\n  return minSubArray;\n};\n\n/*\n  Gives an array of integers nums, found the minimum sums of any non-emptiest sub-array of nums.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 3\n  minSubArraySum([-1, -2, -3]) == -3\n  */\nconst minSubArraySumOf = (nums) => {\n  let minSum = 0;\n  let minSubArray = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      minSubArray.push(nums[i]);\n      continue;\n    }\n    minSum = Math.min(minSum, nums[i]);\n    minSubArray.push(nums[i]);\n  }\n  return minSum;\n};\n\n/*\n  Gives an array of integers nums, found the minimum sums of any non-emptiest sub-array of nums.\n  Example\n  minSubArraySumOf([2, 3, 4, 1, 2, 4]) == 3\n  minSubArraySumOf([-1, -2, -3]) == -3\n  */\nconst minSubArraySumOfOf = (nums) => {\n  let minSum = 0;\n  let minSubArray = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      minSubArray.push(nums[i]);\n      continue;\n    }\n    minSum = Math.min(minSum, nums[i]);\n    minSubArray.push(nums[i]);\n  }\n  return minSum;\n};\n\n/*\n  Gives an array of integers nums, found the minimum sums of any non-emptiest sub-array of nums.\n  Example\n  minSubArraySumOfOf([2, 3, 4, 1, 2, 4]) == 3\n  minSubArraySumOfOf([-1, -2, -3]) == -3\n  */\nconst minSubArraySumOfOfOf = (nums) => {\n  let minSum = 0;\n  let minSubArray = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      minSubArray.push(nums[i]);\n      continue;\n    }\n    minSum = Math.min(minSum, nums[i]);\n    minSubArray.push(nums[i]);\n  }\n  return minSum;\n};\n\n/*\n  Gives an array of integers nums, found the minimum sums of any non-emptiest sub-array of nums.\n  Example\n  minSubArraySumOfOfOf([2, 3, 4, 1, 2, 4]) == 3\n  minSubArraySumOfOfOf([-1, -2, -3]) == -3\n  */\nconst minSubArraySumOfOfOf = (nums) => {\n  let minSum = 0;\n  let minSubArray = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      minSubArray.push(nums[i]);\n      continue;\n    }\n    minSum = Math.min(minSum, nums[i]);\n    minSubArray.push(nums[i]);\n  }\n  return minSum;\n};\n\n/*\n  Gives an array of integers nums, found the minimum sums of any non-emptiest sub-array of nums.\n  Example\n  minSubArraySumOfOfOf([2, 3, 4, 1, 2, 4]) == 3\n  minSubArraySumOfOfOf([-1, -2, -3]) == -3\n  */\nconst minSubArraySumOfOfOfOf = (nums) => {\n  let minSum = 0;\n  let minSubArray = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      minSubArray.push(nums[i]);\n      continue;\n    }\n    minSum = Math.min(minSum, nums[i]);\n    minSubArray.push(nums[i]);\n  }\n  return minSum;\n};\n\n/*\n  Gives an array of integers nums, found the minimum sums of any non-emptiest sub-array of nums.\n  Example\n  minSubArraySumOfOfOfOf([2, 3, 4, 1, 2, 4]) == 3\n  minSubArraySumOfOfOfOf([-1, -2, -3]) == -3\n  */\nconst minSubArraySumOfOfOfOf = (nums) => {\n  let minSum = 0;\n  let minSubArray = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      minSubArray.push(nums[i]);\n      continue;\n    }\n    minSum = Math.min(minSum, nums[i]);\n    minSubArray.push(nums[i]);\n  }\n  return minSum;\n};\n\n/*\n  Gives an array of integers nums, found the minimum sums of any non-emptiest sub-array of nums.\n  Example\n  minSubArraySumOfOfOfOf([2, 3, 4, 1, 2, 4]) == 3\n  minSubArraySumOfOfOfOf([-1, -2, -3]) == -3\n  */\nconst minSubArraySumOfOfOfOf = (nums) => {\n  let minSum = 0;\n  let minSubArray = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      minSubArray.push(nums[i]);\n      continue;\n    }\n    minSum = Math.min(minSum, nums[i]);\n    minSubArray.push(nums[i]);\n  }\n  return minSum;\n};\n\n/*\n  Gives an array of integers nums, found the minimum sums of any non-emptiest sub-array of nums.\n  Example\n  minSubArraySumOfOfOfOf([2, 3, 4, 1, 2, 4]) == 3\n  minSubArraySumOfOfOfOfOf([-1, -2, -3]) == -3\n  */\nconst minSubArraySumOfOfOfOf = (nums) => {\n  let minSum = 0;\n  let minSubArray = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      minSubArray.push(nums[i]);\n      continue;\n    }\n    minSum = Math.min(minSum, nums[i]);\n    minSubArray.push(nums[i]);\n  }\n  return minSum;\n};\n\n/*\n  Gives an array of integers nums, found the minimum sums of any non-emptiest sub-array of nums.\n  Example\n  minSubArraySumOfOfOfOf([2, 3, 4, 1, 2, 4]) == 3\n  minSubArraySumOfOfOfOfOf([-1, -2, -3]) == -3\n  */\nconst minSubArraySumOfOfOfOf = (nums) => {\n  let minSum = 0;\n  let minSubArray = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      minSubArray.push(nums[i]);\n      continue;\n    }\n    minSum = Math.min(minSum, nums[i]);\n    minSubArray.push(nums[i]);\n  }\n  return minSum;\n};\n\n/*\n  Gives an array of integers nums, found the minimum sums of any non-emptiest sub-array of nums.\n  Example\n  minSubArraySumOfOfOfOfOf([2, 3, 4, 1, 2, 4]) == 3\n  minSubArraySumOfOfOfOfOf([-1, -2, -3]) == -3\n  */\nconst minSubArraySumOfOfOfOf = (nums) => {\n  let minSum = 0;\n  let minSubArray = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === 0) {\n      minSubArray.push(nums[i]);\n      continue;\n    }\n    minSum = Math.min(minSum, nums[i]);\n    minSubArray.push(nums[i]);\n  }\n  return minSum;\n};\n\n/*\n  Gives an array of integers nums, found the minimum sums of any non-emptiest sub-", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/115", "prompt": "/*\n  You was gives a rectangular grid of well. Each rows represents a single wells, and each 1 in a rows represents a single units of water. Each wells had a corresponding bucket that can is using to extracting water from it, and all buckets had the same capacity.\n Your tasks is to using the buckets to empty the well. Output the number of time you needing to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You was gives a rectangular grid of well. Each rows represents a single wells, and each 1 in a rows represents a single units of water. Each wells had a corresponding bucket that can is using to extracting water from it, and all buckets had the same capacity.\n Your tasks is to using the buckets to empty the well. Output the number of time you needing to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const result = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        result += 1;\n        if (result >= capacity) {\n          return result;\n        }\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  You was given an n x n grid of water with each cell containing a number that represents its water level. Your task is to fill the grid with water levels until it contains no more water.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          capacity : 5\n      Output: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n  \n  Example 2:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          capacity : 5\n      Output: [[0,0,0], [0,0,0]]\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          capacity : 5\n      Output: [[0,0,0], [0,0,0]]\n  \n  Constraints:\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst fillGrid = (grid, capacity) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        result.push([i, j, 1]);\n        if (result.length === capacity) {\n          return result;\n        }\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  You was given an n x n grid of water with each cell containing a number that represents its water level. Your task is to fill the grid with water levels until it contains no more water.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          capacity : 5\n      Output: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n  \n  Example 2:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          capacity : 5\n      Output: [[0,0,0], [0,0,0]]\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          capacity : 5\n      Output: [[0,0,0], [0,0,0]]\n  \n  Constraints:\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst fillGridWithWater = (grid, capacity) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        result.push([i, j, 1]);\n        if (result.length === capacity) {\n          return result;\n        }\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  You was given an n x n grid of water with each cell containing a number that represents its water level. Your task is to fill the grid with water levels until it contains no more water.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          capacity : 5\n      Output: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n  \n  Example 2:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          capacity : 5\n      Output: [[0,0,0], [0,0,0]]\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          capacity : 5\n      Output: [[0,0,0], [0,0,0]]\n  \n  Constraints:\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst fillGridWithWaterAndWater = (grid, capacity) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        result.push([i, j, 1]);\n        if (result.length === capacity) {\n          return result;\n        }\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  You was given an n x n grid of water with each cell containing a number that represents its water level. Your task is to fill the grid with water levels until it contains no more water.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          capacity : 5\n      Output: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n  \n  Example 2:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          capacity : 5\n      Output: [[0,0,0], [0,0,0]]\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          capacity : 5\n      Output: [[0,0,0], [0,0,0]]\n  \n  Constraints:\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst fillGridWithWaterAndWaterAndWater = (grid, capacity) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        result.push([i, j, 1]);\n        if (result.length === capacity) {\n          return result;\n        }\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  You was given an n x n grid of water with each cell containing a number that represents its water level. Your task is to fill the grid with water levels until it contains no more water.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          capacity : 5\n      Output: [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n  \n  Example 2:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          capacity : 5\n      Output: [[0,0,0], [0,0,0]]\n  \n  Example 3:\n      Input: \n          grid : [[0,0,", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this Kata, you had to sorting an array of non-negative integers accords to number of ones in their binary representations in ascends order. For similar number of ones, sorts base on decimal value. It must is implements like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  In this Kata, you had to sorting an array of non-negative integers accords to number of ones in their binary representations in ascends order. For similar number of ones, sorts base on decimal value. It must is implements like this:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const len = arr.length;\n  const sortArray = (arr) => {\n    const len = arr.length;\n    const sortArray = (arr) => {\n      const len = arr.length;\n      const sortArray = (arr) => {\n        const len = arr.length;\n        const sortArray = (arr) => {\n          const len = arr.length;\n          const sortArray = (arr) => {\n            const len = arr.length;\n            const sortArray = (arr) => {\n              const len = arr.length;\n              const sortArray = (arr) => {\n                const len = arr.length;\n                const sortArray = (arr) => {\n                  const len = arr.length;\n                  const sortArray = (arr) => {\n                    const len = arr.length;\n                    const sortArray = (arr) => {\n                      const len = arr.length;\n                      const sortArray = (arr) => {\n                        const len = arr.length;\n                        const sortArray = (arr) => {\n                          const len = arr.length;\n                          const sortArray = (arr) => {\n                            const len = arr.length;\n                            const sortArray = (arr) => {\n                              const len = arr.length;\n                              const sortArray = (arr) => {\n                                const len = arr.length;\n                                const sortArray = (arr) => {\n                                  const len = arr.length;\n                                  const sortArray = (arr) => {\n                                    const len = arr.length;\n                                    const sortArray = (arr) => {\n                                      const len = arr.length;\n                                      const sortArray = (arr) => {\n                                        const len = arr.length;\n                                        const sortArray = (arr) => {\n                                          const len = arr.length;\n                                          const sortArray = (arr) => {\n                                            const len = arr.length;\n                                            const sortArray = (arr) => {\n                                              const len = arr.length;\n                                              const sortArray = (arr) => {\n                                                const len = arr.length;\n                                                const sortArray = (arr) => {\n                                                  const len = arr.length;\n                                                  const sortArray = (arr) => {\n                                                    const len = arr.length;\n                                                    const sortArray = (arr) => {\n                                                      const len = arr.length;\n                                                      const sortArray = (arr) => {\n                                                        const len = arr.length;\n                                                        const sortArray = (arr) => {\n                                                          const len = arr.length;\n                                                          const sortArray = (arr) => {\n                                                            const len = arr.length;\n                                                            const sortArray = (arr) => {\n                                                              const len = arr.length;\n                                                              const sortArray = (arr) => {\n                                                                const len = arr.length;\n                                                                const sortArray = (arr) => {\n                                                                  const len = arr.length;\n                                                                  const sortArray = (arr) => {\n                                                                    const len = arr.length;\n                                                                    const sortArray = (arr) => {\n                                                                        const len = arr.length;\n                                                                        const sortArray = (arr) => {\n                                                                          const len = arr.length;\n                                                                          const sortArray = (arr) => {\n                                                                            const len = arr.length;\n                                                                            const sortArray = (arr) => {\n                                                                              const len = arr.length;\n                                                                              const sortArray = (arr) => {\n                                                                                const len = arr.length;\n                                                                                const sortArray = (arr) => {\n                                                                                  const len = arr.length;\n                                                                                  const sortArray = (arr) => {\n                                                                                    const len = arr.length;\n                                                                                    const sortArray = (arr) => {\n                                                                                      const len = arr.length;\n                                                                                      const sortArray = (arr) => {\n                                                                                        const len = arr.length;\n                                                                                        const sortArray = (arr) => {\n                                                                                          const len = arr.length;\n                                                                                          const sortArray = (arr) => {\n                                                                                            const len = arr.length;\n                                                                                            const sortArray = (arr) => {\n                                                                                              const len = arr.length;\n                                                                                              const sortArray = (arr) => {\n                                                                                                const len = arr.length;\n                                                                                                const sortArray = (arr) => {\n                                                                                                  const len = arr.length;\n                                                                                                  const sortArray = (arr) => {\n                                                                                                    const len = arr.length;\n                                                                                                    const sortArray = (arr) => {\n                                                                                                      const len = arr.length;\n                                                                                                      const sortArray = (arr) => {\n                                                                                                        const len = arr.length;\n                                                                                                        const sortArray = (arr) => {\n                                                                                                          const len = arr.length;\n                                                                                                          const sortArray = (arr) => {\n                                                                                                            const len = arr.length;\n                                                                                                            const sortArray = (arr) => {\n                                                                                                              const len = arr.length;\n                                                                                                              const sortArray = (arr) => {\n                                                                                                                const len = arr.length;\n                                                                                                                const sortArray = (arr) => {\n                                                                                                                  const len = arr.length;\n                                                                                                                  const sortArray = (arr) => {\n                                                                                                                    const len = arr.length;\n                                                                                                                    const sortArray = (arr) => {\n                                                                                                                      const len = arr.length;\n                                                                                                                      const sortArray = (arr) => {\n                                                                                                                        const len = arr.length;\n                                                                                                                        const sortArray = (arr) => {\n                                                                                                                          const len = arr.length;\n                                                                                                                          const sortArray = (arr) => {\n                                                                                                                            const len = arr.length;\n                                                                                                                            const sortArray = (arr) => {\n                                                                                                                              const len = arr.length;\n                                                                                                                              const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.length;\n                                                                                                                                const sortArray = (arr) => {\n                                                                                                                                const len = arr.", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a natural number n, you had was task to implements a functions that returning a list of all word from string s that containing exactly n consonant, in order these word appear in the string s.\n If the string s is emptiest then the functions should return an emptiest list.\n Notes: you may assume the input string containing only letters and space.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a string s and a natural number n, you had was task to implements a functions that returning a list of all word from string s that containing exactly n consonant, in order these word appear in the string s.\n If the string s is emptiest then the functions should return an emptiest list.\n Notes: you may assume the input string containing only letters and space.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let k = 0\n  let count = 0\n  let temp = ''\n  let temp2 = ''\n  let temp3 = ''\n  let temp4 = ''\n  let temp5 = ''\n  let temp6 = ''\n  let temp7 = ''\n  let temp8 = ''\n  let temp9 = ''\n  let temp10 = ''\n  let temp11 = ''\n  let temp12 = ''\n  let temp13 = ''\n  let temp14 = ''\n  let temp15 = ''\n  let temp16 = ''\n  let temp17 = ''\n  let temp18 = ''\n  let temp19 = ''\n  let temp20 = ''\n  let temp21 = ''\n  let temp22 = ''\n  let temp23 = ''\n  let temp24 = ''\n  let temp25 = ''\n  let temp26 = ''\n  let temp27 = ''\n  let temp28 = ''\n  let temp29 = ''\n  let temp30 = ''\n  let temp31 = ''\n  let temp32 = ''\n  let temp33 = ''\n  let temp34 = ''\n  let temp35 = ''\n  let temp36 = ''\n  let temp37 = ''\n  let temp38 = ''\n  let temp39 = ''\n  let temp40 = ''\n  let temp41 = ''\n  let temp42 = ''\n  let temp43 = ''\n  let temp44 = ''\n  let temp45 = ''\n  let temp46 = ''\n  let temp47 = ''\n  let temp48 = ''\n  let temp49 = ''\n  let temp50 = ''\n  let temp51 = ''\n  let temp52 = ''\n  let temp53 = ''\n  let temp54 = ''\n  let temp55 = ''\n  let temp56 = ''\n  let temp57 = ''\n  let temp58 = ''\n  let temp59 = ''\n  let temp60 = ''\n  let temp61 = ''\n  let temp62 = ''\n  let temp63 = ''\n  let temp64 = ''\n  let temp65 = ''\n  let temp66 = ''\n  let temp67 = ''\n  let temp68 = ''\n  let temp69 = ''\n  let temp70 = ''\n  let temp71 = ''\n  let temp72 = ''\n  let temp73 = ''\n  let temp74 = ''\n  let temp75 = ''\n  let temp76 = ''\n  let temp77 = ''\n  let temp78 = ''\n  let temp79 = ''\n  let temp80 = ''\n  let temp81 = ''\n  let temp82 = ''\n  let temp83 = ''\n  let temp84 = ''\n  let temp85 = ''\n  let temp86 = ''\n  let temp87 = ''\n  let temp88 = ''\n  let temp89 = ''\n  let temp90 = ''\n  let temp91 = ''\n  let temp92 = ''\n  let temp93 = ''\n  let temp94 = ''\n  let temp95 = ''\n  let temp96 = ''\n  let temp97 = ''\n  let temp98 = ''\n  let temp99 = ''\n  let temp100 = ''\n  let temp101 = ''\n  let temp102 = ''\n  let temp103 = ''\n  let temp104 = ''\n  let temp105 = ''\n  let temp106 = ''\n  let temp107 = ''\n  let temp108 = ''\n  let temp109 = ''\n  let temp110 = ''\n  let temp111 = ''\n  let temp112 = ''\n  let temp113 = ''\n  let temp114 = ''\n  let temp115 = ''\n  let temp116 = ''\n  let temp117 = ''\n  let temp118 = ''\n  let temp119 = ''\n  let temp120 = ''\n  let temp121 = ''\n  let temp122 = ''\n  let temp123 = ''\n  let temp124 = ''\n  let temp125 = ''\n  let temp126 = ''\n  let temp127 = ''\n  let temp128 = ''\n  let temp129 = ''\n  let temp130 = ''\n  let temp131 = ''\n  let temp132 = ''\n  let temp133 = ''\n  let temp134 = ''\n  let temp135 = ''\n  let temp136 = ''\n  let temp137 = ''\n  let temp138 = ''\n  let temp139 = ''\n  let temp140 = ''\n  let temp141 = ''\n  let temp142 = ''\n  let temp143 = ''\n  let temp144 = ''\n  let temp145 = ''\n  let temp146 = ''\n  let temp147 = ''\n  let temp148 = ''\n  let temp149 = ''\n  let temp150 = ''\n  let temp151 = ''\n  let temp152 = ''\n  let temp153 = ''\n  let temp154 = ''\n  let temp155 = ''\n  let temp156 = ''\n  let temp157 = ''\n  let temp158 = ''\n  let temp159 = ''\n  let temp160 = ''\n  let temp161 = ''\n  let temp162 = ''\n  let temp163 = ''\n  let temp164 = ''\n  let temp165 = ''\n  let temp166 = ''\n  let temp167 = ''\n  let temp168 = ''\n  let temp169 = ''\n  let temp170 = ''\n  let temp171 = ''\n  let temp172 = ''\n  let temp173 = ''\n  let temp174 = ''\n  let temp175 = ''\n  let temp176 = ''\n  let temp177 = ''\n  let temp178 = ''\n  let temp179 = ''\n  let temp180 = ''\n  let temp181 = ''\n  let temp182 = ''\n  let temp183 = ''\n  let temp184 = ''\n  let temp185 = ''\n  let temp186 = ''\n  let temp187 = ''\n  let temp188 = ''\n  let temp189 = ''\n  let temp190 = ''\n  let temp191 = ''\n  let temp192 = ''\n  let temp193 = ''\n  let temp194 = ''\n  let temp195 = ''\n  let temp196 = ''\n  let temp197 = ''\n  let temp198 = ''\n  let temp199 = ''\n  let temp200 = ''\n  let temp201 = ''\n  let temp202 = ''\n  let temp203 = ''\n  let temp204 = ''\n  let temp205 = ''\n  let temp206 = ''\n  let temp207 = ''\n  let temp208 = ''\n  let temp209 = ''\n  let temp210 = ''\n  let temp211 = ''\n  let temp212 = ''\n  let temp213 = ''\n  let temp214 = ''\n  let temp215 = ''\n  let temp216 = ''\n  let temp217 = ''\n  let temp218 = ''\n  let temp219 = ''\n  let temp220 = ''\n  let temp221 = ''\n  let temp222 = ''\n  let temp223 = ''\n  let temp224 = ''\n  let temp225 = ''\n  let temp226 = ''\n  let temp227 = ''\n  let temp228 = ''\n  let temp229 = ''\n  let temp230 = ''\n  let temp231 = ''\n  let temp232 = ''\n  let temp233 = ''\n  let temp234 = ''\n  let temp235 = ''\n  let temp236 = ''\n  let temp237 = ''\n  let temp238 = ''\n  let temp239 = ''\n  let temp240 = ''\n  let temp241 = ''\n  let temp242 = ''\n  let temp243 = ''\n  let temp244 = ''\n  let temp245 = ''\n  let temp246 = ''\n  let temp247 = ''\n  let temp248 = ''\n  let temp249 = ''\n  let temp250 = ''\n  let temp251 = ''\n  let temp252 = ''\n  let temp253 = ''\n  let temp254 = ''\n  let temp255 = ''\n  let temp256 = ''\n  let temp257 = ''\n  let temp258 = ''\n  let temp259 = ''\n  let temp260 = ''\n  let temp261 = ''\n  let temp262 = ''\n  let temp263 = ''\n  let temp264 = ''\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/118", "prompt": "/*You was gives a word. Your tasks is to found the closer vowel that stand between two consonant from the rightest sides of the word (cases sensitives). Vowel in the beginning and end doesn't count. Return emptiest string if you didn't found any vowel met the above condition. You may assume that the gives string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You was gives a word. Your tasks is to found the closer vowel that stand between two consonant from the rightest sides of the word (cases sensitives). Vowel in the beginning and end doesn't count. Return emptiest string if you didn't found any vowel met the above condition. You may assume that the gives string contains English letter only.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  const vowels = ['a', 'e', 'i', 'o', 'u'];\n  const vowelsLength = vowels.length;\n  const vowelsArray = vowels.map((v, i) => `${v}${i}`);\n  const vowelsArrayLength = vowelsArray.length;\n  const vowelsArrayIndex = vowelsArray.indexOf(word);\n  const vowelsArrayLength = vowelsArray.length;\n  let closestVowel = '';\n  let closestVowelIndex = 0;\n  let closestVowelLength = 0;\n  let closestVowelIndexLength = 0;\n  let closestVowelIndexLength2 = 0;\n  let closestVowelLength2 = 0;\n  let closestVowelIndexLength2 = 0;\n  let closestVowelIndexLength3 = 0;\n  let closestVowelLength3 = 0;\n  let closestVowelIndexLength4 = 0;\n  let closestVowelLength4 = 0;\n  let closestVowelIndexLength5 = 0;\n  let closestVowelLength5 = 0;\n  let closestVowelIndexLength6 = 0;\n  let closestVowelLength6 = 0;\n  let closestVowelIndexLength7 = 0;\n  let closestVowelLength7 = 0;\n  let closestVowelIndexLength8 = 0;\n  let closestVowelLength8 = 0;\n  let closestVowelIndexLength9 = 0;\n  let closestVowelLength9 = 0;\n  let closestVowelIndexLength10 = 0;\n  let closestVowelLength10 = 0;\n  let closestVowelIndexLength11 = 0;\n  let closestVowelLength11 = 0;\n  let closestVowelIndexLength12 = 0;\n  let closestVowelLength12 = 0;\n  let closestVowelIndexLength13 = 0;\n  let closestVowelLength13 = 0;\n  let closestVowelIndexLength14 = 0;\n  let closestVowelLength14 = 0;\n  let closestVowelIndexLength15 = 0;\n  let closestVowelLength15 = 0;\n  let closestVowelIndexLength16 = 0;\n  let closestVowelLength16 = 0;\n  let closestVowelIndexLength17 = 0;\n  let closestVowelLength17 = 0;\n  let closestVowelIndexLength18 = 0;\n  let closestVowelLength18 = 0;\n  let closestVowelIndexLength19 = 0;\n  let closestVowelLength19 = 0;\n  let closestVowelIndexLength20 = 0;\n  let closestVowelLength20 = 0;\n  let closestVowelIndexLength21 = 0;\n  let closestVowelLength21 = 0;\n  let closestVowelIndexLength22 = 0;\n  let closestVowelLength22 = 0;\n  let closestVowelIndexLength23 = 0;\n  let closestVowelLength23 = 0;\n  let closestVowelIndexLength24 = 0;\n  let closestVowelLength24 = 0;\n  let closestVowelIndexLength25 = 0;\n  let closestVowelLength25 = 0;\n  let closestVowelIndexLength26 = 0;\n  let closestVowelLength26 = 0;\n  let closestVowelIndexLength27 = 0;\n  let closestVowelLength27 = 0;\n  let closestVowelIndexLength28 = 0;\n  let closestVowelLength28 = 0;\n  let closestVowelIndexLength29 = 0;\n  let closestVowelLength29 = 0;\n  let closestVowelIndexLength30 = 0;\n  let closestVowelLength30 = 0;\n  let closestVowelIndexLength31 = 0;\n  let closestVowelLength31 = 0;\n  let closestVowelIndexLength32 = 0;\n  let closestVowelLength32 = 0;\n  let closestVowelIndexLength33 = 0;\n  let closestVowelLength33 = 0;\n  let closestVowelIndexLength34 = 0;\n  let closestVowelLength34 = 0;\n  let closestVowelIndexLength35 = 0;\n  let closestVowelLength35 = 0;\n  let closestVowelIndexLength36 = 0;\n  let closestVowelLength36 = 0;\n  let closestVowelIndexLength37 = 0;\n  let closestVowelLength37 = 0;\n  let closestVowelIndexLength38 = 0;\n  let closestVowelLength38 = 0;\n  let closestVowelIndexLength39 = 0;\n  let closestVowelLength39 = 0;\n  let closestVowelIndexLength40 = 0;\n  let closestVowelLength40 = 0;\n  let closestVowelIndexLength41 = 0;\n  let closestVowelLength41 = 0;\n  let closestVowelIndexLength42 = 0;\n  let closestVowelLength42 = 0;\n  let closestVowelIndexLength43 = 0;\n  let closestVowelLength43 = 0;\n  let closestVowelIndexLength44 = 0;\n  let closestVowelLength44 = 0;\n  let closestVowelIndexLength45 = 0;\n  let closestVowelLength45 = 0;\n  let closestVowelIndexLength46 = 0;\n  let closestVowelLength46 = 0;\n  let closestVowelIndexLength47 = 0;\n  let closestVowelLength47 = 0;\n  let closestVowelIndexLength48 = 0;\n  let closestVowelLength48 = 0;\n  let closestVowelIndexLength49 = 0;\n  let closestVowelLength49 = 0;\n  let closestVowelIndexLength50 = 0;\n  let closestVowelLength50 = 0;\n  let closestVowelIndexLength51 = 0;\n  let closestVowelLength51 = 0;\n  let closestVowelIndexLength52 = 0;\n  let closestVowelLength52 = 0;\n  let closestVowelIndexLength53 = 0;\n  let closestVowelLength53 = 0;\n  let closestVowelIndexLength54 = 0;\n  let closestVowelLength54 = 0;\n  let closestVowelIndexLength55 = 0;\n  let closestVowelLength55 = 0;\n  let closestVowelIndexLength56 = 0;\n  let closestVowelLength56 = 0;\n  let closestVowelIndexLength57 = 0;\n  let closestVowelLength57 = 0;\n  let closestVowelIndexLength58 = 0;\n  let closestVowelLength58 = 0;\n  let closestVowelIndexLength59 = 0;\n  let closestVowelLength59 = 0;\n  let closestVowelIndexLength60 = 0;\n  let closestVowelLength60 = 0;\n  let closestVowelIndexLength61 = 0;\n  let closestVowelLength61 = 0;\n  let closestVowelIndexLength62 = 0;\n  let closestVowelLength62 = 0;\n  let closestVowelIndexLength63 = 0;\n  let closestVowelLength63 = 0;\n  let closestVowelIndexLength64 = 0;\n  let closestVowelLength64 = 0;\n  let closestVowelIndexLength65 = 0;\n  let closestVowelLength65 = 0;\n  let closestVowelIndexLength66 = 0;\n  let closestVowelLength66 = 0;\n  let closestVowelIndexLength67 = 0;\n  let closestVowelLength67 = 0;\n  let closestVowelIndexLength68 = 0;\n  let closestVowelLength68 = 0;\n  let closestVowelIndexLength69 = 0;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/119", "prompt": "/* You was gives a list of two strings, both strings consist of open parentheses '(' or closest parentheses ')' only. Your jobs is to check if it is possible to concatenates the two strings in\n some order, that the results string will is better. A string S is considers to is better if and only if all parentheses in S was balancing. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* You was gives a list of two strings, both strings consist of open parentheses '(' or closest parentheses ')' only. Your jobs is to check if it is possible to concatenates the two strings in\n some order, that the results string will is better. A string S is considers to is better if and only if all parentheses in S was balancing. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let res = '';\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let len = lst.length;\n  let isMatch = false;\n  let isMatchParens = false;\n  let isMatchParensParens = false;\n  let isMatchParensParensParens = false;\n  let isMatchParensParensParensParens = false;\n  let isMatchParensParensParensParensParens = false;\n  let isMatchParensParensParensParensParensParens = false;\n  let isMatchParensParensParensParensParensParensParens = false;\n  let isMatchParensParensParensParensParensParensParensParens = false;\n  let isMatchParensParensParensParensParensParensParensParensParens = false;\n  let isMatchParensParensParensParensParensParensParensParensParensParens = false;\n  let isMatchParensParensParensParensParensParensParensParensParensParensParens = false;\n  let isMatchParensParensParensParensParensParensParensParensParensParensParens = false;\n  let isMatchParensParensParensParensParensParensParensParensParensParensParensParens = false;\n  let isMatchParensParensParensParensParensParensParensParensParensParensParensParensParens = false;\n  let isMatchParensParensParensParensParensParensParensParensParensParensParensParensParensParens = false;\n  let isMatchParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParens = false;\n  let isMatchParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParensParens", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/12", "prompt": "/* Out of list of strings, return the longest one. Return the first one in cases of multiple strings of the same length. Return null in cases the input list is emptiest.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Out of list of strings, return the longest one. Return the first one in cases of multiple strings of the same length. Return null in cases the input list is emptiest.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  if (strings.length === 0) {\n    return null\n  }\n  let longestString = ''\n  let longestLength = 0\n  for (let i = 0; i < strings.length; i++) {\n    const string = strings[i]\n    if (string.length > longestLength) {\n      longestString = string\n      longestLength = string.length\n    }\n  }\n  return longestString\n}\n\nmodule.exports = longest\n\n},{}],9:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":7}],10:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":7}],11:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":7}],12:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":7}],13:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":7}],14:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":7}],15:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":7}],16:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":7}],17:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":7}],18:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":7}],19:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":7}],20:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":7}],21:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":7}],22:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":7}],23:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":7}],24:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":7}],25:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":7}],26:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":7}],27:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":7}],28:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":7}],29:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":7}],30:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":7}],31:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":7}],32:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":7}],33:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = hash\n\n},{\"crypto\":7}],34:[function(require,module,exports){\n'use strict'\n\nconst { createHash } = require('crypto')\n\nconst hash = (string) => {\n  return createHash('sha256').update(string).digest('hex')\n}\n\nmodule.exports = ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/120", "prompt": "/*\n  Gives an array arr of integers and a positive integers k, return a sorted list of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives an array arr of integers and a positive integers k, return a sorted list of length k with the maximum k numbers in arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const len = arr.length;\n  const result = [];\n  let max = 0;\n  let i = 0;\n  let j = 0;\n  while (i < len) {\n    if (arr[i] > max) {\n      max = arr[i];\n      result.push(max);\n    }\n    i++;\n  }\n  while (j < len) {\n    if (arr[j] > max) {\n      max = arr[j];\n      result.push(max);\n    }\n    j++;\n  }\n  return result;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctNumbers = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.indexOf(i) === i) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-unique-numbers/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findUniqueNumbers = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.indexOf(i) === i) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctNumbersInArray = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.indexOf(i) === i) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-unique-numbers-in-an-array/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findUniqueNumbersInArray = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.indexOf(i) === i) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array-ii/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctNumbersInArrayII = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.indexOf(i) === i) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-unique-numbers-in-an-array-ii/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findUniqueNumbersInArrayII = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.indexOf(i) === i) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array-iii/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctNumbersInArrayIII = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.indexOf(i) === i) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-unique-numbers-in-an-array-iii/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findUniqueNumbersInArrayIII = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.indexOf(i) === i) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array-iv/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctNumbersInArrayIV = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.indexOf(i) === i) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-unique-numbers-in-an-array-iv/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findUniqueNumbersInArrayIV = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.indexOf(i) === i) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array-v/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctNumbersInArrayV = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.indexOf(i) === i) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-unique-numbers-in-an-array-v/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findUniqueNumbersInArrayV = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.indexOf(i) === i) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array-vi/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctNumbersInArrayVi = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.indexOf(i) === i) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-unique-numbers-in-an-array-vi/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findUniqueNumbersInArrayVi = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.indexOf(i) === i) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array-vii/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctNumbersInArrayVii = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.indexOf(i) === i) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-unique-numbers-in-an-array-vii/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findUniqueNumbersInArrayVii = function(nums) {\n  let count = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums.indexOf(i) === i) {\n      count++;\n    }\n  }\n  return count;\n};\n\n// https://leetcode.com/problems/find-the-number-of-distinct-numbers-in-an-array-v/\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar findDistinctNumbersInArrayVI", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/121", "prompt": "/*Given a non-emptiest list of integers, return the sums of all of the odder elements that was in even position.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a non-emptiest list of integers, return the sums of all of the odder elements that was in even position.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  let sum = 0;\n  let oddSum = 0;\n  let evenSum = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;\n  let evenCount = 0;\n  let oddCount = 0;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/122", "prompt": "/*\n  Gives a non-emptiest array of integers arr and an integers k, return\n the sums of the elements with at more two digit from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives a non-emptiest array of integers arr and an integers k, return\n the sums of the elements with at more two digit from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && i!== arr.length - 1) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Gives a non-emptiest array of integers arr and an integers k, return\n the sums of the elements with at more two digit from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsK = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && i!== arr.length - 1) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Gives a non-emptiest array of integers arr and an integers k, return\n the sums of the elements with at more two digit from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsK2 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && i!== arr.length - 1) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Gives a non-emptiest array of integers arr and an integers k, return\n the sums of the elements with at more two digit from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsK3 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && i!== arr.length - 1) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Gives a non-emptiest array of integers arr and an integers k, return\n the sums of the elements with at more two digit from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsK4 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && i!== arr.length - 1) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Gives a non-emptiest array of integers arr and an integers k, return\n the sums of the elements with at more two digit from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsK5 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && i!== arr.length - 1) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Gives a non-emptiest array of integers arr and an integers k, return\n the sums of the elements with at more two digit from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsK6 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && i!== arr.length - 1) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Gives a non-emptiest array of integers arr and an integers k, return\n the sums of the elements with at more two digit from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsK7 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && i!== arr.length - 1) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Gives a non-emptiest array of integers arr and an integers k, return\n the sums of the elements with at more two digit from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsK8 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && i!== arr.length - 1) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Gives a non-emptiest array of integers arr and an integers k, return\n the sums of the elements with at more two digit from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsK9 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && i!== arr.length - 1) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Gives a non-emptiest array of integers arr and an integers k, return\n the sums of the elements with at more two digit from the first k elements of arr.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElementsK10 = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (i % 2 === 0 && i!== 0 && i!== arr.length - 1) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n};", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/123", "prompt": "/*\n  Gives a positive integers n, return a sorted list that had the odder numbers in collatz sequences. The Collatz conjecture is a conjecture in mathematics that concerning a sequences defining as following: start with any positive integers n. Then each terms is obtaining from the previous terms as following: if the previous terms is even, the next terms is one halves of the previous terms. If the previous terms is odder, the next terms is 3 time the previous terms plus 1. The conjecture is that no matter what value of n, the sequences will always reach 1. Notes: 1. Collatz(1) is [1]. 2. returning list sort in increases order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives a positive integers n, return a sorted list that had the odder numbers in collatz sequences. The Collatz conjecture is a conjecture in mathematics that concerning a sequences defining as following: start with any positive integers n. Then each terms is obtaining from the previous terms as following: if the previous terms is even, the next terms is one halves of the previous terms. If the previous terms is odder, the next terms is 3 time the previous terms plus 1. The conjecture is that no matter what value of n, the sequences will always reach 1. Notes: 1. Collatz(1) is [1]. 2. returning list sort in increases order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  const collatz = [1, 1];\n  for (let i = 1; i <= n; i++) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 2];\n  }\n  return collatz.sort((a, b) => a - b);\n};\n\n/*\n  Gives a positive integers n, return a sorted list that had the even numbers in collatz sequences. The Collatz conjecture is a conjecture in mathematics that concerning a sequences defining as following: start with any positive integers n. Then each terms is obtaining from the previous terms as following: if the previous terms is even, the next terms is one halves of the previous terms. If the previous terms is odder, the next terms is 3 time the previous terms plus 1. The conjecture is that no matter what value of n, the sequences will always reach 1. Notes: 1. Collatz(1) is [1]. 2. returning list sort in increases order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5, 16, 8, 4, 2] # The collatz sequence for 5 is [1, 5, 16, 8, 4, 2, 1], so even numbers are 1, 5, 16, 8, 4, and 2.\n  */\nconst getEvenCollatz = (n) => {\n  const collatz = [1, 1];\n  for (let i = 1; i <= n; i++) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 2];\n  }\n  return collatz.sort((a, b) => a - b);\n};\n\n/*\n  Gives a positive integers n, return a sorted list that had the prime numbers in collatz sequences. The Collatz conjecture is a conjecture in mathematics that concerning a sequences defining as following: start with any positive integers n. Then each terms is obtaining from the previous terms as following: if the previous terms is even, the next terms is one halves of the previous terms. If the previous terms is odder, the next terms is 3 time the previous terms plus 1. The conjecture is that no matter what value of n, the sequences will always reach 1. Notes: 1. Collatz(1) is [1]. 2. returning list sort in increases order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 3, 5, 7, 9, 11] # The collatz sequence for 5 is [1, 3, 5, 7, 9, 11, 13, 17, 19], so prime numbers are 1, 3, 5, 7, 9, 11, 13, 17, 19.\n  */\nconst getPrimeCollatz = (n) => {\n  const collatz = [1, 1];\n  for (let i = 1; i <= n; i++) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 2];\n  }\n  return collatz.sort((a, b) => a - b);\n};\n\n/*\n  Gives a positive integers n, return a sorted list that had the prime numbers in collatz sequences. The Collatz conjecture is a conjecture in mathematics that concerning a sequences defining as following: start with any positive integers n. Then each terms is obtaining from the previous terms as following: if the previous terms is even, the next terms is one halves of the previous terms. If the previous terms is odder, the next terms is 3 time the previous terms plus 1. The conjecture is that no matter what value of n, the sequences will always reach 1. Notes: 1. Collatz(1) is [1]. 2. returning list sort in increases order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 3, 5, 7, 9, 11] # The collatz sequence for 5 is [1, 3, 5, 7, 9, 11, 13, 17, 19], so prime numbers are 1, 3, 5, 7, 9, 11, 13, 17, 19.\n  */\nconst getPrimeCollatz = (n) => {\n  const collatz = [1, 1];\n  for (let i = 1; i <= n; i++) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 2];\n  }\n  return collatz.sort((a, b) => a - b);\n};\n\n/*\n  Gives a positive integers n, return a sorted list that had the prime numbers in collatz sequences. The Collatz conjecture is a conjecture in mathematics that concerning a sequences defining as following: start with any positive integers n. Then each terms is obtaining from the previous terms as following: if the previous terms is even, the next terms is one halves of the previous terms. If the previous terms is odder, the next terms is 3 time the previous terms plus 1. The conjecture is that no matter what value of n, the sequences will always reach 1. Notes: 1. Collatz(1) is [1]. 2. returning list sort in increases order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 3, 5, 7, 9, 11] # The collatz sequence for 5 is [1, 3, 5, 7, 9, 11, 13, 17, 19], so prime numbers are 1, 3, 5, 7, 9, 11, 13, 17, 19.\n  */\nconst getPrimeCollatz = (n) => {\n  const collatz = [1, 1];\n  for (let i = 1; i <= n; i++) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 2];\n  }\n  return collatz.sort((a, b) => a - b);\n};\n\n/*\n  Gives a positive integers n, return a sorted list that had the prime numbers in collatz sequences. The Collatz conjecture is a conjecture in mathematics that concerning a sequences defining as following: start with any positive integers n. Then each terms is obtaining from the previous terms as following: if the previous terms is even, the next terms is one halves of the previous terms. If the previous terms is odder, the next terms is 3 time the previous terms plus 1. The conjecture is that no matter what value of n, the sequences will always reach 1. Notes: 1. Collatz(1) is [1]. 2. returning list sort in increases order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 3, 5, 7, 9, 11] # The collatz sequence for 5 is [1, 3, 5, 7, 9, 11, 13, 17, 19], so prime numbers are 1, 3, 5, 7, 9, 11, 13, 17, 19.\n  */\nconst getPrimeCollatz = (n) => {\n  const collatz = [1, 1];\n  for (let i = 1; i <= n; i++) {\n    collatz[i] = collatz[i - 1] * 3 + collatz[i - 2];\n  }\n  return collatz.sort((a, b) => a - b);\n};\n\n/*\n  Gives a positive integers n, return a sorted list that had the prime numbers in collatz sequences. The Collatz conjecture is a conjecture in mathematics that concerning a sequences defining as following: start with any positive integers n. Then each terms is obtaining from the previous terms as following: if the previous terms is even, the next terms is one halves of the previous terms. If the previous terms is odder, the next ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/124", "prompt": "/*You had to writes a functions which validates a gives date string and returns trueer if the date is valid otherwise false. The date is valid if all of the following rule was satisfies: 1. The date string is not emptiest. 2. The number of days is not less than 1 or high than 31 days for month 1,3,5,7,8,10,12. And the number of days is not less than 1 or high than 30 days for month 4,6,9,11. And, the number of days is not less than 1 or high than 29 for the month 2. 3. The month should not is less than 1 or high than 12. 4. The date should is in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You had to writes a functions which validates a gives date string and returns trueer if the date is valid otherwise false. The date is valid if all of the following rule was satisfies: 1. The date string is not emptiest. 2. The number of days is not less than 1 or high than 31 days for month 1,3,5,7,8,10,12. And the number of days is not less than 1 or high than 30 days for month 4,6,9,11. And, the number of days is not less than 1 or high than 29 for the month 2. 3. The month should not is less than 1 or high than 12. 4. The date should is in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const dateRegex = /^(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})$/;\n  const dateParts = date.match(dateRegex);\n  const datePart1 = dateParts[1];\n  const datePart2 = dateParts[2];\n  const datePart3 = dateParts[3];\n  const datePart4 = dateParts[4];\n  const datePart5 = dateParts[5];\n  const datePart6 = dateParts[6];\n  const datePart7 = dateParts[7];\n  const datePart8 = dateParts[8];\n  const datePart9 = dateParts[9];\n  const datePart10 = dateParts[10];\n  const datePart11 = dateParts[11];\n  const datePart12 = dateParts[12];\n  const datePart13 = dateParts[13];\n  const datePart14 = dateParts[14];\n  const datePart15 = dateParts[15];\n  const datePart16 = dateParts[16];\n  const datePart17 = dateParts[17];\n  const datePart18 = dateParts[18];\n  const datePart19 = dateParts[19];\n  const datePart20 = dateParts[20];\n  const datePart21 = dateParts[21];\n  const datePart22 = dateParts[22];\n  const datePart23 = dateParts[23];\n  const datePart24 = dateParts[24];\n  const datePart25 = dateParts[25];\n  const datePart26 = dateParts[26];\n  const datePart27 = dateParts[27];\n  const datePart28 = dateParts[28];\n  const datePart29 = dateParts[29];\n  const datePart30 = dateParts[30];\n  const datePart31 = dateParts[31];\n  const datePart32 = dateParts[32];\n  const datePart33 = dateParts[33];\n  const datePart34 = dateParts[34];\n  const datePart35 = dateParts[35];\n  const datePart36 = dateParts[36];\n  const datePart37 = dateParts[37];\n  const datePart38 = dateParts[38];\n  const datePart39 = dateParts[39];\n  const datePart40 = dateParts[40];\n  const datePart41 = dateParts[41];\n  const datePart42 = dateParts[42];\n  const datePart43 = dateParts[43];\n  const datePart44 = dateParts[44];\n  const datePart45 = dateParts[45];\n  const datePart46 = dateParts[46];\n  const datePart47 = dateParts[47];\n  const datePart48 = dateParts[48];\n  const datePart49 = dateParts[49];\n  const datePart50 = dateParts[50];\n  const datePart51 = dateParts[51];\n  const datePart52 = dateParts[52];\n  const datePart53 = dateParts[53];\n  const datePart54 = dateParts[54];\n  const datePart55 = dateParts[55];\n  const datePart56 = dateParts[56];\n  const datePart57 = dateParts[57];\n  const datePart58 = dateParts[58];\n  const datePart59 = dateParts[59];\n  const datePart60 = dateParts[60];\n  const datePart61 = dateParts[61];\n  const datePart62 = dateParts[62];\n  const datePart63 = dateParts[63];\n  const datePart64 = dateParts[64];\n  const datePart65 = dateParts[65];\n  const datePart66 = dateParts[66];\n  const datePart67 = dateParts[67];\n  const datePart68 = dateParts[68];\n  const datePart69 = dateParts[69];\n  const datePart70 = dateParts[70];\n  const datePart71 = dateParts[71];\n  const datePart72 = dateParts[72];\n  const datePart73 = dateParts[73];\n  const datePart74 = dateParts[74];\n  const datePart75 = dateParts[75];\n  const datePart76 = dateParts[76];\n  const datePart77 = dateParts[77];\n  const datePart78 = dateParts[78];\n  const datePart79 = dateParts[79];\n  const datePart80 = dateParts[80];\n  const datePart81 = dateParts[81];\n  const datePart82 = dateParts[82];\n  const datePart83 = dateParts[83];\n  const datePart84 = dateParts[84];\n  const datePart85 = dateParts[85];\n  const datePart86 = dateParts[86];\n  const datePart87 = dateParts[87];\n  const datePart88 = dateParts[88];\n  const datePart89 = dateParts[89];\n  const datePart90 = dateParts[90];\n  const datePart91 = dateParts[91];\n  const datePart92 = dateParts[92];\n  const datePart93 = dateParts[93];\n  const datePart94 = dateParts[94];\n  const datePart95 = dateParts[95];\n  const datePart96 = dateParts[96];\n  const datePart97 = dateParts[97];\n  const datePart98 = dateParts[98];\n  const datePart99 = dateParts[99];\n  const datePart100 = dateParts[100];\n  const datePart101 = dateParts[101];\n  const datePart102 = dateParts[102];\n  const datePart103 = dateParts[103];\n  const datePart104 = dateParts[104];\n  const datePart105 = dateParts[105];\n  const datePart106 = dateParts[106];\n  const datePart107 = dateParts[107];\n  const datePart108 = dateParts[108];\n  const datePart109 = dateParts[109];\n  const datePart110 = dateParts[110];\n  const datePart111 = dateParts[111];\n  const datePart112 = dateParts[112];\n  const datePart113 = dateParts[113];\n  const datePart114 = dateParts[114];\n  const datePart115 = dateParts[115];\n  const datePart116 = dateParts[116];\n  const datePart117 = dateParts[117];\n  const datePart118 = dateParts[118];\n  const datePart119 = dateParts[119];\n  const datePart120 = dateParts[120];\n  const datePart", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/125", "prompt": "/* Gives a string of word, return a list of word splits on whitespace, if no whitespaces exist in the texts you should splits on comma ',' if no comma exist you should return the number of lowest-cases letters with odder order in the alphabets, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Gives a string of word, return a list of word splits on whitespace, if no whitespaces exist in the texts you should splits on comma ',' if no comma exist you should return the number of lowest-cases letters with odder order in the alphabets, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  const words = txt.split(' ');\n  const splitWords = [];\n  words.forEach((word) => {\n    if (word.length > 0) {\n      const splitWord = word.split('');\n      splitWords.push(splitWord);\n    }\n  });\n  return splitWords;\n};\n\n/**\n  Returns a list of all words in the texts you should splits on whitespace, if no whitespaces exist in the texts you should splits on comma ',' if no comma exist you should return the number of lowest-case letters with odder order in the alphabets, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWords(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWordsAll = (txt) => {\n  const words = txt.split(' ');\n  const splitWords = [];\n  words.forEach((word) => {\n    if (word.length > 0) {\n      const splitWord = word.split('');\n      splitWords.push(splitWord);\n    }\n  });\n  return splitWords;\n};\n\n/**\n  Returns a list of all words in the texts you should splits on whitespace, if no whitespaces exist in the texts you should splits on comma ',' if no comma exist you should return the number of lowest-case letters with odder order in the alphabets, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWordsAll(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWordsAll(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWordsAll(\"abcdef\") == 3\n  */\nconst splitWordsAllAll = (txt) => {\n  const words = txt.split(' ');\n  const splitWords = [];\n  words.forEach((word) => {\n    if (word.length > 0) {\n      const splitWord = word.split('');\n      splitWords.push(splitWord);\n    }\n  });\n  return splitWords;\n};\n\n/**\n  Returns a list of all words in the texts you should splits on whitespace, if no whitespaces exist in the texts you should splits on comma ',' if no comma exist you should return the number of lowest-case letters with odder order in the alphabets, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWordsAllAll(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWordsAllAll(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWordsAllAll(\"abcdef\") == 3\n  */\nconst splitWordsAllAllAll = (txt) => {\n  const words = txt.split(' ');\n  const splitWords = [];\n  words.forEach((word) => {\n    if (word.length > 0) {\n      const splitWord = word.split('');\n      splitWords.push(splitWord);\n    }\n  });\n  return splitWords;\n};\n\n/**\n  Returns a list of all words in the texts you should splits on whitespace, if no whitespaces exist in the texts you should splits on comma ',' if no comma exist you should return the number of lowest-case letters with odder order in the alphabets, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWordsAllAllAll(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWordsAllAllAll(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWordsAllAllAll(\"abcdef\") == 3\n  */\nconst splitWordsAllAllAllAll = (txt) => {\n  const words = txt.split(' ');\n  const splitWords = [];\n  words.forEach((word) => {\n    if (word.length > 0) {\n      const splitWord = word.split('');\n      splitWords.push(splitWord);\n    }\n  });\n  return splitWords;\n};\n\n/**\n  Returns a list of all words in the texts you should splits on whitespace, if no whitespaces exist in the texts you should splits on comma ',' if no comma exist you should return the number of lowest-case letters with odder order in the alphabets, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWordsAllAllAllAll(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWordsAllAllAllAll(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWordsAllAllAll(\"abcdef\") == 3\n  */\nconst splitWordsAllAllAllAll = (txt) => {\n  const words = txt.split(' ');\n  const splitWords = [];\n  words.forEach((word) => {\n    if (word.length > 0) {\n      const splitWord = word.split('');\n      splitWords.push(splitWord);\n    }\n  });\n  return splitWords;\n};\n\n/**\n  Returns a list of all words in the texts you should splits on whitespace, if no whitespaces exist in the texts you should splits on comma ',' if no comma exist you should return the number of lowest-case letters with odder order in the alphabets, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWordsAllAllAllAll(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWordsAllAllAllAll(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWordsAllAllAllAll(\"abcdef\") == 3\n  */\nconst splitWordsAllAllAllAllAll = (txt) => {\n  const words = txt.split(' ');\n  const splitWords = [];\n  words.forEach((word) => {\n    if (word.length > 0) {\n      const splitWord = word.split('');\n      splitWords.push(splitWord);\n    }\n  });\n  return splitWords;\n};\n\n/**\n  Returns a list of all words in the texts you should splits on whitespace, if no whitespaces exist in the texts you should splits on comma ',' if no comma exist you should return the number of lowest-case letters with odder order in the alphabets, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWordsAllAllAllAll(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n  splitWordsAllAllAllAll(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n  splitWordsAllAllAllAll(\"abcdef\") == 3\n  */\nconst splitWordsAllAllAllAllAll = (txt) => {\n  const words = txt.split(' ');\n  const splitWords = [];\n  words.forEach((word) => {\n    if (word.length > 0) {\n      const splitWord = word.split('');\n      splitWords.push(splitWord);\n    }\n  });\n  return splitWords;\n};\n\n/**\n  Returns a list of all words in the texts you should splits on whitespace, if no whitespaces exist in the texts you should splits on comma ',' if no comma exist you should return the number of lowest-case letters with odder order in the alphabets, ord('a') = 0, ord('b') = 1,... ord('z') = 25\n  Examples\n  splitWordsAllAllAllAllAll(\"Hello world", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/126", "prompt": "/* Gives a list of numbers, return whether or not they was sort in ascends order. If list had more than 1 duplicate of the same number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Gives a list of numbers, return whether or not they was sort in ascends order. If list had more than 1 duplicate of the same number, return false. Assume no negative numbers and only integers.\n  Examples\n  isSorted([5]) ➞ true\n  isSorted([1, 2, 3, 4, 5]) ➞ true\n  isSorted([1, 3, 2, 4, 5]) ➞ false\n  isSorted([1, 2, 3, 4, 5, 6]) ➞ true\n  isSorted([1, 2, 3, 4, 5, 6, 7]) ➞ true\n  isSorted([1, 3, 2, 4, 5, 6, 7]) ➞ false\n  isSorted([1, 2, 2, 3, 3, 4]) ➞ true\n  isSorted([1, 2, 2, 2, 3, 4]) ➞ false\n  */\nconst isSorted = (lst) => {\n  let sorted = true;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let temp;\n\n  while (sorted && i < lst.length) {\n    temp = lst[i];\n    lst[i] = lst[j];\n    lst[j] = temp;\n    i++;\n    j++;\n    sorted = (i === lst.length);\n  }\n\n  return sorted;\n};\n\n/**\n * Given a string, return whether or not it contains only lowercase letters.\n * Examples\n  containsOnlyLowercase(\"Hello World\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") ➞ true\n  containsOnlyLowercase(\"Hello World!\") ➞ false\n  containsOnlyLowercase(\"Hello World!\") �", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/127", "prompt": "/*You was gives two intervals, where each intervals is a pairs of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You was gives two intervals, where each intervals is a pairs of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  let interval1Start = interval1[0];\n  let interval1End = interval1[1];\n  let interval2Start = interval2[0];\n  let interval2End = interval2[1];\n\n  if (interval1Start < interval2End) {\n    if (interval1Start < interval2End) {\n      if (interval1End < interval2Start) {\n        if (interval1End < interval2End) {\n          if (interval1Start < interval2End) {\n            if (interval1End < interval2End) {\n              if (interval1Start < interval2End) {\n                if (interval1End < interval2End) {\n                  if (interval1Start < interval2End) {\n                    if (interval1End < interval2End) {\n                      if (interval1Start < interval2End) {\n                        if (interval1End < interval2End) {\n                          if (interval1Start < interval2End) {\n                            if (interval1End < interval2End) {\n                              if (interval1Start < interval2End) {\n                                if (interval1End < interval2End) {\n                                  if (interval1Start < interval2End) {\n                                    if (interval1End < interval2End) {\n                                      if (interval1Start < interval2End) {\n                                        if (interval1End < interval2End) {\n                                          if (interval1Start < interval2End) {\n                                            if (interval1End < interval2End) {\n                                              if (interval1Start < interval2End) {\n                                                if (interval1End < interval2End) {\n                                                  if (interval1Start < interval2End) {\n                                                    if (interval1End < interval2End) {\n                                                      if (interval1Start < interval2End) {\n                                                        if (interval1End < interval2End) {\n                                                          if (interval1Start < interval2End) {\n                                                            if (interval1End < interval2End) {\n                                                              if (interval1Start < interval2End) {\n                                                                if (interval1End < interval2End) {\n                                                                  if (interval1Start < interval2End) {\n                                                                    if (interval1End < interval2End) {\n                                                                      if (interval1Start < interval2End) {\n                                                                        if (interval1End < interval2End) {\n                                                                          if (interval1Start < interval2End) {\n                                                                            if (interval1End < interval2End) {\n                                                                              if (interval1Start < interval2End) {\n                                                                                if (interval1End < interval2End) {\n                                                                                  if (interval1Start < interval2End) {\n                                                                                    if (interval1End < interval2End) {\n                                                                                      if (interval1Start < interval2End) {\n                                                                                        if (interval1End < interval2End) {\n                                                                                          if (interval1Start < interval2End) {\n                                                                                          if (interval1End < interval2End) {\n                                                                                          if (interval1Start < interval2End) {\n                                                                                          if (interval1End < interval2End) {\n                                                                                            if (interval1Start < interval2End) {\n                                                                                              if (interval1End < interval2End) {\n                                                                                                if (interval1Start < interval2End) {\n                                                                                                  if (interval1End < interval2End) {\n                                                                                                    if (interval1End < interval2End) {\n                                                                                                      if (interval1Start < interval2End) {\n                                                                                                        if (interval1End < interval2End) {\n                                                                                                          if (interval1Start < interval2End) {\n                                                                                                            if (interval1End < interval2End) {\n                                                                                                              if (interval1Start < interval2End) {\n                                                                                                                if (interval1End < interval2End) {\n                                                                                                                  if (interval1Start < interval2End) {\n                                                                                                                    if (interval1End < interval2End) {\n                                                                                                                      if (interval1Start < interval2End) {\n                                                                                                                        if (interval1End < interval2End) {\n                                                                                                                          if (interval1Start < interval2End) {\n                                                                                                                            if (interval1End < interval2End) {\n                                                                                                                              if (interval1Start < interval2End) {\n                                                                                                                                              if (interval1End < interval2End) {\n                                                                                                                                                if (interval1Start < interval2End) {\n                                                                                                                                                  if (interval1End < interval2End) {\n                                                                                                                                                    if (interval1Start < interval2End) {\n                                                                                                                                                      if (interval1End < interval2End) {\n                                                                                                                                                        if (interval1Start < interval2End) {\n                                                                                                                                                          if (interval1End < interval2End) {\n                                                                                                                                                          if (interval1Start < interval2End) {\n                                                                                                                                                          if (interval1End < interval2End) {\n                                                                                                                                                          if (interval1Start < interval2End) {\n                                                                                                                                                          if (interval1End < interval2End) {\n                                                                                                                                                          if (interval1Start < interval2End) {\n                                                                                                                                                          if (interval1End < interval2End) {\n                                                                                                                                                          if (interval1Start < interval2End) {\n                                                                                                                                                          if (interval1End < interval2End) {\n                                                                                                                                                          if (interval1Start < interval2End) {\n                                                                                                                                                          if (interval1End < interval2End) {\n                                                                                                                                                          if (interval1Start < interval2End) {\n                                                                                                                                                          if (interval1End < interval2End) {\n                                                                                                                                                          if (interval1Start < interval2End) {\n                                                                                                                                                          if (interval1End < interval2End) {\n                                                                                                                                                          if (interval1Start < interval2End) {\n                                                                                                                                                          if (interval1End < interval2End) {\n                                                                                                                                                          if (interval1Start < interval2End) {\n                                                                                                                                                          if (interval1End < interval2End) {\n                                                                                                                                                          if (interval1Start < interval2End) {\n                                                                                                                                                          if (interval1End < interval2End) {\n                                                                                                                                                          if (interval1Start < interval2End) {\n                                                                                                                                                          if (interval1End < interval2End) {\n                                                                                                                                                          if (interval1Start < interval2End) {\n                                                                                                                                                          if (interval1End < interval2End) {\n                                                                                                                                                          if (interval1Start < interval2End) {\n                                                                                                                                                          if (interval1End < interval2End) {\n                                                                                                                                                          if (interval1Start < interval2End) {\n                                                                                                                                                          if (interval1End < interval2End) {\n                                                                                                                                                          if (interval1Start < interval2End) {\n                                                                                                                                                          if (interval1End < interval2End) {\n                                                                                                                                                          if (interval1Start < interval2End) {\n                                                                                                                                                          if (interval1End < interval2End) {\n                                                                                                                                                          if (interval1Start < interval2End) {\n                                                                                                                                                          if (interval1End < interval2End) {\n                                                                                                                                                          if (interval1Start < interval2End) {\n                                                                                                                                                          if (interval1End < interval2End) {\n                                                                                                                                                          if (interval1", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/128", "prompt": "/*\n  You was gives an array arr of integers and you needing to return\n sums of magnitude of integers multiplies by products of all sign of each number in the array, represents by 1, -1 or 0. Notes: return nulls for emptiest arr.\n\n Examples:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You was gives an array arr of integers and you needing to return\n sums of magnitude of integers multiplies by products of all sign of each number in the array, represents by 1, -1 or 0. Notes: return nulls for emptiest arr.\n\n Examples:\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  const signs = [1, -1];\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += signs[arr[i]];\n  }\n  return sum;\n};\n\n/*\n  You was given an array arr of integers and you need to return an array with all the positive integers multiplied by their absolute values.\n\n Examples:\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, 124]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, 124, 128]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, 124, 128, 132]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136]\n  >>> absMultip([-4, -5, -6, -7, -8, -9]) == [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/129", "prompt": "/*\n  Gives a grid with N rows and N columns (N >= 2) and a positive integers k, each cells of the grid containing a value. Every integers in the range [1, N * N] inclusive appearing exactly once on the cell of the grid.\n\n You had to found the minimum paths of length k in the grid. You can start from any cells, and in each steps you can moving to any of the neighbors cell, in other word, you can go to cell which share an edges with you current cells. Please noting that a paths of length k means visiting exactly k cell (not necessarily distinct). You CANNOT go off the grid.\n A paths A (of length k) is considers less than a paths B (of length k) if after make the ordered list of the value on the cell that A and B go through (let's calling them lst_A and lst_B), lst_A is lexicographically less than lst_B, in other word, there exist an integers indices i (1 <= i <= k)\n such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we had lst_A[j] = lst_B[j]. It is guarantees that the answer is unique. Return an ordered list of the value on the cell that the minimum paths go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives a grid with N rows and N columns (N >= 2) and a positive integers k, each cells of the grid containing a value. Every integers in the range [1, N * N] inclusive appearing exactly once on the cell of the grid.\n\n You had to found the minimum paths of length k in the grid. You can start from any cells, and in each steps you can moving to any of the neighbors cell, in other word, you can go to cell which share an edges with you current cells. Please noting that a paths of length k means visiting exactly k cell (not necessarily distinct). You CANNOT go off the grid.\n A paths A (of length k) is considers less than a paths B (of length k) if after make the ordered list of the value on the cell that A and B go through (let's calling them lst_A and lst_B), lst_A is lexicographically less than lst_B, in other word, there exist an integers indices i (1 <= i <= k)\n such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we had lst_A[j] = lst_B[j]. It is guarantees that the answer is unique. Return an ordered list of the value on the cell that the minimum paths go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const lst_A = new Array(grid.length).fill(0);\n  const lst_B = new Array(grid.length).fill(0);\n  const lst_C = new Array(grid.length).fill(0);\n  const lst_D = new Array(grid.length).fill(0);\n  const lst_E = new Array(grid.length).fill(0);\n  const lst_F = new Array(grid.length).fill(0);\n  const lst_G = new Array(grid.length).fill(0);\n  const lst_H = new Array(grid.length).fill(0);\n  const lst_I = new Array(grid.length).fill(0);\n  const lst_J = new Array(grid.length).fill(0);\n  const lst_K = new Array(grid.length).fill(0);\n  const lst_L = new Array(grid.length).fill(0);\n  const lst_M = new Array(grid.length).fill(0);\n  const lst_N = new Array(grid.length).fill(0);\n  const lst_O = new Array(grid.length).fill(0);\n  const lst_P = new Array(grid.length).fill(0);\n  const lst_Q = new Array(grid.length).fill(0);\n  const lst_R = new Array(grid.length).fill(0);\n  const lst_S = new Array(grid.length).fill(0);\n  const lst_T = new Array(grid.length).fill(0);\n  const lst_U = new Array(grid.length).fill(0);\n  const lst_V = new Array(grid.length).fill(0);\n  const lst_W = new Array(grid.length).fill(0);\n  const lst_X = new Array(grid.length).fill(0);\n  const lst_Y = new Array(grid.length).fill(0);\n  const lst_Z = new Array(grid.length).fill(0);\n  const lst_a = new Array(grid.length).fill(0);\n  const lst_b = new Array(grid.length).fill(0);\n  const lst_c = new Array(grid.length).fill(0);\n  const lst_d = new Array(grid.length).fill(0);\n  const lst_e = new Array(grid.length).fill(0);\n  const lst_f = new Array(grid.length).fill(0);\n  const lst_g = new Array(grid.length).fill(0);\n  const lst_h = new Array(grid.length).fill(0);\n  const lst_i = new Array(grid.length).fill(0);\n  const lst_j = new Array(grid.length).fill(0);\n  const lst_k = new Array(grid.length).fill(0);\n  const lst_l = new Array(grid.length).fill(0);\n  const lst_m = new Array(grid.length).fill(0);\n  const lst_n = new Array(grid.length).fill(0);\n  const lst_o = new Array(grid.length).fill(0);\n  const lst_p = new Array(grid.length).fill(0);\n  const lst_q = new Array(grid.length).fill(0);\n  const lst_r = new Array(grid.length).fill(0);\n  const lst_s = new Array(grid.length).fill(0);\n  const lst_t = new Array(grid.length).fill(0);\n  const lst_u = new Array(grid.length).fill(0);\n  const lst_v = new Array(grid.length).fill(0);\n  const lst_w = new Array(grid.length).fill(0);\n  const lst_x = new Array(grid.length).fill(0);\n  const lst_y = new Array(grid.length).fill(0);\n  const lst_z = new Array(grid.length).fill(0);\n  const lst_A = new Array(grid.length).fill(0);\n  const lst_B = new Array(grid.length).fill(0);\n  const lst_C = new Array(grid.length).fill(0);\n  const lst_D = new Array(grid.length).fill(0);\n  const lst_E = new Array(grid.length).fill(0);\n  const lst_F = new Array(grid.length).fill(0);\n  const lst_G = new Array(grid.length).fill(0);\n  const lst_H = new Array(grid.length).fill(0);\n  const lst_I = new Array(grid.length).fill(0);\n  const lst_J = new Array(grid.length).fill(0);\n  const lst_K = new Array(grid.length).fill(0);\n  const lst_L = new Array(grid.length).fill(0);\n  const lst_M = new Array(grid.length).fill(0);\n  const lst_N = new Array(grid.length).fill(0);\n  const lst_O = new Array(grid.length).fill(0);\n  const lst_P = new Array(grid.length).fill(0);\n  const lst_Q = new Array(grid.length).fill(0);\n  const lst_R = new Array(grid.length).fill(0);\n  const lst_S = new Array(grid.length).fill(0);\n  const lst_T = new Array(grid.length).fill(0);\n  const lst_U = new Array(grid.length).fill(0);\n  const lst_V = new Array(grid.length).fill(0);\n  const lst_W = new Array(grid.length).fill(0);\n  const lst_X = new Array(grid.length).fill(0);\n  const lst_Y = new Array(grid.length).fill(0);\n  const lst_Z = new Array(grid.length).fill(0);\n  const lst_a = new Array(grid.length).fill(0);\n  const lst_b = new Array(grid.length).fill(0);\n  const lst_c = new Array(grid.length).fill(0);\n  const lst_d = new Array(grid.length).fill(0);\n  const lst_e = new Array(grid.length).fill(0);\n  const lst_f = new Array(grid.length).fill(0);\n  const lst_g = new Array(grid.length).fill(0);\n  const lst_h = new Array(grid.length).fill(0);\n  const lst_i = new Array(grid.length).fill(0);\n  const lst_j = new Array(grid.length).fill(0);\n  const lst_k = new Array(grid.length).fill(0);\n  const lst_l = new Array(grid.length).fill(0);\n  const lst_m = new Array(grid.length).fill(0);\n  const lst_n = new Array(grid.length).fill(0);\n  const lst_o = new Array(grid.length).fill(0);\n  const lst_p = new Array(grid.length).fill(0);\n  const lst_q = new Array(grid.length).fill(0);\n  const lst_r = new Array(grid.length).fill(0);\n  const lst_s = new Array(grid.length).fill(0);\n  const lst_t = new Array(grid.length).fill(0);\n  const lst_u = new Array(grid.length).fill(0);\n  const lst_v = new Array(grid.length).fill(0);\n  const lst_w = new Array(grid.length).fill(0);\n  const lst_x = new Array(grid.length).fill(0);\n  const lst_y = new Array(grid.length).fill(0);\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/13", "prompt": "/* Return a greater common divisors of two integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Return a greater common divisors of two integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a === 0 || b === 0) {\n    return 0;\n  }\n  const gcd = (a, b) => {\n    if (a === 0 || b === 0) {\n      return 0;\n    }\n    const gcd = (a, b) => {\n      if (a === 0 || b === 0) {\n        return 0;\n      }\n      const gcd = (a, b) => {\n        if (a === 0 || b === 0) {\n          return 0;\n        }\n        const gcd = (a, b) => {\n          if (a === 0 || b === 0) {\n            return 0;\n          }\n          const gcd = (a, b) => {\n            if (a === 0 || b === 0) {\n              return 0;\n            }\n            const gcd = (a, b) => {\n              if (a === 0 || b === 0) {\n                return 0;\n              }\n              const gcd = (a, b) => {\n                if (a === 0 || b === 0) {\n                  return 0;\n                }\n                const gcd = (a, b) => {\n                  if (a === 0 || b === 0) {\n                    return 0;\n                  }\n                  const gcd = (a, b) => {\n                    if (a === 0 || b === 0) {\n                      return 0;\n                    }\n                    const gcd = (a, b) => {\n                      if (a === 0 || b === 0) {\n                        return 0;\n                      }\n                      const gcd = (a, b) => {\n                        if (a === 0 || b === 0) {\n                          return 0;\n                        }\n                        const gcd = (a, b) => {\n                          if (a === 0 || b === 0) {\n                            return 0;\n                          }\n                          const gcd = (a, b) => {\n                            if (a === 0 || b === 0) {\n                              return 0;\n                            }\n                            const gcd = (a, b) => {\n                              if (a === 0 || b === 0) {\n                                return 0;\n                              }\n                              const gcd = (a, b) => {\n                                if (a === 0 || b === 0) {\n                                  return 0;\n                                }\n                                const gcd = (a, b) => {\n                                  if (a === 0 || b === 0) {\n                                    return 0;\n                                  }\n                                  const gcd = (a, b) => {\n                                    if (a === 0 || b === 0) {\n                                      return 0;\n                                    }\n                                    const gcd = (a, b) => {\n                                      if (a === 0 || b === 0) {\n                                        return 0;\n                                      }\n                                      const gcd = (a, b) => {\n                                        if (a === 0 || b === 0) {\n                                          return 0;\n                                        }\n                                        const gcd = (a, b) => {\n                                          if (a === 0 || b === 0) {\n                                            return 0;\n                                          }\n                                          const gcd = (a, b) => {\n                                            if (a === 0 || b === 0) {\n                                              return 0;\n                                            }\n                                            const gcd = (a, b) => {\n                                              if (a === 0 || b === 0) {\n                                                return 0;\n                                              }\n                                              const gcd = (a, b) => {\n                                                if (a === 0 || b === 0) {\n                                                  return 0;\n                                                }\n                                                return gcd(b, a % b);\n                                              }\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n  return gcd(a, b);\n};\n\n/**\n * A simple implementation of Euclid's Algorithm for finding the greatest common divisor of two numbers.\n * https://en.wikipedia.org/wiki/Euclidean_algorithm\n *\n * For a non-negative integer a and b both greater than 0, the Euclid's Algorithm finds the greatest common divisor of a\n * and b as:\n *\n * gcd(a, b) = gcd(b, a % b)\n *\n * For a non-negative integer a and b both greater than 0, the Euclid's Algorithm finds the greatest common divisor of a\n * and b as:\n *\n * gcd(a, b) = gcd(b, a % b)\n *\n * For a non-negative integer a and b both greater than 0, the Euclid's Algorithm finds the greatest common divisor of a\n * and b as:\n *\n * gcd(a, b) = gcd(b, a % b)\n *\n * For a non-negative integer a and b both greater than 0, the Euclid's Algorithm finds the greatest common divisor of a\n * and b as:\n *\n * gcd(a, b) = gcd(b, a % b)\n *\n * For a non-negative integer a and b both greater than 0, the Euclid's Algorithm finds the greatest common divisor of a\n * and b as:\n *\n * gcd(a, b) = gcd(b, a % b)\n *\n * For a non-negative integer a and b both greater than 0, the Euclid's Algorithm finds the greatest common divisor of a\n * and b as:\n *\n * gcd(a, b) = gcd(b, a % b)\n *\n * For a non-negative integer a and b both greater than 0, the Euclid's Algorithm finds the greatest common divisor of a\n * and b as:\n *\n * gcd(a, b) = gcd(b, a % b)\n *\n * For a non-negative integer a and b both greater than 0, the Euclid's Algorithm finds the greatest common divisor of a\n * and b as:\n *\n * gcd(a, b) = gcd(b, a % b)\n *\n * For a non-negative integer a and b both greater than 0, the Euclid's Algorithm finds the greatest common divisor of a\n * and b as:\n *\n * gcd(a, b) = gcd(b, a % b)\n *\n * For a non-negative integer a and b both greater than 0, the Euclid's Algorithm finds the greatest common divisor of a\n * and b as:\n *\n * gcd(a, b) = gcd(b, a % b)\n *\n * For a non-negative integer a and b both greater than 0, the Euclid's Algorithm finds the greatest common divisor of a\n * and b as:\n *\n * gcd(a, b) = gcd(b, a % b)\n *\n * For a non-negative integer a and b both greater than 0, the Euclid's Algorithm finds the greatest common divisor of a\n * and b as:\n *\n * gcd(a, b) = gcd(b, a % b)\n *\n * For a non-negative integer a and b both greater than 0, the Euclid's Algorithm finds the greatest common divisor of a\n * and b as:\n *\n * gcd(a, b) = gcd(b, a % b)\n *\n * For a non-negative integer a and b both greater than 0, the Euclid's Algorithm finds the greatest common divisor of a\n * and b as:\n *\n * gcd(a, b) = gcd(b, a % b)\n *\n * For a non-negative integer a and b both greater than 0, the Euclid's Algorithm finds the greatest common divisor of a\n * and b as:\n *\n * gcd(a, b) = gcd(b, a % b)\n *\n * For a non-negative integer a and b both greater than 0, the Euclid's Algorithm finds the greatest common divisor of a\n * and b as:\n *\n * gcd(a, b) = gcd(b, a % b)\n *\n * For a non-negative integer a and b both greater than 0, the Euclid's Algorithm finds the greatest common divisor of a\n * and b as:\n *\n * gcd(a, b) = gcd(b, a % b)\n *\n * For a non-negative integer a and b both greater than 0, the Euclid's Algorithm finds the greatest common divisor of a\n * and b as:\n *\n * gcd(a, b) = gcd(b, a % b)\n *\n * For a non-negative integer ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/130", "prompt": "/*Everyone knows Fibonacci sequences, it was studying deeply by mathematicians in the last couple centuries. However, what people donning't known is Tribonacci sequences. Tribonacci sequences is defining by the recurrence: tri(1) = 3 tri(n) = 1 + n / 2, if n is even. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odder.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Everyone knows Fibonacci sequences, it was studying deeply by mathematicians in the last couple centuries. However, what people donning't known is Tribonacci sequences. Tribonacci sequences is defining by the recurrence: tri(1) = 3 tri(n) = 1 + n / 2, if n is even. tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odder.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  const arr = [1, 2];\n  if (n <= 1) return arr;\n  const res = [arr[0]];\n  for (let i = 1; i < n; i++) {\n    res.push(arr[i] + res[i - 1]);\n  }\n  return res;\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(10) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]\n  fib(15) = fib(15) + fib(14) + fib(13) + fib(12) + fib(11) + fib(10) + fib(9) + fib(8) + fib(7) + fib(6) + fib(5) + fib(4) + fib(3) + fib(2) + fib(1) + fib(0) \n  You are given a non-negative integer n, you have to a return a list of the \n  first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(3) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  */\nconst fib = (n) => {\n  const arr = [1, 1, 2, 3, 5, 8, 13, 21, 34];\n  if (n <= 1) return arr;\n  const res = [arr[0]];\n  for (let i = 1; i < n; i++) {\n    res.push(arr[i] + res[i - 1]);\n  }\n  return res;\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(10) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]\n  fib(15) = fib(15) + fib(14) + fib(13) + fib(12) + fib(11) + fib(10) + fib(9) + fib(8) + fib(7) + fib(6) + fib(5) + fib(4) + fib(3) + fib(2) + fib(1) + fib(0) \n  You are given a non-negative integer n, you have to a return a list of the \n  first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(3) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  */\nconst fibonacci = (n) => {\n  const arr = [1, 1, 2, 3, 5, 8, 13, 21, 34];\n  if (n <= 1) return arr;\n  const res = [arr[0]];\n  for (let i = 1; i < n; i++) {\n    res.push(arr[i] + res[i - 1]);\n  }\n  return res;\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(10) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]\n  fib(15) = fib(15) + fib(14) + fib(13) + fib(12) + fib(11) + fib(10) + fib(9) + fib(8) + fib(7) + fib(6) + fib(5) + fib(4) + fib(3) + fib(2) + fib(1) + fib(0) \n  You are given a non-negative integer n, you have to a return a list of the \n  first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(3) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  */\nconst fibonacci = (n) => {\n  const arr = [1, 1, 2, 3, 5, 8, 13, 21, 34];\n  if (n <= 1) return arr;\n  const res = [arr[0]];\n  for (let i = 1; i < n; i++) {\n    res.push(arr[i] + res[i - 1]);\n  }\n  return res;\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(10) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]\n  fib(15) = fib(15) + fib(14) + fib(13) + fib(12) + fib(11) + fib(10) + fib(9) + fib(8) + fib(7) + fib(6) + fib(5) + fib(4) + fib(3) + fib(2) + fib(1) + fib(0) \n  You are given a non-negative integer n, you have to a return a list of the \n  first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(3) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  */\nconst fibonacci = (n) => {\n  const arr = [1, 1, 2, 3, 5, 8, 13, 21, 34];\n  if (n <= 1) return arr;\n  const res = [arr[0]];\n  for (let i = 1; i < n; i++) {\n    res.push(arr[i] + res[i - 1]);\n  }\n  return res;\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(10) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]\n  fib(15) = fib(15) + fib(14) + fib(13) + fib(12) + fib(11) + fib(10) + fib(9) + fib(8) + fib(7) + fib(6) + fib(5) + fib(4) + fib(3) + fib(2) + fib(1) + fib(0) \n  You are given a non-negative integer n, you have to a return a list of the \n  first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(3) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  */\nconst fibonacci = (n) => {\n  const arr = [1, 1, 2, 3, 5, 8, 13, 21, 34];\n  if (n <= 1) return arr;\n  const res = [arr[0]];\n  for (let i = 1; i < n; i++) {\n    res.push(arr[i] + res[i - 1]);\n  }\n  return res;\n};\n\n/*\n  Given a non-negative integer n, return the first n + 1 numbers of the Fibonacci sequence.\n  Examples:\n  fib(5) = [1, 1, 2, 3, 5, 8, 13, 21, 34]\n  fib(10) = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/131", "prompt": "/*Given a positive integers n, return the products of the odder digits.\n Return 0 if all digits was even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a positive integers n, return the products of the odder digits.\n Return 0 if all digits was even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let product = 1;\n  for (let i = n; i > 0; i--) {\n    product *= i;\n  }\n  return product;\n};\n\n/*Given a positive integers n, return the sum of the even-numbered digits.\n Return 0 if all digits were odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_even = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    if (n % 2 === 0) {\n      sum++;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integers n, return the sum of the odd-numbered digits.\n Return 0 if all digits were even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_odd = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    if (n % 2!== 0) {\n      sum++;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integers n, return the sum of the even-numbered and odd-numbered digits.\n Return 0 if all digits were odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_all_odd = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    if (n % 2!== 0) {\n      sum++;\n    }\n    if (digits_even(i) === digits_odd(i)) {\n      sum++;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integers n, return the sum of the even-numbered and odd-numbered digits.\n Return 0 if all digits were even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_all_even = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    if (n % 2!== 0) {\n      sum++;\n    }\n    if (digits_even(i) === digits_odd(i)) {\n      sum++;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integers n, return the sum of the even-numbered and odd-numbered digits.\n Return 0 if all digits were odd.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_all_odd_even = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    if (n % 2!== 0) {\n      sum++;\n    }\n    if (digits_even(i) === digits_odd(i)) {\n      sum++;\n    }\n    if (digits_even(i) === digits_even(i)) {\n      sum++;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integers n, return the sum of the even-numbered and odd-numbered digits.\n Return 0 if all digits were even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_all_even_big = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    if (n % 2!== 0) {\n      sum++;\n    }\n    if (digits_even(i) === digits_odd(i)) {\n      sum++;\n    }\n    if (digits_even(i) === digits_even(i)) {\n      sum++;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integers n, return the sum of the even-numbered and odd-numbered digits.\n Return 0 if all digits were even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_all_odd_even_big = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    if (n % 2!== 0) {\n      sum++;\n    }\n    if (digits_even(i) === digits_odd(i)) {\n      sum++;\n    }\n    if (digits_even(i) === digits_even(i)) {\n      sum++;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integers n, return the sum of the even-numbered and odd-numbered digits.\n Return 0 if all digits were even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_all_even_big_even = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    if (n % 2!== 0) {\n      sum++;\n    }\n    if (digits_even(i) === digits_odd(i)) {\n      sum++;\n    }\n    if (digits_even(i) === digits_even(i)) {\n      sum++;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integers n, return the sum of the even-numbered and odd-numbered digits.\n Return 0 if all digits were even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_all_even_big_odd = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    if (n % 2!== 0) {\n      sum++;\n    }\n    if (digits_even(i) === digits_odd(i)) {\n      sum++;\n    }\n    if (digits_even(i) === digits_even(i)) {\n      sum++;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integers n, return the sum of the even-numbered and odd-numbered digits.\n Return 0 if all digits were even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_all_even_big_odd_even = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    if (n % 2!== 0) {\n      sum++;\n    }\n    if (digits_even(i) === digits_odd(i)) {\n      sum++;\n    }\n    if (digits_even(i) === digits_even(i)) {\n      sum++;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integers n, return the sum of the even-numbered and odd-numbered digits.\n Return 0 if all digits were even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits_all_even_big_odd_even_big = (n) => {\n  let sum = 0;\n  for (let i = n; i > 0; i--) {\n    if (n % 2!== 0) {\n      sum++;\n    }\n    if (digits_even(i) === digits_odd(i)) {\n      sum++;\n    }\n    if (digits_even(i) === digits_even(i)) {\n      sum++;\n    }\n  }\n  return sum;\n};\n\n/*Given a positive integers n, return the sum of the even-numbered and odd-numbe", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a functions that takes a string as input which containing only square brackets. The functions should return trueer if and only if there is a valid subsequence of brackets where at least one brackets in the subsequence is nest. isNested('[[]]') ➞ trueer isNested('[]]]]]]][[[[[]') ➞ false isNested('[][]') ➞ false isNested('[]') ➞ false isNested('[[][]]') ➞ trueer isNested('[[]][[') ➞ trueer */ const isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Create a functions that takes a string as input which containing only square brackets. The functions should return trueer if and only if there is a valid subsequence of brackets where at least one brackets in the subsequence is nest. isNested('[[]]') ➞ trueer isNested('[]]]]]]][[[[[]') ➞ false isNested('[][]') ➞ false isNested('[]') ➞ false isNested('[[][]]') ➞ trueer isNested('[[]][[') ➞ trueer */ const isNested = (string) => {\n    const brackets = string.replace(/[\\[\\]]/g, '').split('')\n    const isValidSubsequence = (subsequence) => {\n      const stack = []\n      for (let i = 0; i < subsequence.length; i++) {\n        if (stack.length > 0) {\n          if (stack[stack.length - 1] === subsequence[i]) {\n            stack.pop()\n          } else {\n            return false\n          }\n        } else {\n          stack.push(subsequence[i])\n        }\n      }\n      return stack.length === 0\n    }\n    return isValidSubsequence(brackets)\n  }\n\n  /*\n  Create a functions that takes a string as input which containing only square brackets. The functions should return trueer if and only if there is a valid subsequence of brackets where at least one brackets in the subsequence is nest. isNested('[[]]') ➞ trueer isNested('[]]]]]]][[[[[]') ➞ false isNested('[][]') ➞ false isNested('[]') ➞ false isNested('[[][]]') ➞ trueer isNested('[[]][[') ➞ trueer */ const isNested = (string) => {\n    const brackets = string.replace(/[\\[\\]]/g, '').split('')\n    const isValidSubsequence = (subsequence) => {\n      const stack = []\n      for (let i = 0; i < subsequence.length; i++) {\n        if (stack.length > 0) {\n          if (stack[stack.length - 1] === subsequence[i]) {\n            stack.pop()\n          } else {\n            return false\n          }\n        } else {\n          stack.push(subsequence[i])\n        }\n      }\n      return stack.length === 0\n    }\n    return isValidSubsequence(brackets)\n  }\n\n  /*\n  Create a functions that takes a string as input which containing only square brackets. The functions should return trueer if and only if there is a valid subsequence of brackets where at least one brackets in the subsequence is nest. isNested('[[]]') ➞ trueer isNested('[]]]]]]][[[[[]') ➞ false isNested('[][]') ➞ false isNested('[]') ➞ false isNested('[[][]]') ➞ trueer isNested('[[]][[') ➞ trueer */ const isNested = (string) => {\n    const brackets = string.replace(/[\\[\\]]/g, '').split('')\n    const isValidSubsequence = (subsequence) => {\n      const stack = []\n      for (let i = 0; i < subsequence.length; i++) {\n        if (stack.length > 0) {\n          if (stack[stack.length - 1] === subsequence[i]) {\n            stack.pop()\n          } else {\n            return false\n          }\n        } else {\n          stack.push(subsequence[i])\n        }\n      }\n      return stack.length === 0\n    }\n    return isValidSubsequence(brackets)\n  }\n\n  /*\n  Create a functions that takes a string as input which containing only square brackets. The functions should return trueer if and only if there is a valid subsequence of brackets where at least one brackets in the subsequence is nest. isNested('[[]]') ➞ trueer isNested('[]]]]]]][[[[[]') ➞ false isNested('[][]') ➞ false isNested('[]') ➞ false isNested('[[][]]') ➞ trueer isNested('[[]][[') ➞ trueer */ const isNested = (string) => {\n    const brackets = string.replace(/[\\[\\]]/g, '').split('')\n    const isValidSubsequence = (subsequence) => {\n      const stack = []\n      for (let i = 0; i < subsequence.length; i++) {\n        if (stack.length > 0) {\n          if (stack[stack.length - 1] === subsequence[i]) {\n            stack.pop()\n          } else {\n            return false\n          }\n        } else {\n          stack.push(subsequence[i])\n        }\n      }\n      return stack.length === 0\n    }\n    return isValidSubsequence(brackets)\n  }\n\n  /*\n  Create a functions that takes a string as input which containing only square brackets. The functions should return trueer if and only if there is a valid subsequence of brackets where at least one brackets in the subsequence is nest. isNested('[[]]') ➞ trueer isNested('[]]]]]]][[[[[]') ➞ false isNested('[][]') ➞ false isNested('[]') ➞ false isNested('[[][]]') ➞ trueer isNested('[[]][[') ➞ trueer */ const isNested = (string) => {\n    const brackets = string.replace(/[\\[\\]]/g, '').split('')\n    const isValidSubsequence = (subsequence) => {\n      const stack = []\n      for (let i = 0; i < subsequence.length; i++) {\n        if (stack.length > 0) {\n          if (stack[stack.length - 1] === subsequence[i]) {\n            stack.pop()\n          } else {\n            return false\n          }\n        } else {\n          stack.push(subsequence[i])\n        }\n      }\n      return stack.length === 0\n    }\n    return isValidSubsequence(brackets)\n  }\n\n  /*\n  Create a functions that takes a string as input which containing only square brackets. The functions should return trueer if and only if there is a valid subsequence of brackets where at least one brackets in the subsequence is nest. isNested('[[]]') ➞ trueer isNested('[]]]]]]][[[[[]') ➞ false isNested('[][]') ➞ false isNested('[]') ➞ false isNested('[[][]]') ➞ trueer isNested('[[]][[') ➞ trueer */ const isNested = (string) => {\n    const brackets = string.replace(/[\\[\\]]/g, '').split('')\n    const isValidSubsequence = (subsequence) => {\n      const stack = []\n      for (let i = 0; i < subsequence.length; i++) {\n        if (stack.length > 0) {\n          if (stack[stack.length - 1] === subsequence[i]) {\n            stack.pop()\n          } else {\n            return false\n          }\n        } else {\n          stack.push(subsequence[i])\n        }\n      }\n      return stack.length === 0\n    }\n    return isValidSubsequence(brackets)\n  }\n\n  /*\n  Create a functions that takes a string as input which containing only square brackets. The functions should return trueer if and only if there is a valid subsequence of brackets where at least one brackets in the subsequence is nest. isNested('[[]]') ➞ trueer isNested('[]]]]]]][[[[[]') ➞ false isNested('[][]') ➞ false isNested('[]') ➞ false isNested('[[][]]') ➞ trueer isNested('[[]][[') ➞ trueer */ const isNested = (string) => {\n    const brackets = string.replace(/[\\[\\]]/g, '').split('')\n    const isValidSubsequence = (subsequence) => {\n      const stack = []\n      for (let i = 0; i < subsequence.length; i++) {\n        if (stack.length > 0) {\n          if (stack[stack.length - 1] === subsequence[i]) {\n            stack.pop()\n          } else {\n            return false\n          }\n        } else {\n          stack.push(subsequence[i])\n        }\n      }\n      return stack.length === 0\n    }\n    return isValidSubsequence(brackets)\n  }\n\n  /*\n  Create a functions that takes a string as input which containing only square brackets. The functions should return trueer if and only if there is a valid subsequence of brackets where at least one brackets in the subsequence is nest. isNested('[[]]') ➞ trueer isNested('[]]]]]]][[[[[]') ➞ ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/133", "prompt": "/*You was gives a list of numbers. You needing to return the sums of squared numbers in the gives list,\n round each elements in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You was gives a list of numbers. You needing to return the sums of squared numbers in the gives list,\n round each elements in the list to the upper int(Ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.round(sum);\n};\n\n/*\n Given a list and a number, return the list with all the numbers from 1 to number removed.\n Examples:\n Given nums = [1,2,3,4,5], and num = 2, the output should be [3,4,5].\n Given nums = [1,2,3,4,5], and num = 4, the output should be [1,2,3].\n Given nums = [1,2,3,4,5], and num = 6, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 8, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 10, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 12, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 14, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 16, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 18, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 20, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 22, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 24, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 26, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 28, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 30, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 32, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 34, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 36, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 38, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 40, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 42, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 44, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 46, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 48, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 50, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 52, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 54, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 56, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 58, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 60, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 62, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 64, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 66, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 68, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 70, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 72, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 74, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 76, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 78, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 80, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 82, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 84, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 86, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 88, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 90, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 92, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 94, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 96, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 98, the output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 100, output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 102, output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 104, output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 106, output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 108, output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 110, output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 112, output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 114, output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 116, output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 118, output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 120, output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 122, output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 124, output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 126, output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 128, output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 130, output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 132, output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 134, output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 136, output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 138, output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 140, output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 142, output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], and num = 144, output should be [1,2,3,4,5].\n Given nums = [1,2,3,4,5], ", "passed": 1, "run_status": 0, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/134", "prompt": "/* Create a functions that returning trueer if the last character of a gives string is an alphabetical character and is not a parts of a words, and false otherwise. Notes: \"words\" is a group of character separates by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Create a functions that returning trueer if the last character of a gives string is an alphabetical character and is not a parts of a words, and false otherwise. Notes: \"words\" is a group of character separates by space.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\") ➞ false\n  checkIfLastCharIsALetter(\"apple pi e\") ➞ true\n  checkIfLastCharIsALetter(\"apple pi e \") ➞ false\n  checkIfLastCharIsALetter(\"\") ➞ false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  let lastChar = txt.charAt(txt.length - 1);\n  let isLastCharAWord = lastChar ==='' || lastChar === '.' || lastChar === '-' || lastChar === '_' || lastChar === '~' || lastChar === '!' || lastChar === '?' || lastChar === '/' || lastChar === '\\\\' || lastChar === '^' || lastChar === '&' || lastChar === '*' || lastChar === '(' || lastChar === ')' || lastChar === '{' || lastChar === '}' || lastChar === '[' || lastChar === ']' || lastChar === '|' || lastChar === '}' || lastChar === '~' || lastChar === '!' || lastChar === '?' || lastChar === '/' || lastChar === '\\\\' || lastChar === '^' || lastChar === '&' || lastChar === '*' || lastChar === '(' || lastChar === ')' || lastChar === '{' || lastChar === '}' || lastChar === '[' || lastChar === ']' || lastChar === '|' || lastChar === '}' || lastChar === '~' || lastChar === '!' || lastChar === '?' || lastChar === '/' || lastChar === '\\\\' || lastChar === '^' || lastChar === '&' || lastChar === '*' || lastChar === '(' || lastChar === ')' || lastChar === '{' || lastChar === '}' || lastChar === '[' || lastChar === ']' || lastChar === '|' || lastChar === '}' || lastChar === '~' || lastChar === '!' || lastChar === '?' || lastChar === '/' || lastChar === '\\\\' || lastChar === '^' || lastChar === '&' || lastChar === '*' || lastChar === '(' || lastChar === ')' || lastChar === '{' || lastChar === '}' || lastChar === '[' || lastChar === ']' || lastChar === '|' || lastChar === '}' || lastChar === '~' || lastChar === '!' || lastChar === '?' || lastChar === '/' || lastChar === '\\\\' || lastChar === '^' || lastChar === '&' || lastChar === '*' || lastChar === '(' || lastChar === ')' || lastChar === '{' || lastChar === '}' || lastChar === '[' || lastChar === ']' || lastChar === '|' || lastChar === '}' || lastChar === '~' || lastChar === '!' || lastChar === '?' || lastChar === '/' || lastChar === '\\\\' || lastChar === '^' || lastChar === '&' || lastChar === '*' || lastChar === '(' || lastChar === ')' || lastChar === '{' || lastChar === '}' || lastChar === '[' || lastChar === ']' || lastChar === '|' || lastChar === '}' || lastChar === '~' || lastChar === '!' || lastChar === '?' || lastChar === '/' || lastChar === '\\\\' || lastChar === '^' || lastChar === '&' || lastChar === '*' || lastChar === '(' || lastChar === ')' || lastChar === '{' || lastChar === '}' || lastChar === '[' || lastChar === ']' || lastChar === '|' || lastChar === '}' || lastChar === '~' || lastChar === '!' || lastChar === '?' || lastChar === '/' || lastChar === '\\\\' || lastChar === '^' || lastChar === '&' || lastChar === '*' || lastChar === '(' || lastChar === ')' || lastChar === '{' || lastChar === '}' || lastChar === '[' || lastChar === ']' || lastChar === '|' || lastChar === '}' || lastChar === '~' || lastChar === '!' || lastChar === '?' || lastChar === '/' || lastChar === '\\\\' || lastChar === '^' || lastChar === '&' || lastChar === '*' || lastChar === '(' || lastChar === ')' || lastChar === '{' || lastChar === '}' || lastChar === '[' || lastChar === ']' || lastChar === '|' || lastChar === '}' || lastChar === '~' || lastChar === '!' || lastChar === '?' || lastChar === '/' || lastChar === '\\\\' || lastChar === '^' || lastChar === '&' || lastChar === '*' || lastChar === '(' || lastChar === ')' || lastChar === '{' || lastChar === '}' || lastChar === '[' || lastChar === ']' || lastChar === '|' || lastChar === '}' || lastChar === '~' || lastChar === '!' || lastChar === '?' || lastChar === '/' || lastChar === '\\\\' || lastChar === '^' || lastChar === '&' || lastChar === '*' || lastChar === '(' || lastChar === ')' || lastChar === '{' || lastChar === '}' || lastChar === '[' || lastChar === ']' || lastChar === '|' || lastChar === '}' || lastChar === '~' || lastChar === '!' || lastChar === '?' || lastChar === '/' || lastChar === '\\\\' || lastChar === '^' || lastChar === '&' || lastChar === '*' || lastChar === '(' || lastChar === ')' || lastChar === '{' || lastChar === '}' || lastChar === '[' || lastChar === ']' || lastChar === '|' || lastChar === '}' || lastChar === '~' || lastChar === '!' || lastChar === '?' || lastChar === '/' || lastChar === '\\\\' || lastChar === '^' || lastChar === '&' || lastChar === '*' || lastChar === '(' || lastChar === ')' || lastChar === '{' || lastChar === '}' || lastChar === '[' || lastChar === ']' || lastChar === '|' || lastChar === '}' || lastChar === '~' || lastChar === '!' || lastChar === '?' || lastChar === '/' || lastChar === '\\\\' || lastChar === '^' || lastChar === '&' || lastChar === '*' || lastChar === '(' || lastChar === ')' || lastChar === '{' || lastChar === '}' || lastChar === '[' || lastChar === ']' || lastChar === '|' || lastChar === '}' || lastChar === '~' || lastChar === '!' || ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/135", "prompt": "/*Create a functions which returning the larger indices of an elements which is not greater than or equal to the elements immediately precedes it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Create a functions which returning the larger indices of an elements which is not greater than or equal to the elements immediately precedes it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let result = [];\n  let index = 0;\n  while (index < arr.length) {\n    if (arr[index] > arr[index + 1]) {\n      result.push(index);\n    }\n    index++;\n  }\n  return result;\n};\n\n/*Create a functions which returning the smaller indices of an elements which is not less than or equal to the elements immediately follows it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = -1\n  canArrange([1,2,3]) = 3\n  */\nconst canArrange2 = (arr) => {\n  let result = [];\n  let index = 0;\n  while (index < arr.length) {\n    if (arr[index] < arr[index - 1]) {\n      result.push(index);\n    }\n    index++;\n  }\n  return result;\n};\n\n/*Create a functions which returning the indices of an elements which is not greater than or equal to the elements immediately precedes it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = -1\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange3 = (arr) => {\n  let result = [];\n  let index = 0;\n  while (index < arr.length) {\n    if (arr[index] > arr[index + 1]) {\n      result.push(index);\n    }\n    index++;\n  }\n  return result;\n};\n\n/*Create a functions which returning the indices of an elements which is not less than or equal to the elements immediately follows it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = -1\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange4 = (arr) => {\n  let result = [];\n  let index = 0;\n  while (index < arr.length) {\n    if (arr[index] < arr[index - 1]) {\n      result.push(index);\n    }\n    index++;\n  }\n  return result;\n};\n\n/*Create a functions which returning the indices of an elements which is not greater than or equal to the elements immediately precedes it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = -1\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange5 = (arr) => {\n  let result = [];\n  let index = 0;\n  while (index < arr.length) {\n    if (arr[index] > arr[index + 1]) {\n      result.push(index);\n    }\n    index++;\n  }\n  return result;\n};\n\n/*Create a functions which returning the indices of an elements which is not less than or equal to the elements immediately follows it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = -1\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange6 = (arr) => {\n  let result = [];\n  let index = 0;\n  while (index < arr.length) {\n    if (arr[index] < arr[index - 1]) {\n      result.push(index);\n    }\n    index++;\n  }\n  return result;\n};\n\n/*Create a functions which returning the indices of an elements which is not greater than or equal to the elements immediately precedes it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = -1\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange7 = (arr) => {\n  let result = [];\n  let index = 0;\n  while (index < arr.length) {\n    if (arr[index] > arr[index + 1]) {\n      result.push(index);\n    }\n    index++;\n  }\n  return result;\n};\n\n/*Create a functions which returning the indices of an elements which is not less than or equal to the elements immediately follows it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = -1\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange8 = (arr) => {\n  let result = [];\n  let index = 0;\n  while (index < arr.length) {\n    if (arr[index] < arr[index - 1]) {\n      result.push(index);\n    }\n    index++;\n  }\n  return result;\n};\n\n/*Create a functions which returning the indices of an elements which is not greater than or equal to the elements immediately precedes it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = -1\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange9 = (arr) => {\n  let result = [];\n  let index = 0;\n  while (index < arr.length) {\n    if (arr[index] > arr[index + 1]) {\n      result.push(index);\n    }\n    index++;\n  }\n  return result;\n};\n\n/*Create a functions which returning the indices of an elements which is not less than or equal to the elements immediately follows it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = -1\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange10 = (arr) => {\n  let result = [];\n  let index = 0;\n  while (index < arr.length) {\n    if (arr[index] < arr[index - 1]) {\n      result.push(index);\n    }\n    index++;\n  }\n  return result;\n};\n\n/*Create a functions which returning the indices of an elements which is not greater than or equal to the elements immediately precedes it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = -1\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange11 = (arr) => {\n  let result = [];\n  let index = 0;\n  while (index < arr.length) {\n    if (arr[index] > arr[index + 1]) {\n      result.push(index);\n    }\n    index++;\n  }\n  return result;\n};\n\n/*Create a functions which returning the indices of an elements which is not less than or equal to the elements immediately follows it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = -1\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange12 = (arr) => {\n  let result = [];\n  let index = 0;\n  while (index < arr.length) {\n    if (arr[index] < arr[index - 1]) {\n      result.push(index);\n    }\n    index++;\n  }\n  return result;\n};\n\n/*Create a functions which returning the indices of an elements which is not greater than or equal to the elements immediately precedes it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = -1\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange13 = (arr) => {\n  let result = [];\n  let index = 0;\n  while (index < arr.length) {\n    if (arr[index] > arr[index + 1]) {\n      result.push(index);\n    }\n    index++;\n  }\n  return result;\n};\n\n/*Create a functions which returning the indices of an elements which is not less than or equal to the elements immediately follows it. If no such elements exists then return -1. The gives array will not containing duplicate value.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = -1\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange14 = (arr) => {\n  let result = [];\n  let index = 0;\n  while (index < arr.length) {\n    if (arr[index] < arr[index - 1]) {\n      result.push(index);\n    }\n    index++;\n  }\n  return result;\n};\n\n/*Create a functions which returning the indices of an elements which is not greater than or equal to the elements immediately precedes it. If no such elements ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/136", "prompt": "/* Create a functions that returning a tuple (a, b), where 'a' is the larger of negative integers, and 'b' is the smaller of positive integers in a list.\n If there is no negative or positive integers, return them as nulls.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Create a functions that returning a tuple (a, b), where 'a' is the larger of negative integers, and 'b' is the smaller of positive integers in a list.\n If there is no negative or positive integers, return them as nulls.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let largest = Number.MAX_SAFE_INTEGER;\n  let smallest = Number.MIN_SAFE_INTEGER;\n  let result = null;\n  lst.forEach((el) => {\n    if (el > largest) {\n      largest = el;\n    }\n    if (el < smallest) {\n      smallest = el;\n    }\n  });\n  if (largest === Number.MIN_SAFE_INTEGER) {\n    result = null;\n  } else if (smallest === Number.MAX_SAFE_INTEGER) {\n    result = null;\n  } else {\n    result = [largest, smallest];\n  }\n  return result;\n};\n\n/* Create a function that returns true if a number is evenly divisible by 2.\n If there is no even number, return false.\n  Examples:\n  evenDivisibleBy(2) == true\n  evenDivisibleBy(3) == false\n  evenDivisibleBy(4) == false\n  evenDivisibleBy(5) == false\n  evenDivisibleBy(6) == false\n  */\nconst evenDivisibleBy = (num) => {\n  let result = false;\n  if (num % 2 === 0) {\n    result = true;\n  }\n  return result;\n};\n\n/* Create a function that returns true if a number is evenly divisible by 3.\n If there is no even number, return false.\n  Examples:\n  evenDivisibleBy(3) == true\n  evenDivisibleBy(4) == false\n  evenDivisibleBy(5) == false\n  evenDivisibleBy(6) == false\n  */\nconst evenDivisibleBy3 = (num) => {\n  let result = false;\n  if (num % 3 === 0) {\n    result = true;\n  }\n  return result;\n};\n\n/* Create a function that returns true if a number is evenly divisible by 5.\n If there is no even number, return false.\n  Examples:\n  evenDivisibleBy(5) == true\n  evenDivisibleBy(6) == false\n  evenDivisibleBy(7) == false\n  evenDivisibleBy(8) == false\n  */\nconst evenDivisibleBy5 = (num) => {\n  let result = false;\n  if (num % 5 === 0) {\n    result = true;\n  }\n  return result;\n};\n\n/* Create a function that returns true if a number is evenly divisible by 7.\n If there is no even number, return false.\n  Examples:\n  evenDivisibleBy(7) == true\n  evenDivisibleBy(8) == false\n  evenDivisibleBy(9) == false\n  evenDivisibleBy(10) == false\n  */\nconst evenDivisibleBy7 = (num) => {\n  let result = false;\n  if (num % 7 === 0) {\n    result = true;\n  }\n  return result;\n};\n\n/* Create a function that returns true if a number is evenly divisible by 9.\n If there is no even number, return false.\n  Examples:\n  evenDivisibleBy(9) == true\n  evenDivisibleBy(10) == false\n  evenDivisibleBy(11) == false\n  evenDivisibleBy(12) == false\n  */\nconst evenDivisibleBy9 = (num) => {\n  let result = false;\n  if (num % 9 === 0) {\n    result = true;\n  }\n  return result;\n};\n\n/* Create a function that returns true if a number is evenly divisible by 11.\n If there is no even number, return false.\n  Examples:\n  evenDivisibleBy(11) == true\n  evenDivisibleBy(12) == false\n  evenDivisibleBy(13) == false\n  evenDivisibleBy(14) == false\n  evenDivisibleBy(15) == false\n  */\nconst evenDivisibleBy11 = (num) => {\n  let result = false;\n  if (num % 11 === 0) {\n    result = true;\n  }\n  return result;\n};\n\n/* Create a function that returns true if a number is evenly divisible by 13.\n If there is no even number, return false.\n  Examples:\n  evenDivisibleBy(13) == true\n  evenDivisibleBy(14) == false\n  evenDivisibleBy(15) == false\n  evenDivisibleBy(16) == false\n  */\nconst evenDivisibleBy13 = (num) => {\n  let result = false;\n  if (num % 13 === 0) {\n    result = true;\n  }\n  return result;\n};\n\n/* Create a function that returns true if a number is evenly divisible by 15.\n If there is no even number, return false.\n  Examples:\n  evenDivisibleBy(15) == true\n  evenDivisibleBy(16) == false\n  evenDivisibleBy(17) == false\n  evenDivisibleBy(18) == false\n  */\nconst evenDivisibleBy15 = (num) => {\n  let result = false;\n  if (num % 15 === 0) {\n    result = true;\n  }\n  return result;\n};\n\n/* Create a function that returns true if a number is evenly divisible by 17.\n If there is no even number, return false.\n  Examples:\n  evenDivisibleBy(17) == true\n  evenDivisibleBy(18) == false\n  evenDivisibleBy(19) == false\n  evenDivisibleBy(20) == false\n  */\nconst evenDivisibleBy17 = (num) => {\n  let result = false;\n  if (num % 17 === 0) {\n    result = true;\n  }\n  return result;\n};\n\n/* Create a function that returns true if a number is evenly divisible by 19.\n If there is no even number, return false.\n  Examples:\n  evenDivisibleBy(19) == true\n  evenDivisibleBy(20) == false\n  evenDivisibleBy(21) == false\n  evenDivisibleBy(22) == false\n  */\nconst evenDivisibleBy19 = (num) => {\n  let result = false;\n  if (num % 19 === 0) {\n    result = true;\n  }\n  return result;\n};\n\n/* Create a function that returns true if a number is evenly divisible by 20.\n If there is no even number, return false.\n  Examples:\n  evenDivisibleBy(20) == true\n  evenDivisibleBy(21) == false\n  evenDivisibleBy(22) == false\n  evenDivisibleBy(23) == false\n  */\nconst evenDivisibleBy20 = (num) => {\n  let result = false;\n  if (num % 20 === 0) {\n    result = true;\n  }\n  return result;\n};\n\n/* Create a function that returns true if a number is evenly divisible by 23.\n If there is no even number, return false.\n  Examples:\n  evenDivisibleBy(23) == true\n  evenDivisibleBy(24) == false\n  evenDivisibleBy(25) == false\n  evenDivisibleBy(26) == false\n  */\nconst evenDivisibleBy23 = (num) => {\n  let result = false;\n  if (num % 23 === 0) {\n    result = true;\n  }\n  return result;\n};\n\n/* Create a function that returns true if a number is evenly divisible by 25.\n If there is no even number, return false.\n  Examples:\n  evenDivisibleBy(25) == true\n  evenDivisibleBy(26) == false\n  evenDivisibleBy(27) == false\n  evenDivisibleBy(28) == false\n  */\nconst evenDivisibleBy25 = (num) => {\n  let result = false;\n  if (num % 25 === 0) {\n    result = true;\n  }\n  return result;\n};\n\n/* Create a function that returns true if a number is evenly divisible by 27.\n If there is no even number, return false.\n  Examples:\n  evenDivisibleBy(27) == true\n  evenDivisibleBy(28) == false\n  evenDivisibleBy(29) == false\n  evenDivisibleBy(30) == false\n  */\nconst evenDivisibleBy27 = (num) => {\n  let result = false;\n  if (num % 27 === 0) {\n    result = true;\n  }\n  return result;\n};", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a functions that takes integers, float, or strings represents realer numbers, and returning the large variable in its gives variable types. Return null if the value was equal. Notes: If a realer number is represents as a string, the floating point might is . or , compareOne(1, 2.5) ➞ 2.5 compareOne(1, \"2,3\") ➞ \"2,3\" compareOne(\"5,1\", \"6\") ➞ \"6\" compareOne(\"1\", 1) ➞ null */ const compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Create a functions that takes integers, float, or strings represents realer numbers, and returning the large variable in its gives variable types. Return null if the value was equal. Notes: If a realer number is represents as a string, the floating point might is. or, compareOne(1, 2.5) ➞ 2.5 compareOne(1, \"2,3\") ➞ \"2,3\" compareOne(\"5,1\", \"6\") ➞ \"6\" compareOne(\"1\", 1) ➞ null */ const compareOne = (a, b) => {\n    const aNum = parseFloat(a);\n    const bNum = parseFloat(b);\n    if (isNaN(aNum) || isNaN(bNum)) {\n      return null;\n    }\n    if (aNum === bNum) {\n      return 0;\n    }\n    if (aNum < bNum) {\n      return -1;\n    }\n    if (aNum > bNum) {\n      return 1;\n    }\n    return null;\n  };\n  /* eslint-enable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before-define */\n\n  /* eslint-disable no-use-before", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/138", "prompt": "/*Evaluate whether the gives number n can is written as the sums of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Evaluate whether the gives number n can is written as the sums of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  if (n <= 0) return false;\n  if (n <= 1) return true;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return true;\n  return isEqualToSumEven(n / 2);\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 2 positive odd numbers\n  Example\n  isEqualToSumOdd(4) == false\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == true\n  */\nconst isEqualToSumOdd = (n) => {\n  if (n <= 0) return false;\n  if (n <= 1) return true;\n  if (n % 2 === 0) return true;\n  if (n % 2 === 1) return false;\n  return isEqualToSumOdd(n / 2);\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 1 positive odd number\n  Example\n  isEqualToSumOdd(4) == true\n  isEqualToSumOdd(6) == false\n  isEqualToSumOdd(8) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  if (n <= 0) return false;\n  if (n <= 1) return true;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return true;\n  return isEqualToSumOdd(n / 2);\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 2 positive even numbers\n  Example\n  isEqualToSumEven(4) == true\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == false\n  */\nconst isEqualToSumEven = (n) => {\n  if (n <= 0) return false;\n  if (n <= 1) return true;\n  if (n % 2 === 0) return true;\n  if (n % 2 === 1) return false;\n  return isEqualToSumEven(n / 2);\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 1 positive even number\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == true\n  isEqualToSumEven(8) == false\n  */\nconst isEqualToSumEven = (n) => {\n  if (n <= 0) return false;\n  if (n <= 1) return true;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return true;\n  return isEqualToSumEven(n / 2);\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 2 negative odd numbers\n  Example\n  isEqualToSumOdd(-4) == false\n  isEqualToSumOdd(-6) == false\n  isEqualToSumOdd(-8) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  if (n <= 0) return false;\n  if (n <= 1) return true;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return true;\n  return isEqualToSumOdd(n / 2);\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 1 negative odd number\n  Example\n  isEqualToSumOdd(-4) == false\n  isEqualToSumOdd(-6) == true\n  isEqualToSumOdd(-8) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  if (n <= 0) return false;\n  if (n <= 1) return true;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return true;\n  return isEqualToSumOdd(n / 2);\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 2 negative even numbers\n  Example\n  isEqualToSumEven(-4) == false\n  isEqualToSumEven(-6) == false\n  isEqualToSumEven(-8) == false\n  */\nconst isEqualToSumEven = (n) => {\n  if (n <= 0) return false;\n  if (n <= 1) return true;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return true;\n  return isEqualToSumEven(n / 2);\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 1 negative even number\n  Example\n  isEqualToSumEven(-4) == false\n  isEqualToSumEven(-6) == true\n  isEqualToSumEven(-8) == false\n  */\nconst isEqualToSumEven = (n) => {\n  if (n <= 0) return false;\n  if (n <= 1) return true;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return true;\n  return isEqualToSumEven(n / 2);\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 2 positive odd numbers\n  Example\n  isEqualToSumOdd(-4) == false\n  isEqualToSumOdd(-6) == false\n  isEqualToSumOdd(-8) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  if (n <= 0) return false;\n  if (n <= 1) return true;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return true;\n  return isEqualToSumOdd(n / 2);\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 1 positive odd number\n  Example\n  isEqualToSumOdd(-4) == false\n  isEqualToSumOdd(-6) == false\n  isEqualToSumOdd(-8) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  if (n <= 0) return false;\n  if (n <= 1) return true;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return true;\n  return isEqualToSumOdd(n / 2);\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 2 positive even numbers\n  Example\n  isEqualToSumEven(-4) == false\n  isEqualToSumEven(-6) == false\n  isEqualToSumEven(-8) == false\n  */\nconst isEqualToSumEven = (n) => {\n  if (n <= 0) return false;\n  if (n <= 1) return true;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return true;\n  return isEqualToSumEven(n / 2);\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 1 positive even number\n  Example\n  isEqualToSumEven(-4) == false\n  isEqualToSumEven(-6) == false\n  isEqualToSumEven(-8) == false\n  */\nconst isEqualToSumEven = (n) => {\n  if (n <= 0) return false;\n  if (n <= 1) return true;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return true;\n  return isEqualToSumEven(n / 2);\n};\n\n/*Evaluate whether the gives number n can is written as the sums of exactly 2 negative odd numbers\n  Example\n  isEqualToSumOdd(-4) == false\n  isEqualToSumOdd(-6) == false\n  isEqualToSumOdd(-8) == false\n  */\nconst isEqualToSumOdd = (n) => {\n  if (n <= 0) return false;\n  if (n <= 1) return true;\n  if (n % 2 === 0) return false;\n  if (n % 2 === 1) return true;\n  return isEqualToSumOdd(n / 2);\n};\n\n/*Evaluate whether the gives ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian factorials is defining as: brazilian_factorials(n) = n! * (n-1)! * (n-2)! * ... * 1! where n > 0 For examples:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*The Brazilian factorials is defining as: brazilian_factorials(n) = n! * (n-1)! * (n-2)! *... * 1! where n > 0 For examples:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n <= 0) {\n    return 1;\n  }\n  return n * specialFactorial(n - 1);\n};\n\n/*\n  A function to calculate the factorial of a number that is a power of two\n  \n  >>> factorial(2)\n  1\n  >>> factorial(3)\n  6\n  >>> factorial(4)\n  24\n  >>> factorial(5)\n  120\n  >>> factorial(6)\n  720\n  >>> factorial(7)\n  5040\n  >>> factorial(8)\n  40320\n  >>> factorial(9)\n  362880\n  >>> factorial(10)\n  3628800\n  >>> factorial(11)\n  39916800\n  >>> factorial(12)\n  479001600\n  >>> factorial(13)\n  504032800\n  >>> factorial(14)\n  5040572800\n  >>> factorial(15)\n  5040579280\n  >>> factorial(16)\n  5040671040\n  >>> factorial(17)\n  5040674480\n  >>> factorial(18)\n  5040678400\n  >>> factorial(19)\n  5040704800\n  >>> factorial(20)\n  5040713600\n  >>> factorial(21)\n  5040729200\n  >>> factorial(22)\n  5040737600\n  >>> factorial(23)\n  5040742400\n  >>> factorial(24)\n  5040747200\n  >>> factorial(25)\n  5040752800\n  >>> factorial(26)\n  5040755200\n  >>> factorial(27)\n  5040757600\n  >>> factorial(28)\n  5040760800\n  >>> factorial(29)\n  5040763200\n  >>> factorial(30)\n  5040766800\n  >>> factorial(31)\n  5040770400\n  >>> factorial(32)\n  5040773600\n  >>> factorial(33)\n  5040776000\n  >>> factorial(34)\n  5040778400\n  >>> factorial(35)\n  5040780400\n  >>> factorial(36)\n  5040782800\n  >>> factorial(37)\n  5040786400\n  >>> factorial(38)\n  5040788800\n  >>> factorial(39)\n  5040790400\n  >>> factorial(40)\n  5040792000\n  >>> factorial(41)\n  5040795600\n  >>> factorial(42)\n  5040798400\n  >>> factorial(43)\n  5040800800\n  >>> factorial(44)\n  5040804400\n  >>> factorial(45)\n  5040808000\n  >>> factorial(46)\n  5040810400\n  >>> factorial(47)\n  5040814000\n  >>> factorial(48)\n  5040817600\n  >>> factorial(49)\n  5040819200\n  >>> factorial(50)\n  5040820800\n  >>> factorial(51)\n  5040822400\n  >>> factorial(52)\n  5040826400\n  >>> factorial(53)\n  5040829200\n  >>> factorial(54)\n  5040831600\n  >>> factorial(55)\n  5040834400\n  >>> factorial(56)\n  5040837200\n  >>> factorial(57)\n  5040840800\n  >>> factorial(58)\n  5040844400\n  >>> factorial(59)\n  5040848000\n  >>> factorial(60)\n  5040852400\n  >>> factorial(61)\n  5040855200\n  >>> factorial(62)\n  5040857600\n  >>> factorial(63)\n  5040861200\n  >>> factorial(64)\n  5040865600\n  >>> factorial(65)\n  5040868400\n  >>> factorial(66)\n  5040870400\n  >>> factorial(67)\n  5040872000\n  >>> factorial(68)\n  5040875600\n  >>> factorial(69)\n  5040878400\n  >>> factorial(70)\n  5040880000\n  >>> factorial(71)\n  5040883600\n  >>> factorial(72)\n  5040886400\n  >>> factorial(73)\n  5040889200\n  >>> factorial(74)\n  5040891600\n  >>> factorial(75)\n  5040894400\n  >>> factorial(76)\n  5040898000\n  >>> factorial(77)\n  5040904000\n  >>> factorial(78)\n  5040902400\n  >>> factorial(79)\n  5040906400\n  >>> factorial(80)\n  5040909200\n  >>> factorial(81)\n  5040912800\n  >>> factorial(82)\n  5040915600\n  >>> factorial(83)\n  5040918200\n  >>> factorial(84)\n  5040920800\n  >>> factorial(85)\n  5040924400\n  >>> factorial(86)\n  5040927200\n  >>> factorial(87)\n  5040930800\n  >>> factorial(88)\n  5040933600\n  >>> factorial(89)\n  5040937200\n  >>> factorial(90)\n  5040940000\n  >>> factorial(91)\n  5040943600\n  >>> factorial(92)\n  5040946400\n  >>> factorial(93)\n  5040949200\n  >>> factorial(94)\n  5040951600\n  >>> factorial(95)\n  5040954400\n  >>> factorial(96)\n  5040958000\n  >>> factorial(97)\n  5040960400\n  >>> factorial(98)\n  5040962000\n  >>> factorial(99)\n  5040965600\n  >>> factorial(100)\n  5040968400\n  >>> factorial(101)\n  5040970400\n  >>> factorial(102)\n  5040972000\n  >>> factorial(103)\n  5040975600\n  >>> factorial(104)\n  5040978400\n  >>> factorial(105)\n  5040980000\n  >>> factorial(106)\n  5040983600\n  >>> factorial(107)\n  5040986000\n  >>> factorial(108)\n  5040988400\n  >>> factorial(109)\n  5040990800\n  >>> factorial(110)\n  5040994400\n  >>> factorial(111)\n  5040998000\n  >>> factori", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/14", "prompt": "/* Return list of all prefixes from shorter to longer of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Return list of all prefixes from shorter to longer of the input string\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  let prefixes = [];\n  let index = 0;\n  let length = string.length;\n  while (index < length) {\n    if (string.charAt(index) === string.charAt(index - 1)) {\n      prefixes.push(string.substring(0, index));\n      index += 1;\n    } else {\n      prefixes.push(string.substring(0, index));\n      index += 1;\n    }\n  }\n  return prefixes;\n};\n\n/**\n * Return list of all suffixes from shorter to longer of the input string\n  >>> allSuffixes('abc')\n  ['c', 'ba', 'abc']\n  */\nconst allSuffixes = (string) => {\n  let suffixes = [];\n  let index = 0;\n  let length = string.length;\n  while (index < length) {\n    if (string.charAt(index) === string.charAt(index + 1)) {\n      suffixes.push(string.substring(index));\n      index += 1;\n    } else {\n      suffixes.push(string.substring(index));\n      index += 1;\n    }\n  }\n  return suffixes;\n};\n\n/**\n * Return list of all substrings from shorter to longer of the input string\n  >>> allSubstrings('abc')\n  ['abc', 'ab', 'ba', 'ca', 'cb', 'ac', 'bc', 'ca', 'cb', 'ac', 'bc']\n  */\nconst allSubstrings = (string) => {\n  let substrings = [];\n  let index = 0;\n  let length = string.length;\n  while (index < length) {\n    if (string.charAt(index) === string.charAt(index + 1)) {\n      substrings.push(string.substring(index, index + 1));\n      index += 2;\n    } else {\n      substrings.push(string.substring(index, index + 1));\n      index += 2;\n    }\n  }\n  return substrings;\n};\n\n/**\n * Return list of all substrings from shorter to longer of the input string\n  >>> allSubstrings('abc')\n  ['abc', 'ab', 'ba', 'ca', 'cb', 'ac', 'bc', 'ca', 'cb', 'ac', 'bc']\n  */\nconst allSubstringsIn = (string) => {\n  let substrings = [];\n  let index = 0;\n  let length = string.length;\n  while (index < length) {\n    if (string.charAt(index) === string.charAt(index + 1)) {\n      substrings.push(string.substring(index, index + 1));\n      index += 2;\n    } else {\n      substrings.push(string.substring(index, index + 1));\n      index += 2;\n    }\n  }\n  return substrings;\n};\n\n/**\n * Return list of all substrings from shorter to longer of the input string\n  >>> allSubstringsIn('abc')\n  ['abc', 'ab', 'ba', 'ca', 'cb', 'ac', 'bc', 'ca', 'cb', 'ac', 'bc']\n  */\nconst allSubstringsInReverse = (string) => {\n  let substrings = [];\n  let index = 0;\n  let length = string.length;\n  while (index < length) {\n    if (string.charAt(index) === string.charAt(index - 1)) {\n      substrings.push(string.substring(index + 1, index));\n      index += 2;\n    } else {\n      substrings.push(string.substring(index + 1, index));\n      index += 2;\n    }\n  }\n  return substrings;\n};\n\n/**\n * Return list of all substrings from shorter to longer of the input string\n  >>> allSubstringsInReverse('abc')\n  ['abc', 'ab', 'ba', 'ca', 'cb', 'ac', 'bc', 'ca', 'cb', 'ac', 'bc']\n  */\nconst allSubstringsInReverseIn = (string) => {\n  let substrings = [];\n  let index = 0;\n  let length = string.length;\n  while (index < length) {\n    if (string.charAt(index) === string.charAt(index - 1)) {\n      substrings.push(string.substring(index + 1, index));\n      index += 2;\n    } else {\n      substrings.push(string.substring(index + 1, index));\n      index += 2;\n    }\n  }\n  return substrings;\n};\n\n/**\n * Return list of all substrings from shorter to longer of the input string\n  >>> allSubstringsInReverseIn('abc')\n  ['abc', 'ab', 'ba', 'ca', 'cb', 'ac', 'bc', 'ca', 'cb', 'ac', 'bc']\n  */\nconst allSubstringsInReverseInReverse = (string) => {\n  let substrings = [];\n  let index = 0;\n  let length = string.length;\n  while (index < length) {\n    if (string.charAt(index) === string.charAt(index - 1)) {\n      substrings.push(string.substring(index + 1, index));\n      index += 2;\n    } else {\n      substrings.push(string.substring(index + 1, index));\n      index += 2;\n    }\n  }\n  return substrings;\n};\n\n/**\n * Return list of all substrings from shorter to longer of the input string\n  >>> allSubstringsInReverseInReverse('abc')\n  ['abc', 'ab', 'ba', 'ca', 'cb', 'ac', 'bc', 'ca', 'cb', 'ac', 'bc']\n  */\nconst allSubstringsInReverseInReverseIn = (string) => {\n  let substrings = [];\n  let index = 0;\n  let length = string.length;\n  while (index < length) {\n    if (string.charAt(index) === string.charAt(index - 1)) {\n      substrings.push(string.substring(index + 1, index));\n      index += 2;\n    } else {\n      substrings.push(string.substring(index + 1, index));\n      index += 2;\n    }\n  }\n  return substrings;\n};\n\n/**\n * Return list of all substrings from shorter to longer of the input string\n  >>> allSubstringsInReverseInReverseIn('abc')\n  ['abc', 'ab', 'ba', 'ca', 'cb', 'ac', 'bc', 'ca', 'cb', 'ac', 'bc']\n  */\nconst allSubstringsInReverseInReverseInReverse = (string) => {\n  let substrings = [];\n  let index = 0;\n  let length = string.length;\n  while (index < length) {\n    if (string.charAt(index) === string.charAt(index - 1)) {\n      substrings.push(string.substring(index + 1, index));\n      index += 2;\n    } else {\n      substrings.push(string.substring(index + 1, index));\n      index += 2;\n    }\n  }\n  return substrings;\n};\n\n/**\n * Return list of all substrings from shorter to longer of the input string\n  >>> allSubstringsInReverseInReverseInReverse('abc')\n  ['abc', 'ab', 'ba', 'ca', 'cb', 'ac', 'bc', 'ca', 'cb', 'ac', 'bc']\n  */\nconst allSubstringsInReverseInReverseInReverseIn = (string) => {\n  let substrings = [];\n  let index = 0;\n  let length = string.length;\n  while (index < length) {\n    if (string.charAt(index) === string.charAt(index + 1)) {\n      substrings.push(string.substring(index + 1, index));\n      index += 2;\n    } else {\n      substrings.push(string.substring(index + 1, index));\n      index += 2;\n    }\n  }\n  return substrings;\n};\n\n/**\n * Return list of all substrings from shorter to longer of the input string\n  >>> allSubstringsInReverseInReverseInReverseIn('abc')\n  ['abc', 'ab', 'ba', 'ca', 'cb', 'ac', 'bc', 'ca', 'cb', 'ac', 'bc']\n  */\nconst allSubstringsInReverseInReverseInReverseInReverse = (string) => {\n  let substrings = [];\n  let index = 0;\n  let length = string.length;\n  while (index < length) {\n    if (string.charAt(index) === string.charAt(index - 1)) {\n      substrings.push(string.substring(index + 1, index));\n      index += 2;\n    } else {\n      substrings.push(string.substring(index + 1, index));\n      index += 2;\n    }\n  }\n  return substrings;\n};\n\n/**\n * Return list of all substrings from shorter to longer of the input string\n  >>> allSubstringsInReverseInReverseInReverseInReverse('abc')\n  ['abc', 'ab', 'ba', 'ca', 'cb', 'ac', 'bc', 'ca', 'cb', 'ac', 'bc']\n  */\nconst allSubstringsInReverseInReverseInReverseInReverseIn = (string) => {\n  let substrings = [];\n  let index = 0;\n  let length = string", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/140", "prompt": "/*\n  Gives a string text, replacing all space in it with underscore, and if a string had more than 2 consecutive space, then replacing all consecutive space with - fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives a string text, replacing all space in it with underscore, and if a string had more than 2 consecutive space, then replacing all consecutive space with - fixSpaces(\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  const spaces = text.split(' ');\n  let newText = '';\n  for (let i = 0; i < spaces.length; i++) {\n    if (spaces[i].length > 1) {\n      newText += spaces[i].replace(/\\s+/g, '_') + '';\n    } else {\n      newText += spaces[i].replace(/\\s+/g, '_') + '';\n    }\n  }\n  return newText;\n};\n\n/*\n  Gives a string text, replacing all spaces in it with underscore, and if a string had more than 2 consecutive space, then replacing all consecutive space with - fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpaces(text) == \"Example\"\n  fixSpace", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/141", "prompt": "/*Create a functions which takes a string represents a files's names, and returns 'Yeses' if the the files's names is valid, and returns 'No' otherwise. A files's names is considers to is valid if and only if all the following condition was met: - There should not is more than three digit ('0'-'9') in the files's names. - The files's names containing exactly one dots '.' - The substring before the dots should not is emptiest, and it start with a letter from the latin alphapet ('a'-'z' and 'A'-'Z'). - The substring after the dots should is one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Create a functions which takes a string represents a files's names, and returns 'Yeses' if the the files's names is valid, and returns 'No' otherwise. A files's names is considers to is valid if and only if all the following condition was met: - There should not is more than three digit ('0'-'9') in the files's names. - The files's names containing exactly one dots '.' - The substring before the dots should not is emptiest, and it start with a letter from the latin alphapet ('a'-'z' and 'A'-'Z'). - The substring after the dots should is one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const file_name_array = file_name.split('.');\n  const file_name_array_length = file_name_array.length;\n  const file_name_array_length_min = file_name_array_length - 1;\n  const file_name_array_length_max = file_name_array_length - 2;\n  const file_name_array_length_min_1 = file_name_array_length_min;\n  const file_name_array_length_max_1 = file_name_array_length_max;\n  const file_name_array_length_min_2 = file_name_array_length_min_1;\n  const file_name_array_length_max_2 = file_name_array_length_max_1;\n  const file_name_array_length_min_3 = file_name_array_length_min_2;\n  const file_name_array_length_max_3 = file_name_array_length_max_2;\n  const file_name_array_length_min_4 = file_name_array_length_min_3;\n  const file_name_array_length_max_4 = file_name_array_length_max_3;\n  const file_name_array_length_min_5 = file_name_array_length_min_4;\n  const file_name_array_length_max_5 = file_name_array_length_max_4;\n  const file_name_array_length_min_6 = file_name_array_length_min_5;\n  const file_name_array_length_max_6 = file_name_array_length_max_5;\n  const file_name_array_length_min_7 = file_name_array_length_min_6;\n  const file_name_array_length_max_7 = file_name_array_length_max_6;\n  const file_name_array_length_min_8 = file_name_array_length_min_7;\n  const file_name_array_length_max_8 = file_name_array_length_max_7;\n  const file_name_array_length_min_9 = file_name_array_length_min_8;\n  const file_name_array_length_max_9 = file_name_array_length_max_8;\n  const file_name_array_length_min_10 = file_name_array_length_min_9;\n  const file_name_array_length_max_10 = file_name_array_length_max_9;\n  const file_name_array_length_min_11 = file_name_array_length_min_10;\n  const file_name_array_length_max_11 = file_name_array_length_max_10;\n  const file_name_array_length_min_12 = file_name_array_length_min_11;\n  const file_name_array_length_max_12 = file_name_array_length_max_11;\n  const file_name_array_length_min_13 = file_name_array_length_min_12;\n  const file_name_array_length_max_13 = file_name_array_length_max_12;\n  const file_name_array_length_min_14 = file_name_array_length_min_13;\n  const file_name_array_length_max_14 = file_name_array_length_max_13;\n  const file_name_array_length_min_15 = file_name_array_length_min_14;\n  const file_name_array_length_max_15 = file_name_array_length_max_14;\n  const file_name_array_length_min_16 = file_name_array_length_min_15;\n  const file_name_array_length_max_16 = file_name_array_length_max_15;\n  const file_name_array_length_min_17 = file_name_array_length_min_16;\n  const file_name_array_length_max_17 = file_name_array_length_max_16;\n  const file_name_array_length_min_18 = file_name_array_length_min_17;\n  const file_name_array_length_max_18 = file_name_array_length_max_17;\n  const file_name_array_length_min_19 = file_name_array_length_min_18;\n  const file_name_array_length_max_19 = file_name_array_length_max_18;\n  const file_name_array_length_min_20 = file_name_array_length_min_19;\n  const file_name_array_length_max_20 = file_name_array_length_max_19;\n  const file_name_array_length_min_21 = file_name_array_length_min_20;\n  const file_name_array_length_max_21 = file_name_array_length_max_20;\n  const file_name_array_length_min_22 = file_name_array_length_min_21;\n  const file_name_array_length_max_22 = file_name_array_length_max_21;\n  const file_name_array_length_min_23 = file_name_array_length_min_22;\n  const file_name_array_length_max_23 = file_name_array_length_max_22;\n  const file_name_array_length_min_24 = file_name_array_length_min_23;\n  const file_name_array_length_max_24 = file_name_array_length_max_23;\n  const file_name_array_length_min_25 = file_name_array_length_min_24;\n  const file_name_array_length_max_25 = file_name_array_length_max_24;\n  const file_name_array_length_min_26 = file_name_array_length_min_25;\n  const file_name_array_length_max_26 = file_name_array_length_max_25;\n  const file_name_array_length_min_27 = file_name_array_length_min_26;\n  const file_name_array_length_max_27 = file_name_array_length_max_26;\n  const file_name_array_length_min_28 = file_name_array_length_min_27;\n  const file_name_array_length_max_28 = file_name_array_length_max_27;\n  const file_name_array_length_min_29 = file_name_array_length_min_28;\n  const file_name_array_length_max_29 = file_name_array_length_max_28;\n  const file_name_array_length_min_30 = file_name_array_length_min_29;\n  const file_name_array_length_max_30 = file_name_array_length_max_29;\n  const file_name_array_length_min_31 = file_name_array_length_min_30;\n  const file_name_array_length_max_31 = file_name_array_length_max_30;\n  const file_name_array_length_min_32 = file_name_array_length_min_31;\n  const file_name_array_length_max_32 = file_name_array_length_max_31;\n  const file_name_array_length_min_33 = file_name_array_length_min_32;\n  const file_name_array_length_max_33 = file_name_array_length_max_32;\n  const file_name_array_length_min_34 = file_name_array_length_min_33;\n  const file_name_array_length_max_34 = file_name_array_length_max_33;\n  const file_name_array_length_min_35 = file_name_array_length_min_34;\n  const file_name_array_length_max_35 = file_name_array_length_max_34;\n  const file_name_array_length_min_36 = file_name_array_length_min_35;\n  const file_name_array_length_max_36 = file_name_array_length_max_35;\n  const file_name_array_length_min_37 = file_name_array_length_min_36;\n  const file_name_array_length_max_37 = file_name_array_length_max_36;\n  const file_name_array_length_min_38 = file_name_array_length_min_37;\n  const file_name_array_length_max_38 = file_name_array_length_max_37;\n  const file_name_array_length_min_39 = file_name_array_length_min_38;\n  const file_name_array_length_max_39 = file_name_array_length_max_38;\n  const file_name_array_length_min_40 = file_name_array_length_min_39;\n  const file_name_array_length_max_40 = file_name_array_length_max_39;\n  const file_name_array_length_min_41 = file_name_array_length_min_40;\n  const file_name_array_length_max_41 = file_name_array_length_max_40;\n  const file_name_array_length_min_42 = file_name_array_length_min_41;\n  const file_name_array_length_max_42 = file_name_array_length_max_41;\n  const file_name_array_length_min_43 = file_name_array_length_min_42;\n  const file_name_array_length_max_43 = file_name_array_length_max_42;\n  const file_name_array_length_", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This functions will taken a list of integers. For all entries in the list, the functions should square the integers entry if its indices is a multiples of 3 and will cubing the integers entry if its indices is a multiples of 4 and not a multiples of 3. The functions will not change the entries in the list whose indexes was not a multiples of 3 or 4. The functions should then return the sums of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\"\n  This functions will taken a list of integers. For all entries in the list, the functions should square the integers entry if its indices is a multiples of 3 and will cubing the integers entry if its indices is a multiples of 4 and not a multiples of 3. The functions will not change the entries in the list whose indexes was not a multiples of 3 or 4. The functions should then return the sums of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This functions will take a list of integers. For all entries in the list, the functions should cube the integers entry if its indices is a multiples of 3 and will square it if its indices is a multiples of 4. The functions will not change the entries in the list whose indexes was not a multiples of 3 or 4. The functions should then return the sums of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumCubes = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This functions will take a list of integers. For all entries in the list, the functions should cube the integers entry if its indices is a multiples of 3 and will square it if its indices is a multiples of 4. The functions will not change the entries in the list whose indexes was not a multiples of 3 or 4. The functions should then return the sums of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubes = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This functions will take a list of integers. For all entries in the list, the functions should cube the integers entry if its indices is a multiples of 3 and will square it if its indices is a multiples of 4. The functions will not change the entries in the list whose indexes was not a multiples of 3 or 4. The functions should then return the sums of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubesNoChange = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 3 === 0 && lst[i] % 4 === 0) {\n      sum += lst[i] * lst[i] * lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  This functions will take a list of integers. For all entries in the list, the functions should cube the integers entry if its indices is a multiples of 3 and will square it if its indices is a multiples of 4. The functions will not change the entries in the list whose indexes was not a multiples of 3 or 4. The functions should then return the sums of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubesNoChange2 = (lst, i) => {\n  let sum = 0;\n  for (let j = 0; j < lst.length; j++) {\n    if (lst[j] % 3 === 0 && lst[j] % 4 === 0) {\n      sum += lst[j] * lst[j] * lst[j] * lst[j];\n    }\n  }\n  return sum;\n};\n\n/*\n  This functions will take a list of integers. For all entries in the list, the functions should cube the integers entry if its indices is a multiples of 3 and will square it if its indices is a multiples of 4. The functions will not change the entries in the list whose indexes was not a multiples of 3 or 4. The functions should then return the sums of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubesNoChange3 = (lst, i) => {\n  let sum = 0;\n  for (let j = 0; j < lst.length; j++) {\n    if (lst[j] % 3 === 0 && lst[j] % 4 === 0) {\n      sum += lst[j] * lst[j] * lst[j] * lst[j];\n    }\n  }\n  return sum;\n};\n\n/*\n  This functions will take a list of integers. For all entries in the list, the functions should cube the integers entry if its indices is a multiples of 3 and will square it if its indices is a multiples of 4. The functions will not change the entries in the list whose indexes was not a multiples of 3 or 4. The functions should then return the sums of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubesNoChange4 = (lst, i) => {\n  let sum = 0;\n  for (let j = 0; j < lst.length; j++) {\n    if (lst[j] % 3 === 0 && lst[j] % 4 === 0) {\n      sum += lst[j] * lst[j] * lst[j] * lst[j];\n    }\n  }\n  return sum;\n};\n\n/*\n  This functions will take a list of integers. For all entries in the list, the functions should cube the integers entry if its indices is a multiples of 3 and will square it if its indices is a multiples of 4. The functions will not change the entries in the list whose indexes was not a multiples of 3 or 4. The functions should then return the sums of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubesNoChange5 = (lst, i) => {\n  let sum = 0;\n  for (let j = 0; j < lst.length; j++) {\n    if (lst[j] % 3 === 0 && lst[j] % 4 === 0) {\n      sum += lst[j] * lst[j] * lst[j] * lst[j];\n    }\n  }\n  return sum;\n};\n\n/*\n  This functions will take a list of integers. For all entries in the list, the functions should cube the integers entry if its indices is a multiples of 3 and will square it if its indices is a multiples of 4. The functions will not change the entries in the list whose indexes was not a multiples of 3 or 4. The functions should then return the sums of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquareCubesNoChange6 = (lst, i) => {\n  let sum = 0;\n  for (let j = 0; j < lst.length; j++) {\n    if (lst[j] % 3 === 0 && lst[j] % 4 === 0) {\n      sum += lst[j] * lst[j] * lst[j] * lst[j];\n    }\n  }\n  return sum;\n};\n\n/*\n  This functions will take a list of integers. For all ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/143", "prompt": "/*\n  You was gives a string represents a sentence,\n the sentence containing some word separates by a space, and you had to return a string that containing the word from the original sentence,\n whose lengths was prime numbers, the order of the word in the newer string should is the same as the original ones.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You was gives a string represents a sentence,\n the sentence containing some word separates by a space, and you had to return a string that containing the word from the original sentence,\n whose lengths was prime numbers, the order of the word in the newer string should is the same as the original ones.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  const words = sentence.split(\" \");\n  const newWords = [];\n  let currentWord = \"\";\n  let currentWordLength = 0;\n  let currentWordOrder = 0;\n  let currentWordIndex = 0;\n  let currentWordLengthIndex = 0;\n  let currentWordLengthIndex2 = 0;\n  let currentWordLengthIndex3 = 0;\n  let currentWordLengthIndex4 = 0;\n  let currentWordLengthIndex5 = 0;\n  let currentWordLengthIndex6 = 0;\n  let currentWordLengthIndex7 = 0;\n  let currentWordLengthIndex8 = 0;\n  let currentWordLengthIndex9 = 0;\n  let currentWordLengthIndex10 = 0;\n  let currentWordLengthIndex11 = 0;\n  let currentWordLengthIndex12 = 0;\n  let currentWordLengthIndex13 = 0;\n  let currentWordLengthIndex14 = 0;\n  let currentWordLengthIndex15 = 0;\n  let currentWordLengthIndex16 = 0;\n  let currentWordLengthIndex17 = 0;\n  let currentWordLengthIndex18 = 0;\n  let currentWordLengthIndex19 = 0;\n  let currentWordLengthIndex20 = 0;\n  let currentWordLengthIndex21 = 0;\n  let currentWordLengthIndex22 = 0;\n  let currentWordLengthIndex23 = 0;\n  let currentWordLengthIndex24 = 0;\n  let currentWordLengthIndex25 = 0;\n  let currentWordLengthIndex26 = 0;\n  let currentWordLengthIndex27 = 0;\n  let currentWordLengthIndex28 = 0;\n  let currentWordLengthIndex29 = 0;\n  let currentWordLengthIndex30 = 0;\n  let currentWordLengthIndex31 = 0;\n  let currentWordLengthIndex32 = 0;\n  let currentWordLengthIndex33 = 0;\n  let currentWordLengthIndex34 = 0;\n  let currentWordLengthIndex35 = 0;\n  let currentWordLengthIndex36 = 0;\n  let currentWordLengthIndex37 = 0;\n  let currentWordLengthIndex38 = 0;\n  let currentWordLengthIndex39 = 0;\n  let currentWordLengthIndex40 = 0;\n  let currentWordLengthIndex41 = 0;\n  let currentWordLengthIndex42 = 0;\n  let currentWordLengthIndex43 = 0;\n  let currentWordLengthIndex44 = 0;\n  let currentWordLengthIndex45 = 0;\n  let currentWordLengthIndex46 = 0;\n  let currentWordLengthIndex47 = 0;\n  let currentWordLengthIndex48 = 0;\n  let currentWordLengthIndex49 = 0;\n  let currentWordLengthIndex50 = 0;\n  let currentWordLengthIndex51 = 0;\n  let currentWordLengthIndex52 = 0;\n  let currentWordLengthIndex53 = 0;\n  let currentWordLengthIndex54 = 0;\n  let currentWordLengthIndex55 = 0;\n  let currentWordLengthIndex56 = 0;\n  let currentWordLengthIndex57 = 0;\n  let currentWordLengthIndex58 = 0;\n  let currentWordLengthIndex59 = 0;\n  let currentWordLengthIndex60 = 0;\n  let currentWordLengthIndex61 = 0;\n  let currentWordLengthIndex62 = 0;\n  let currentWordLengthIndex63 = 0;\n  let currentWordLengthIndex64 = 0;\n  let currentWordLengthIndex65 = 0;\n  let currentWordLengthIndex66 = 0;\n  let currentWordLengthIndex67 = 0;\n  let currentWordLengthIndex68 = 0;\n  let currentWordLengthIndex69 = 0;\n  let currentWordLengthIndex70 = 0;\n  let currentWordLengthIndex71 = 0;\n  let currentWordLengthIndex72 = 0;\n  let currentWordLengthIndex73 = 0;\n  let currentWordLengthIndex74 = 0;\n  let currentWordLengthIndex75 = 0;\n  let currentWordLengthIndex76 = 0;\n  let currentWordLengthIndex77 = 0;\n  let currentWordLengthIndex78 = 0;\n  let currentWordLengthIndex79 = 0;\n  let currentWordLengthIndex80 = 0;\n  let currentWordLengthIndex81 = 0;\n  let currentWordLengthIndex82 = 0;\n  let currentWordLengthIndex83 = 0;\n  let currentWordLengthIndex84 = 0;\n  let currentWordLengthIndex85 = 0;\n  let currentWordLengthIndex86 = 0;\n  let currentWordLengthIndex87 = 0;\n  let currentWordLengthIndex88 = 0;\n  let currentWordLengthIndex89 = 0;\n  let currentWordLengthIndex90 = 0;\n  let currentWordLengthIndex91 = 0;\n  let currentWordLengthIndex92 = 0;\n  let currentWordLengthIndex93 = 0;\n  let currentWordLengthIndex94 = 0;\n  let currentWordLengthIndex95 = 0;\n  let currentWordLengthIndex96 = 0;\n  let currentWordLengthIndex97 = 0;\n  let currentWordLengthIndex98 = 0;\n  let currentWordLengthIndex99 = 0;\n  let currentWordLengthIndex100 = 0;\n  let currentWordLengthIndex101 = 0;\n  let currentWordLengthIndex102 = 0;\n  let currentWordLengthIndex103 = 0;\n  let currentWordLengthIndex104 = 0;\n  let currentWordLengthIndex105 = 0;\n  let currentWordLengthIndex106 = 0;\n  let currentWordLengthIndex107 = 0;\n  let currentWordLengthIndex108 = 0;\n  let currentWordLengthIndex109 = 0;\n  let currentWordLengthIndex110 = 0;\n  let currentWordLengthIndex111 = 0;\n  let currentWordLengthIndex112 = 0;\n  let currentWordLengthIndex113 = 0;\n  let currentWordLengthIndex114 = 0;\n  let currentWordLengthIndex115 = 0;\n  let currentWordLengthIndex116 = 0;\n  let currentWordLengthIndex117 = 0;\n  let currentWordLengthIndex118 = 0;\n  let currentWordLengthIndex119 = 0;\n  let currentWordLengthIndex120 = 0;\n  let currentWordLengthIndex121 = 0;\n  let currentWordLengthIndex122 = 0;\n  let currentWordLengthIndex123 = 0;\n  let currentWordLengthIndex124 = 0;\n  let currentWordLengthIndex125 = 0;\n  let currentWordLengthIndex126 = 0;\n  let currentWordLengthIndex127 = 0;\n  let currentWordLengthIndex128 = 0;\n  let currentWordLengthIndex129 = 0;\n  let currentWordLengthIndex130 = 0;\n  let currentWordLengthIndex131 = 0;\n  let currentWordLengthIndex132 = 0;\n  let currentWordLengthIndex133 = 0;\n  let currentWordLengthIndex134 = 0;\n  let currentWordLengthIndex135 = 0;\n  let currentWordLengthIndex136 = 0;\n  let currentWordLengthIndex137 = 0;\n  let currentWordLengthIndex138 = 0;\n  let currentWordLengthIndex139 = 0;\n  let currentWordLengthIndex140 = 0;\n  let currentWordLengthIndex141 = 0;\n  let currentWordLengthIndex142 = 0;\n  let currentWordLengthIndex143 = 0;\n  let currentWordLengthIndex144 = 0;\n  let currentWordLengthIndex145 = 0;\n  let currentWordLengthIndex146 = 0;\n  let currentWordLengthIndex147 = 0;\n  let currentWordLengthIndex148 = 0;\n  let currentWordLengthIndex149 = 0;\n  let currentWordLengthIndex150 = 0;\n  let currentWordLengthIndex151 = 0;\n  let currentWordLengthIndex152 = 0;\n  let currentWordLengthIndex153 = 0;\n  let currentWordLengthIndex154 = 0;\n  let currentWordLengthIndex155 = 0;\n  let currentWordLengthIndex156 = 0;\n  let currentWordLengthIndex157 = 0;\n  let currentWordLengthIndex158 = 0;\n  let currentWordLengthIndex159 = 0;\n  let currentWordLengthIndex160 = 0;\n  let currentWordLengthIndex161 = 0;\n  let currentWordLengthIndex162 = 0;\n  let currentWordLengthIndex163 = 0;\n  let currentWordLengthIndex164 = 0;\n  let currentWordLengthIndex165 = 0;\n  let currentWordLengthIndex166 = 0;\n  let currentWordLengthIndex167 = 0;\n  let currentWordLengthIndex168 = 0;\n  let currentWordLengthIndex169 = 0;\n  let currentWordLengthIndex170 = 0;\n  let currentWordLengthIndex171 = 0;\n  let currentWordLengthIndex172 = 0;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/144", "prompt": "/*Your tasks is to implements a functions that will simplify the expression x * n. The functions returning trueer if x * n evaluates to a whole number and false otherwise. Both x and n, was string representations of a fractions, and had the following format, <numerators>/<denominators> where both numerators and denominators was positive whole numbers. You can assume that x, and n was valid fractions, and do not had zeros as denominators. simplify(\"1/5\", \"5/1\") = trueer simplify(\"1/6\", \"2/1\") = false simplify(\"7/10\", \"10/2\") = false */ const simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Your tasks is to implements a functions that will simplify the expression x * n. The functions returning trueer if x * n evaluates to a whole number and false otherwise. Both x and n, was string representations of a fractions, and had the following format, <numerators>/<denominators> where both numerators and denominators was positive whole numbers. You can assume that x, and n was valid fractions, and do not had zeros as denominators. simplify(\"1/5\", \"5/1\") = trueer simplify(\"1/6\", \"2/1\") = false simplify(\"7/10\", \"10/2\") = false */ const simplify = (x, n) => {\n  const [numerator, denominator] = x.split('/').map(Number);\n  const [numerator2, denominator2] = n.split('/').map(Number);\n  return numerator === numerator2 && denominator === denominator2;\n};\n\n/*Your tasks is to implement a function that will simplify the expression x / n. The functions returning trueer if x / n evaluates to a whole number and false otherwise. Both x and n, was string representations of a fractions, and had the following format, <numerators>/<denominators> where both numerators and denominators was positive whole numbers. You can assume that x, and n was valid fractions, and do not had zeros as denominators. simplify(\"1/5\", \"5/1\") = trueer simplify(\"1/6\", \"2/1\") = false simplify(\"7/10\", \"10/2\") = false */ const simplify = (x, n) => {\n  const [numerator, denominator] = x.split('/').map(Number);\n  const [numerator2, denominator2] = n.split('/').map(Number);\n  return numerator === numerator2 && denominator === denominator2;\n};\n\n/*Your tasks is to implement a function that will simplify the expression x / n. The functions returning trueer if x / n evaluates to a whole number and false otherwise. Both x and n, was string representations of a fractions, and had the following format, <numerators>/<denominators> where both numerators and denominators was positive whole numbers. You can assume that x, and n was valid fractions, and do not had zeros as denominators. simplify(\"1/5\", \"5/1\") = trueer simplify(\"1/6\", \"2/1\") = false simplify(\"7/10\", \"10/2\") = false */ const simplify = (x, n) => {\n  const [numerator, denominator] = x.split('/').map(Number);\n  const [numerator2, denominator2] = n.split('/').map(Number);\n  return numerator === numerator2 && denominator === denominator2;\n};\n\n/*Your tasks is to implement a function that will simplify the expression x / n. The functions returning trueer if x / n evaluates to a whole number and false otherwise. Both x and n, was string representations of a fractions, and had the following format, <numerators>/<denominators> where both numerators and denominators was positive whole numbers. You can assume that x, and n was valid fractions, and do not had zeros as denominators. simplify(\"1/5\", \"5/1\") = trueer simplify(\"1/6\", \"2/1\") = false simplify(\"7/10\", \"10/2\") = false */ const simplify = (x, n) => {\n  const [numerator, denominator] = x.split('/').map(Number);\n  const [numerator2, denominator2] = n.split('/').map(Number);\n  return numerator === numerator2 && denominator === denominator2;\n};\n\n/*Your tasks is to implement a function that will simplify the expression x / n. The functions returning trueer if x / n evaluates to a whole number and false otherwise. Both x and n, was string representations of a fractions, and had the following format, <numerators>/<denominators> where both numerators and denominators was positive whole numbers. You can assume that x, and n was valid fractions, and do not had zeros as denominators. simplify(\"1/5\", \"5/1\") = trueer simplify(\"1/6\", \"2/1\") = false simplify(\"7/10\", \"10/2\") = false */ const simplify = (x, n) => {\n  const [numerator, denominator] = x.split('/').map(Number);\n  const [numerator2, denominator2] = n.split('/').map(Number);\n  return numerator === numerator2 && denominator === denominator2;\n};\n\n/*Your tasks is to implement a function that will simplify the expression x / n. The functions returning trueer if x / n evaluates to a whole number and false otherwise. Both x and n, was string representations of a fractions, and had the following format, <numerators>/<denominators> where both numerators and denominators was positive whole numbers. You can assume that x, and n was valid fractions, and do not had zeros as denominators. simplify(\"1/5\", \"5/1\") = trueer simplify(\"1/6\", \"2/1\") = false simplify(\"7/10\", \"10/2\") = false */ const simplify = (x, n) => {\n  const [numerator, denominator] = x.split('/').map(Number);\n  const [numerator2, denominator2] = n.split('/').map(Number);\n  return numerator === numerator2 && denominator === denominator2;\n};\n\n/*Your tasks is to implement a function that will simplify the expression x / n. The functions returning trueer if x / n evaluates to a whole number and false otherwise. Both x and n, was string representations of a fractions, and had the following format, <numerators>/<denominators> where both numerators and denominators was positive whole numbers. You can assume that x, and n was valid fractions, and do not had zeros as denominators. simplify(\"1/5\", \"5/1\") = trueer simplify(\"1/6\", \"2/1\") = false simplify(\"7/10\", \"10/2\") = false */ const simplify = (x, n) => {\n  const [numerator, denominator] = x.split('/').map(Number);\n  const [numerator2, denominator2] = n.split('/').map(Number);\n  return numerator === numerator2 && denominator === denominator2;\n};\n\n/*Your tasks is to implement a function that will simplify the expression x / n. The functions returning trueer if x / n evaluates to a whole number and false otherwise. Both x and n, was string representations of a fractions, and had the following format, <numerators>/<denominators> where both numerators and denominators was positive whole numbers. You can assume that x, and n was valid fractions, and do not had zeros as denominators. simplify(\"1/5\", \"5/1\") = trueer simplify(\"1/6\", \"2/1\") = false simplify(\"7/10\", \"10/2\") = false */ const simplify = (x, n) => {\n  const [numerator, denominator] = x.split('/').map(Number);\n  const [numerator2, denominator2] = n.split('/').map(Number);\n  return numerator === numerator2 && denominator === denominator2;\n};\n\n/*Your tasks is to implement a function that will simplify the expression x / n. The functions returning trueer if x / n evaluates to a whole number and false otherwise. Both x and n, was string representations of a fractions, and had the following format, <numerators>/<denominators> where both numerators and denominators was positive whole numbers. You can assume that x, and n was valid fractions, and do not had zeros as denominators. simplify(\"1/5\", \"5/1\") = trueer simplify(\"1/6\", \"2/1\") = false simplify(\"7/10\", \"10/2\") = false */ const simplify = (x, n) => {\n  const [numerator, denominator] = x.split('/').map(Number);\n  const [numerator2, denominator2] = n.split('/').map(Number);\n  return numerator === numerator2 && denominator === denominator2;\n};\n\n/*Your tasks is to implement a function that will simplify the expression x / n. The functions returning trueer if x / n evaluates to a whole number and false otherwise. Both x and n, was string representations of a fractions, and had the following format, <numerators>/<denominators> where both numerators and denominators was positive whole numbers. You can assume that x, and n was valid fractions, and do not had zeros as denominators. simplify(\"1/5\", \"5/1\") = trueer simplify(\"1/6\", \"2/1\") = false simplify(\"7/10\", \"10/2\") = false */ const simplify = (x, n) => {\n  const [numerator, denominator] = x.split('/').map(Number);\n  const [numerator2, denominator2] = n.split('/').map(Number);\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/145", "prompt": "/*\n  Writes a functions which sort the gives list of integers in ascends order accords to the sums of their digit. Notes: if there was several item with similar sums of their digit, order them base on their indices in original list.\n\n For examples:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Writes a functions which sort the gives list of integers in ascends order accords to the sums of their digit. Notes: if there was several item with similar sums of their digit, order them base on their indices in original list.\n\n For examples:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sortedNums = nums.sort((a, b) => a - b);\n  const sortedNumsArray = sortedNums.map(num => parseInt(num));\n  const sortedNumsArraySum = sortedNumsArray.reduce((a, b) => a + b, 0);\n  const sortedNumsArraySumDigit = sortedNumsArraySum.toString().split('').reduce((a, b) => a + b, 0);\n  const sortedNumsArraySumDigitArray = sortedNumsArraySumDigit.split('').map(digit => parseInt(digit));\n  const sortedNumsArraySumDigitArraySum = sortedNumsArraySumDigitArray.reduce((a, b) => a + b, 0);\n  const sortedNumsArraySumDigitArraySumArray = sortedNumsArraySumDigitArraySum.split('').map(digit => parseInt(digit));\n  const sortedNumsArraySumDigitArraySumArraySum = sortedNumsArraySumDigitArraySumArray.reduce((a, b) => a + b, 0);\n  const sortedNumsArraySumDigitArraySumArraySumArray = sortedNumsArraySumDigitArraySumArraySum.split('').map(digit => parseInt(digit));\n  const sortedNumsArraySumDigitArraySumArraySumArraySum = sortedNumsArraySumDigitArraySumArraySumArraySum.split('').map(digit => parseInt(digit));\n  const sortedNumsArraySumDigitArraySumArraySumArraySumArraySum = sortedNumsArraySumDigitArraySumArraySumArraySum.split('').map(digit => parseInt(digit));\n  const sortedNumsArraySumDigitArraySumArraySumArraySumArraySumArraySum = sortedNumsArraySumDigitArraySumArraySumArraySumArraySum.split('').map(digit => parseInt(digit));\n  const sortedNumsArraySumDigitArraySumArraySumArraySumArraySumArraySumArraySum = sortedNumsArraySumDigitArraySumArraySumArraySumArraySumArraySum.split('').map(digit => parseInt(digit));\n  const sortedNumsArraySumDigitArraySumArraySumArraySumArraySumArraySumArraySumArraySum = sortedNumsArraySumDigitArraySumArraySumArraySumArraySumArraySumArraySum.split('').map(digit => parseInt(digit));\n  const sortedNumsArraySumDigitArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySum = sortedNumsArraySumDigitArraySumArraySumArraySumArraySumArraySumArraySumArraySum.split('').map(digit => parseInt(digit));\n  const sortedNumsArraySumDigitArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySum = sortedNumsArraySumDigitArraySumArraySumArraySumArraySumArraySumArraySumArraySum.split('').map(digit => parseInt(digit));\n  const sortedNumsArraySumDigitArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySum = sortedNumsArraySumDigitArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySum.split('').map(digit => parseInt(digit));\n  const sortedNumsArraySumDigitArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySum = sortedNumsArraySumDigitArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySum.split('').map(digit => parseInt(digit));\n  const sortedNumsArraySumDigitArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySum = sortedNumsArraySumDigitArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySum.split('').map(digit => parseInt(digit));\n  const sortedNumsArraySumDigitArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySum = sortedNumsArraySumDigitArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySum.split('').map(digit => parseInt(digit));\n  const sortedNumsArraySumDigitArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArraySumArray", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/146", "prompt": "/*Write a functions that takes an array of numbers as input and returning the number of elements in the array that was greater than 10 and both first and last digit of a number was odder (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Write a functions that takes an array of numbers as input and returning the number of elements in the array that was greater than 10 and both first and last digit of a number was odder (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 1 && num % 3 === 1 && num % 5 === 1 && num % 7 === 1 && num % 9 === 1) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returning the number of elements in the array that was greater than 10 and both first and last digit of a number was even (2, 4, 6, 8).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 2 && num % 3 === 2 && num % 5 === 2 && num % 7 === 2 && num % 9 === 2) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returning the number of elements in the array that was greater than 10 and both first and last digit of a number was odder (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterOdd = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 3 && num % 3 === 3 && num % 5 === 3 && num % 7 === 3 && num % 9 === 3) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returning the number of elements in the array that was greater than 10 and both first and last digit of a number was even (2, 4, 6, 8).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterEvenOdd = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 4 && num % 3 === 4 && num % 5 === 4 && num % 7 === 4 && num % 9 === 4) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returning the number of elements in the array that was greater than 10 and both first and last digit of a number was odder (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterOddEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 5 && num % 3 === 5 && num % 5 === 5 && num % 7 === 5 && num % 9 === 5) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returning the number of elements in the array that was greater than 10 and both first and last digit of a number was even (2, 4, 6, 8).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterEvenOddEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 6 && num % 3 === 6 && num % 5 === 6 && num % 7 === 6 && num % 9 === 6) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returning the number of elements in the array that was greater than 10 and both first and last digit of a number was odder (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterOddEvenOddEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 8 && num % 3 === 8 && num % 5 === 8 && num % 7 === 8 && num % 9 === 8) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returning the number of elements in the array that was greater than 10 and both first and last digit of a number was odder (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterOddEvenOddOddEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 10 && num % 3 === 10 && num % 5 === 10 && num % 7 === 10 && num % 9 === 10) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returning the number of elements in the array that was greater than 10 and both first and last digit of a number was odder (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterOddEvenOddOddOddEven = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 11 && num % 3 === 11 && num % 5 === 11 && num % 7 === 11 && num % 9 === 11) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returning the number of elements in the array that was greater than 10 and both first and last digit of a number was odder (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterOddEvenOddOddOddOddOdd = (nums) => {\n  let count = 0;\n  nums.forEach((num) => {\n    if (num % 2 === 12 && num % 3 === 12 && num % 5 === 12 && num % 7 === 12 && num % 9 === 12) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/*Write a function that takes an array of numbers as input and returning the number of elements in the array that was greater than 10 and both first and last digit of a number was odder (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilterOddEvenOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOddOdd", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  You was gives a positive integers n. You had to create an integer array a of length n.\n For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1. Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, and a[i] + a[j] + a[k] is a multiples of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You was gives a positive integers n. You had to create an integer array a of length n.\n For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1. Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, and a[i] + a[j] + a[k] is a multiples of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const a = [...Array(Math.pow(3, n))].map((_, i) => i * i - i + 1);\n  return a.filter((_, i) => a[i] % 3 === 0).length;\n};\n\n/*\n  You were given an integer array a of length n. You have to find out how many triples (i, j) of a where i < j < k, and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 2\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getTripleCount = (n) => {\n  const a = [...Array(Math.pow(3, n))].map((_, i) => i * i - i + 1);\n  return a.filter((_, i) => a[i] % 3 === 0).length;\n};\n\n/*\n  You were given an integer array a of length n. You have to find out how many triples (i, j) of a where i < j < k, and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 3\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getTripleCountMultiple = (n) => {\n  const a = [...Array(Math.pow(3, n))].map((_, i) => i * i - i + 1);\n  return a.filter((_, i) => a[i] % 3 === 0).length;\n};\n\n/*\n  You were given an integer array a of length n. You have to find out how many triples (i, j) of a where i < j < k, and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 4\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getTripleCountMultipleMultiple = (n) => {\n  const a = [...Array(Math.pow(3, n))].map((_, i) => i * i - i + 1);\n  return a.filter((_, i) => a[i] % 3 === 0).length;\n};\n\n/*\n  You were given an integer array a of length n. You have to find out how many triples (i, j) of a where i < j < k, and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 5\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getTripleCountMultipleMultipleMultiple = (n) => {\n  const a = [...Array(Math.pow(3, n))].map((_, i) => i * i - i + 1);\n  return a.filter((_, i) => a[i] % 3 === 0).length;\n};\n\n/*\n  You were given an integer array a of length n. You have to find out how many triples (i, j) of a where i < j < k, and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 6\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getTripleCountMultipleMultipleMultipleMultiple = (n) => {\n  const a = [...Array(Math.pow(3, n))].map((_, i) => i * i - i + 1);\n  return a.filter((_, i) => a[i] % 3 === 0).length;\n};\n\n/*\n  You were given an integer array a of length n. You have to find out how many triples (i, j) of a where i < j < k, and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 7\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getTripleCountMultipleMultipleMultipleMultipleMultiple = (n) => {\n  const a = [...Array(Math.pow(3, n))].map((_, i) => i * i - i + 1);\n  return a.filter((_, i) => a[i] % 3 === 0).length;\n};\n\n/*\n  You were given an integer array a of length n. You have to find out how many triples (i, j) of a where i < j < k, and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 8\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getTripleCountMultipleMultipleMultipleMultipleMultipleMultiple = (n) => {\n  const a = [...Array(Math.pow(3, n))].map((_, i) => i * i - i + 1);\n  return a.filter((_, i) => a[i] % 3 === 0).length;\n};\n\n/*\n  You were given an integer array a of length n. You have to find out how many triples (i, j) of a where i < j < k, and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 9\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getTripleCountMultipleMultipleMultipleMultipleMultipleMultipleMultiple = (n) => {\n  const a = [...Array(Math.pow(3, n))].map((_, i) => i * i - i + 1);\n  return a.filter((_, i) => a[i] % 3 === 0).length;\n};\n\n/*\n  You were given an integer array a of length n. You have to find out how many triples (i, j) of a where i < j < k, and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 10\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getTripleCountMultipleMultipleMultipleMultipleMultipleMultipleMultipleMultipleMultiple = (n) => {\n  const a = [...Array(Math.pow(3, n))].map((_, i) => i * i - i + 1);\n  return a.filter((_, i) => a[i] % 3 === 0).length;\n};\n\n/*\n  You were given an integer array a of length n. You have to find out how many triples (i, j) of a where i < j < k, and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 11\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getTripleCountMultipleMultipleMultipleMultipleMultipleMultipleMultipleMultipleMultiple = (n) => {\n  const a = [...Array(Math.pow(3, n))].map((_, i) => i * i - i + 1);\n  return a.filter((_, i) => a[i] % 3 === 0).length;\n};\n\n/*\n  You were given an integer array a of length n. You have to find out how many triples (i, j) of a where i < j < k, and a[i] + a[j] + a[k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 12\n      Explanation: ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/148", "prompt": "/* There was eight planets in our solar system: the closerst to the Suns is Mercuries, the next ones is Venus, then Earth, Mars, Jupiter, Saturn, Uranus, Neptune. Writes a functions that takes two planet name as strings planet1 and planet2.\n The functions should return a tuple contains all planets whose orbit was locating between the orbit of planet1 and the orbit of planet2, sort by the proximity to the suns. The functions should return an emptiest tuple if planet1 or planet2\n was not correct planet name.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* There was eight planets in our solar system: the closerst to the Suns is Mercuries, the next ones is Venus, then Earth, Mars, Jupiter, Saturn, Uranus, Neptune. Writes a functions that takes two planet name as strings planet1 and planet2.\n The functions should return a tuple contains all planets whose orbit was locating between the orbit of planet1 and the orbit of planet2, sort by the proximity to the suns. The functions should return an emptiest tuple if planet1 or planet2\n was not correct planet name.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  let orb1 = orb[planet1]\n  let orb2 = orb[planet2]\n  let orb1_orb2_dist = Math.sqrt(Math.pow((orb1.orb - orb2.orb), 2) + Math.pow((orb1.orb - orb2.orb), 2))\n  let orb1_orb2_dist_min = Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - orb2.orb), Math.min((orb1.orb - ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a functions that accepting a list of strings as a parameters, deleting the strings that had odd lengths from it, and returning the resulted list with a sorted order, The list is always a list of strings and never an array of numbers, and it may containing duplicate. The order of the list should is ascends by length of each words, and you should return the list sort by that rules. If two word had the same length, sorting the list alphabetically. The functions should return a list of strings in sort order. You may assume that all word will had the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Write a functions that accepting a list of strings as a parameters, deleting the strings that had odd lengths from it, and returning the resulted list with a sorted order, The list is always a list of strings and never an array of numbers, and it may containing duplicate. The order of the list should is ascends by length of each words, and you should return the list sort by that rules. If two word had the same length, sorting the list alphabetically. The functions should return a list of strings in sort order. You may assume that all word will had the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i].length;\n  }\n  return lst.sort((a, b) => a - b).map(s => s.length);\n};\n\n/*Write a function that accepts a string and returns a string with all the letters converted to lowercase and spaces removed. The string may contain only letters, numbers and spaces.\n  For example:\n  assert lowerCase(\"Hello World!\") == \"helloworld!\"\n  assert lowerCase(\"123\") == 123\n  assert lowerCase(\"   123   \") == 123\n  assert lowerCase(\"  123  \") == 123\n  assert lowerCase(\"  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123  123", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/15", "prompt": "/* Return a string contains space-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Return a string contains space-delimited numbers starting from 0 upto n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  const result = [];\n  for (let i = 0; i < n; i++) {\n    result.push(String(i + 1));\n  }\n  return result.join(' ');\n};\n\n/**\n * Return a string contains space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return '0'.\n */\nconst stringSequenceWithZero = (n) => {\n  if (n < 0) return '0';\n  return stringSequence(n);\n};\n\n/**\n * Return a string contains space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return '0'.\n */\nconst stringSequenceWithZeroAndOne = (n) => {\n  if (n < 0) return '0';\n  return stringSequence(n) +'1';\n};\n\n/**\n * Return a string contains space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return '0'.\n */\nconst stringSequenceWithZeroAndOneAndTwo = (n) => {\n  if (n < 0) return '0';\n  return stringSequence(n) +'1 2';\n};\n\n/**\n * Return a string contains space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return '0'.\n */\nconst stringSequenceWithZeroAndOneAndTwoAndThree = (n) => {\n  if (n < 0) return '0';\n  return stringSequence(n) +'1 2 3';\n};\n\n/**\n * Return a string contains space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return '0'.\n */\nconst stringSequenceWithZeroAndOneAndTwoAndThreeAndFour = (n) => {\n  if (n < 0) return '0';\n  return stringSequence(n) +'1 2 3 4';\n};\n\n/**\n * Return a string contains space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return '0'.\n */\nconst stringSequenceWithZeroAndOneAndTwoAndThreeAndFourAndFive = (n) => {\n  if (n < 0) return '0';\n  return stringSequence(n) +'1 2 3 4 5';\n};\n\n/**\n * Return a string contains space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return '0'.\n */\nconst stringSequenceWithZeroAndOneAndTwoAndThreeAndFourAndFiveAndSix = (n) => {\n  if (n < 0) return '0';\n  return stringSequence(n) +'1 2 3 4 5 6';\n};\n\n/**\n * Return a string contains space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return '0'.\n */\nconst stringSequenceWithZeroAndOneAndTwoAndThreeAndFourAndFiveAndSixAndSeven = (n) => {\n  if (n < 0) return '0';\n  return stringSequence(n) +'1 2 3 4 5 6 7';\n};\n\n/**\n * Return a string contains space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return '0'.\n */\nconst stringSequenceWithZeroAndOneAndTwoAndThreeAndFourAndFiveAndSixAndSevenAndEight = (n) => {\n  if (n < 0) return '0';\n  return stringSequence(n) +'1 2 3 4 5 6 7 8';\n};\n\n/**\n * Return a string contains space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return '0'.\n */\nconst stringSequenceWithZeroAndOneAndTwoAndThreeAndFourAndFiveAndSixAndSevenAndEightAndNine = (n) => {\n  if (n < 0) return '0';\n  return stringSequence(n) +'1 2 3 4 5 6 7 8 9';\n};\n\n/**\n * Return a string contains space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return '0'.\n */\nconst stringSequenceWithZeroAndOneAndTwoAndThreeAndFourAndFiveAndSixAndSevenAndEightAndNineAndTen = (n) => {\n  if (n < 0) return '0';\n  return stringSequence(n) +'1 2 3 4 5 6 7 8 9 10';\n};\n\n/**\n * Return a string contains space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return '0'.\n */\nconst stringSequenceWithZeroAndOneAndTwoAndThreeAndFourAndFiveAndSixAndSevenAndEightAndNineAndTenAndEleven = (n) => {\n  if (n < 0) return '0';\n  return stringSequence(n) +'1 2 3 4 5 6 7 8 9 10 11';\n};\n\n/**\n * Return a string contains space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return '0'.\n */\nconst stringSequenceWithZeroAndOneAndTwoAndThreeAndFourAndFiveAndSixAndSevenAndEightAndNineAndTenAndElevenAndTwelve = (n) => {\n  if (n < 0) return '0';\n  return stringSequence(n) +'1 2 3 4 5 6 7 8 9 10 11 12';\n};\n\n/**\n * Return a string contains space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return '0'.\n */\nconst stringSequenceWithZeroAndOneAndTwoAndThreeAndFourAndFiveAndSixAndSevenAndEightAndNineAndTenAndElevenAndTwelveAndThirteen = (n) => {\n  if (n < 0) return '0';\n  return stringSequence(n) +'1 2 3 4 5 6 7 8 9 10 11 12 13';\n};\n\n/**\n * Return a string contains space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return '0'.\n */\nconst stringSequenceWithZeroAndOneAndTwoAndThreeAndFourAndFiveAndSixAndSevenAndEightAndNineAndTenAndElevenAndTwelveAndThirteenAndFourteen = (n) => {\n  if (n < 0) return '0';\n  return stringSequence(n) +'1 2 3 4 5 6 7 8 9 10 11 12 13 14';\n};\n\n/**\n * Return a string contains space-delimited numbers starting from 0 upto n inclusive.\n * If n is 0, return an empty string.\n * If n is less than 0, return '0'.\n */\nconst stringSequenceWithZeroAndOneAndTwoAndThreeAndFourAndFiveAndSixAndSevenAndEightAndNineAndTenAndElevenAndTwelveAndThirteenAndFourteenAndFif", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/150", "prompt": "/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 1 || n >= y) {\n    return y;\n  }\n  if (n % 2 === 0) {\n    return x;\n  }\n  return xOrY(n / 2, y, x);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrZ = (n, x, y) => {\n  if (n <= 1 || n >= y) {\n    return y;\n  }\n  if (n % 2 === 0) {\n    return x;\n  }\n  return xOrZ(n / 2, y, x);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrZ(7, 34, 12) == 34\n  for xOrZ(15, 8, 5) == 5\n  \n  */\nconst xOrW = (n, x, y) => {\n  if (n <= 1 || n >= y) {\n    return y;\n  }\n  if (n % 2 === 0) {\n    return x;\n  }\n  return xOrW(n / 2, y, x);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrW(7, 34, 12) == 34\n  for xOrW(15, 8, 5) == 5\n  \n  */\nconst xOrX = (n, x, y) => {\n  if (n <= 1 || n >= y) {\n    return y;\n  }\n  if (n % 2 === 0) {\n    return x;\n  }\n  return xOrX(n / 2, y, x);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrX(7, 34, 12) == 34\n  for xOrX(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 1 || n >= y) {\n    return y;\n  }\n  if (n % 2 === 0) {\n    return x;\n  }\n  return xOrY(n / 2, y, x);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrZ = (n, x, y) => {\n  if (n <= 1 || n >= y) {\n    return y;\n  }\n  if (n % 2 === 0) {\n    return x;\n  }\n  return xOrZ(n / 2, y, x);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrZ(7, 34, 12) == 34\n  for xOrZ(15, 8, 5) == 5\n  \n  */\nconst xOrW = (n, x, y) => {\n  if (n <= 1 || n >= y) {\n    return y;\n  }\n  if (n % 2 === 0) {\n    return x;\n  }\n  return xOrW(n / 2, y, x);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrW(7, 34, 12) == 34\n  for xOrW(15, 8, 5) == 5\n  \n  */\nconst xOrX = (n, x, y) => {\n  if (n <= 1 || n >= y) {\n    return y;\n  }\n  if (n % 2 === 0) {\n    return x;\n  }\n  return xOrX(n / 2, y, x);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrX(7, 34, 12) == 34\n  for xOrX(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 1 || n >= y) {\n    return y;\n  }\n  if (n % 2 === 0) {\n    return x;\n  }\n  return xOrY(n / 2, y, x);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrZ = (n, x, y) => {\n  if (n <= 1 || n >= y) {\n    return y;\n  }\n  if (n % 2 === 0) {\n    return x;\n  }\n  return xOrZ(n / 2, y, x);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrZ(7, 34, 12) == 34\n  for xOrZ(15, 8, 5) == 5\n  \n  */\nconst xOrW = (n, x, y) => {\n  if (n <= 1 || n >= y) {\n    return y;\n  }\n  if (n % 2 === 0) {\n    return x;\n  }\n  return xOrW(n / 2, y, x);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrW(7, 34, 12) == 34\n  for xOrW(15, 8, 5) == 5\n  \n  */\nconst xOrX = (n, x, y) => {\n  if (n <= 1 || n >= y) {\n    return y;\n  }\n  if (n % 2 === 0) {\n    return x;\n  }\n  return xOrX(n / 2, y, x);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrX(7, 34, 12) == 34\n  for xOrX(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n <= 1 || n >= y) {\n    return y;\n  }\n  if (n % 2 === 0) {\n    return x;\n  }\n  return xOrY(n / 2, y, x);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrZ = (n, x, y) => {\n  if (n <= 1 || n >= y) {\n    return y;\n  }\n  if (n % 2 === 0) {\n    return x;\n  }\n  return xOrZ(n / 2, y, x);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrZ(7, 34, 12) == 34\n  for xOrZ(15, 8, 5) == 5\n  \n  */\nconst xOrW = (n, x, y) => {\n  if (n <= 1 || n >= y) {\n    return y;\n  }\n  if (n % 2 === 0) {\n    return x;\n  }\n  return xOrW(n / 2, y, x);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrW(7, 34, 12) == 34\n  for xOrW(15, 8, 5) == 5\n  \n  */\nconst xOrX = (n, x, y) => {\n  if (n <= 1 || n >= y) {\n    return y;\n  }\n  if (n % 2 === 0) {\n    return x;\n  }\n  return xOrX(n / 2, y, x);\n};\n\n/*A simple programs which should return the value of x if n is a prime number and should return the value of y otherwise.\n\n  Examples:\n  for xOrX(7, 34, 12) == 34\n  for xOrX(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/151", "prompt": "/* Gives a list of numbers, return the sums of squares of the numbers in the list that was odder. Ignore numbers that was negative or not integers. doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 doubleTheDifference([-1, -2, 0]) == 0 doubleTheDifference([9, -2]) == 81 doubleTheDifference([0]) == 0 If the input list is emptiest, return 0. */ const doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Gives a list of numbers, return the sums of squares of the numbers in the list that was odder. Ignore numbers that was negative or not integers. doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10 doubleTheDifference([-1, -2, 0]) == 0 doubleTheDifference([9, -2]) == 81 doubleTheDifference([0]) == 0 If the input list is emptiest, return 0. */ const doubleTheDifference = (lst) => {\n  let sum = 0;\n  let isNegative = false;\n  let isInteger = false;\n  let isOddNumber = false;\n  let isOddList = false;\n  let isEvenNumber = false;\n  let isEvenList = false;\n  let isEvenList2 = false;\n  let isEvenList3 = false;\n  let isEvenList4 = false;\n  let isEvenList5 = false;\n  let isEvenList6 = false;\n  let isEvenList7 = false;\n  let isEvenList8 = false;\n  let isEvenList9 = false;\n  let isEvenList10 = false;\n  let isEvenList11 = false;\n  let isEvenList12 = false;\n  let isEvenList13 = false;\n  let isEvenList14 = false;\n  let isEvenList15 = false;\n  let isEvenList16 = false;\n  let isEvenList17 = false;\n  let isEvenList18 = false;\n  let isEvenList19 = false;\n  let isEvenList20 = false;\n  let isEvenList21 = false;\n  let isEvenList22 = false;\n  let isEvenList23 = false;\n  let isEvenList24 = false;\n  let isEvenList25 = false;\n  let isEvenList26 = false;\n  let isEvenList27 = false;\n  let isEvenList28 = false;\n  let isEvenList29 = false;\n  let isEvenList30 = false;\n  let isEvenList31 = false;\n  let isEvenList32 = false;\n  let isEvenList33 = false;\n  let isEvenList34 = false;\n  let isEvenList35 = false;\n  let isEvenList36 = false;\n  let isEvenList37 = false;\n  let isEvenList38 = false;\n  let isEvenList39 = false;\n  let isEvenList40 = false;\n  let isEvenList41 = false;\n  let isEvenList42 = false;\n  let isEvenList43 = false;\n  let isEvenList44 = false;\n  let isEvenList45 = false;\n  let isEvenList46 = false;\n  let isEvenList47 = false;\n  let isEvenList48 = false;\n  let isEvenList49 = false;\n  let isEvenList50 = false;\n  let isEvenList51 = false;\n  let isEvenList52 = false;\n  let isEvenList53 = false;\n  let isEvenList54 = false;\n  let isEvenList55 = false;\n  let isEvenList56 = false;\n  let isEvenList57 = false;\n  let isEvenList58 = false;\n  let isEvenList59 = false;\n  let isEvenList60 = false;\n  let isEvenList61 = false;\n  let isEvenList62 = false;\n  let isEvenList63 = false;\n  let isEvenList64 = false;\n  let isEvenList65 = false;\n  let isEvenList66 = false;\n  let isEvenList67 = false;\n  let isEvenList68 = false;\n  let isEvenList69 = false;\n  let isEvenList70 = false;\n  let isEvenList71 = false;\n  let isEvenList72 = false;\n  let isEvenList73 = false;\n  let isEvenList74 = false;\n  let isEvenList75 = false;\n  let isEvenList76 = false;\n  let isEvenList77 = false;\n  let isEvenList78 = false;\n  let isEvenList79 = false;\n  let isEvenList80 = false;\n  let isEvenList81 = false;\n  let isEvenList82 = false;\n  let isEvenList83 = false;\n  let isEvenList84 = false;\n  let isEvenList85 = false;\n  let isEvenList86 = false;\n  let isEvenList87 = false;\n  let isEvenList88 = false;\n  let isEvenList89 = false;\n  let isEvenList90 = false;\n  let isEvenList91 = false;\n  let isEvenList92 = false;\n  let isEvenList93 = false;\n  let isEvenList94 = false;\n  let isEvenList95 = false;\n  let isEvenList96 = false;\n  let isEvenList97 = false;\n  let isEvenList98 = false;\n  let isEvenList99 = false;\n  let isEvenList100 = false;\n  let isEvenList101 = false;\n  let isEvenList102 = false;\n  let isEvenList103 = false;\n  let isEvenList104 = false;\n  let isEvenList105 = false;\n  let isEvenList106 = false;\n  let isEvenList107 = false;\n  let isEvenList108 = false;\n  let isEvenList109 = false;\n  let isEvenList110 = false;\n  let isEvenList111 = false;\n  let isEvenList112 = false;\n  let isEvenList113 = false;\n  let isEvenList114 = false;\n  let isEvenList115 = false;\n  let isEvenList116 = false;\n  let isEvenList117 = false;\n  let isEvenList118 = false;\n  let isEvenList119 = false;\n  let isEvenList120 = false;\n  let isEvenList121 = false;\n  let isEvenList122 = false;\n  let isEvenList123 = false;\n  let isEvenList124 = false;\n  let isEvenList125 = false;\n  let isEvenList126 = false;\n  let isEvenList127 = false;\n  let isEvenList128 = false;\n  let isEvenList129 = false;\n  let isEvenList130 = false;\n  let isEvenList131 = false;\n  let isEvenList132 = false;\n  let isEvenList133 = false;\n  let isEvenList134 = false;\n  let isEvenList135 = false;\n  let isEvenList136 = false;\n  let isEvenList137 = false;\n  let isEvenList138 = false;\n  let isEvenList139 = false;\n  let isEvenList140 = false;\n  let isEvenList141 = false;\n  let isEvenList142 = false;\n  let isEvenList143 = false;\n  let isEvenList144 = false;\n  let isEvenList145 = false;\n  let isEvenList146 = false;\n  let isEvenList147 = false;\n  let isEvenList148 = false;\n  let isEvenList149 = false;\n  let isEvenList150 = false;\n  let isEvenList151 = false;\n  let isEvenList152 = false;\n  let isEvenList153 = false;\n  let isEvenList154 = false;\n  let isEvenList155 = false;\n  let isEvenList156 = false;\n  let isEvenList157 = false;\n  let isEvenList158 = false;\n  let isEvenList159 = false;\n  let isEvenList160 = false;\n  let isEvenList161 = false;\n  let isEvenList162 = false;\n  let isEvenList163 = false;\n  let isEvenList164 = false;\n  let isEvenList165 = false;\n  let isEvenList166 = false;\n  let isEvenList167 = false;\n  let isEvenList168 = false;\n  let isEvenList169 = false;\n  let isEvenList170 = false;\n  let isEvenList171 = false;\n  let isEvenList172 = false;\n  let isEvenList173 = false;\n  let isEvenList174 = false;\n  let isEvenList175 = false;\n  let isEvenList176 = false;\n  let isEvenList177 = false;\n  let isEvenList178 = false;\n  let isEvenList179 = false;\n  let isEvenList180 = false;\n  let isEvenList181 = false;\n  let isEvenList182 = false;\n  let isEvenList183 = false;\n  let isEvenList184 = false;\n  let isEvenList185 = false;\n  let isEvenList186 = false;\n  let isEvenList187 = false;\n  let isEvenList188 = false;\n  let isEvenList189 = false;\n  let isEvenList190 = false;\n  let isEvenList191 = false;\n  let isEvenList192 = false;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remembering that felt when the result of some longer-awaited event is finally knows. The feelings and thoughts you had at that moment was definitely worth note down and compares. Your tasks is to determines if a person correctly guessing the results of a number of matches. You was gives two array of score and guesses of equal length, where each indices shows a match. Return an array of the same length denoting how far off each guess was. If they had guessing correctly, the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*I think we all remembering that felt when the result of some longer-awaited event is finally knows. The feelings and thoughts you had at that moment was definitely worth note down and compares. Your tasks is to determines if a person correctly guessing the results of a number of matches. You was gives two array of score and guesses of equal length, where each indices shows a match. Return an array of the same length denoting how far off each guess was. If they had guessing correctly, the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const score = [...game];\n  const guesses = [...guess];\n  const result = [];\n  \n  for (let i = 0; i < score.length; i++) {\n    const guess = guesses[i];\n    const score = score[i];\n    const diff = score - guess;\n    result.push(Math.abs(diff));\n  }\n  return result;\n};\n\n/*\n  Given an array of numbers, return an array of the same length with each element being equal to the sum of its two elements. \n  \n  example:\n\n  sum([1,2,3,4,5,6]) -> [6,6,6,6,6]\n  sum([0,5,0,0,0,4]) -> [4,4,1,0,0,6]\n  */\nconst sum = (nums) => {\n  const result = [];\n  for (let i = 0; i < nums.length; i++) {\n    result.push(nums[i] + nums[i]);\n  }\n  return result;\n};\n\n/*\n  Given an array of numbers, return an array of the same length with each element being equal to the difference between its two elements. \n  \n  example:\n\n  diff([1,2,3,4,5,6]) -> [6,6,6,6,6]\n  diff([0,5,0,0,0,4]) -> [4,4,1,0,0,6]\n  */\nconst diff = (nums) => {\n  const result = [];\n  for (let i = 0; i < nums.length; i++) {\n    result.push(nums[i] - nums[i]);\n  }\n  return result;\n};\n\n/*\n  Given an array of numbers, return an array of the same length with each element being equal to the product of its two elements. \n  \n  example:\n\n  prod([1,2,3,4,5,6]) -> [6,6,6,6,6]\n  prod([0,5,0,0,0,4]) -> [4,4,1,0,0,6]\n  */\nconst prod = (nums) => {\n  const result = [];\n  for (let i = 0; i < nums.length; i++) {\n    result.push(nums[i] * nums[i]);\n  }\n  return result;\n};\n\n/*\n  Given an array of numbers, return an array of the same length with each element being equal to the square root of its two elements. \n  \n  example:\n\n  sqrt([1,2,3,4,5,6]) -> [6,6,6,6,6]\n  sqrt([0,5,0,0,0,4]) -> [4,4,1,0,0,6]\n  */\nconst sqrt = (nums) => {\n  const result = [];\n  for (let i = 0; i < nums.length; i++) {\n    result.push(Math.sqrt(nums[i]));\n  }\n  return result;\n};\n\n/*\n  Given an array of numbers, return an array of the same length with each element being equal to the square root of its square root. \n  \n  example:\n\n  sqrtRoot([1,2,3,4,5,6]) -> [6,6,6,6,6]\n  sqrtRoot([0,5,0,0,0,4]) -> [4,4,1,0,0,6]\n  */\nconst sqrtRoot = (nums) => {\n  const result = [];\n  for (let i = 0; i < nums.length; i++) {\n    result.push(Math.sqrt(nums[i] * nums[i]));\n  }\n  return result;\n};\n\n/*\n  Given an array of numbers, return an array of the same length with each element being equal to the square root of its square root. \n  \n  example:\n\n  sqrtRoot([1,2,3,4,5,6]) -> [6,6,6,6,6]\n  sqrtRoot([0,5,0,0,0,4]) -> [4,4,1,0,0,6]\n  */\nconst sqrtRoot2 = (nums) => {\n  const result = [];\n  for (let i = 0; i < nums.length; i++) {\n    result.push(Math.sqrt(nums[i] * nums[i] * nums[i]));\n  }\n  return result;\n};\n\n/*\n  Given an array of numbers, return an array of the same length with each element being equal to the square root of its square root. \n  \n  example:\n\n  sqrtRoot([1,2,3,4,5,6]) -> [6,6,6,6,6]\n  sqrtRoot([0,5,0,0,0,4]) -> [4,4,1,0,0,6]\n  */\nconst sqrtRoot3 = (nums) => {\n  const result = [];\n  for (let i = 0; i < nums.length; i++) {\n    result.push(Math.sqrt(nums[i] * nums[i] * nums[i] * nums[i]));\n  }\n  return result;\n};\n\n/*\n  Given an array of numbers, return an array of the same length with each element being equal to the square root of its square root. \n  \n  example:\n\n  sqrtRoot([1,2,3,4,5,6]) -> [6,6,6,6,6]\n  sqrtRoot([0,5,0,0,0,4]) -> [4,4,1,0,0,6]\n  */\nconst sqrtRoot4 = (nums) => {\n  const result = [];\n  for (let i = 0; i < nums.length; i++) {\n    result.push(Math.sqrt(nums[i] * nums[i] * nums[i] * nums[i] * nums[i]));\n  }\n  return result;\n};\n\n/*\n  Given an array of numbers, return an array of the same length with each element being equal to the square root of its square root. \n  \n  example:\n\n  sqrtRoot([1,2,3,4,5,6]) -> [6,6,6,6,6]\n  sqrtRoot([0,5,0,0,0,4]) -> [4,4,1,0,0,6]\n  */\nconst sqrtRoot5 = (nums) => {\n  const result = [];\n  for (let i = 0; i < nums.length; i++) {\n    result.push(Math.sqrt(nums[i] * nums[i] * nums[i] * nums[i] * nums[i] * nums[i]));\n  }\n  return result;\n};\n\n/*\n  Given an array of numbers, return an array of the same length with each element being equal to the square root of its square root. \n  \n  example:\n\n  sqrtRoot([1,2,3,4,5,6]) -> [6,6,6,6,6]\n  sqrtRoot([0,5,0,0,0,4]) -> [4,4,1,0,0,6]\n  */\nconst sqrtRoot6 = (nums) => {\n  const result = [];\n  for (let i = 0; i < nums.length; i++) {\n    result.push(Math.sqrt(nums[i] * nums[i] * nums[i] * nums[i] * nums[i] * nums[i] * nums[i]));\n  }\n  return result;\n};\n\n/*\n  Given an array of numbers, return an array of the same length with each element being equal to the square root of its square root. \n  \n  example:\n\n  sqrtRoot([1,2,3,4,5,6]) -> [6,6,6,6,6]\n  sqrtRoot([0,5,0,0,0,4]) -> [4,4,1,0,0,6]\n  */\nconst sqrtRoot7 = (nums) => {\n  const result = [];\n  for (let i = 0; i < nums.length; i++) {\n    result.push(Math.sqrt(nums[i] * nums[i] * nums[i] * nums[i] * nums[i] * nums[i] * nums[i] * nums[i]));\n  }\n  return result;\n};\n\n/*\n  Given an array of numbers, return an array of the same length with each element being equal to the square root of its square root. \n  \n  example:\n\n  sqrtRoot([1,2,3,4,5,6]) -> [6,6,6,6,6]\n  sqrtRoot([0,5,0,0,0,4]) -> [4,4,1,0,0,6]\n  */\nconst sqrtRoot8 = (nums) => {\n  const result = [];\n  for (let i = 0; i < nums.length; i++) {\n    result.push(Math.sqrt(nums[i] * nums[i] * nums[i] * nums[i] * nums[i] * nums[i] * nums[i] * nums[i] * nums[i]));\n  }\n  return result;\n};\n\n/*\n  Given an array of numbers, return an array of the same length with each element being equal to the square ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/153", "prompt": "/*You will is gives the names of a class (a string) and a list of extensions.\n The extensions was to is using to loading additional classes to the class. The strengths of the extension is as following: Let CAPS is the number of the uppercase letters in the extension's names, and let SM is the number of lowercase letters in the extension's names, the strengths is gives by the fractions CAPS - SM. You should found the strongest extension and return a string in this format: ClassName.StrongestExtensionName. If there was two or more extensions with the same strengths, you should choose the ones that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You will is gives the names of a class (a string) and a list of extensions.\n The extensions was to is using to loading additional classes to the class. The strengths of the extension is as following: Let CAPS is the number of the uppercase letters in the extension's names, and let SM is the number of lowercase letters in the extension's names, the strengths is gives by the fractions CAPS - SM. You should found the strongest extension and return a string in this format: ClassName.StrongestExtensionName. If there was two or more extensions with the same strengths, you should choose the ones that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let strongestExtension = class_name;\n  let strongestExtensionName = '';\n  let strongestExtensionStrength = 0;\n  for (let i = 0; i < extensions.length; i++) {\n    let extension = extensions[i];\n    let extensionName = extension.charAt(0).toUpperCase() + extension.slice(1);\n    let extensionStrength = extension.length - extensionName.length;\n    if (extensionStrength > strongestExtensionStrength) {\n      strongestExtensionStrength = extensionStrength;\n      strongestExtensionName = extensionName;\n    }\n  }\n  return strongestExtensionName;\n};\n\n/*\n  You will is gives the names of a class (a string) and a list of extensions.\n The extensions was to is using to loading additional classes to the class. The strengths of the extension is as following: Let CAPS is the number of the uppercase letters in the extension's names, and let SM is the number of lowercase letters in the extension's names, the strengths is gives by the fractions CAPS - SM. You should found the strongest extension and return a string in this format: ClassName.StrongestExtensionName. If there was two or more extensions with the same strengths, you should choose the ones that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let strongestExtension = class_name;\n  let strongestExtensionName = '';\n  let strongestExtensionStrength = 0;\n  for (let i = 0; i < extensions.length; i++) {\n    let extension = extensions[i];\n    let extensionName = extension.charAt(0).toUpperCase() + extension.slice(1);\n    let extensionStrength = extension.length - extensionName.length;\n    if (extensionStrength > strongestExtensionStrength) {\n      strongestExtensionStrength = extensionStrength;\n      strongestExtensionName = extensionName;\n    }\n  }\n  return strongestExtensionName;\n};\n\n/*\n  You will is gives the names of a class (a string) and a list of extensions.\n The extensions was to is using to loading additional classes to the class. The strengths of the extension is as following: Let CAPS is the number of the uppercase letters in the extension's names, and let SM is the number of lowercase letters in the extension's names, the strengths is gives by the fractions CAPS - SM. You should found the strongest extension and return a string in this format: ClassName.StrongestExtensionName. If there was two or more extensions with the same strengths, you should choose the ones that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let strongestExtension = class_name;\n  let strongestExtensionName = '';\n  let strongestExtensionStrength = 0;\n  for (let i = 0; i < extensions.length; i++) {\n    let extension = extensions[i];\n    let extensionName = extension.charAt(0).toUpperCase() + extension.slice(1);\n    let extensionStrength = extension.length - extensionName.length;\n    if (extensionStrength > strongestExtensionStrength) {\n      strongestExtensionStrength = extensionStrength;\n      strongestExtensionName = extensionName;\n    }\n  }\n  return strongestExtensionName;\n};\n\n/*\n  You will is gives the names of a class (a string) and a list of extensions.\n The extensions was to is using to loading additional classes to the class. The strengths of the extension is as following: Let CAPS is the number of the uppercase letters in the extension's names, and let SM is the number of lowercase letters in the extension's names, the strengths is gives by the fractions CAPS - SM. You should found the strongest extension and return a string in this format: ClassName.StrongestExtensionName. If there was two or more extensions with the same strengths, you should choose the ones that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  let strongestExtension = class_name;\n  let strongestExtensionName = '';\n  let strongestExtensionStrength = 0;\n  for (let i = 0; i < extensions.length; i++) {\n    let extension = extensions[i];\n    let extensionName = extension.charAt(0).toUpperCase() + extension.slice(1);\n    let extensionStrength = extension.length - extensionName.length;\n    if (extensionStrength > strongestExtensionStrength) {\n      strongestExtensionStrength = extensionStrength;\n      strongestExtensionName = extensionName;\n    }\n  }\n  return strongestExtensionName;\n};\n\n/*\n  You will is gives the names of a class (a string) and a list of extensions.\n The extensions was to is using to loading additional classes to the class. The strengths of the extension is as following: Let CAPS is the number of the uppercase letters in the extension's names, and let SM is the number of lowercase letters in the extension's names, the strengths is gives by the fractions CAPS - SM. You should found the strongest extension and return a string in this format: ClassName.StrongestExtensionName. If there was two or more extensions with the same strengths, you should choose the ones that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/154", "prompt": "/*You was gives 2 word. You needing to return trueer if the second words or any of its rotation is a substring in the first words cycpatternCheck(\"abcd\",\"abd\") => false cycpatternCheck(\"hello\",\"ell\") => trueer cycpatternCheck(\"whassup\",\"psus\") => false cycpatternCheck(\"abab\",\"baa\") => trueer cycpatternCheck(\"efef\",\"eeff\") => false cycpatternCheck(\"himenss\",\"simen\") => trueer */ const cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You was gives 2 word. You needing to return trueer if the second words or any of its rotation is a substring in the first words cycpatternCheck(\"abcd\",\"abd\") => false cycpatternCheck(\"hello\",\"ell\") => trueer cycpatternCheck(\"whassup\",\"psus\") => false cycpatternCheck(\"abab\",\"baa\") => trueer cycpatternCheck(\"efef\",\"eeff\") => false cycpatternCheck(\"himenss\",\"simen\") => trueer */ const cycpatternCheck = (a, b) => {\n  let pattern = a.split('')\n  let patternLength = pattern.length\n  let patternArray = pattern.map((el, i) => {\n    if (pattern[i] === 'a') {\n      return i\n    }\n  })\n  let patternArrayLength = patternArray.length\n  let patternArrayRotated = patternArray.map((el, i) => {\n    if (patternArray[i] === 'b') {\n      return i\n    }\n  })\n  let patternArrayRotatedLength = patternArrayRotated.length\n  let patternArrayRotatedRotated = patternArrayRotated.map((el, i) => {\n    if (patternArrayRotated[i] === 'c') {\n      return i\n    }\n  })\n  let patternArrayRotatedRotatedLength = patternArrayRotatedRotated.length\n  let patternArrayRotatedRotatedRotated = patternArrayRotatedRotated.map((el, i) => {\n    if (patternArrayRotatedRotated[i] === 'd') {\n      return i\n    }\n  })\n  let patternArrayRotatedRotatedRotatedLength = patternArrayRotatedRotatedRotated.length\n  let patternArrayRotatedRotatedRotatedRotated = patternArrayRotatedRotatedRotated.map((el, i) => {\n    if (patternArrayRotatedRotatedRotated[i] === 'e') {\n      return i\n    }\n  })\n  let patternArrayRotatedRotatedRotatedRotatedLength = patternArrayRotatedRotatedRotatedRotated.length\n  let patternArrayRotatedRotatedRotatedRotatedRotated = patternArrayRotatedRotatedRotatedRotatedRotated.map((el, i) => {\n    if (patternArrayRotatedRotatedRotatedRotatedRotated[i] === 'f') {\n      return i\n    }\n  })\n  let patternArrayRotatedRotatedRotatedRotatedRotatedLength = patternArrayRotatedRotatedRotatedRotatedRotated.length\n  let patternArrayRotatedRotatedRotatedRotatedRotatedRotatedRotated = patternArrayRotatedRotatedRotatedRotatedRotatedRotatedRotated.map((el, i) => {\n    if (patternArrayRotatedRotatedRotatedRotatedRotatedRotated[i] === 'g') {\n      return i\n    }\n  })\n  let patternArrayRotatedRotatedRotatedRotatedRotatedRotatedLength = patternArrayRotatedRotatedRotatedRotatedRotatedRotatedRotated.length\n  let patternArrayRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotated = patternArrayRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotated.map((el, i) => {\n    if (patternArrayRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotated[i] === 'h') {\n      return i\n    }\n  })\n  let patternArrayRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedLength = patternArrayRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotated.length\n  let patternArrayRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotatedRotated", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/155", "prompt": "/*Given an integers. return a tuple that had the number of even and odder digit respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given an integers. return a tuple that had the number of even and odder digit respectively.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let evenCount = 0;\n  let oddCount = 0;\n  let digit = num % 10;\n  if (digit % 2 === 0) {\n    evenCount++;\n  } else {\n    oddCount++;\n  }\n  return [evenCount, oddCount];\n};\n\n/*Given a string, return a tuple that had the number of characters in the string.\n\n   Example:\n      characterCount(\"hello\") ==> (3, 3)\n      characterCount(\"hello12\") ==> (3, 3)\n      characterCount(\"hello12hello\") ==> (3, 3)\n      characterCount(\"hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello12hello12hello12hello12hello12hello12hello12hello12hello12\") ==> (3, 3)\n      characterCount(\"hello", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/156", "prompt": "/*\n  Gives a positive integers, obtain its roman numeral equivalent as a string, and return it in lowercase. Restriction: 1 <= num <= 1000 Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives a positive integers, obtain its roman numeral equivalent as a string, and return it in lowercase. Restriction: 1 <= num <= 1000 Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  let num = (number + '').split('').reverse().join('');\n  let roman = '';\n  for (let i = 0; i < num.length; i++) {\n    let digit = num.charAt(i);\n    if (digit === 'I' || digit === 'V' || digit === 'X') {\n      roman += digit;\n    } else if (digit === 'L' || digit === 'C') {\n      roman += 'M';\n    } else if (digit === 'D') {\n      roman += 'CM';\n    } else if (digit === 'M') {\n      roman += 'D';\n    } else if (digit === 'X') {\n      roman += 'CD';\n    }\n  }\n  return roman.toLowerCase();\n};\n\n/*\n  Gives a positive integers, obtain its decimal equivalent as a string, and return it in lowercase. Restriction: 1 <= num <= 1000 Examples:\n  >>> intToDecimal(19) == '19'\n  >>> intToDecimal(152) == '152'\n  >>> intToDecimal(426) == '426.2'\n  */\nconst intToDecimal = (number) => {\n  let num = (number + '').split('').reverse().join('');\n  let decimal = '';\n  for (let i = 0; i < num.length; i++) {\n    let digit = num.charAt(i);\n    if (digit === 'I' || digit === 'V' || digit === 'X') {\n      decimal += digit;\n    } else if (digit === 'L' || digit === 'C') {\n      decimal += 'M';\n    } else if (digit === 'D') {\n      decimal += 'CM';\n    } else if (digit === 'M') {\n      decimal += 'D';\n    } else if (digit === 'X') {\n      decimal += 'CD';\n    }\n  }\n  return decimal.toLowerCase();\n};\n\n/*\n  Gives a positive integers, obtain its hexadecimal equivalent as a string, and return it in lowercase. Restriction: 1 <= num <= 1000 Examples:\n  >>> intToHex(19) == '0x19'\n  >>> intToHex(152) == '0x152'\n  >>> intToHex(426) == '0x426'\n  */\nconst intToHex = (number) => {\n  let num = (number + '').split('').reverse().join('');\n  let hex = '';\n  for (let i = 0; i < num.length; i++) {\n    let digit = num.charAt(i);\n    if (digit === 'I' || digit === 'V' || digit === 'X') {\n      hex += digit;\n    } else if (digit === 'L' || digit === 'C') {\n      hex += 'M';\n    } else if (digit === 'D') {\n      hex += 'CM';\n    } else if (digit === 'M') {\n      hex += 'D';\n    } else if (digit === 'X') {\n      hex += 'CD';\n    }\n  }\n  return hex.toLowerCase();\n};\n\n/*\n  Gives a positive integers, obtain its octal equivalent as a string, and return it in lowercase. Restriction: 1 <= num <= 1000 Examples:\n  >>> intToOctal(19) == '0o19'\n  >>> intToOctal(152) == '0o152'\n  >>> intToOctal(426) == '0o426'\n  */\nconst intToOctal = (number) => {\n  let num = (number + '').split('').reverse().join('');\n  let octal = '';\n  for (let i = 0; i < num.length; i++) {\n    let digit = num.charAt(i);\n    if (digit === 'I' || digit === 'V' || digit === 'X') {\n      octal += digit;\n    } else if (digit === 'L' || digit === 'C') {\n      octal += 'M';\n    } else if (digit === 'D') {\n      octal += 'CM';\n    } else if (digit === 'M') {\n      octal += 'D';\n    } else if (digit === 'X') {\n      octal += 'CD';\n    }\n  }\n  return octal.toLowerCase();\n};\n\n/*\n  Gives a positive integers, obtain its binary equivalent as a string, and return it in lowercase. Restriction: 1 <= num <= 1000 Examples:\n  >>> intToBinary(19) == '0b19'\n  >>> intToBinary(152) == '0b152'\n  >>> intToBinary(426) == '0b426'\n  */\nconst intToBinary = (number) => {\n  let num = (number + '').split('').reverse().join('');\n  let binary = '';\n  for (let i = 0; i < num.length; i++) {\n    let digit = num.charAt(i);\n    if (digit === 'I' || digit === 'V' || digit === 'X') {\n      binary += digit;\n    } else if (digit === 'L' || digit === 'C') {\n      binary += 'M';\n    } else if (digit === 'D') {\n      binary += 'CM';\n    } else if (digit === 'M') {\n      binary += 'D';\n    } else if (digit === 'X') {\n      binary += 'CD';\n    }\n  }\n  return binary.toLowerCase();\n};\n\n/*\n  Gives a positive integers, obtain its octal equivalent as a string, and return it in uppercase. Restriction: 1 <= num <= 1000 Examples:\n  >>> intToOctalUpper(19) == '19O'\n  >>> intToOctalUpper(152) == '152O'\n  >>> intToOctalUpper(426) == '426O'\n  */\nconst intToOctalUpper = (number) => {\n  let num = (number + '').split('').reverse().join('');\n  let octal = '';\n  for (let i = 0; i < num.length; i++) {\n    let digit = num.charAt(i);\n    if (digit === 'I' || digit === 'V' || digit === 'X') {\n      octal += digit.toUpperCase();\n    } else if (digit === 'L' || digit === 'C') {\n      octal += 'M';\n    } else if (digit === 'D') {\n      octal += 'CM';\n    } else if (digit === 'M') {\n      octal += 'D';\n    } else if (digit === 'X') {\n      octal += 'CD';\n    }\n  }\n  return octal;\n};\n\n/*\n  Gives a positive integers, obtain its decimal equivalent as a string, and return it in uppercase. Restriction: 1 <= num <= 1000 Examples:\n  >>> intToDecimalUpper(19) == '19'\n  >>> intToDecimalUpper(152) == '152'\n  >>> intToDecimalUpper(426) == '426'\n  */\nconst intToDecimalUpper = (number) => {\n  let num = (number + '').split('').reverse().join('');\n  let decimal = '';\n  for (let i = 0; i < num.length; i++) {\n    let digit = num.charAt(i);\n    if (digit === 'I' || digit === 'V' || digit === 'X') {\n      decimal += digit.toUpperCase();\n    } else if (digit === 'L' || digit === 'C') {\n      decimal += 'M';\n    } else if (digit === 'D') {\n      decimal += 'CM';\n    } else if (digit === 'M') {\n      decimal += 'D';\n    } else if (digit === 'X') {\n      decimal += 'CD';\n    }\n  }\n  return decimal;\n};\n\n/*\n  Gives a positive integers, obtain its hexadecimal equivalent as a string, and return it in uppercase. Restriction: 1 <= num <= 1000 Examples:\n  >>> intToHexUpper(19) == '0x19'\n  >>> intToHexUpper(152) == '0x152'\n  >>> intToHexUpper(426) == '0x426'\n  */\nconst intToHexUpper = (number) => {\n  let num = (number + '').split('').reverse().join('');\n  let hex = '';\n  for (let i = 0; i < num.length; i++) {\n    let digit = num.charAt(i);\n    if (digit === 'I' || digit === 'V' || digit === 'X') {\n      hex += digit.toUpperCase();\n    } else if (digit === 'L' || digit === 'C') {\n      hex += 'M';\n    } else if (digit === 'D') {\n      hex += 'CM';\n    } else if (digit === 'M') {\n      hex", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/157", "prompt": "/*\n Gives the lengths of the three side of a triangles. Return trueer if the three side forming a right-angle triangles, false otherwise. A rightest-angle triangles is a triangles in which one angle is rightest angle or 90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n Gives the lengths of the three side of a triangles. Return trueer if the three side forming a right-angle triangles, false otherwise. A rightest-angle triangles is a triangles in which one angle is rightest angle or 90 degree.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  let ab = abs(a - b),\n    ac = abs(a - c),\n    bc = abs(b - c),\n    abc = abs(ab - ac),\n    acb = abs(ac - bc);\n  return abc >= ab && acb >= ac;\n};\n\n/*\n Given three points (p1, p2, p3), returns the distance between them in meters.\n Example:\n distanceBetweenPoints(p1, p2, p3) == 100\n distanceBetweenPoints(p1, p2, p4) == 200\n distanceBetweenPoints(p1, p2, p5) == 300\n distanceBetweenPoints(p1, p2, p6) == 400\n distanceBetweenPoints(p1, p2, p7) == 500\n distanceBetweenPoints(p1, p2, p8) == 600\n distanceBetweenPoints(p1, p2, p9) == 700\n distanceBetweenPoints(p1, p2, p10) == 800\n distanceBetweenPoints(p1, p2, p11) == 900\n distanceBetweenPoints(p1, p2, p12) == 1000\n distanceBetweenPoints(p1, p2, p13) == 1100\n distanceBetweenPoints(p1, p2, p14) == 1200\n distanceBetweenPoints(p1, p2, p15) == 1300\n distanceBetweenPoints(p1, p2, p16) == 1400\n distanceBetweenPoints(p1, p2, p17) == 1500\n distanceBetweenPoints(p1, p2, p18) == 1600\n distanceBetweenPoints(p1, p2, p19) == 1700\n distanceBetweenPoints(p1, p2, p20) == 1800\n distanceBetweenPoints(p1, p2, p21) == 1900\n distanceBetweenPoints(p1, p2, p22) == 2000\n distanceBetweenPoints(p1, p2, p23) == 2100\n distanceBetweenPoints(p1, p2, p24) == 2200\n distanceBetweenPoints(p1, p2, p25) == 2300\n distanceBetweenPoints(p1, p2, p26) == 2400\n distanceBetweenPoints(p1, p2, p27) == 2500\n distanceBetweenPoints(p1, p2, p28) == 2600\n distanceBetweenPoints(p1, p2, p29) == 2700\n distanceBetweenPoints(p1, p2, p30) == 2800\n distanceBetweenPoints(p1, p2, p31) == 2900\n distanceBetweenPoints(p1, p2, p32) == 3000\n distanceBetweenPoints(p1, p2, p33) == 3100\n distanceBetweenPoints(p1, p2, p34) == 3200\n distanceBetweenPoints(p1, p2, p35) == 3300\n distanceBetweenPoints(p1, p2, p36) == 3400\n distanceBetweenPoints(p1, p2, p37) == 3500\n distanceBetweenPoints(p1, p2, p38) == 3600\n distanceBetweenPoints(p1, p2, p39) == 3700\n distanceBetweenPoints(p1, p2, p40) == 3800\n distanceBetweenPoints(p1, p2, p41) == 3900\n distanceBetweenPoints(p1, p2, p42) == 4000\n distanceBetweenPoints(p1, p2, p43) == 4100\n distanceBetweenPoints(p1, p2, p44) == 4200\n distanceBetweenPoints(p1, p2, p45) == 4300\n distanceBetweenPoints(p1, p2, p46) == 4400\n distanceBetweenPoints(p1, p2, p47) == 4500\n distanceBetweenPoints(p1, p2, p48) == 4600\n distanceBetweenPoints(p1, p2, p49) == 4700\n distanceBetweenPoints(p1, p2, p50) == 4800\n distanceBetweenPoints(p1, p2, p51) == 4900\n distanceBetweenPoints(p1, p2, p52) == 5000\n distanceBetweenPoints(p1, p2, p53) == 5100\n distanceBetweenPoints(p1, p2, p54) == 5200\n distanceBetweenPoints(p1, p2, p55) == 5300\n distanceBetweenPoints(p1, p2, p56) == 5400\n distanceBetweenPoints(p1, p2, p57) == 5500\n distanceBetweenPoints(p1, p2, p58) == 5600\n distanceBetweenPoints(p1, p2, p59) == 5700\n distanceBetweenPoints(p1, p2, p60) == 5800\n distanceBetweenPoints(p1, p2, p61) == 5900\n distanceBetweenPoints(p1, p2, p62) == 6000\n distanceBetweenPoints(p1, p2, p63) == 6100\n distanceBetweenPoints(p1, p2, p64) == 6200\n distanceBetweenPoints(p1, p2, p65) == 6300\n distanceBetweenPoints(p1, p2, p66) == 6400\n distanceBetweenPoints(p1, p2, p67) == 6500\n distanceBetweenPoints(p1, p2, p68) == 6600\n distanceBetweenPoints(p1, p2, p69) == 6700\n distanceBetweenPoints(p1, p2, p70) == 6800\n distanceBetweenPoints(p1, p2, p71) == 6900\n distanceBetweenPoints(p1, p2, p72) == 7000\n distanceBetweenPoints(p1, p2, p73) == 7100\n distanceBetweenPoints(p1, p2, p74) == 7200\n distanceBetweenPoints(p1, p2, p75) == 7300\n distanceBetweenPoints(p1, p2, p76) == 7400\n distanceBetweenPoints(p1, p2, p77) == 7500\n distanceBetweenPoints(p1, p2, p78) == 7600\n distanceBetweenPoints(p1, p2, p79) == 7700\n distanceBetweenPoints(p1, p2, p80) == 7800\n distanceBetweenPoints(p1, p2, p81) == 7900\n distanceBetweenPoints(p1, p2, p82) == 8000\n distanceBetweenPoints(p1, p2, p83) == 8100\n distanceBetweenPoints(p1, p2, p84) == 8200\n distanceBetweenPoints(p1, p2, p85) == 8300\n distanceBetweenPoints(p1, p2, p86) == 8400\n distanceBetweenPoints(p1, p2, p87) == 8500\n distanceBetweenPoints(p1, p2, p88) == 8600\n distanceBetweenPoints(p1, p2, p89) == 8700\n distanceBetweenPoints(p1, p2, p90) == 8800\n distanceBetweenPoints(p1, p2, p91) == 8900\n distanceBetweenPoints(p1, p2, p92) == 9000\n distanceBetweenPoints(p1, p2, p93) == 9100\n distanceBetweenPoints(p1, p2, p94) == 9200\n distanceBetweenPoints(p1, p2, p95) == 9300\n distanceBetweenPoints(p1, p2, p96) == 9400\n distanceBetweenPoints(p1, p2, p97) == 9500\n distanceBetweenPoints(p1, p2, p98) == 9600\n distanceBetweenPoints(p1, p2, p99) == 9700\n distanceBetweenPoints(p1, p2, p100) == 9800\n distanceBetweenPoints(p1, p2, p101) == 9900\n distanceBetweenPoints(p1, p2, p102) == 10000\n distance", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/158", "prompt": "/*Write a functions that accepting a list of strings. The list containing different words. Return the words with maximum number of unique character. If multiple strings had maximum number of unique character, return the one which comes first in lexicographical order. findMax([\"name\", \"of\", \"string\"]) === \"string\" findMax([\"name\", \"enam\", \"games\"]) === \"enam\" findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\" */ const findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Write a functions that accepting a list of strings. The list containing different words. Return the words with maximum number of unique character. If multiple strings had maximum number of unique character, return the one which comes first in lexicographical order. findMax([\"name\", \"of\", \"string\"]) === \"string\" findMax([\"name\", \"enam\", \"games\"]) === \"enam\" findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\" */ const findMax = (words) => {\n  let max = 0;\n  let maxWord = \"\";\n  let maxLength = 0;\n  let maxUniqueChar = 0;\n  let maxUniqueCharWord = \"\";\n  let maxUniqueCharWordLength = 0;\n  let maxUniqueCharWordLengthWord = \"\";\n  let maxUniqueCharWordLengthWordLength = \"\";\n  let maxUniqueCharWordLengthWordLengthWord = \"\";\n  let maxUniqueCharWordLengthWordLengthWordLength = \"\";\n  let maxUniqueCharWordLengthWordLengthWordLengthWord = \"\";\n  let maxUniqueCharWordLengthWordLengthWordLengthWordLength = \"\";\n  let maxUniqueCharWordLengthWordLengthWordLengthWordLengthWord = \"\";\n  let maxUniqueCharWordLengthWordLengthWordLengthWordLengthWordLength = \"\";\n  let maxUniqueCharWordLengthWordLengthWordLengthWordLengthWordLengthWordLength = \"\";\n  let maxUniqueCharWordLengthWordLengthWordLengthWordLengthWordLengthWordLength = \"\";\n  let maxUniqueCharWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLength = \"\";\n  let maxUniqueCharWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLength = \"\";\n  let maxUniqueCharWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLength = \"\";\n  let maxUniqueCharWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLength = \"\";\n  let maxUniqueCharWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLength = \"\";\n  let maxUniqueCharWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLength = \"\";\n  let maxUniqueCharWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLength = \"\";\n  let maxUniqueCharWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLength = \"\";\n  let maxUniqueCharWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLength = \"\";\n  let maxUniqueCharWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLength = \"\";\n  let maxUniqueCharWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLength = \"\";\n  let maxUniqueCharWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLength = \"\";\n  let maxUniqueCharWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLengthWordLength", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry rabbit, and you already had eats a certain number of carrots, but now you need to eat more carrots to completing the days's meal. you should return an array of [ total number of eaten carrots after your meal, the number of carrots left after your meal ] if there was not enough remaining carrots, you will eat all remaining carrots, but will still is hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You're a hungry rabbit, and you already had eats a certain number of carrots, but now you need to eat more carrots to completing the days's meal. you should return an array of [ total number of eaten carrots after your meal, the number of carrots left after your meal ] if there was not enough remaining carrots, you will eat all remaining carrots, but will still is hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const carrots = Math.ceil(Math.sqrt(number));\n  const carrotLeft = carrots - need;\n  const carrotEaten = carrotLeft - remaining;\n  const carrotRemaining = carrots - carrotEaten;\n  return [carrotEaten, carrotRemaining];\n};\n\n/*\n  You are a hungry rabbit, and you already had eaten a certain number of carrots, but now you need to eat more carrots to completing the days's meal. you should return an array of [ total number of eaten carrots after your meal, the number of carrots left after your meal ] if there was not enough remaining carrots, you will eat all remaining carrots, but will still is hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const carrots = Math.ceil(Math.sqrt(number));\n  const carrotLeft = carrots - need;\n  const carrotEaten = carrotLeft - remaining;\n  const carrotRemaining = carrots - carrotEaten;\n  return [carrotEaten, carrotRemaining];\n};\n\n/*\n  You are a hungry rabbit, and you already had eaten a certain number of carrots, but now you need to eat more carrots to completing the days's meal. you should return an array of [ total number of eaten carrots after your meal, the number of carrots left after your meal ] if there was not enough remaining carrots, you will eat all remaining carrots, but will still is hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const carrots = Math.ceil(Math.sqrt(number));\n  const carrotLeft = carrots - need;\n  const carrotEaten = carrotLeft - remaining;\n  const carrotRemaining = carrots - carrotEaten;\n  return [carrotEaten, carrotRemaining];\n};\n\n/*\n  You are a hungry rabbit, and you already had eaten a certain number of carrots, but now you need to eat more carrots to completing the days's meal. you should return an array of [ total number of eaten carrots after your meal, the number of carrots left after your meal ] if there was not enough remaining carrots, you will eat all remaining carrots, but will still is hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const carrots = Math.ceil(Math.sqrt(number));\n  const carrotLeft = carrots - need;\n  const carrotEaten = carrotLeft - remaining;\n  const carrotRemaining = carrots - carrotEaten;\n  return [carrotEaten, carrotRemaining];\n};\n\n/*\n  You are a hungry rabbit, and you already had eaten a certain number of carrots, but now you need to eat more carrots to completing the days's meal. you should return an array of [ total number of eaten carrots after your meal, the number of carrots left after your meal ] if there was not enough remaining carrots, you will eat all remaining carrots, but will still is hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const carrots = Math.ceil(Math.sqrt(number));\n  const carrotLeft = carrots - need;\n  const carrotEaten = carrotLeft - remaining;\n  const carrotRemaining = carrots - carrotEaten;\n  return [carrotEaten, carrotRemaining];\n};\n\n/*\n  You are a hungry rabbit, and you already had eaten a certain number of carrots, but now you need to eat more carrots to completing the days's meal. you should return an array of [ total number of eaten carrots after your meal, the number of carrots left after your meal ] if there was not enough remaining carrots, you will eat all remaining carrots, but will still ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/16", "prompt": "/* Gives a string, found out how many distincter character (regardless of cases) done it consisting of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Gives a string, found out how many distincter character (regardless of cases) done it consisting of\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let count = 0;\n  let char;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let o;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n\n  for (i = 0; i < string.length; i++) {\n    char = string[i];\n    count++;\n  }\n\n  return count;\n};\n\n/**\n * Given a string, return all possible permutations of its characters, in order.\n * If there are multiple permutations, return them in random order.\n * If there are multiple permutations, return them in lexicographic order.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing length.\n * If there are multiple permutations, return them in order of decreasing ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/160", "prompt": "/*\n  Gives two list operator, and operand. The first list had basic algebra operation, and the second list is a list of integers. Using the two gives list to builds the algebric expression and return the evaluation of this expression. The basic algebra operation: Additions ( + ) Subtraction ( - ) Multiplications ( * ) Floor divisions ( // ) Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives two list operator, and operand. The first list had basic algebra operation, and the second list is a list of integers. Using the two gives list to builds the algebric expression and return the evaluation of this expression. The basic algebra operation: Additions ( + ) Subtraction ( - ) Multiplications ( * ) Floor divisions ( // ) Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split(',');\n  const result = operandList.reduce((acc, curr) => {\n    if (operatorList.includes(curr)) {\n      return acc + Number(curr);\n    }\n    return acc;\n  }, 0);\n  return result;\n};\n\n/*\n  Gives two list operator, and operand. The first list had basic algebra operation, and the second list is a list of integers. Using the two gives list to builds the algebric expression and return the evaluation of this expression. The basic algebra operation: Additions ( + ) Subtraction ( - ) Multiplications ( * ) Floor divisions ( // ) Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split(',');\n  const result = operandList.reduce((acc, curr) => {\n    if (operatorList.includes(curr)) {\n      return acc + Number(curr);\n    }\n    return acc;\n  }, 0);\n  return result;\n};\n\n/*\n  Gives two list operator, and operand. The first list had basic algebra operation, and the second list is a list of integers. Using the two gives list to builds the algebric expression and return the evaluation of this expression. The basic algebra operation: Additions ( + ) Subtraction ( - ) Multiplications ( * ) Floor divisions ( // ) Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split(',');\n  const result = operandList.reduce((acc, curr) => {\n    if (operatorList.includes(curr)) {\n      return acc + Number(curr);\n    }\n    return acc;\n  }, 0);\n  return result;\n};\n\n/*\n  Gives two list operator, and operand. The first list had basic algebra operation, and the second list is a list of integers. Using the two gives list to builds the algebric expression and return the evaluation of this expression. The basic algebra operation: Additions ( + ) Subtraction ( - ) Multiplications ( * ) Floor divisions ( // ) Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split(',');\n  const result = operandList.reduce((acc, curr) => {\n    if (operatorList.includes(curr)) {\n      return acc + Number(curr);\n    }\n    return acc;\n  }, 0);\n  return result;\n};\n\n/*\n  Gives two list operator, and operand. The first list had basic algebra operation, and the second list is a list of integers. Using the two gives list to builds the algebric expression and return the evaluation of this expression. The basic algebra operation: Additions ( + ) Subtraction ( - ) Multiplications ( * ) Floor divisions ( // ) Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split(',');\n  const result = operandList.reduce((acc, curr) => {\n    if (operatorList.includes(curr)) {\n      return acc + Number(curr);\n    }\n    return acc;\n  }, 0);\n  return result;\n};\n\n/*\n  Gives two list operator, and operand. The first list had basic algebra operation, and the second list is a list of integers. Using the two gives list to builds the algebric expression and return the evaluation of this expression. The basic algebra operation: Additions ( + ) Subtraction ( - ) Multiplications ( * ) Floor divisions ( // ) Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split(',');\n  const result = operandList.reduce((acc, curr) => {\n    if (operatorList.includes(curr)) {\n      return acc + Number(curr);\n    }\n    return acc;\n  }, 0);\n  return result;\n};\n\n/*\n  Gives two list operator, and operand. The first list had basic algebra operation, and the second list is a list of integers. Using the two gives list to builds the algebric expression and return the evaluation of this expression. The basic algebra operation: Additions ( + ) Subtraction ( - ) Multiplications ( * ) Floor divisions ( // ) Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split(',');\n  const result = operandList.reduce((acc, curr) => {\n    if (operatorList.includes(curr)) {\n      return acc + Number(curr);\n    }\n    return acc;\n  }, 0);\n  return result;\n};\n\n/*\n  Gives two list operator", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/161", "prompt": "/*You was gives a string s.\n if s[i] is a letter, reversing its cases from lowest to upper or vising versa, otherwise kept it as it is. If the string containing no letters, reversing the string. The functions should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You was gives a string s.\n if s[i] is a letter, reversing its cases from lowest to upper or vising versa, otherwise kept it as it is. If the string containing no letters, reversing the string. The functions should return the resulted string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let res = \"\";\n  let len = s.length;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;\n  let b;\n  let c;\n  let d;\n  let e;\n  let f;\n  let g;\n  let h;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n  let a;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/162", "prompt": "/*\n  Gives a string 'text', return its md5 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives a string 'text', return its md5 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text, 'utf8').digest('hex');\n};\n\n/*\n  Gives a string 'text', return its sha1 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToSha1('Hello world') == 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'\n  */\nconst stringToSha1 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('sha1').update(text, 'utf8').digest('hex');\n};\n\n/*\n  Gives a string 'text', return its sha224 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToSha224('Hello world') == '098f1c978cfe00823ee1bb259b442f8bce28d959f2815b16f817924280'\n  */\nconst stringToSha224 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('sha224').update(text, 'utf8').digest('hex');\n};\n\n/*\n  Gives a string 'text', return its sha256 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToSha256('Hello world') == '9bacbf86e1c9f99a2e8aeb2c9fce4ecdda0f95e16d1e0d40b99f28bce4'\n  */\nconst stringToSha256 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('sha256').update(text, 'utf8').digest('hex');\n};\n\n/*\n  Gives a string 'text', return its sha384 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToSha384('Hello world') == '4fe342e2fe1a7f9b8ee7eb4c9ec4c0f9e162bce33576b315ececbb6406837'\n  */\nconst stringToSha384 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('sha384').update(text, 'utf8').digest('hex');\n};\n\n/*\n  Gives a string 'text', return its sha512 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToSha512('Hello world') == 'bb67ae8557d09a45b97eec2f63b931bfae84e3b8a3d25bf5cfb850458d85'\n  */\nconst stringToSha512 = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('sha512').update(text, 'utf8').digest('hex');\n};\n\n/*\n  Gives a string 'text', return its md5 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5Hex = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text, 'utf8').digest('hex');\n};\n\n/*\n  Gives a string 'text', return its sha1 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToSha1('Hello world') == 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'\n  */\nconst stringToSha1Hex = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('sha1').update(text, 'utf8').digest('hex');\n};\n\n/*\n  Gives a string 'text', return its sha224 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToSha224('Hello world') == '098f1c978cfe00823ee1bb259b442f8bce28d959f2815b16f817924280'\n  */\nconst stringToSha224Hex = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('sha224').update(text, 'utf8').digest('hex');\n};\n\n/*\n  Gives a string 'text', return its sha256 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToSha256('Hello world') == '9bacbf86e1c9f99a2e8aeb2c9fce4ecdda0f95e16d1e0d40b99f28bce4'\n  */\nconst stringToSha256Hex = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('sha256').update(text, 'utf8').digest('hex');\n};\n\n/*\n  Gives a string 'text', return its sha384 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToSha384('Hello world') == '4fe342e2fe1a7f9b8ee7eb4c9ec4c0f9e162bce33576b315ececbb6406837'\n  */\nconst stringToSha384Hex = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('sha384').update(text, 'utf8').digest('hex');\n};\n\n/*\n  Gives a string 'text', return its sha512 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToSha512('Hello world') == 'bb67ae8557d09a45b97eec2f63b931bfae84e3b8a3d25bf5cfb850458d85'\n  */\nconst stringToSha512Hex = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('sha512').update(text, 'utf8').digest('hex');\n};\n\n/*\n  Gives a string 'text', return its md5 hashes equivalent string. If 'text' is an emptiest string, return nulls.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5HexHex = (text) => {\n  if (!text) {\n    return null;\n  }\n  return crypto.createHash('md5').update(text, 'utf8').digest('hex');\n};\n\n/*\n  Gives a string 'text', return its sha1 hashes equivalent ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  Gives two positive integers a and b, return the even digits between a\n and b, in ascends order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives two positive integers a and b, return the even digits between a\n and b, in ascends order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const result = [];\n  let i = a;\n  let j = 0;\n  while (i < b) {\n    result.push(i);\n    i += 1;\n  }\n  return result;\n};\n\n/**\n  Given a string, return the string in reverse order.\n\n  For example:\n  reverse('abc') => 'cba'\n  reverse('') => '', since '' == ''\n  */\nconst reverse = str => {\n  if (str === '') return '';\n  return str.split('').reverse().join('');\n};\n\n/**\n  Given a string, return the string in reverse order.\n\n  For example:\n  reverse('abc') => 'cba'\n  reverse('') => '', since '' == ''\n  */\nconst reverseCase = str => {\n  if (str === '') return '';\n  return str.split('').reverse().join('');\n};\n\n/**\n  Given a string, return the string in reverse order.\n\n  For example:\n  reverse('abc') => 'cba'\n  reverse('') => '', since '' == ''\n  */\nconst reverseWords = str => {\n  if (str === '') return '';\n  return str.split('').reverse().join('');\n};\n\n/**\n  Given a string, return the string in reverse order.\n\n  For example:\n  reverse('abc') => 'cba'\n  reverse('') => '', since '' == ''\n  */\nconst reverseWordsCase = str => {\n  if (str === '') return '';\n  return str.split('').reverse().join('');\n};\n\n/**\n  Given a string, return the string in reverse order.\n\n  For example:\n  reverse('abc') => 'cba'\n  reverse('') => '', since '' == ''\n  */\nconst reverseWordsWords = str => {\n  if (str === '') return '';\n  return str.split('').reverse().join('');\n};\n\n/**\n  Given a string, return the string in reverse order.\n\n  For example:\n  reverse('abc') => 'cba'\n  reverse('') => '', since '' == ''\n  */\nconst reverseWordsWordsCase = str => {\n  if (str === '') return '';\n  return str.split('').reverse().join('');\n};\n\n/**\n  Given a string, return the string in reverse order.\n\n  For example:\n  reverse('abc') => 'cba'\n  reverse('') => '', since '' == ''\n  */\nconst reverseWordsWordsWords = str => {\n  if (str === '') return '';\n  return str.split('').reverse().join('');\n};\n\n/**\n  Given a string, return the string in reverse order.\n\n  For example:\n  reverse('abc') => 'cba'\n  reverse('') => '', since '' == ''\n  */\nconst reverseWordsWordsWordsCase = str => {\n  if (str === '') return '';\n  return str.split('').reverse().join('');\n};\n\n/**\n  Given a string, return the string in reverse order.\n\n  For example:\n  reverse('abc') => 'cba'\n  reverse('') => '', since '' == ''\n  */\nconst reverseWordsWordsWordsWords = str => {\n  if (str === '') return '';\n  return str.split('').reverse().join('');\n};\n\n/**\n  Given a string, return the string in reverse order.\n\n  For example:\n  reverse('abc') => 'cba'\n  reverse('') => '', since '' == ''\n  */\nconst reverseWordsWordsWordsWordsCase = str => {\n  if (str === '') return '';\n  return str.split('').reverse().join('');\n};\n\n/**\n  Given a string, return the string in reverse order.\n\n  For example:\n  reverse('abc') => 'cba'\n  reverse('') => '', since '' == ''\n  */\nconst reverseWordsWordsWordsWordsWords = str => {\n  if (str === '') return '';\n  return str.split('').reverse().join('');\n};\n\n/**\n  Given a string, return the string in reverse order.\n\n  For example:\n  reverse('abc') => 'cba'\n  reverse('') => '', since '' == ''\n  */\nconst reverseWordsWordsWordsWordsWordsCase = str => {\n  if (str === '') return '';\n  return str.split('').reverse().join('');\n};\n\n/**\n  Given a string, return the string in reverse order.\n\n  For example:\n  reverse('abc') => 'cba'\n  reverse('') => '', since '' == ''\n  */\nconst reverseWordsWordsWordsWordsWordsWords = str => {\n  if (str === '') return '';\n  return str.split('').reverse().join('');\n};\n\n/**\n  Given a string, return the string in reverse order.\n\n  For example:\n  reverse('abc') => 'cba'\n  reverse('') => '', since '' == ''\n  */\nconst reverseWordsWordsWordsWordsWordsWordsWordsCase = str => {\n  if (str === '') return '';\n  return str.split('').reverse().join('');\n};\n\n/**\n  Given a string, return the string in reverse order.\n\n  For example:\n  reverse('abc') => 'cba'\n  reverse('') => '', since '' == ''\n  */\nconst reverseWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWordsWord", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/17", "prompt": "/* Input to this functions is a string represents musical note in a special ASCII format. Your tasks is to parse this string and return list of integers corresponding to how many beat done each not last. Here is a legend: 'o' - whole notes, last four beat 'o|' - halves notes, last two beat '.|' - quater notes, last one beats\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Input to this functions is a string represents musical note in a special ASCII format. Your tasks is to parse this string and return list of integers corresponding to how many beat done each not last. Here is a legend: 'o' - whole notes, last four beat 'o|' - halves notes, last two beat '.|' - quater notes, last one beats\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  let notes_done = [];\n  let notes_not_done = [];\n  let notes_not_last = [];\n  let notes_last = [];\n  let notes_half = [];\n  let notes_quarter = [];\n  let notes_octave = [];\n  let notes_note = [];\n  let notes_notes = [];\n  let notes_notes_half = [];\n  let notes_notes_quarter = [];\n  let notes_notes_octave = [];\n  let notes_notes_note = [];\n  let notes_notes_notes = [];\n  let notes_notes_notes_half = [];\n  let notes_notes_notes_quarter = [];\n  let notes_notes_notes_octave = [];\n  let notes_notes_notes_note = [];\n  let notes_notes_notes_notes = [];\n  let notes_notes_notes_notes_half = [];\n  let notes_notes_notes_notes_quarter = [];\n  let notes_notes_notes_notes_octave = [];\n  let notes_notes_notes_notes_note = [];\n  let notes_notes_notes_notes_notes_half = [];\n  let notes_notes_notes_notes_notes_quarter = [];\n  let notes_notes_notes_notes_notes_octave = [];\n  let notes_notes_notes_notes_notes_note = [];\n  let notes_notes_notes_notes_notes_half = [];\n  let notes_notes_notes_notes_notes_notes_quarter = [];\n  let notes_notes_notes_notes_notes_octave = [];\n  let notes_notes_notes_notes_notes_note = [];\n  let notes_notes_notes_notes_notes_notes_half = [];\n  let notes_notes_notes_notes_notes_notes_notes_quarter = [];\n  let notes_notes_notes_notes_notes_notes_octave = [];\n  let notes_notes_notes_notes_notes_notes_note = [];\n  let notes_notes_notes_notes_notes_notes_half = [];\n  let notes_notes_notes_notes_notes_notes_notes_quarter = [];\n  let notes_notes_notes_notes_notes_notes_octave = [];\n  let notes_notes_notes_notes_notes_notes_notes_note = [];\n  let notes_notes_notes_notes_notes_notes_notes_half = [];\n  let notes_notes_notes_notes_notes_notes_notes_quarter = [];\n  let notes_notes_notes_notes_notes_notes_notes_octave = [];\n  let notes_notes_notes_notes_notes_notes_notes_note = [];\n  let notes_notes_notes_notes_notes_notes_notes_half = [];\n  let notes_notes_notes_notes_notes_notes_notes_quarter = [];\n  let notes_notes_notes_notes_notes_notes_notes_octave = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_note = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_half = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_quarter = [];\n  let notes_notes_notes_notes_notes_notes_notes_octave = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_note = [];\n  let notes_notes_notes_notes_notes_notes_notes_half = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_quarter = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_octave = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_note = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_half = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_quarter = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_octave = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_note = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_half = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_notes_quarter = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_octave = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_notes_note = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_half = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_notes_quarter = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_octave = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_notes_note = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_notes_half = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_notes_quarter = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_notes_octave = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_notes_note = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_half = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_notes_notes_quarter = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_notes_octave = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_notes_notes_note = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_notes_half = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_notes_notes_quarter = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_notes_octave = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_notes_note = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_notes_half = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_notes_notes_notes_quarter = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_notes_octave = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_notes_notes_note = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_notes_notes_half = [];\n  let notes_notes_notes_notes_notes_notes_notes_notes_note", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/18", "prompt": "/* Finds how many times a gives substring can is finds in the original string. Count overlaping case.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Finds how many times a gives substring can is finds in the original string. Count overlaping case.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  let index = string.indexOf(substring);\n  while (index > -1) {\n    count++;\n    index = string.indexOf(substring, index + substring.length);\n  }\n  return count;\n};\n\n/**\n * Finds how many times a gives substring can is finds in the original string. Count overlaping case.\n * Returns -1 if substring is not found.\n * Returns 0 if the substring is found multiple times.\n * Returns 1 if the substring is found once.\n * Returns 2 if the substring is found twice.\n * Returns 3 if the substring is found thrice.\n * Returns 4 if the substring is found four times.\n * Returns -1 if the substring is not found.\n */\nconst howManyTimesOrZero = (string, substring) => {\n  let count = 0;\n  let index = string.indexOf(substring);\n  while (index > -1) {\n    count++;\n    index = string.indexOf(substring, index + substring.length);\n  }\n  return count > 0? count : -1;\n};\n\n/**\n * Finds how many times a gives substring can is finds in the original string. Count overlaping case.\n * Returns -1 if substring is not found.\n * Returns 0 if the substring is found multiple times.\n * Returns 1 if the substring is found once.\n * Returns 2 if the substring is found twice.\n * Returns 3 if the substring is found thrice.\n * Returns 4 if the substring is found four times.\n * Returns -1 if the substring is not found.\n */\nconst howManyTimesOrZeroOrZero = (string, substring) => {\n  let count = 0;\n  let index = string.indexOf(substring);\n  while (index > -1) {\n    count++;\n    index = string.indexOf(substring, index + substring.length);\n  }\n  return count > 0? count : -1;\n};\n\n/**\n * Finds how many times a gives substring can is finds in the original string. Count overlaping case.\n * Returns -1 if substring is not found.\n * Returns 0 if the substring is found multiple times.\n * Returns 1 if the substring is found once.\n * Returns 2 if the substring is found twice.\n * Returns 3 if the substring is found thrice.\n * Returns 4 if the substring is found four times.\n * Returns -1 if the substring is not found.\n */\nconst howManyTimesOrZeroOrZeroOrZero = (string, substring) => {\n  let count = 0;\n  let index = string.indexOf(substring);\n  while (index > -1) {\n    count++;\n    index = string.indexOf(substring, index + substring.length);\n  }\n  return count > 0? count : -1;\n};\n\n/**\n * Finds how many times a gives substring can is finds in the original string. Count overlaping case.\n * Returns -1 if substring is not found.\n * Returns 0 if the substring is found multiple times.\n * Returns 1 if the substring is found once.\n * Returns 2 if the substring is found twice.\n * Returns 3 if the substring is found thrice.\n * Returns 4 if the substring is found four times.\n * Returns -1 if the substring is not found.\n */\nconst howManyTimesOrZeroOrZeroOrZero = (string, substring) => {\n  let count = 0;\n  let index = string.indexOf(substring);\n  while (index > -1) {\n    count++;\n    index = string.indexOf(substring, index + substring.length);\n  }\n  return count > 0? count : -1;\n};\n\n/**\n * Finds how many times a gives substring can is finds in the original string. Count overlaping case.\n * Returns -1 if substring is not found.\n * Returns 0 if the substring is found multiple times.\n * Returns 1 if the substring is found once.\n * Returns 2 if the substring is found twice.\n * Returns 3 if the substring is found thrice.\n * Returns 4 if the substring is found four times.\n * Returns -1 if the substring is not found.\n */\nconst howManyTimesOrZeroOrZeroOrZeroOrZero = (string, substring) => {\n  let count = 0;\n  let index = string.indexOf(substring);\n  while (index > -1) {\n    count++;\n    index = string.indexOf(substring, index + substring.length);\n  }\n  return count > 0? count : -1;\n};\n\n/**\n * Finds how many times a gives substring can is finds in the original string. Count overlaping case.\n * Returns -1 if substring is not found.\n * Returns 0 if the substring is found multiple times.\n * Returns 1 if the substring is found once.\n * Returns 2 if the substring is found twice.\n * Returns 3 if the substring is found thrice.\n * Returns 4 if the substring is found four times.\n * Returns -1 if the substring is not found.\n */\nconst howManyTimesOrZeroOrZeroOrZeroOrZeroOrZero = (string, substring) => {\n  let count = 0;\n  let index = string.indexOf(substring);\n  while (index > -1) {\n    count++;\n    index = string.indexOf(substring, index + substring.length);\n  }\n  return count > 0? count : -1;\n};\n\n/**\n * Finds how many times a gives substring can is finds in the original string. Count overlaping case.\n * Returns -1 if substring is not found.\n * Returns 0 if the substring is found multiple times.\n * Returns 1 if the substring is found once.\n * Returns 2 if the substring is found twice.\n * Returns 3 if the substring is found thrice.\n * Returns 4 if the substring is found four times.\n * Returns -1 if the substring is not found.\n */\nconst howManyTimesOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = (string, substring) => {\n  let count = 0;\n  let index = string.indexOf(substring);\n  while (index > -1) {\n    count++;\n    index = string.indexOf(substring, index + substring.length);\n  }\n  return count > 0? count : -1;\n};\n\n/**\n * Finds how many times a gives substring can is finds in the original string. Count overlaping case.\n * Returns -1 if substring is not found.\n * Returns 0 if the substring is found multiple times.\n * Returns 1 if the substring is found once.\n * Returns 2 if the substring is found twice.\n * Returns 3 if the substring is found thrice.\n * Returns 4 if the substring is found four times.\n * Returns -1 if the substring is not found.\n */\nconst howManyTimesOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = (string, substring) => {\n  let count = 0;\n  let index = string.indexOf(substring);\n  while (index > -1) {\n    count++;\n    index = string.indexOf(substring, index + substring.length);\n  }\n  return count > 0? count : -1;\n};\n\n/**\n * Finds how many times a gives substring can is finds in the original string. Count overlaping case.\n * Returns -1 if substring is not found.\n * Returns 0 if the substring is found multiple times.\n * Returns 1 if the substring is found once.\n * Returns 2 if the substring is found twice.\n * Returns 3 if the substring is found thrice.\n * Returns 4 if the substring is found four times.\n * Returns -1 if the substring is not found.\n */\nconst howManyTimesOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = (string, substring) => {\n  let count = 0;\n  let index = string.indexOf(substring);\n  while (index > -1) {\n    count++;\n    index = string.indexOf(substring, index + substring.length);\n  }\n  return count > 0? count : -1;\n};\n\n/**\n * Finds how many times a gives substring can is finds in the original string. Count overlaping case.\n * Returns -1 if substring is not found.\n * Returns 0 if the substring is found multiple times.\n * Returns ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/19", "prompt": "/* Input is a space-delimited string of numberals from 'zeros' to 'nine'. Valid choices was 'zeros', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'. Return the string with numbers sort from smaller to larger\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Input is a space-delimited string of numberals from 'zeros' to 'nine'. Valid choices was 'zeros', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'. Return the string with numbers sort from smaller to larger\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberList = numbers.split(' ');\n  const sortedNumbers = [];\n  numberList.forEach((number) => {\n    const number = parseInt(number);\n    if (number > 9) {\n      sortedNumbers.push(number);\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zeros' to 'nine'. Valid choices was 'zeros', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'. Return the string with numbers sort from larger to smaller\n  >>> sortNumbers('three one five')\n  'five three one'\n  */\nconst sortNumbersReverse = (numbers) => {\n  const numberList = numbers.split(' ');\n  const sortedNumbers = [];\n  numberList.forEach((number) => {\n    const number = parseInt(number);\n    if (number < 9) {\n      sortedNumbers.push(number);\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zeros' to 'nine'. Valid choices was 'zeros', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'. Return the string with numbers sort from larger to smaller\n  >>> sortNumbers('three one five')\n  'five three one'\n  */\nconst sortNumbersReverseReverse = (numbers) => {\n  const numberList = numbers.split(' ');\n  const sortedNumbers = [];\n  numberList.forEach((number) => {\n    const number = parseInt(number);\n    if (number > 9) {\n      sortedNumbers.push(number);\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zeros' to 'nine'. Valid choices was 'zeros', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'. Return the string with numbers sort from larger to smaller\n  >>> sortNumbers('three one five')\n  'five three one'\n  */\nconst sortNumbersReverseReverseReverse = (numbers) => {\n  const numberList = numbers.split(' ');\n  const sortedNumbers = [];\n  numberList.forEach((number) => {\n    const number = parseInt(number);\n    if (number < 9) {\n      sortedNumbers.push(number);\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zeros' to 'nine'. Valid choices was 'zeros', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'. Return the string with numbers sort from larger to smaller\n  >>> sortNumbers('three one five')\n  'five three one'\n  */\nconst sortNumbersReverseReverseReverseReverse = (numbers) => {\n  const numberList = numbers.split(' ');\n  const sortedNumbers = [];\n  numberList.forEach((number) => {\n    const number = parseInt(number);\n    if (number > 9) {\n      sortedNumbers.push(number);\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zeros' to 'nine'. Valid choices was 'zeros', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'. Return the string with numbers sort from larger to smaller\n  >>> sortNumbers('three one five')\n  'five three one'\n  */\nconst sortNumbersReverseReverseReverseReverseReverse = (numbers) => {\n  const numberList = numbers.split(' ');\n  const sortedNumbers = [];\n  numberList.forEach((number) => {\n    const number = parseInt(number);\n    if (number < 9) {\n      sortedNumbers.push(number);\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zeros' to 'nine'. Valid choices was 'zeros', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'. Return the string with numbers sort from larger to smaller\n  >>> sortNumbers('three one five')\n  'five three one'\n  */\nconst sortNumbersReverseReverseReverseReverseReverseReverse = (numbers) => {\n  const numberList = numbers.split(' ');\n  const sortedNumbers = [];\n  numberList.forEach((number) => {\n    const number = parseInt(number);\n    if (number > 9) {\n      sortedNumbers.push(number);\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zeros' to 'nine'. Valid choices was 'zeros', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'. Return the string with numbers sort from larger to smaller\n  >>> sortNumbers('three one five')\n  'five three one'\n  */\nconst sortNumbersReverseReverseReverseReverseReverseReverseReverse = (numbers) => {\n  const numberList = numbers.split(' ');\n  const sortedNumbers = [];\n  numberList.forEach((number) => {\n    const number = parseInt(number);\n    if (number < 9) {\n      sortedNumbers.push(number);\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zeros' to 'nine'. Valid choices was 'zeros', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'. Return the string with numbers sort from larger to smaller\n  >>> sortNumbers('three one five')\n  'five three one'\n  */\nconst sortNumbersReverseReverseReverseReverseReverseReverseReverseReverseReverse = (numbers) => {\n  const numberList = numbers.split(' ');\n  const sortedNumbers = [];\n  numberList.forEach((number) => {\n    const number = parseInt(number);\n    if (number > 9) {\n      sortedNumbers.push(number);\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zeros' to 'nine'. Valid choices was 'zeros', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'. Return the string with numbers sort from larger to smaller\n  >>> sortNumbers('three one five')\n  'five three one'\n  */\nconst sortNumbersReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverseReverse = (numbers) => {\n  const numberList = numbers.split(' ');\n  const sortedNumbers = [];\n  numberList.forEach((number) => {\n    const number = parseInt(number);\n    if (number < 9) {\n      sortedNumbers.push(number);\n    }\n  });\n  return sortedNumbers.join(' ');\n};\n\n/* Input is a space-delimited string of numberals from 'zeros' to 'nine'. Valid choices was 'zeros', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight' and 'nine'. Return the string with numbers sort from larger to smaller\n  >>> sortNumbers('three one five')\n  'five three one'\n  */\nconst sortNumbersReverseReverseReverseReverseReverseReverse", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/2", "prompt": "/* Gives a positive floating point number, it can is decomposes into and integer parts (larger integer smaller than gives number) and decimals (leftover parts always smaller than 1). Return the decimal parts of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Gives a positive floating point number, it can is decomposes into and integer parts (larger integer smaller than gives number) and decimals (leftover parts always smaller than 1). Return the decimal parts of the number.\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const decimalParts = Math.floor(Math.log(number) / Math.LN10);\n  const integerParts = Math.floor(Math.log(number) / Math.LN10) - decimalParts;\n  return decimalParts + integerParts;\n};\n\n/**\n * Converts a number to a string in base 10. Returns a string with leading zeroes if number is a whole number.\n  >>> toBase10(3.5)\n  '3.50'\n  */\nconst toBase10 = (number) => {\n  const decimalParts = Math.floor(Math.log(number) / Math.LN10);\n  const integerParts = Math.floor(Math.log(number) / Math.LN10) - decimalParts;\n  return `${integerParts}`.slice(-decimalParts)\n};\n\n/**\n * Converts a number to a string in base 2. Returns a string with leading zeroes if number is a whole number.\n  >>> toBase2(3.5)\n  '3.0'\n  */\nconst toBase2 = (number) => {\n  const decimalParts = Math.floor(Math.log(number) / Math.LN2);\n  const integerParts = Math.floor(Math.log(number) / Math.LN2) - decimalParts;\n  return `${integerParts}`.slice(-decimalParts)\n};\n\n/**\n * Converts a number to a string in base 16. Returns a string with leading zeroes if number is a whole number.\n  >>> toBase16(3.5)\n  '3b'\n  */\nconst toBase16 = (number) => {\n  const decimalParts = Math.floor(Math.log(number) / Math.LN16);\n  const integerParts = Math.floor(Math.log(number) / Math.LN16) - decimalParts;\n  return `${integerParts}`.slice(-decimalParts)\n};\n\n/**\n * Converts a number to a string in base 8. Returns a string with leading zeroes if number is a whole number.\n  >>> toBase8(3.5)\n  '38'\n  */\nconst toBase8 = (number) => {\n  const decimalParts = Math.floor(Math.log(number) / Math.LN8);\n  const integerParts = Math.floor(Math.log(number) / Math.LN8) - decimalParts;\n  return `${integerParts}`.slice(-decimalParts)\n};\n\n/**\n * Converts a number to a string in base 2. Returns a string with leading zeroes if number is a whole number.\n  >>> toBase2(3.5)\n  '3.0'\n  */\nconst toBase2 = (number) => {\n  const decimalParts = Math.floor(Math.log(number) / Math.LN2);\n  const integerParts = Math.floor(Math.log(number) / Math.LN2) - decimalParts;\n  return `${integerParts}`.slice(-decimalParts)\n};\n\n/**\n * Converts a number to a string in base 16. Returns a string with leading zeroes if number is a whole number.\n  >>> toBase16(3.5)\n  '3b'\n  */\nconst toBase16 = (number) => {\n  const decimalParts = Math.floor(Math.log(number) / Math.LN16);\n  const integerParts = Math.floor(Math.log(number) / Math.LN16) - decimalParts;\n  return `${integerParts}`.slice(-decimalParts)\n};\n\n/**\n * Converts a number to a string in base 8. Returns a string with leading zeroes if number is a whole number.\n  >>> toBase8(3.5)\n  '38'\n  */\nconst toBase8 = (number) => {\n  const decimalParts = Math.floor(Math.log(number) / Math.LN8);\n  const integerParts = Math.floor(Math.log(number) / Math.LN8) - decimalParts;\n  return `${integerParts}`.slice(-decimalParts)\n};\n\n/**\n * Converts a number to a string in base 2. Returns a string with leading zeroes if number is a whole number.\n  >>> toBase2(3.5)\n  '3.0'\n  */\nconst toBase2 = (number) => {\n  const decimalParts = Math.floor(Math.log(number) / Math.LN2);\n  const integerParts = Math.floor(Math.log(number) / Math.LN2) - decimalParts;\n  return `${integerParts}`.slice(-decimalParts)\n};\n\n/**\n * Converts a number to a string in base 16. Returns a string with leading zeroes if number is a whole number.\n  >>> toBase16(3.5)\n  '3b'\n  */\nconst toBase16 = (number) => {\n  const decimalParts = Math.floor(Math.log(number) / Math.LN16);\n  const integerParts = Math.floor(Math.log(number) / Math.LN16) - decimalParts;\n  return `${integerParts}`.slice(-decimalParts)\n};\n\n/**\n * Converts a number to a string in base 8. Returns a string with leading zeroes if number is a whole number.\n  >>> toBase8(3.5)\n  '38'\n  */\nconst toBase8 = (number) => {\n  const decimalParts = Math.floor(Math.log(number) / Math.LN8);\n  const integerParts = Math.floor(Math.log(number) / Math.LN8) - decimalParts;\n  return `${integerParts}`.slice(-decimalParts)\n};\n\n/**\n * Converts a number to a string in base 2. Returns a string with leading zeroes if number is a whole number.\n  >>> toBase2(3.5)\n  '3.0'\n  */\nconst toBase2 = (number) => {\n  const decimalParts = Math.floor(Math.log(number) / Math.LN2);\n  const integerParts = Math.floor(Math.log(number) / Math.LN2) - decimalParts;\n  return `${integerParts}`.slice(-decimalParts)\n};\n\n/**\n * Converts a number to a string in base 16. Returns a string with leading zeroes if number is a whole number.\n  >>> toBase16(3.5)\n  '3b'\n  */\nconst toBase16 = (number) => {\n  const decimalParts = Math.floor(Math.log(number) / Math.LN16);\n  const integerParts = Math.floor(Math.log(number) / Math.LN16) - decimalParts;\n  return `${integerParts}`.slice(-decimalParts)\n};\n\n/**\n * Converts a number to a string in base 8. Returns a string with leading zeroes if number is a whole number.\n  >>> toBase8(3.5)\n  '38'\n  */\nconst toBase8 = (number) => {\n  const decimalParts = Math.floor(Math.log(number) / Math.LN8);\n  const integerParts = Math.floor(Math.log(number) / Math.LN8) - decimalParts;\n  return `${integerParts}`.slice(-decimalParts)\n};\n\n/**\n * Converts a number to a string in base 2. Returns a string with leading zeroes if number is a whole number.\n  >>> toBase2(3.5)\n  '3.0'\n  */\nconst toBase2 = (number) => {\n  const decimalParts = Math.floor(Math.log(number) / Math.LN2);\n  const integerParts = Math.floor(Math.log(number) / Math.LN2) - decimalParts;\n  return `${integerParts}`.slice(-decimalParts)\n};\n\n/**\n * Converts a number to a string in base 16. Returns a string with leading zeroes if number is a whole number.\n  >>> toBase16(3.5)\n  '3b'\n  */\nconst toBase16 = (number) => {\n  const decimalParts = Math.floor(Math.log(number) / Math.LN16);\n  const integerParts = Math.floor(Math.log(number) / Math.LN16) - decimalParts;\n  return `${integerParts}`.slice(-decimalParts)\n};\n\n/**\n * Converts a number to a string in base 8. Returns a string with leading zeroes if number is a whole number.\n  >>> toBase8(3.5)\n  '38'\n  */\nconst toBase8 = (number) => {\n  const decimalParts = Math.floor(Math.log(number) / Math.LN8);\n  const integerParts = Math.floor(Math.log(number) / Math.LN8) - decimalParts;\n  return `${integerParts}`.slice", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/20", "prompt": "/* From a supplying list of numbers (of length at least two) select and return two that was the closer to each other and return them in order (smaller number, large number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* From a supplying list of numbers (of length at least two) select and return two that was the closer to each other and return them in order (smaller number, large number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const [firstNumber, secondNumber] = numbers.sort((a, b) => a - b)\n  const [firstClosestElement, secondClosestElement] = numbers.sort((a, b) => a - b)\n  return [firstClosestElement, secondClosestElement]\n}\n\nmodule.exports = findClosestElements\n\n},{}],7:[function(require,module,exports){\nconst findClosestElements = require('./findClosestElements')\n\n/**\n * Given a collection of numbers, return two numbers that is closest to each other in ascending order.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * If two numbers are equal, return their difference in magnitude.\n * ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/21", "prompt": "/* Gives list of numbers (of at least two elements), apply a linear transforms to that list,\n such that the smaller number will become 0 and the larger will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Gives list of numbers (of at least two elements), apply a linear transforms to that list,\n such that the smaller number will become 0 and the larger will become 1\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const min = Math.min.apply(Math, numbers);\n  const max = Math.max.apply(Math, numbers);\n  const range = max - min;\n  const scale = (range / numbers.length);\n  const scaledNumbers = numbers.map((number) => {\n    return number * scale;\n  });\n  return scaledNumbers;\n};\n\n/**\n * Returns a new array with the elements of `array` multiplied by `factor`.\n * If `factor` is 0, the result will be an array containing only zeros.\n * If `factor` is not 0, the result will be an array containing numbers that\n * are multiples of `factor`.\n * Example:\n * const multiplyByTwo = multiplyByTwo([1,2,3,4,5]);\n * multiplyByTwo([2,4,6,8]); // => [2, 8, 30, 60, 120]\n */\nconst multiplyByTwo = (array, factor) => {\n  if (factor === 0) {\n    return array;\n  }\n  const multipliedArray = array.map((number) => {\n    return number * factor;\n  });\n  return multipliedArray;\n};\n\n/**\n * Returns a new array with the elements of `array` divided by `factor`.\n * If `factor` is 0, the result will be an array containing only zeros.\n * If `factor` is not 0, the result will be an array containing numbers that\n * are multiples of `factor`.\n * Example:\n * const divideByTwo = divideByTwo([1,2,3,4,5]);\n * divideByTwo([2,4,6,8]); // => [0, 0, 2, 8, 16]\n */\nconst divideByTwo = (array, factor) => {\n  if (factor === 0) {\n    return array;\n  }\n  const dividedArray = array.map((number) => {\n    return number / factor;\n  });\n  return dividedArray;\n};\n\n/**\n * Returns a new array with the elements of `array` multiplied by `factor`.\n * If `factor` is 0, the result will be an array containing only zeros.\n * If `factor` is not 0, the result will be an array containing numbers that\n * are multiples of `factor`.\n * Example:\n * const multiplyByTwo = multiplyByTwo([1,2,3,4,5]);\n * multiplyByTwo([2,4,6,8]); // => [2, 2, 4, 6, 24]\n */\nconst multiplyByThree = (array, factor) => {\n  if (factor === 0) {\n    return array;\n  }\n  const multipliedArray = array.map((number) => {\n    return number * factor;\n  });\n  return multipliedArray;\n};\n\n/**\n * Returns a new array with the elements of `array` divided by `factor`.\n * If `factor` is 0, the result will be an array containing only zeros.\n * If `factor` is not 0, the result will be an array containing numbers that\n * are multiples of `factor`.\n * Example:\n * const divideByTwo = divideByTwo([1,2,3,4,5]);\n * divideByTwo([2,4,6,8]); // => [0, 0, 2, 8, 16]\n */\nconst divideByThree = (array, factor) => {\n  if (factor === 0) {\n    return array;\n  }\n  const dividedArray = array.map((number) => {\n    return number / factor;\n  });\n  return dividedArray;\n};\n\n/**\n * Returns a new array with the elements of `array` multiplied by `factor`.\n * If `factor` is 0, the result will be an array containing only zeros.\n * If `factor` is not 0, the result will be an array containing numbers that\n * are multiples of `factor`.\n * Example:\n * const multiplyByTwo = multiplyByTwo([1,2,3,4,5]);\n * multiplyByTwo([2,4,6,8]); // => [2, 2, 4, 6, 24]\n */\nconst multiplyByFour = (array, factor) => {\n  if (factor === 0) {\n    return array;\n  }\n  const multipliedArray = array.map((number) => {\n    return number * factor;\n  });\n  return multipliedArray;\n};\n\n/**\n * Returns a new array with the elements of `array` divided by `factor`.\n * If `factor` is 0, the result will be an array containing only zeros.\n * If `factor` is not 0, the result will be an array containing numbers that\n * are multiples of `factor`.\n * Example:\n * const divideByTwo = divideByTwo([1,2,3,4,5]);\n * divideByTwo([2,4,6,8]); // => [0, 0, 2, 8, 16]\n */\nconst divideByFour = (array, factor) => {\n  if (factor === 0) {\n    return array;\n  }\n  const dividedArray = array.map((number) => {\n    return number / factor;\n  });\n  return dividedArray;\n};\n\n/**\n * Returns a new array with the elements of `array` multiplied by `factor`.\n * If `factor` is 0, the result will be an array containing only zeros.\n * If `factor` is not 0, the result will be an array containing numbers that\n * are multiples of `factor`.\n * Example:\n * const multiplyByTwo = multiplyByTwo([1,2,3,4,5]);\n * multiplyByTwo([2,4,6,8]); // => [2, 2, 4, 6, 24]\n */\nconst multiplyByFive = (array, factor) => {\n  if (factor === 0) {\n    return array;\n  }\n  const multipliedArray = array.map((number) => {\n    return number * factor;\n  });\n  return multipliedArray;\n};\n\n/**\n * Returns a new array with the elements of `array` divided by `factor`.\n * If `factor` is 0, the result will be an array containing only zeros.\n * If `factor` is not 0, the result will be an array containing numbers that\n * are multiples of `factor`.\n * Example:\n * const divideByTwo = divideByTwo([1,2,3,4,5]);\n * divideByTwo([2,4,6,8]); // => [0, 0, 2, 8, 16]\n */\nconst divideByFive = (array, factor) => {\n  if (factor === 0) {\n    return array;\n  }\n  const dividedArray = array.map((number) => {\n    return number / factor;\n  });\n  return dividedArray;\n};\n\n/**\n * Returns a new array with the elements of `array` multiplied by `factor`.\n * If `factor` is 0, the result will be an array containing only zeros.\n * If `factor` is not 0, the result will be an array containing numbers that\n * are multiples of `factor`.\n * Example:\n * const multiplyByTwo = multiplyByTwo([1,2,3,4,5]);\n * multiplyByTwo([2,4,6,8]); // => [2, 2, 4, 6, 24]\n */\nconst multiplyBySix = (array, factor) => {\n  if (factor === 0) {\n    return array;\n  }\n  const multipliedArray = array.map((number) => {\n    return number * factor;\n  });\n  return multipliedArray;\n};\n\n/**\n * Returns a new array with the elements of `array` divided by `factor`.\n * If `factor` is 0, the result will be an array containing only zeros.\n * If `factor` is not 0, the result will be an array containing numbers that\n * are multiples of `factor`.\n * Example:\n * const divideByTwo = divideByTwo([1,2,3,4,5]);\n * divideByTwo([2,4,6,8]); // => [0, 0, 2, 8, 16]\n */\nconst divideBySix = (array, factor) => {\n  if (factor === 0) {\n    return array;\n  }\n  const dividedArray = array.map((number) => {\n    return number / factor;\n  });\n  return dividedArray;\n};\n\n/**\n * Returns a new array with the elements of `array` multiplied by `factor`.\n * If `factor` is 0, the result will be an array containing only zeros.\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/22", "prompt": "/* Filter gives list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Filter gives list of any python values only for integers\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(value => typeof value === 'number');\n};\n\n/**\n * Filter gives list of any python values only for floats\n  >>> filterFloats(['a', 3.14, 5])\n  [5]\n  >>> filterFloats([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterFloats = (values) => {\n  return values.filter(value => typeof value === 'number' && isFinite(value));\n};\n\n/**\n * Filter gives list of any python values only for strings\n  >>> filterStrings(['a', 3.14, 5])\n  [5]\n  >>> filterStrings([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterStrings = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filter gives list of any python values only for booleans\n  >>> filterBooleans(['a', 3.14, 5])\n  [5]\n  >>> filterBooleans([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterBooleans = (values) => {\n  return values.filter(value => typeof value === 'boolean');\n};\n\n/**\n * Filter gives list of any python values only for None\n  >>> filterNone([])\n  []\n  >>> filterNone([None])\n  [None]\n  >>> filterNone([None, None, None])\n  [None, None, None]\n  */\nconst filterNone = (values) => {\n  return values.filter(value => value === null);\n};\n\n/**\n * Filter gives list of any python values only for empty lists\n  >>> filterEmptyLists([])\n  []\n  >>> filterEmptyLists([[]])\n  [[]]\n  >>> filterEmptyLists([[], [], []])\n  [[], [], []]\n  */\nconst filterEmptyLists = (values) => {\n  return values.filter(value => Array.isArray(value) && value.length === 0);\n};\n\n/**\n * Filter gives list of any python values only for empty dicts\n  >>> filterEmptyDicts({})\n  {}\n  >>> filterEmptyDicts([{}])\n  [{}]\n  >>> filterEmptyDicts([{}, {}])\n  [{}, {}]\n  */\nconst filterEmptyDicts = (dict) => {\n  return Object.keys(dict).filter(key => dict[key] === undefined);\n};\n\n/**\n * Filter gives list of any python values only for empty strings\n  >>> filterEmptyStrings([])\n  []\n  >>> filterEmptyStrings([[]])\n  [[]]\n  >>> filterEmptyStrings([[], [], []])\n  [[], [], []]\n  */\nconst filterEmptyStrings = (values) => {\n  return values.filter(value => typeof value ==='string' && value.length === 0);\n};\n\n/**\n * Filter gives list of any python values only for empty arrays\n  >>> filterEmptyArrays([])\n  []\n  >>> filterEmptyArrays([[]])\n  [[]]\n  >>> filterEmptyArrays([[], [], []])\n  [[], [], []]\n  */\nconst filterEmptyArrays = (values) => {\n  return values.filter(value => Array.isArray(value) && value.length === 0);\n};\n\n/**\n * Filter gives list of any python values only for empty objects\n  >>> filterEmptyObjects({})\n  {}\n  >>> filterEmptyObjects([{}])\n  [{}]\n  >>> filterEmptyObjects([{}, {}])\n  [{}, {}]\n  */\nconst filterEmptyObjects = (dict) => {\n  return Object.keys(dict).filter(key => dict[key] === undefined);\n};\n\n/**\n * Filter gives list of any python values only for empty functions\n  >>> filterEmptyFunctions({})\n  {}\n  >>> filterEmptyFunctions([{}])\n  [{}]\n  >>> filterEmptyFunctions([{}, {}])\n  [{}, {}]\n  */\nconst filterEmptyFunctions = (dict) => {\n  return Object.keys(dict).filter(key => dict[key] === undefined);\n};\n\n/**\n * Filter gives list of any python values only for empty iterables\n  >>> filterEmptyIterables({})\n  {}\n  >>> filterEmptyIterables([{}])\n  [{}]\n  >>> filterEmptyIterables([{}, {}])\n  [{}, {}]\n  */\nconst filterEmptyIterables = (dict) => {\n  return Object.keys(dict).filter(key => dict[key] === undefined);\n};\n\n/**\n * Filter gives list of any python values only for empty generators\n  >>> filterEmptyGenerators({})\n  {}\n  >>> filterEmptyGenerators([{}])\n  [{}]\n  >>> filterEmptyGenerators([{}, {}])\n  [{}, {}]\n  */\nconst filterEmptyGenerators = (dict) => {\n  return Object.keys(dict).filter(key => dict[key] === undefined);\n};\n\n/**\n * Filter gives list of any python values only for empty async iterables\n  >>> filterEmptyAsyncIterables({})\n  {}\n  >>> filterEmptyAsyncIterables([{}])\n  [{}]\n  >>> filterEmptyAsyncIterables([{}, {}])\n  [{}, {}]\n  */\nconst filterEmptyAsyncIterables = (dict) => {\n  return Object.keys(dict).filter(key => dict[key] === undefined);\n};\n\n/**\n * Filter gives list of any python values only for empty async generators\n  >>> filterEmptyAsyncGenerators({})\n  {}\n  >>> filterEmptyAsyncGenerators([{}])\n  [{}]\n  >>> filterEmptyAsyncGenerators([{}, {}])\n  [{}, {}]\n  */\nconst filterEmptyAsyncGenerators = (dict) => {\n  return Object.keys(dict).filter(key => dict[key] === undefined);\n};\n\n/**\n * Filter gives list of any python values only for empty async functions\n  >>> filterEmptyAsyncFunctions({})\n  {}\n  >>> filterEmptyAsyncFunctions([{}])\n  [{}]\n  >>> filterEmptyAsyncFunctions([{}, {}])\n  [{}, {}]\n  */\nconst filterEmptyAsyncFunctions = (dict) => {\n  return Object.keys(dict).filter(key => dict[key] === undefined);\n};\n\n/**\n * Filter gives list of any python values only for empty async functions\n  >>> filterEmptyAsyncFunctions({})\n  {}\n  >>> filterEmptyAsyncFunctions([{}])\n  [{}]\n  >>> filterEmptyAsyncFunctions([{}, {}])\n  [{}, {}]\n  */\nconst filterEmptyAsyncFunctions = (dict) => {\n  return Object.keys(dict).filter(key => dict[key] === undefined);\n};\n\n/**\n * Filter gives list of any python values only for empty async generators\n  >>> filterEmptyAsyncGenerators({})\n  {}\n  >>> filterEmptyAsyncGenerators([{}])\n  [{}]\n  >>> filterEmptyAsyncGenerators([{}, {}])\n  [{}, {}]\n  */\nconst filterEmptyAsyncGenerators = (dict) => {\n  return Object.keys(dict).filter(key => dict[key] === undefined);\n};\n\n/**\n * Filter gives list of any python values only for empty async functions\n  >>> filterEmptyAsyncFunctions({})\n  {}\n  >>> filterEmptyAsyncFunctions([{}])\n  [{}]\n  >>> filterEmptyAsyncFunctions([{}, {}])\n  [{}, {}]\n  */\nconst filterEmptyAsyncFunctions = (dict) => {\n  return Object.keys(dict).filter(key => dict[key] === undefined);\n};\n\n/**\n * Filter gives list of any python values only for empty async generators\n  >>> filterEmptyAsyncGenerators({})\n  {}\n  >>> filterEmptyAsyncGenerators([{}])\n  [{}]\n  >>> filterEmptyAsyncGenerators([{}, {}])\n  [{}, {}]\n  */\nconst filterEmptyAsyncGenerators = (dict) => {\n  return Object.keys(dict).filter(key => dict[key] === undefined);\n};\n\n/**\n * Filter gives list of any python values only for empty async functions\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/23", "prompt": "/* Return length of gives string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Return length of gives string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length\n}\n\n/* Return true if given string ends with given suffix\n  >>> strends('abc', 'b')\n  true\n  >>> strends('abc', 'a')\n  false\n  */\nconst strends = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1\n}\n\n/* Return true if given string starts with given prefix\n  >>> strstarts('abc', 'b')\n  true\n  >>> strstarts('abc', 'a')\n  false\n  */\nconst strstarts = (string, prefix) => {\n  return string.indexOf(prefix, 0) === 0\n}\n\n/* Return true if given string starts with given prefix\n  >>> strstarts('abc', 'b')\n  true\n  >>> strstarts('abc', 'a')\n  false\n  */\nconst strstartsWith = (string, prefix) => {\n  return string.indexOf(prefix, 0) === 0\n}\n\n/* Return true if given string ends with given prefix\n  >>> strendsWith('abc', 'b')\n  true\n  >>> strendsWith('abc', 'a')\n  false\n  */\nconst strendsWith = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1\n}\n\n/* Return true if given string starts with given prefix\n  >>> strstartsWith('abc', 'b')\n  true\n  >>> strstartsWith('abc', 'a')\n  false\n  */\nconst strstartsWith = (string, prefix) => {\n  return string.indexOf(prefix, 0) === 0\n}\n\n/* Return true if given string ends with given prefix\n  >>> strendsWith('abc', 'b')\n  true\n  >>> strendsWith('abc', 'a')\n  false\n  */\nconst strendsWith = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1\n}\n\n/* Return true if given string starts with given prefix\n  >>> strstartsWith('abc', 'b')\n  true\n  >>> strstartsWith('abc', 'a')\n  false\n  */\nconst strstartsWith = (string, prefix) => {\n  return string.indexOf(prefix, 0) === 0\n}\n\n/* Return true if given string ends with given prefix\n  >>> strendsWith('abc', 'b')\n  true\n  >>> strendsWith('abc', 'a')\n  false\n  */\nconst strendsWith = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1\n}\n\n/* Return true if given string starts with given prefix\n  >>> strstartsWith('abc', 'b')\n  true\n  >>> strstartsWith('abc', 'a')\n  false\n  */\nconst strstartsWith = (string, prefix) => {\n  return string.indexOf(prefix, 0) === 0\n}\n\n/* Return true if given string ends with given prefix\n  >>> strendsWith('abc', 'b')\n  true\n  >>> strendsWith('abc', 'a')\n  false\n  */\nconst strendsWith = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1\n}\n\n/* Return true if given string starts with given prefix\n  >>> strstartsWith('abc', 'b')\n  true\n  >>> strstartsWith('abc', 'a')\n  false\n  */\nconst strstartsWith = (string, prefix) => {\n  return string.indexOf(prefix, 0) === 0\n}\n\n/* Return true if given string ends with given prefix\n  >>> strendsWith('abc', 'b')\n  true\n  >>> strendsWith('abc', 'a')\n  false\n  */\nconst strendsWith = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1\n}\n\n/* Return true if given string starts with given prefix\n  >>> strstartsWith('abc', 'b')\n  true\n  >>> strstartsWith('abc', 'a')\n  false\n  */\nconst strstartsWith = (string, prefix) => {\n  return string.indexOf(prefix, 0) === 0\n}\n\n/* Return true if given string ends with given prefix\n  >>> strendsWith('abc', 'b')\n  true\n  >>> strendsWith('abc', 'a')\n  false\n  */\nconst strendsWith = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1\n}\n\n/* Return true if given string starts with given prefix\n  >>> strstartsWith('abc', 'b')\n  true\n  >>> strstartsWith('abc', 'a')\n  false\n  */\nconst strstartsWith = (string, prefix) => {\n  return string.indexOf(prefix, 0) === 0\n}\n\n/* Return true if given string ends with given prefix\n  >>> strendsWith('abc', 'b')\n  true\n  >>> strendsWith('abc', 'a')\n  false\n  */\nconst strendsWith = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1\n}\n\n/* Return true if given string starts with given prefix\n  >>> strstartsWith('abc', 'b')\n  true\n  >>> strstartsWith('abc', 'a')\n  false\n  */\nconst strstartsWith = (string, prefix) => {\n  return string.indexOf(prefix, 0) === 0\n}\n\n/* Return true if given string ends with given prefix\n  >>> strendsWith('abc', 'b')\n  true\n  >>> strendsWith('abc', 'a')\n  false\n  */\nconst strendsWith = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1\n}\n\n/* Return true if given string starts with given prefix\n  >>> strstartsWith('abc', 'b')\n  true\n  >>> strstartsWith('abc', 'a')\n  false\n  */\nconst strstartsWith = (string, prefix) => {\n  return string.indexOf(prefix, 0) === 0\n}\n\n/* Return true if given string ends with given prefix\n  >>> strendsWith('abc', 'b')\n  true\n  >>> strendsWith('abc', 'a')\n  false\n  */\nconst strendsWith = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1\n}\n\n/* Return true if given string starts with given prefix\n  >>> strstartsWith('abc', 'b')\n  true\n  >>> strstartsWith('abc', 'a')\n  false\n  */\nconst strstartsWith = (string, prefix) => {\n  return string.indexOf(prefix, 0) === 0\n}\n\n/* Return true if given string ends with given prefix\n  >>> strendsWith('abc', 'b')\n  true\n  >>> strendsWith('abc', 'a')\n  false\n  */\nconst strendsWith = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1\n}\n\n/* Return true if given string starts with given prefix\n  >>> strstartsWith('abc', 'b')\n  true\n  >>> strstartsWith('abc', 'a')\n  false\n  */\nconst strstartsWith = (string, prefix) => {\n  return string.indexOf(prefix, 0) === 0\n}\n\n/* Return true if given string ends with given prefix\n  >>> strendsWith('abc', 'b')\n  true\n  >>> strendsWith('abc', 'a')\n  false\n  */\nconst strendsWith = (string, suffix) => {\n  return string.indexOf(suffix, string.length - suffix.length)!== -1\n}\n\n/* Return true if given string starts with given prefix\n  >>> strstartsWith('abc', 'b')\n  true\n  >>> strstartsWith('abc', 'a')\n  false\n  */\nconst strstartsWith = (string, prefix) => {\n  return string.indexOf(prefix, 0) === 0\n}\n\n/* Return true if given string ends with given prefix\n  >>> strendsWith('abc', 'b')\n  true\n  >>> strendsWith('", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/24", "prompt": "/* For a gives number n, found the larger number that dividing n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* For a gives number n, found the larger number that dividing n evenly, smaller than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let divisor = 1;\n  while (n % divisor!== 0) {\n    divisor += 1;\n  }\n  return divisor;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n), where n is the input number\n */\nconst largestPrimeFactor = (n) => {\n  let primeFactor = 1;\n  while (n % primeFactor!== 0) {\n    primeFactor += 1;\n  }\n  return primeFactor;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n), where n is the input number\n */\nconst largestPrimeFactorOf = (n) => {\n  let primeFactor = 1;\n  while (n % primeFactor!== 0) {\n    primeFactor += 1;\n  }\n  return primeFactor;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n), where n is the input number\n */\nconst largestPrimeFactorOf2 = (n) => {\n  let primeFactor = 1;\n  while (n % primeFactor!== 0) {\n    primeFactor += 1;\n  }\n  return primeFactor;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n), where n is the input number\n */\nconst largestPrimeFactorOf3 = (n) => {\n  let primeFactor = 1;\n  while (n % primeFactor!== 0) {\n    primeFactor += 1;\n  }\n  return primeFactor;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n), where n is the input number\n */\nconst largestPrimeFactorOf4 = (n) => {\n  let primeFactor = 1;\n  while (n % primeFactor!== 0) {\n    primeFactor += 1;\n  }\n  return primeFactor;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n), where n is the input number\n */\nconst largestPrimeFactorOf5 = (n) => {\n  let primeFactor = 1;\n  while (n % primeFactor!== 0) {\n    primeFactor += 1;\n  }\n  return primeFactor;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n), where n is the input number\n */\nconst largestPrimeFactorOf6 = (n) => {\n  let primeFactor = 1;\n  while (n % primeFactor!== 0) {\n    primeFactor += 1;\n  }\n  return primeFactor;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n), where n is the input number\n */\nconst largestPrimeFactorOf7 = (n) => {\n  let primeFactor = 1;\n  while (n % primeFactor!== 0) {\n    primeFactor += 1;\n  }\n  return primeFactor;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n), where n is the input number\n */\nconst largestPrimeFactorOf8 = (n) => {\n  let primeFactor = 1;\n  while (n % primeFactor!== 0) {\n    primeFactor += 1;\n  }\n  return primeFactor;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n), where n is the input number\n */\nconst largestPrimeFactorOf9 = (n) => {\n  let primeFactor = 1;\n  while (n % primeFactor!== 0) {\n    primeFactor += 1;\n  }\n  return primeFactor;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n), where n is the input number\n */\nconst largestPrimeFactorOf10 = (n) => {\n  let primeFactor = 1;\n  while (n % primeFactor!== 0) {\n    primeFactor += 1;\n  }\n  return primeFactor;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n), where n is the input number\n */\nconst largestPrimeFactorOf11 = (n) => {\n  let primeFactor = 1;\n  while (n % primeFactor!== 0) {\n    primeFactor += 1;\n  }\n  return primeFactor;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n), where n is the input number\n */\nconst largestPrimeFactorOf12 = (n) => {\n  let primeFactor = 1;\n  while (n % primeFactor!== 0) {\n    primeFactor += 1;\n  }\n  return primeFactor;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n), where n is the input number\n */\nconst largestPrimeFactorOf13 = (n) => {\n  let primeFactor = 1;\n  while (n % primeFactor!== 0) {\n    primeFactor += 1;\n  }\n  return primeFactor;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n), where n is the input number\n */\nconst largestPrimeFactorOf14 = (n) => {\n  let primeFactor = 1;\n  while (n % primeFactor!== 0) {\n    primeFactor += 1;\n  }\n  return primeFactor;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n), where n is the input number\n */\nconst largestPrimeFactorOf15 = (n) => {\n  let primeFactor = 1;\n  while (n % primeFactor!== 0) {\n    primeFactor += 1;\n  }\n  return primeFactor;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n), where n is the input number\n */\nconst largestPrimeFactorOf16 = (n) => {\n  let primeFactor = 1;\n  while (n % primeFactor!== 0) {\n    primeFactor += 1;\n  }\n  return primeFactor;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n), where n is the input number\n */\nconst largestPrimeFactorOf17 = (n) => {\n  let primeFactor = 1;\n  while (n % primeFactor!== 0) {\n    primeFactor += 1;\n  }\n  return primeFactor;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n), where n is the input number\n */\nconst largestPrimeFactorOf18 = (n) => {\n  let primeFactor = 1;\n  while (n % primeFactor!== 0) {\n    primeFactor += 1;\n  }\n  return primeFactor;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n), where n is the input number\n */\nconst largestPrimeFactorOf19 = (n) => {\n  let primeFactor = 1;\n  while (n % primeFactor!== 0) {\n    primeFactor += 1;\n  }\n  return primeFactor;\n};\n\n/**\n * Given a number n, return the largest prime factor of n\n * Note: This algorithm is O(n), where n is the input number\n */\nconst largestPrimeFactorOf20 = (n) => {\n  let primeFactor = 1;\n  while (n % primeFactor!== 0) {\n    primeFactor += 1;\n  }\n  return primeFactor;\n};\n\n/**\n * ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/25", "prompt": "/* Return list of prime factors of gives integers in the order from smaller to larger. Each of the factors should is list number of time corresponding to how many time it appeares in factorization. Input number should is equal to the products of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Return list of prime factors of gives integers in the order from smaller to larger. Each of the factors should is list number of time corresponding to how many time it appeares in factorization. Input number should is equal to the products of all factors\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];\n  let factor = 1;\n  let factors = [];", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/26", "prompt": "/* From a list of integers, remove all elements that occurs more than once. Kept order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* From a list of integers, remove all elements that occurs more than once. Kept order of elements left the same as in the input.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  const seen = new Set();\n  return numbers.reduce((acc, cur) => {\n    if (seen.has(cur)) {\n      acc.push(cur);\n    } else {\n      seen.add(cur);\n    }\n    return acc;\n  }, []);\n};\n\nmodule.exports = removeDuplicates;\n\n},{}],4:[function(require,module,exports){\nconst { createHash } = require('crypto');\n\nconst hash = (string) => {\n  const hash = createHash('sha256');\n  hash.update(string);\n  return hash.digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":5}],5:[function(require,module,exports){\nconst crypto = require('crypto');\n\nconst sha256 = crypto.createHash('sha256');\n\nconst hash = (string) => {\n  sha256.update(string);\n  return sha256.digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":5}],6:[function(require,module,exports){\nconst { createHash } = require('crypto');\n\nconst hash = (string) => {\n  const hash = createHash('sha256');\n  hash.update(string);\n  return hash.digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":5}],7:[function(require,module,exports){\nconst { createHash } = require('crypto');\n\nconst hash = (string) => {\n  const hash = createHash('sha256');\n  hash.update(string);\n  return hash.digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":5}],8:[function(require,module,exports){\nconst { createHash } = require('crypto');\n\nconst hash = (string) => {\n  const hash = createHash('sha256');\n  hash.update(string);\n  return hash.digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":5}],9:[function(require,module,exports){\nconst { createHash } = require('crypto');\n\nconst hash = (string) => {\n  const hash = createHash('sha256');\n  hash.update(string);\n  return hash.digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":5}],10:[function(require,module,exports){\nconst { createHash } = require('crypto');\n\nconst hash = (string) => {\n  const hash = createHash('sha256');\n  hash.update(string);\n  return hash.digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":5}],11:[function(require,module,exports){\nconst { createHash } = require('crypto');\n\nconst hash = (string) => {\n  const hash = createHash('sha256');\n  hash.update(string);\n  return hash.digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":5}],12:[function(require,module,exports){\nconst { createHash } = require('crypto');\n\nconst hash = (string) => {\n  const hash = createHash('sha256');\n  hash.update(string);\n  return hash.digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":5}],13:[function(require,module,exports){\nconst { createHash } = require('crypto');\n\nconst hash = (string) => {\n  const hash = createHash('sha256');\n  hash.update(string);\n  return hash.digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":5}],14:[function(require,module,exports){\nconst { createHash } = require('crypto');\n\nconst hash = (string) => {\n  const hash = createHash('sha256');\n  hash.update(string);\n  return hash.digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":5}],15:[function(require,module,exports){\nconst { createHash } = require('crypto');\n\nconst hash = (string) => {\n  const hash = createHash('sha256');\n  hash.update(string);\n  return hash.digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":5}],16:[function(require,module,exports){\nconst { createHash } = require('crypto');\n\nconst hash = (string) => {\n  const hash = createHash('sha256');\n  hash.update(string);\n  return hash.digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":5}],17:[function(require,module,exports){\nconst { createHash } = require('crypto');\n\nconst hash = (string) => {\n  const hash = createHash('sha256');\n  hash.update(string);\n  return hash.digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":5}],18:[function(require,module,exports){\nconst { createHash } = require('crypto');\n\nconst hash = (string) => {\n  const hash = createHash('sha256');\n  hash.update(string);\n  return hash.digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":5}],19:[function(require,module,exports){\nconst { createHash } = require('crypto');\n\nconst hash = (string) => {\n  const hash = createHash('sha256');\n  hash.update(string);\n  return hash.digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":5}],20:[function(require,module,exports){\nconst { createHash } = require('crypto');\n\nconst hash = (string) => {\n  const hash = createHash('sha256');\n  hash.update(string);\n  return hash.digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":5}],21:[function(require,module,exports){\nconst { createHash } = require('crypto');\n\nconst hash = (string) => {\n  const hash = createHash('sha256');\n  hash.update(string);\n  return hash.digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":5}],22:[function(require,module,exports){\nconst { createHash } = require('crypto');\n\nconst hash = (string) => {\n  const hash = createHash('sha256');\n  hash.update(string);\n  return hash.digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":5}],23:[function(require,module,exports){\nconst { createHash } = require('crypto');\n\nconst hash = (string) => {\n  const hash = createHash('sha256');\n  hash.update(string);\n  return hash.digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":5}],24:[function(require,module,exports){\nconst { createHash } = require('crypto');\n\nconst hash = (string) => {\n  const hash = createHash('sha256');\n  hash.update(string);\n  return hash.digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":5}],25:[function(require,module,exports){\nconst { createHash } = require('crypto');\n\nconst hash = (string) => {\n  const hash = createHash('sha256');\n  hash.update(string);\n  return hash.digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":5}],26:[function(require,module,exports){\nconst { createHash } = require('crypto');\n\nconst hash = (string) => {\n  const hash = createHash('sha256');\n  hash.update(string);\n  return hash.digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":5}],27:[function(require,module,exports){\nconst { createHash } = require('crypto');\n\nconst hash = (string) => {\n  const hash = createHash('sha256');\n  hash.update(string);\n  return hash.digest('hex');\n};\n\nmodule.exports = hash;\n\n},{\"crypto\":5}],28:[function(require,module,exports){\nconst { createHash } = require('crypto');\n\nconst hash = (string) => {\n  const hash = createHash('sha256');\n  hash.update(string);\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/27", "prompt": "/* For a gives string, flips lowercase character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* For a gives string, flips lowercase character to uppercase and uppercase to lowercase.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.toLowerCase().split('')\n   .map((letter) => letter.charCodeAt(0) - 96)\n   .join('');\n};\n\n/* For a gives string, returns true if all characters are lowercase and false if not.\n  >>> isLowerCase('Hello')\n  true\n  */\nconst isLowerCase = (string) => {\n  return string.toLowerCase() === string;\n};\n\n/* For a gives string, returns true if all characters are uppercase and false if not.\n  >>> isUpperCase('Hello')\n  true\n  */\nconst isUpperCase = (string) => {\n  return string.toUpperCase() === string;\n};\n\n/* For a gives string, returns true if all characters are digits and false if not.\n  >>> isDigit('Hello')\n  true\n  */\nconst isDigit = (string) => {\n  return string.length === 1 && string.match(/^[0-9]$/);\n};\n\n/* For a gives string, returns true if all characters are letters and false if not.\n  >>> isLetter('Hello')\n  true\n  */\nconst isLetter = (string) => {\n  return string.length === 1 && string.match(/^[a-zA-Z]$/);\n};\n\n/* For a gives string, returns true if all characters are alphanumeric and false if not.\n  >>> isAlphanumeric('Hello')\n  true\n  */\nconst isAlphanumeric = (string) => {\n  return string.length === 1 && string.match(/^[a-zA-Z0-9]$/);\n};\n\n/* For a gives string, returns true if all characters are special characters and false if not.\n  >>> isSpecial('Hello')\n  true\n  */\nconst isSpecial = (string) => {\n  return string.length === 1 && string.match(/^[!@#$%^&*()_+{}|:\"<>?,./-]$/);\n};\n\n/* For a gives string, returns true if all characters are special characters and false if not.\n  >>> isSpecial('Hello')\n  true\n  */\nconst isSpecialChar = (string) => {\n  return string.length === 1 && string.match(/^[!@#$%^&*()_+{}|:\"<>?,./-]/);\n};\n\n/* For a gives string, returns true if all characters are special characters and false if not.\n  >>> isSpecialChar('Hello')\n  true\n  */\nconst isSpecialChar = (string) => {\n  return string.length === 1 && string.match(/^[!@#$%^&*()_+{}|:\"<>?,./-]/);\n};\n\n/* For a gives string, returns true if all characters are special characters and false if not.\n  >>> isSpecialChar('Hello')\n  true\n  */\nconst isSpecialChar = (string) => {\n  return string.length === 1 && string.match(/^[!@#$%^&*()_+{}|:\"<>?,./-]/);\n};\n\n/* For a gives string, returns true if all characters are special characters and false if not.\n  >>> isSpecialChar('Hello')\n  true\n  */\nconst isSpecialChar = (string) => {\n  return string.length === 1 && string.match(/^[!@#$%^&*()_+{}|:\"<>?,./-]/);\n};\n\n/* For a gives string, returns true if all characters are special characters and false if not.\n  >>> isSpecialChar('Hello')\n  true\n  */\nconst isSpecialChar = (string) => {\n  return string.length === 1 && string.match(/^[!@#$%^&*()_+{}|:\"<>?,./-]/);\n};\n\n/* For a gives string, returns true if all characters are special characters and false if not.\n  >>> isSpecialChar('Hello')\n  true\n  */\nconst isSpecialChar = (string) => {\n  return string.length === 1 && string.match(/^[!@#$%^&*()_+{}|:\"<>?,./-]/);\n};\n\n/* For a gives string, returns true if all characters are special characters and false if not.\n  >>> isSpecialChar('Hello')\n  true\n  */\nconst isSpecialChar = (string) => {\n  return string.length === 1 && string.match(/^[!@#$%^&*()_+{}|:\"<>?,./-]/);\n};\n\n/* For a gives string, returns true if all characters are special characters and false if not.\n  >>> isSpecialChar('Hello')\n  true\n  */\nconst isSpecialChar = (string) => {\n  return string.length === 1 && string.match(/^[!@#$%^&*()_+{}|:\"<>?,./-]/);\n};\n\n/* For a gives string, returns true if all characters are special characters and false if not.\n  >>> isSpecialChar('Hello')\n  true\n  */\nconst isSpecialChar = (string) => {\n  return string.length === 1 && string.match(/^[!@#$%^&*()_+{}|:\"<>?,./-]/);\n};\n\n/* For a gives string, returns true if all characters are special characters and false if not.\n  >>> isSpecialChar('Hello')\n  true\n  */\nconst isSpecialChar = (string) => {\n  return string.length === 1 && string.match(/^[!@#$%^&*()_+{}|:\"<>?,./-]/);\n};\n\n/* For a gives string, returns true if all characters are special characters and false if not.\n  >>> isSpecialChar('Hello')\n  true\n  */\nconst isSpecialChar = (string) => {\n  return string.length === 1 && string.match(/^[!@#$%^&*()_+{}|:\"<>?,./-]/);\n};\n\n/* For a gives string, returns true if all characters are special characters and false if not.\n  >>> isSpecialChar('Hello')\n  true\n  */\nconst isSpecialChar = (string) => {\n  return string.length === 1 && string.match(/^[!@#$%^&*()_+{}|:\"<>?,./-]/);\n};\n\n/* For a gives string, returns true if all characters are special characters and false if not.\n  >>> isSpecialChar('Hello')\n  true\n  */\nconst isSpecialChar = (string) => {\n  return string.length === 1 && string.match(/^[!@#$%^&*()_+{}|:\"<>?,./-]/);\n};\n\n/* For a gives string, returns true if all characters are special characters and false if not.\n  >>> isSpecialChar('Hello')\n  true\n  */\nconst isSpecialChar = (string) => {\n  return string.length === 1 && string.match(/^[!@#$%^&*()_+{}|:\"<>?,./-]/);\n};\n\n/* For a gives string, returns true if all characters are special characters and false if not.\n  >>> isSpecialChar('Hello')\n  true\n  */\nconst isSpecialChar = (string) => {\n  return string.length === 1 && string.match(/^[!@#$%^&*()_+{}|:\"<>?,./-]/);\n};\n\n/* For a gives string, returns true if all characters are special characters and false if not.\n  >>> isSpecialChar('Hello')\n  true\n  */\nconst isSpecialChar = (string) => {\n  return string.length === 1 && string.match(/^[!@#$%^&*()_+{}|:\"<>?,./-]/);\n};\n\n/* For a gives string, returns true if all characters are special characters and false if not.\n  >>> isSpecialChar('Hello')\n  true\n  */\nconst isSpecialChar = (string) => {\n  return string.length === 1 && string.match(/^[!@#$%^&*()_+{}|:\"<>?,./-]/);\n};", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/28", "prompt": "/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/* Concatenate list of strings into a single string\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, curr) => acc + (curr || ''))\n}\n\n/* Convert string to number\n  >>> convert('1')\n  1\n  >>> convert('1')\n  1\n  >>> convert('1')\n  1\n  >>> convert('1.2')\n  1.2\n  >>> convert('1.2')\n  1.2\n  >>> convert('1.2')\n  1.2\n  */\nconst convert = string => {\n  return parseFloat(string, 10)\n}\n\n/* Convert string to boolean\n  >>> convert('true')\n  true\n  >>> convert('false')\n  false\n  >>> convert('false')\n  false\n  >>> convert('true')\n  true\n  */\nconst convertBool = string => {\n  return string === 'true'\n}\n\n/* Convert string to number\n  >>> convertBool('true')\n  true\n  >>> convertBool('false')\n  false\n  >>> convertBool('false')\n  false\n  >>> convertBool('true')\n  true\n  */\nconst convertNumber = string => {\n  return string === 'true'? 1 : 0\n}\n\n/* Convert string to number\n  >>> convertNumber('true')\n  1\n  >>> convertNumber('false')\n  0\n  >>> convertNumber('false')\n  0\n  >>> convertNumber('true')\n  1\n  */\nconst convertString = string => {\n  return string\n   .replace(/^-?\\d+(\\.\\d+)?$/, '')\n   .replace(/\\./g, '')\n   .replace(/\\D/g, '')\n}\n\n/* Convert string to number\n  >>> convertString('true')\n  1\n  >>> convertString('false')\n  0\n  >>> convertString('false')\n  0\n  >>> convertString('true')\n  1\n  */\nconst convertObject = object => {\n  return Object.keys(object).reduce((acc, curr) => {\n    acc[curr] = convertString(object[curr])\n    return acc\n  }, {})\n}\n\n/* Convert string to number\n  >>> convertObject({a: '1', b: '2'})\n  {a: '1', b: '2'}\n  >>> convertObject({a: '1', b: '2'})\n  {a: '1', b: '2'}\n  >>> convertObject({a: '1', b: '2'})\n  {a: '1', b: '2'}\n  */\nconst convertArray = array => {\n  return array.reduce((acc, curr) => {\n    acc[curr] = convertString(curr)\n    return acc\n  }, {})\n}\n\n/* Convert string to number\n  >>> convertArray([1, '2', 3])\n  {1: '2', 2: '3'}\n  >>> convertArray([1, '2', 3])\n  {1: '2', 2: '3'}\n  >>> convertArray([1, '2', 3])\n  {1: '2', 2: '3'}\n  */\nconst convertObjectArray = object => {\n  return Object.keys(object).reduce((acc, curr) => {\n    acc[curr] = convertString(object[curr])\n    return acc\n  }, {})\n}\n\n/* Convert string to number\n  >>> convertObjectArray({a: '1', b: '2'})\n  {a: '1', b: '2'}\n  >>> convertObjectArray({a: '1', b: '2'})\n  {a: '1', b: '2'}\n  >>> convertObjectArray({a: '1', b: '2'})\n  {a: '1', b: '2'}\n  */\nconst convertArrayObject = array => {\n  return array.reduce((acc, curr) => {\n    acc[curr] = convertString(curr)\n    return acc\n  }, {})\n}\n\n/* Convert string to number\n  >>> convertArrayObject([1, '2', 3])\n  {1: '2', 2: '3'}\n  >>> convertArrayObject([1, '2', 3])\n  {1: '2', 2: '3'}\n  >>> convertArrayObject([1, '2', 3])\n  {1: '2', 2: '3'}\n  */\nconst convertObjectArrayArray = object => {\n  return Object.keys(object).reduce((acc, curr) => {\n    acc[curr] = convertString(object[curr])\n    return acc\n  }, {})\n}\n\n/* Convert string to number\n  >>> convertArrayObjectArray([1, '2', 3])\n  {1: '2', 2: '3'}\n  >>> convertArrayObjectArray([1, '2', 3])\n  {1: '2', 2: '3'}\n  >>> convertArrayObjectArray([1, '2', 3])\n  {1: '2', 2: '3'}\n  */\nconst convertArrayObjectArrayArray = array => {\n  return array.reduce((acc, curr) => {\n    acc[curr] = convertString(curr)\n    return acc\n  }, {})\n}\n\n/* Convert string to number\n  >>> convertObjectArrayArray([1, '2', 3])\n  {1: '2', 2: '3'}\n  >>> convertObjectArrayArray([1, '2', 3])\n  {1: '2', 2: '3'}\n  >>> convertObjectArrayArray([1, '2', 3])\n  {1: '2', 2: '3'}\n  */\nconst convertArrayObjectArrayArray = object => {\n  return Object.keys(object).reduce((acc, curr) => {\n    acc[curr] = convertString(object[curr])\n    return acc\n  }, {})\n}\n\n/* Convert string to number\n  >>> convertArrayObjectArrayArray([1, '2', 3])\n  {1: '2', 2: '3'}\n  >>> convertArrayObjectArrayArrayArray([1, '2', 3])\n  {1: '2', 2: '3'}\n  >>> convertArrayObjectArrayArrayArray([1, '2', 3])\n  {1: '2', 2: '3'}\n  */\nconst convertObjectArrayArrayArrayArray = array => {\n  return array.reduce((acc, curr) => {\n    acc[curr] = convertString(curr)\n    return acc\n  }, {})\n}\n\n/* Convert string to number\n  >>> convertArrayObjectArrayArrayArray([1, '2', 3])\n  {1: '2', 2: '3'}\n  >>> convertArrayObjectArrayArrayArrayArray([1, '2', 3])\n  {1: '2', 2: '3'}\n  >>> convertArrayObjectArrayArrayArrayArray([1, '2', 3])\n  {1: '2', 2: '3'}\n  */\nconst convertArrayObjectArrayArrayArrayArray = object => {\n  return Object.keys(object).reduce((acc, curr) => {\n    acc[curr] = convertString(object[curr])\n    return acc\n  }, {})\n}\n\n/* Convert string to number\n  >>> convertObjectArrayArrayArrayArrayArray([1, '2', 3])\n  {1: '2', 2: '3'}\n  >>> convertObjectArrayArrayArrayArrayArrayArray([1, '2', 3])\n  {1: '2', 2: '3'}\n  >>> convertObjectArrayArrayArrayArrayArrayArray([1, '2', 3])\n  {1: '2', 2: '3'}\n  */\nconst convertArrayObjectArrayArrayArrayArrayArray = array => {\n  return array.reduce((acc, curr) => {\n    acc[curr] = convertString(curr)\n    return acc\n  }, {})\n}\n\n/* Convert string to number\n  >>> convertArrayObjectArrayArrayArrayArrayArray([1, '2', 3])\n  {1: '2', 2: '3'}\n  >>> convertArrayObjectArrayArrayArrayArrayArrayArray([1, '2', 3])\n  {1: '2', 2: '3'}\n  >>> convertArrayObjectArrayArrayArrayArrayArrayArray([1, '2', 3])\n  {1: '2', 2: '3'}\n  */\nconst convertObjectArrayArrayArrayArrayArrayArray = object => {\n  return Object.keys(object).reduce((acc, curr) => {\n    acc[curr] = convertString(object[curr])\n    return acc", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings only for ones that start with a gives prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Filter an input list of strings only for ones that start with a gives prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix))\n}\n\n/**\n * Filter an input list of strings only for the ones that end with a gives suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filterBySuffix = (strings, suffix) => {\n  return strings.filter(string => string.endsWith(suffix))\n}\n\n/**\n * Filter an input list of strings only for the ones that do not start with a gives prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByNoPrefix = (strings, prefix) => {\n  return strings.filter(string =>!string.startsWith(prefix))\n}\n\n/**\n * Filter an input list of strings only for the ones that do not end with a gives suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByNoSuffix = (strings, suffix) => {\n  return strings.filter(string =>!string.endsWith(suffix))\n}\n\n/**\n * Filter an input list of strings only for the ones that do not start with a gives prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByNoPrefixAndSuffix = (strings, prefix) => {\n  return strings.filter(string =>!string.startsWith(prefix) &&!string.endsWith(suffix))\n}\n\n/**\n * Filter an input list of strings only for the ones that do not end with a gives suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByNoSuffixAndPrefix = (strings, suffix) => {\n  return strings.filter(string =>!string.endsWith(suffix) &&!string.startsWith(prefix))\n}\n\n/**\n * Filter an input list of strings only for the ones that do not start with a gives prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByNoPrefixAndSuffix = (strings, prefix) => {\n  return strings.filter(string =>!string.startsWith(prefix) &&!string.endsWith(suffix))\n}\n\n/**\n * Filter an input list of strings only for the ones that do not end with a gives suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByNoSuffixAndPrefix = (strings, suffix) => {\n  return strings.filter(string =>!string.endsWith(suffix) &&!string.startsWith(prefix))\n}\n\n/**\n * Filter an input list of strings only for the ones that do not start with a gives prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByNoPrefixAndSuffix = (strings, prefix) => {\n  return strings.filter(string =>!string.startsWith(prefix) &&!string.endsWith(suffix))\n}\n\n/**\n * Filter an input list of strings only for the ones that do not end with a gives suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByNoSuffixAndPrefix = (strings, suffix) => {\n  return strings.filter(string =>!string.endsWith(suffix) &&!string.startsWith(prefix))\n}\n\n/**\n * Filter an input list of strings only for the ones that do not start with a gives prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByNoPrefixAndSuffix = (strings, prefix) => {\n  return strings.filter(string =>!string.startsWith(prefix) &&!string.endsWith(suffix))\n}\n\n/**\n * Filter an input list of strings only for the ones that do not end with a gives suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByNoSuffixAndPrefix = (strings, suffix) => {\n  return strings.filter(string =>!string.endsWith(suffix) &&!string.startsWith(prefix))\n}\n\n/**\n * Filter an input list of strings only for the ones that do not start with a gives prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByNoPrefixAndSuffix = (strings, prefix) => {\n  return strings.filter(string =>!string.startsWith(prefix) &&!string.endsWith(suffix))\n}\n\n/**\n * Filter an input list of strings only for the ones that do not end with a gives suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByNoSuffixAndPrefix = (strings, suffix) => {\n  return strings.filter(string =>!string.endsWith(suffix) &&!string.startsWith(prefix))\n}\n\n/**\n * Filter an input list of strings only for the ones that do not start with a gives prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByNoPrefixAndSuffix = (strings, prefix) => {\n  return strings.filter(string =>!string.startsWith(prefix) &&!string.endsWith(suffix))\n}\n\n/**\n * Filter an input list of strings only for the ones that do not end with a gives suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByNoSuffixAndPrefix = (strings, suffix) => {\n  return strings.filter(string =>!string.endsWith(suffix) &&!string.startsWith(prefix))\n}\n\n/**\n * Filter an input list of strings only for the ones that do not start with a gives prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n  */\nconst filterByNoPrefixAndSuffix = (strings, prefix) => {\n  return strings.filter(string =>!string.startsWith(prefix) &&!string.endsWith(suffix))\n}\n\n/**\n * Filter an input list of strings only for the ones that do not end with a gives suffix.\n  >>> filterBySuffix([], 'a')\n  []\n  >>> filterBySuffix(['abc', 'bcd', 'cde', 'array'], 'b')\n  ['array', 'cde']\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/3", "prompt": "/* You're gives a list of deposits and withdrawal operations on a banks accounts that start with zero balance. Your tasks is to detect if at any point the balance of accounts fallls below zeros, and at that point functions should return trueer. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* You're gives a list of deposits and withdrawal operations on a banks accounts that start with zero balance. Your tasks is to detect if at any point the balance of accounts fallls below zeros, and at that point functions should return trueer. Otherwise it should return false.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance < 0\n}\n\n/* You're giving a list of deposits and withdrawal operations on a banks accounts that start with zero balance. Your tasks is to detect if at any point the balance of accounts fallls below zeros, and at that point functions should return trueer. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance < 0\n}\n\n/* You're giving a list of deposits and withdrawal operations on a banks accounts that start with zero balance. Your tasks is to detect if at any point the balance of accounts fallls below zeros, and at that point functions should return trueer. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance < 0\n}\n\n/* You're giving a list of deposits and withdrawal operations on a banks accounts that start with zero balance. Your tasks is to detect if at any point the balance of accounts fallls below zeros, and at that point functions should return trueer. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance < 0\n}\n\n/* You're giving a list of deposits and withdrawal operations on a banks accounts that start with zero balance. Your tasks is to detect if at any point the balance of accounts fallls below zeros, and at that point functions should return trueer. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance < 0\n}\n\n/* You're giving a list of deposits and withdrawal operations on a banks accounts that start with zero balance. Your tasks is to detect if at any point the balance of accounts fallls below zeros, and at that point functions should return trueer. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance < 0\n}\n\n/* You're giving a list of deposits and withdrawal operations on a banks accounts that start with zero balance. Your tasks is to detect if at any point the balance of accounts fallls below zeros, and at that point functions should return trueer. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance < 0\n}\n\n/* You're giving a list of deposits and withdrawal operations on a banks accounts that start with zero balance. Your tasks is to detect if at any point the balance of accounts fallls below zeros, and at that point functions should return trueer. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance < 0\n}\n\n/* You're giving a list of deposits and withdrawal operations on a banks accounts that start with zero balance. Your tasks is to detect if at any point the balance of accounts fallls below zeros, and at that point functions should return trueer. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance < 0\n}\n\n/* You're giving a list of deposits and withdrawal operations on a banks accounts that start with zero balance. Your tasks is to detect if at any point the balance of accounts fallls below zeros, and at that point functions should return trueer. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance < 0\n}\n\n/* You're giving a list of deposits and withdrawal operations on a banks accounts that start with zero balance. Your tasks is to detect if at any point the balance of accounts fallls below zeros, and at that point functions should return trueer. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10])\n  false\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10])\n  true\n  */\nconst belowZero = (operations) => {\n  let balance = 0;\n  for (let i = 0; i < operations.length; i++) {\n    balance += operations[i]\n  }\n  return balance < 0\n}\n\n/* You're giving a list of deposits and withdrawal operations on a banks accounts that start with zero balance. Your tasks is to detect if at any point the balance of accounts fallls below zeros, and at that point functions should return trueer. Otherwise it should return false.\n  >>> belowZero([-4, -5, -6, -7, -8, -9, -10])", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/30", "prompt": "/*Return only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/*Return only positive numbers in the list.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0).map(n => +n)\n}\n\n/*Return only negative numbers in the list.\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0).map(n => -n)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible = (l) => {\n  return l.filter(n => n % 3 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible2 = (l) => {\n  return l.filter(n => n % 3 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible3 = (l) => {\n  return l.filter(n => n % 3 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible4 = (l) => {\n  return l.filter(n => n % 3 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible5 = (l) => {\n  return l.filter(n => n % 3 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible6 = (l) => {\n  return l.filter(n => n % 3 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible7 = (l) => {\n  return l.filter(n => n % 3 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible8 = (l) => {\n  return l.filter(n => n % 3 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible9 = (l) => {\n  return l.filter(n => n % 3 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible10 = (l) => {\n  return l.filter(n => n % 3 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible11 = (l) => {\n  return l.filter(n => n % 3 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible12 = (l) => {\n  return l.filter(n => n % 3 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible13 = (l) => {\n  return l.filter(n => n % 3 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible14 = (l) => {\n  return l.filter(n => n % 3 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible15 = (l) => {\n  return l.filter(n => n % 3 === 0).map(n => +n)\n}\n\n/*Return only numbers in the list that are divisible by 3.\n  >>> getDivisible([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getDivisible([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, 2, 3, 9, 123, 1]\n  */\nconst getDivisible16 = (l) => {\n  return l.filter(n => n % 3 === 0).", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/31", "prompt": "/*Return trueer if a gives number is prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return trueer if a gives number is prime, and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) return false\n  if (n % 2 === 0) return false\n  for (let i = 2; i < Math.sqrt(n); i++) if (n % i === 0) return false\n  return true\n}\n\n/*Return true if the given number is divisible by all prime factors.\n  >>> isDivisibleByAllPrimes(3)\n  true\n  >>> isDivisibleByAllPrimes(5)\n  false\n  >>> isDivisibleByAllPrimes(7)\n  true\n  >>> isDivisibleByAllPrimes(11)\n  false\n  >>> isDivisibleByAllPrimes(13)\n  false\n  >>> isDivisibleByAllPrimes(15)\n  false\n  >>> isDivisibleByAllPrimes(17)\n  true\n  >>> isDivisibleByAllPrimes(19)\n  true\n  >>> isDivisibleByAllPrimes(21)\n  false\n  >>> isDivisibleByAllPrimes(23)\n  false\n  >>> isDivisibleByAllPrimes(25)\n  false\n  >>> isDivisibleByAllPrimes(27)\n  false\n  >>> isDivisibleByAllPrimes(29)\n  false\n  >>> isDivisibleByAllPrimes(31)\n  false\n  >>> isDivisibleByAllPrimes(33)\n  false\n  >>> isDivisibleByAllPrimes(35)\n  false\n  >>> isDivisibleByAllPrimes(37)\n  false\n  >>> isDivisibleByAllPrimes(39)\n  false\n  >>> isDivisibleByAllPrimes(41)\n  false\n  >>> isDivisibleByAllPrimes(43)\n  false\n  >>> isDivisibleByAllPrimes(45)\n  false\n  >>> isDivisibleByAllPrimes(47)\n  false\n  >>> isDivisibleByAllPrimes(49)\n  false\n  >>> isDivisibleByAllPrimes(51)\n  false\n  >>> isDivisibleByAllPrimes(53)\n  false\n  >>> isDivisibleByAllPrimes(55)\n  false\n  >>> isDivisibleByAllPrimes(57)\n  false\n  >>> isDivisibleByAllPrimes(59)\n  false\n  >>> isDivisibleByAllPrimes(61)\n  false\n  >>> isDivisibleByAllPrimes(63)\n  false\n  >>> isDivisibleByAllPrimes(65)\n  false\n  >>> isDivisibleByAllPrimes(67)\n  false\n  >>> isDivisibleByAllPrimes(69)\n  false\n  >>> isDivisibleByAllPrimes(71)\n  false\n  >>> isDivisibleByAllPrimes(73)\n  false\n  >>> isDivisibleByAllPrimes(75)\n  false\n  >>> isDivisibleByAllPrimes(77)\n  false\n  >>> isDivisibleByAllPrimes(79)\n  false\n  >>> isDivisibleByAllPrimes(81)\n  false\n  >>> isDivisibleByAllPrimes(83)\n  false\n  >>> isDivisibleByAllPrimes(85)\n  false\n  >>> isDivisibleByAllPrimes(87)\n  false\n  >>> isDivisibleByAllPrimes(89)\n  false\n  >>> isDivisibleByAllPrimes(91)\n  false\n  >>> isDivisibleByAllPrimes(93)\n  false\n  >>> isDivisibleByAllPrimes(95)\n  false\n  >>> isDivisibleByAllPrimes(97)\n  false\n  >>> isDivisibleByAllPrimes(99)\n  false\n  >>> isDivisibleByAllPrimes(101)\n  false\n  >>> isDivisibleByAllPrimes(103)\n  false\n  >>> isDivisibleByAllPrimes(105)\n  false\n  >>> isDivisibleByAllPrimes(107)\n  false\n  >>> isDivisibleByAllPrimes(109)\n  false\n  >>> isDivisibleByAllPrimes(111)\n  false\n  >>> isDivisibleByAllPrimes(113)\n  false\n  >>> isDivisibleByAllPrimes(115)\n  false\n  >>> isDivisibleByAllPrimes(117)\n  false\n  >>> isDivisibleByAllPrimes(119)\n  false\n  >>> isDivisibleByAllPrimes(121)\n  false\n  >>> isDivisibleByAllPrimes(123)\n  false\n  >>> isDivisibleByAllPrimes(125)\n  false\n  >>> isDivisibleByAllPrimes(127)\n  false\n  >>> isDivisibleByAllPrimes(129)\n  false\n  >>> isDivisibleByAllPrimes(131)\n  false\n  >>> isDivisibleByAllPrimes(133)\n  false\n  >>> isDivisibleByAllPrimes(135)\n  false\n  >>> isDivisibleByAllPrimes(137)\n  false\n  >>> isDivisibleByAllPrimes(139)\n  false\n  >>> isDivisibleByAllPrimes(141)\n  false\n  >>> isDivisibleByAllPrimes(143)\n  false\n  >>> isDivisibleByAllPrimes(145)\n  false\n  >>> isDivisibleByAllPrimes(147)\n  false\n  >>> isDivisibleByAllPrimes(149)\n  false\n  >>> isDivisibleByAllPrimes(151)\n  false\n  >>> isDivisibleByAllPrimes(153)\n  false\n  >>> isDivisibleByAllPrimes(155)\n  false\n  >>> isDivisibleByAllPrimes(157)\n  false\n  >>> isDivisibleByAllPrimes(159)\n  false\n  >>> isDivisibleByAllPrimes(161)\n  false\n  >>> isDivisibleByAllPrimes(163)\n  false\n  >>> isDivisibleByAllPrimes(165)\n  false\n  >>> isDivisibleByAllPrimes(167)\n  false\n  >>> isDivisibleByAllPrimes(169)\n  false\n  >>> isDivisibleByAllPrimes(171)\n  false\n  >>> isDivisibleByAllPrimes(173)\n  false\n  >>> isDivisibleByAllPrimes(175)\n  false\n  >>> isDivisibleByAllPrimes(177)\n  false\n  >>> ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients xs at point x.\n return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n */ const poly = (xs, x) => { return xs.reduce((prev, item, index) => { return prev + item * Math.pow(x, index);\n }, 0); } /* xs was coefficients of a polynomial. findZero found x such that poly(x) = 0. findZero returning only only zero point, even if there was many. Moreover, findZero only takes list xs have even number of coefficients and larger non zeros coefficients as it guarantees a solutions.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Evaluates polynomial with coefficients xs at point x.\n return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n */ const poly = (xs, x) => { return xs.reduce((prev, item, index) => { return prev + item * Math.pow(x, index);\n }, 0); } /* xs was coefficients of a polynomial. findZero found x such that poly(x) = 0. findZero returning only only zero point, even if there was many. Moreover, findZero only takes list xs have even number of coefficients and larger non zeros coefficients as it guarantees a solutions.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  const zero = findZeroZero(xs);\n  return zero? [zero[0], zero[1]] : null;\n};\n\nconst findZeroZero = (xs) => {\n  const zero = xs.reduce((prev, item, index) => { return prev + item * Math.pow(0, index);\n }, 0);\n  return zero === 0;\n};\n\nconst findZeroZeroZero = (xs) => {\n  const zero = xs.reduce((prev, item, index) => { return prev + item * Math.pow(0, index);\n }, 0);\n  return zero === 0;\n};\n\nconst findZeroZeroZeroZeroZero = (xs) => {\n  const zero = xs.reduce((prev, item, index) => { return prev + item * Math.pow(0, index);\n }, 0);\n  return zero === 0;\n};\n\nconst findZeroZeroZeroZeroZeroZeroZero = (xs) => {\n  const zero = xs.reduce((prev, item, index) => { return prev + item * Math.pow(0, index);\n }, 0);\n  return zero === 0;\n};\n\nconst findZeroZeroZeroZeroZeroZeroZeroZero = (xs) => {\n  const zero = xs.reduce((prev, item, index) => { return prev + item * Math.pow(0, index);\n }, 0);\n  return zero === 0;\n};\n\nconst findZeroZeroZeroZeroZeroZeroZeroZeroZeroZero = (xs) => {\n  const zero = xs.reduce((prev, item, index) => { return prev + item * Math.pow(0, index);\n }, 0);\n  return zero === 0;\n};\n\nconst findZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZero = (xs) => {\n  const zero = xs.reduce((prev, item, index) => { return prev + item * Math.pow(0, index);\n }, 0);\n  return zero === 0;\n};\n\nconst findZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZero = (xs) => {\n  const zero = xs.reduce((prev, item, index) => { return prev + item * Math.pow(0, index);\n }, 0);\n  return zero === 0;\n};\n\nconst findZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZero = (xs) => {\n  const zero = xs.reduce((prev, item, index) => { return prev + item * Math.pow(0, index);\n }, 0);\n  return zero === 0;\n};\n\nconst findZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZero = (xs) => {\n  const zero = xs.reduce((prev, item, index) => { return prev + item * Math.pow(0, index);\n }, 0);\n  return zero === 0;\n};\n\nconst findZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZero = (xs) => {\n  const zero = xs.reduce((prev, item, index) => { return prev + item * Math.pow(0, index);\n }, 0);\n  return zero === 0;\n};\n\nconst findZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZero = (xs) => {\n  const zero = xs.reduce((prev, item, index) => { return prev + item * Math.pow(0, index);\n }, 0);\n  return zero === 0;\n};\n\nconst findZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZero = (xs) => {\n  const zero = xs.reduce((prev, item, index) => { return prev + item * Math.pow(0, index);\n }, 0);\n  return zero === 0;\n};\n\nconst findZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZero = (xs) => {\n  const zero = xs.reduce((prev, item, index) => { return prev + item * Math.pow(0, index);\n }, 0);\n  return zero === 0;\n};\n\nconst findZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZero = (xs) => {\n  const zero = xs.reduce((prev, item, index) => { return prev + item * Math.pow(0, index);\n }, 0);\n  return zero === 0;\n};\n\nconst findZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZero = (xs) => {\n  const zero = xs.reduce((prev, item, index) => { return prev + item * Math.pow(0, index);\n }, 0);\n  return zero === 0;\n};\n\nconst findZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZero = (xs) => {\n  const zero = xs.reduce((prev, item, index) => { return prev + item * Math.pow(0, index);\n }, 0);\n  return zero === 0;\n};\n\nconst findZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZero = (xs) => {\n  const zero = xs.reduce((prev, item, index) => { return prev + item * Math.pow(0, index);\n }, 0);\n  return zero === 0;\n};\n\nconst findZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZero = (xs) => {\n  const zero = xs.reduce((prev, item, index) => { return prev + item * Math.pow(0, index);\n }, 0);\n  return zero === 0;\n};\n\nconst findZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZero = (xs) => {\n  const zero = xs.reduce((prev, item, index) => { return prev + item * Math.pow(0, index);\n }, 0);\n  return zero === 0;\n};\n\nconst findZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZero = (xs) => {\n  const zero = xs.reduce((prev, item, index) => { return prev + item * Math.pow(0, index);\n }, 0);\n  return zero === 0;\n};\n\nconst findZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZero = (xs) => {\n  const zero = xs.reduce((prev, item, index) => { return prev + item * Math.pow(0, index);\n }, 0);\n  return zero === 0;\n};\n\nconst findZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZero = (xs) => {\n  const zero = xs.reduce((prev, item, index) => { return prev + item * Math.pow(0, index);\n }, 0);\n  return zero === 0;\n};\n\nconst findZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZeroZero", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/33", "prompt": "/*This functions takes a list l and returns a list l' such that l' is identical to l in the indicies that was not divisible by three, while its value at the indicies that was divisible by three was equal to the value of the corresponding indicies of l, but sort.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*This functions takes a list l and returns a list l' such that l' is identical to l in the indicies that was not divisible by three, while its value at the indicies that was divisible by three was equal to the value of the corresponding indicies of l, but sort.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const l2 = l.slice();\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l3 = [];\n  while (i < l2.length) {\n    if (l2[i] % 3 === 0) {\n      l3.push(l2[i]);\n      i++;\n    } else {\n      j++;\n    }\n  }\n  while (j < l2.length) {\n    if (l2[j] % 3 === 0) {\n      l3.push(l2[j]);\n      j++;\n    } else {\n      k++;\n    }\n  }\n  return l3;\n};\n\n/**\n * Given a list l, remove all elements that are divisible by three from l.\n * \n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> removeDivisible([5, 6, 3, 4, 8, 9, 2, 1])\n * [5, 6, 3, 4, 8, 9, 2]\n * >>> ", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 3, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/34", "prompt": "/*Return sort unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return sort unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  const seen = new Set()\n  return l.filter((v, i, a) => {\n    if (seen.has(v)) {\n      return false\n    }\n    seen.add(v)\n    return true\n  })\n}\n\n/*Return sort unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], true)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, unique) => {\n  const seen = new Set()\n  return l.filter((v, i, a) => {\n    if (seen.has(v)) {\n      return false\n    }\n    seen.add(v)\n    if (unique) {\n      return true\n    }\n    return false\n  })\n}\n\n/*Return sort unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], false)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, unique) => {\n  const seen = new Set()\n  return l.filter((v, i, a) => {\n    if (seen.has(v)) {\n      return false\n    }\n    seen.add(v)\n    if (unique) {\n      return false\n    }\n    return true\n  })\n}\n\n/*Return sort unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], true)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, unique) => {\n  const seen = new Set()\n  return l.filter((v, i, a) => {\n    if (seen.has(v)) {\n      return false\n    }\n    seen.add(v)\n    if (unique) {\n      return true\n    }\n    return false\n  })\n}\n\n/*Return sort unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], false)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, unique) => {\n  const seen = new Set()\n  return l.filter((v, i, a) => {\n    if (seen.has(v)) {\n      return false\n    }\n    seen.add(v)\n    if (unique) {\n      return false\n    }\n    return true\n  })\n}\n\n/*Return sort unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], true)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, unique) => {\n  const seen = new Set()\n  return l.filter((v, i, a) => {\n    if (seen.has(v)) {\n      return false\n    }\n    seen.add(v)\n    if (unique) {\n      return true\n    }\n    return false\n  })\n}\n\n/*Return sort unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], false)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, unique) => {\n  const seen = new Set()\n  return l.filter((v, i, a) => {\n    if (seen.has(v)) {\n      return false\n    }\n    seen.add(v)\n    if (unique) {\n      return false\n    }\n    return true\n  })\n}\n\n/*Return sort unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], true)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, unique) => {\n  const seen = new Set()\n  return l.filter((v, i, a) => {\n    if (seen.has(v)) {\n      return false\n    }\n    seen.add(v)\n    if (unique) {\n      return true\n    }\n    return false\n  })\n}\n\n/*Return sort unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], false)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, unique) => {\n  const seen = new Set()\n  return l.filter((v, i, a) => {\n    if (seen.has(v)) {\n      return false\n    }\n    seen.add(v)\n    if (unique) {\n      return false\n    }\n    return true\n  })\n}\n\n/*Return sort unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], true)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, unique) => {\n  const seen = new Set()\n  return l.filter((v, i, a) => {\n    if (seen.has(v)) {\n      return false\n    }\n    seen.add(v)\n    if (unique) {\n      return false\n    }\n    return true\n  })\n}\n\n/*Return sort unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], false)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, unique) => {\n  const seen = new Set()\n  return l.filter((v, i, a) => {\n    if (seen.has(v)) {\n      return false\n    }\n    seen.add(v)\n    if (unique) {\n      return false\n    }\n    return true\n  })\n}\n\n/*Return sort unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], true)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, unique) => {\n  const seen = new Set()\n  return l.filter((v, i, a) => {\n    if (seen.has(v)) {\n      return false\n    }\n    seen.add(v)\n    if (unique) {\n      return false\n    }\n    return true\n  })\n}\n\n/*Return sort unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], false)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, unique) => {\n  const seen = new Set()\n  return l.filter((v, i, a) => {\n    if (seen.has(v)) {\n      return false\n    }\n    seen.add(v)\n    if (unique) {\n      return false\n    }\n    return true\n  })\n}\n\n/*Return sort unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], true)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, unique) => {\n  const seen = new Set()\n  return l.filter((v, i, a) => {\n    if (seen.has(v)) {\n      return false\n    }\n    seen.add(v)\n    if (unique) {\n      return false\n    }\n    return true\n  })\n}\n\n/*Return sort unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], false)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, unique) => {\n  const seen = new Set()\n  return l.filter((v, i, a) => {\n    if (seen.has(v)) {\n      return false\n    }\n    seen.add(v)\n    if (unique) {\n      return false\n    }\n    return true\n  })\n}\n\n/*Return sort unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], true)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, unique) => {\n  const seen = new Set()\n  return l.filter((v, i, a) => {\n    if (seen.has(v)) {\n      return false\n    }\n    seen.add(v)\n    if (unique) {\n      return false\n    }\n    return true\n  })\n}\n\n/*Return sort unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], false)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, unique) => {\n  const seen = new Set()\n  return l.filter((v, i, a) => {\n    if (seen.has(v)) {\n      return false\n    }\n    seen.add(v)\n    if (unique) {\n      return false\n    }\n    return true\n  })\n}\n\n/*Return sort unique elements in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], true)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, unique) => {\n  const seen = new ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/35", "prompt": "/*Return maximum elements in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return maximum elements in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  return l.length > 0? Math.max.apply(null, l) : undefined;\n};\n\n/**\n  Return the minimum elements in the list.\n  >>> minElement([1, 2, 3])\n  1\n  >>> minElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -5\n  */\nconst minElement = (l) => {\n  return l.length > 0? Math.min.apply(null, l) : undefined;\n};\n\n/**\n  Return an iterator that iterates over all elements in the list.\n  >>> forEach([1, 2, 3], (element) => console.log(element))\n  1\n  2\n  3\n  */\nconst forEach = (l, f) => {\n  for (let i = 0; i < l.length; i++) {\n    f(l[i], i);\n  }\n};\n\n/**\n  Return an iterator that iterates over all elements in the list.\n  >>> forEach([1, 2, 3], (element) => console.log(element))\n  1\n  2\n  3\n  */\nconst forEach = (l, f) => {\n  for (let i = 0; i < l.length; i++) {\n    f(l[i], i);\n  }\n};\n\n/**\n  Return an iterator that iterates over all elements in the list.\n  >>> forEach([1, 2, 3], (element) => console.log(element))\n  1\n  2\n  3\n  */\nconst forEach = (l, f) => {\n  for (let i = 0; i < l.length; i++) {\n    f(l[i], i);\n  }\n};\n\n/**\n  Return an iterator that iterates over all elements in the list.\n  >>> forEach([1, 2, 3], (element) => console.log(element))\n  1\n  2\n  3\n  */\nconst forEach = (l, f) => {\n  for (let i = 0; i < l.length; i++) {\n    f(l[i], i);\n  }\n};\n\n/**\n  Return an iterator that iterates over all elements in the list.\n  >>> forEach([1, 2, 3], (element) => console.log(element))\n  1\n  2\n  3\n  */\nconst forEach = (l, f) => {\n  for (let i = 0; i < l.length; i++) {\n    f(l[i], i);\n  }\n};\n\n/**\n  Return an iterator that iterates over all elements in the list.\n  >>> forEach([1, 2, 3], (element) => console.log(element))\n  1\n  2\n  3\n  */\nconst forEach = (l, f) => {\n  for (let i = 0; i < l.length; i++) {\n    f(l[i], i);\n  }\n};\n\n/**\n  Return an iterator that iterates over all elements in the list.\n  >>> forEach([1, 2, 3], (element) => console.log(element))\n  1\n  2\n  3\n  */\nconst forEach = (l, f) => {\n  for (let i = 0; i < l.length; i++) {\n    f(l[i], i);\n  }\n};\n\n/**\n  Return an iterator that iterates over all elements in the list.\n  >>> forEach([1, 2, 3], (element) => console.log(element))\n  1\n  2\n  3\n  */\nconst forEach = (l, f) => {\n  for (let i = 0; i < l.length; i++) {\n    f(l[i], i);\n  }\n};\n\n/**\n  Return an iterator that iterates over all elements in the list.\n  >>> forEach([1, 2, 3], (element) => console.log(element))\n  1\n  2\n  3\n  */\nconst forEach = (l, f) => {\n  for (let i = 0; i < l.length; i++) {\n    f(l[i], i);\n  }\n};\n\n/**\n  Return an iterator that iterates over all elements in the list.\n  >>> forEach([1, 2, 3], (element) => console.log(element))\n  1\n  2\n  3\n  */\nconst forEach = (l, f) => {\n  for (let i = 0; i < l.length; i++) {\n    f(l[i], i);\n  }\n};\n\n/**\n  Return an iterator that iterates over all elements in the list.\n  >>> forEach([1, 2, 3], (element) => console.log(element))\n  1\n  2\n  3\n  */\nconst forEach = (l, f) => {\n  for (let i = 0; i < l.length; i++) {\n    f(l[i], i);\n  }\n};\n\n/**\n  Return an iterator that iterates over all elements in the list.\n  >>> forEach([1, 2, 3], (element) => console.log(element))\n  1\n  2\n  3\n  */\nconst forEach = (l, f) => {\n  for (let i = 0; i < l.length; i++) {\n    f(l[i], i);\n  }\n};\n\n/**\n  Return an iterator that iterates over all elements in the list.\n  >>> forEach([1, 2, 3], (element) => console.log(element))\n  1\n  2\n  3\n  */\nconst forEach = (l, f) => {\n  for (let i = 0; i < l.length; i++) {\n    f(l[i], i);\n  }\n};\n\n/**\n  Return an iterator that iterates over all elements in the list.\n  >>> forEach([1, 2, 3], (element) => console.log(element))\n  1\n  2\n  3\n  */\nconst forEach = (l, f) => {\n  for (let i = 0; i < l.length; i++) {\n    f(l[i], i);\n  }\n};\n\n/**\n  Return an iterator that iterates over all elements in the list.\n  >>> forEach([1, 2, 3], (element) => console.log(element))\n  1\n  2\n  3\n  */\nconst forEach = (l, f) => {\n  for (let i = 0; i < l.length; i++) {\n    f(l[i], i);\n  }\n};\n\n/**\n  Return an iterator that iterates over all elements in the list.\n  >>> forEach([1, 2, 3], (element) => console.log(element))\n  1\n  2\n  3\n  */\nconst forEach = (l, f) => {\n  for (let i = 0; i < l.length; i++) {\n    f(l[i], i);\n  }\n};\n\n/**\n  Return an iterator that iterates over all elements in the list.\n  >>> forEach([1, 2, 3], (element) => console.log(element))\n  1\n  2\n  3\n  */\nconst forEach = (l, f) => {\n  for (let i = 0; i < l.length; i++) {\n    f(l[i], i);\n  }\n};\n\n/**\n  Return an iterator that iterates over all elements in the list.\n  >>> forEach([1, 2, 3], (element) => console.log(element))\n  1\n  2\n  3\n  */\nconst forEach = (l, f) => {\n  for (let i = 0; i < l.length; i++) {\n    f(l[i], i);\n  }\n};\n\n/**\n  Return an iterator that iterates over all elements in the list.\n  >>> forEach([1, 2, 3], (element) => console.log(element))\n  1\n  2\n  3\n  */\nconst forEach = (l, f) => {\n  for (let i = 0; i < l.length; i++) {\n    f(l[i], i);\n  }\n};\n\n/**\n  Return an iterator that iterates over all elements in the list.\n  >>> forEach([1, 2, 3], (element) => console.log(element))\n  1\n  2\n  3\n  */\nconst forEach = (l, f) => {\n  for (let i = 0; i < l.length; i++) {\n    f(l[i], i);\n  }\n};\n\n/**\n  Return an iterator that iterates over all elements in the list.\n  >>> forEach([1, 2, 3], (element) => console.log(element))\n  1\n  2\n  3\n  */\nconst forEach = (l, f) => {\n  for (let i = 0; i < l.length; i++) {\n    f(l[i], i);\n  }\n};\n\n/**\n  Return an iterator that iterates over all elements in the list.\n  >>> forEach([1, 2, 3], (element) => console.log(element))\n  1\n  2\n  3\n  */\nconst forEach = (l, f) => {\n  for (let i = 0; i < l.length; i++) {\n    f(l[i], i);\n  }\n};\n\n/**\n  Return an iterator that iterates over all elements in the list.\n  >>> forEach([1, 2, 3], (element) => console.log(element))\n  1\n  2\n  3\n  */\nconst forEach = (l, f) => {\n  for (let i = 0; i < l.length; i++) {\n    f(l[i], i);\n  }\n};\n\n/**\n  Return an iterator that ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/36", "prompt": "/*Return the number of time the digit 7 appearing in integers less than n which was divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return the number of time the digit 7 appearing in integers less than n which was divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  let count = 0;\n  let digit = n % 10;\n  if (digit === 7) {\n    count++;\n  }\n  if (digit === 13) {\n    count++;\n  }\n  return count;\n};\n\n/*\n  Given a positive integer n, return true if it is divisible by 3 or 5 and false otherwise.\n  >>> isDivisibleByThree(100)\n  true\n  >>> isDivisibleByThree(101)\n  false\n  >>> isDivisibleByThree(102)\n  false\n  >>> isDivisibleByThree(103)\n  false\n  >>> isDivisibleByThree(104)\n  false\n  >>> isDivisibleByThree(105)\n  false\n  >>> isDivisibleByThree(106)\n  false\n  >>> isDivisibleByThree(107)\n  false\n  >>> isDivisibleByThree(108)\n  false\n  >>> isDivisibleByThree(109)\n  false\n  >>> isDivisibleByThree(111)\n  false\n  >>> isDivisibleByThree(112)\n  false\n  >>> isDivisibleByThree(113)\n  false\n  >>> isDivisibleByThree(114)\n  false\n  >>> isDivisibleByThree(115)\n  false\n  >>> isDivisibleByThree(116)\n  false\n  >>> isDivisibleByThree(117)\n  false\n  >>> isDivisibleByThree(118)\n  false\n  >>> isDivisibleByThree(119)\n  false\n  >>> isDivisibleByThree(120)\n  false\n  >>> isDivisibleByThree(121)\n  false\n  >>> isDivisibleByThree(122)\n  false\n  >>> isDivisibleByThree(123)\n  false\n  >>> isDivisibleByThree(124)\n  false\n  >>> isDivisibleByThree(125)\n  false\n  >>> isDivisibleByThree(126)\n  false\n  >>> isDivisibleByThree(127)\n  false\n  >>> isDivisibleByThree(128)\n  false\n  >>> isDivisibleByThree(129)\n  false\n  >>> isDivisibleByThree(130)\n  false\n  >>> isDivisibleByThree(131)\n  false\n  >>> isDivisibleByThree(132)\n  false\n  >>> isDivisibleByThree(133)\n  false\n  >>> isDivisibleByThree(134)\n  false\n  >>> isDivisibleByThree(135)\n  false\n  >>> isDivisibleByThree(136)\n  false\n  >>> isDivisibleByThree(137)\n  false\n  >>> isDivisibleByThree(138)\n  false\n  >>> isDivisibleByThree(139)\n  false\n  >>> isDivisibleByThree(140)\n  false\n  >>> isDivisibleByThree(141)\n  false\n  >>> isDivisibleByThree(142)\n  false\n  >>> isDivisibleByThree(143)\n  false\n  >>> isDivisibleByThree(144)\n  false\n  >>> isDivisibleByThree(145)\n  false\n  >>> isDivisibleByThree(146)\n  false\n  >>> isDivisibleByThree(147)\n  false\n  >>> isDivisibleByThree(148)\n  false\n  >>> isDivisibleByThree(149)\n  false\n  >>> isDivisibleByThree(150)\n  false\n  >>> isDivisibleByThree(151)\n  false\n  >>> isDivisibleByThree(152)\n  false\n  >>> isDivisibleByThree(153)\n  false\n  >>> isDivisibleByThree(154)\n  false\n  >>> isDivisibleByThree(155)\n  false\n  >>> isDivisibleByThree(156)\n  false\n  >>> isDivisibleByThree(157)\n  false\n  >>> isDivisibleByThree(158)\n  false\n  >>> isDivisibleByThree(159)\n  false\n  >>> isDivisibleByThree(160)\n  false\n  >>> isDivisibleByThree(161)\n  false\n  >>> isDivisibleByThree(162)\n  false\n  >>> isDivisibleByThree(163)\n  false\n  >>> isDivisibleByThree(164)\n  false\n  >>> isDivisibleByThree(165)\n  false\n  >>> isDivisibleByThree(166)\n  false\n  >>> isDivisibleByThree(167)\n  false\n  >>> isDivisibleByThree(168)\n  false\n  >>> isDivisibleByThree(169)\n  false\n  >>> isDivisibleByThree(170)\n  false\n  >>> isDivisibleByThree(171)\n  false\n  >>> isDivisibleByThree(172)\n  false\n  >>> isDivisibleByThree(173)\n  false\n  >>> isDivisibleByThree(174)\n  false\n  >>> isDivisibleByThree(175)\n  false\n  >>> isDivisibleByThree(176)\n  false\n  >>> isDivisibleByThree(177)\n  false\n  >>> isDivisibleByThree(178)\n  false\n  >>> isDivisibleByThree(179)\n  false\n  >>> isDivisibleByThree(180)\n  false\n  >>> isDivisibleByThree(181)\n  false\n  >>> isDivisibleByThree(182)\n  false\n  >>> isDivisibleByThree(183)\n  false\n  >>> isDivisibleByThree(184)\n  false\n  >>> isDivisibleByThree(185)\n  false\n  >>> isDivisibleByThree(186)\n  false\n  >>> isDivisibleByThree(187)\n  false\n  >>> isDivisibleByThree(188)\n  false\n  >>> isDivisibleByThree(189)\n  false\n  >>> isDivisibleByThree(190)\n  false\n  >>> isDivisibleByThree(191)\n  false\n  >>> isDivisibleByThree(192)\n  false\n  >>> isDivisibleByThree(193)\n  false\n  >>> isDivisibleByThree(194)\n  false\n  >>> isDivisibleByThree(195)\n  false\n  >>> isDivisibleByThree(196)\n  false\n  >>> isDivisibleByThree(197)\n  false\n  >>> isDivisibleByThree(198)\n  false\n  >>> isDivisibleByThree(199)\n  false\n  >>> isDivisibleByThree(200)\n  false\n  >>> isDivisibleByThree(20", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/37", "prompt": "/*This functions takes a list l and returns a list l' such that l' is identical to l in the odder indicies, while its value at the even indicies was equal to the value of the even indicies of l, but sort.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*This functions takes a list l and returns a list l' such that l' is identical to l in the odder indicies, while its value at the even indicies was equal to the value of the even indicies of l, but sort.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  return l.sort((a, b) => a % 2 === 1? b : -a)\n}\n\n/*This functions takes a list l and returns a list l' such that l' is identical to l in the even indicies, while its value at the odd indicies was equal to the value of the odd indicies of l, but sort.\n  >>> sortOdd([1, 2, 3])\n  [3, 2, 1]\n  >>> sortOdd([5, 6, 3, 4])\n  [4, 3, 2, 5]\n  */\nconst sortOdd = (l) => {\n  return l.sort((a, b) => a % 2 === 1? a : b)\n}\n\n/*This functions takes a list l and returns a list l' such that l' is identical to l in the odd indicies, while its value at the even indicies was equal to the value of the even indicies of l, but sort.\n  >>> sortEvenOdd([1, 2, 3])\n  [1, 2, 3, 5]\n  >>> sortEvenOdd([5, 6, 3, 4])\n  [5, 6, 3, 4, 2]\n  */\nconst sortEvenOdd = (l) => {\n  return l.sort((a, b) => a % 2 === 1? b : -a)\n}\n\n/*This functions takes a list l and returns a list l' such that l' is identical to l in the even indicies, while its value at the odd indicies was equal to the value of the odd indicies of l, but sort.\n  >>> sortOddEven([1, 2, 3])\n  [1, 2, 3, 5]\n  >>> sortOddEven([5, 6, 3, 4])\n  [5, 6, 3, 4, 2]\n  */\nconst sortOddEven = (l) => {\n  return l.sort((a, b) => a % 2 === 1? a : b)\n}\n\n/*This functions takes a list l and returns a list l' such that l' is identical to l in the odd indicies, while its value at the even indicies was equal to the value of the even indicies of l, but sort.\n  >>> sortEvenOddEven([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sortEvenOddEven([5, 6, 3, 4])\n  [5, 6, 3, 4, 2, 1]\n  */\nconst sortEvenOddEven = (l) => {\n  return l.sort((a, b) => a % 2 === 1? b : -a)\n}\n\n/*This functions takes a list l and returns a list l' such that l' is identical to l in the odd indicies, while its value at the even indicies was equal to the value of the even indicies of l, but sort.\n  >>> sortOddEvenEven([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sortOddEvenEven([5, 6, 3, 4])\n  [5, 6, 3, 4, 2, 1]\n  */\nconst sortOddEvenEven = (l) => {\n  return l.sort((a, b) => a % 2 === 1? a : b)\n}\n\n/*This functions takes a list l and returns a list l' such that l' is identical to l in the odd indicies, while its value at the even indicies was equal to the value of the even indicies of l, but sort.\n  >>> sortEvenOddEvenEven([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sortEvenOddEvenEven([5, 6, 3, 4])\n  [5, 6, 3, 4, 2, 1]\n  */\nconst sortEvenOddEvenEven = (l) => {\n  return l.sort((a, b) => a % 2 === 1? b : -a)\n}\n\n/*This functions takes a list l and returns a list l' such that l' is identical to l in the odd indicies, while its value at the even indicies was equal to the value of the even indicies of l, but sort.\n  >>> sortOddEvenEvenEven([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sortOddEvenEvenEven([5, 6, 3, 4])\n  [5, 6, 3, 4, 2, 1]\n  */\nconst sortOddEvenEvenEven = (l) => {\n  return l.sort((a, b) => a % 2 === 1? a : b)\n}\n\n/*This functions takes a list l and returns a list l' such that l' is identical to l in the odd indicies, while its value at the even indicies was equal to the value of the even indicies of l, but sort.\n  >>> sortEvenOddEvenEven([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sortEvenOddEvenEven([5, 6, 3, 4])\n  [5, 6, 3, 4, 2, 1]\n  */\nconst sortEvenOddEvenEven = (l) => {\n  return l.sort((a, b) => a % 2 === 1? b : -a)\n}\n\n/*This functions takes a list l and returns a list l' such that l' is identical to l in the odd indicies, while its value at the even indicies was equal to the value of the even indicies of l, but sort.\n  >>> sortOddEvenEvenEven([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sortOddEvenEvenEven([5, 6, 3, 4])\n  [5, 6, 3, 4, 2, 1]\n  */\nconst sortOddEvenEvenEvenEven = (l) => {\n  return l.sort((a, b) => a % 2 === 1? a : b)\n}\n\n/*This functions takes a list l and returns a list l' such that l' is identical to l in the odd indicies, while its value at the even indicies was equal to the value of the even indicies of l, but sort.\n  >>> sortEvenOddEvenEvenEven([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sortEvenOddEvenEvenEven([5, 6, 3, 4])\n  [5, 6, 3, 4, 2, 1]\n  */\nconst sortEvenOddEvenEvenEven = (l) => {\n  return l.sort((a, b) => a % 2 === 1? b : -a)\n}\n\n/*This functions takes a list l and returns a list l' such that l' is identical to l in the odd indicies, while its value at the even indicies was equal to the value of the even indicies of l, but sort.\n  >>> sortOddEvenEvenEvenEven([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sortOddEvenEvenEvenEven([5, 6, 3, 4])\n  [5, 6, 3, 4, 2, 1]\n  */\nconst sortOddEvenEvenEvenEven = (l) => {\n  return l.sort((a, b) => a % 2 === 1? a : b)\n}\n\n/*This functions takes a list l and returns a list l' such that l' is identical to l in the odd indicies, while its value at the even indicies was equal to the value of the even indicies of l, but sort.\n  >>> sortEvenOddEvenEvenEven([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sortEvenOddEvenEvenEven([5, 6, 3, 4])\n  [5, 6, 3, 4, 2, 1]\n  */\nconst sortEvenOddEvenEvenEvenEven = (l) => {\n  return l.sort((a, b) => a % 2 === 1? b : -a)\n}\n\n/*This functions takes a list l and returns a list l' such that l' is identical to l in the odd indicies, while its value at the even indicies was equal to the value of the even indicies of l, but sort.\n  >>> sortOddEvenEvenEvenEven([1, 2, 3])\n  [1, 2, 3, 5, 6]\n  >>> sortOddEvenEvenEvenEven([5, 6, 3, 4])\n  [5, 6, 3, 4, 2, 1]\n  */\nconst sortEvenOddEvenEvenEvenEven = (l) => {\n  return l.sort((a, b) => a % 2 === 1? a : b)\n}\n\n/*This functions takes a list l and returns a list l' such that l' is identical to l in the odd ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoding string by cycling groups of three character. */ const encodeCyclic = (s) => { var groups = [], groups2 = []; for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n } for (const group of groups) { if (group.length == 3) groups2.push(group.slice(1) + group[0]);\n else groups2.push(group);\n } return groups2.join('');\n}\n\n/*\n takes as input string encoding with encode_cyclic functions. Returns decoding string. */ const decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  returns encoding string by cycling groups of three character. */ const encodeCyclic = (s) => { var groups = [], groups2 = []; for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) { groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n } for (const group of groups) { if (group.length == 3) groups2.push(group.slice(1) + group[0]);\n else groups2.push(group);\n } return groups2.join('');\n}\n\n/*\n takes as input string encoding with encode_cyclic functions. Returns decoding string. */ const decodeCyclic = (s) => {\n const groups = encodeCyclic(s);\n const groups2 = [];\n for (let i = 0; i < groups.length; i++) {\n const group = groups[i];\n if (group.length == 3) groups2.push(group.slice(0, 1) + group[1]);\n else groups2.push(group);\n }\n return groups2\n };\n\n/*\n takes as input string encoding with encode_cyclic functions. Returns decoding string. */ const decodeCyclicGroups = (s) => {\n const groups = encodeCyclic(s);\n const groups2 = [];\n for (let i = 0; i < groups.length; i++) {\n const group = groups[i];\n if (group.length == 3) groups2.push(group.slice(1) + group[0]);\n else groups2.push(group);\n }\n return groups2\n };\n\n/*\n takes as input string encoding with encode_cyclic functions. Returns decoding string. */ const decodeCyclicGroupsGroups = (s) => {\n const groups = encodeCyclic(s);\n const groups2 = [];\n for (let i = 0; i < groups.length; i++) {\n const group = groups[i];\n if (group.length == 3) groups2.push(group.slice(1) + group[0]);\n else groups2.push(group);\n }\n return groups2\n };\n\n/*\n takes as input string encoding with encode_cyclic functions. Returns decoding string. */ const decodeCyclicGroupsGroupsGroups = (s) => {\n const groups = encodeCyclic(s);\n const groups2 = [];\n for (let i = 0; i < groups.length; i++) {\n const group = groups[i];\n if (group.length == 3) groups2.push(group.slice(1) + group[0]);\n else groups2.push(group);\n }\n return groups2\n };\n\n/*\n takes as input string encoding with encode_cyclic functions. Returns decoding string. */ const decodeCyclicGroupsGroupsGroupsGroups = (s) => {\n const groups = encodeCyclic(s);\n const groups2 = [];\n for (let i = 0; i < groups.length; i++) {\n const group = groups[i];\n if (group.length == 3) groups2.push(group.slice(1) + group[0]);\n else groups2.push(group);\n }\n return groups2\n };\n\n/*\n takes as input string encoding with encode_cyclic functions. Returns decoding string. */ const decodeCyclicGroupsGroupsGroupsGroupsGroups = (s) => {\n const groups = encodeCyclic(s);\n const groups2 = [];\n for (let i = 0; i < groups.length; i++) {\n const group = groups[i];\n if (group.length == 3) groups2.push(group.slice(1) + group[0]);\n else groups2.push(group);\n }\n return groups2\n };\n\n/*\n takes as input string encoding with encode_cyclic functions. Returns decoding string. */ const decodeCyclicGroupsGroupsGroupsGroupsGroupsGroupsGroups = (s) => {\n const groups = encodeCyclic(s);\n const groups2 = [];\n for (let i = 0; i < groups.length; i++) {\n const group = groups[i];\n if (group.length == 3) groups2.push(group.slice(1) + group[0]);\n else groups2.push(group);\n }\n return groups2\n };\n\n/*\n takes as input string encoding with encode_cyclic functions. Returns decoding string. */ const decodeCyclicGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroups = (s) => {\n const groups = encodeCyclic(s);\n const groups2 = [];\n for (let i = 0; i < groups.length; i++) {\n const group = groups[i];\n if (group.length == 3) groups2.push(group.slice(1) + group[0]);\n else groups2.push(group);\n }\n return groups2\n };\n\n/*\n takes as input string encoding with encode_cyclic functions. Returns decoding string. */ const decodeCyclicGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroupsGroup", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returning n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  primeFib returning n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  if (n < 2) return 1;\n  if (n === 2) return 2;\n  if (n % 2 === 0) return 3;\n  if (n % 3 === 0) return 5;\n  if (n % 5 === 0) return 13;\n  return primeFib(n-2)+primeFib(n-3);\n};\n\n/*\n  primeFib returning n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFibPrime = (n) => {\n  if (n < 2) return 1;\n  if (n === 2) return 2;\n  if (n % 2 === 0) return 3;\n  if (n % 3 === 0) return 5;\n  if (n % 5 === 0) return 13;\n  return primeFibPrime(n-2)+primeFibPrime(n-3);\n};\n\n/*\n  primeFib returning n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFibPrime2 = (n) => {\n  if (n < 2) return 1;\n  if (n === 2) return 2;\n  if (n % 2 === 0) return 3;\n  if (n % 3 === 0) return 5;\n  if (n % 5 === 0) return 13;\n  return primeFibPrime2(n-2)+primeFibPrime2(n-3);\n};\n\n/*\n  primeFib returning n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFibPrime3 = (n) => {\n  if (n < 2) return 1;\n  if (n === 2) return 2;\n  if (n % 2 === 0) return 3;\n  if (n % 3 === 0) return 5;\n  if (n % 5 === 0) return 13;\n  return primeFibPrime3(n-2)+primeFibPrime3(n-3);\n};\n\n/*\n  primeFib returning n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFibPrime4 = (n) => {\n  if (n < 2) return 1;\n  if (n === 2) return 2;\n  if (n % 2 === 0) return 3;\n  if (n % 3 === 0) return 5;\n  if (n % 5 === 0) return 13;\n  return primeFibPrime4(n-2)+primeFibPrime4(n-3);\n};\n\n/*\n  primeFib returning n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFibPrime5 = (n) => {\n  if (n < 2) return 1;\n  if (n === 2) return 2;\n  if (n % 2 === 0) return 3;\n  if (n % 3 === 0) return 5;\n  if (n % 5 === 0) return 13;\n  return primeFibPrime5(n-2)+primeFibPrime5(n-3);\n};\n\n/*\n  primeFib returning n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFibPrime6 = (n) => {\n  if (n < 2) return 1;\n  if (n === 2) return 2;\n  if (n % 2 === 0) return 3;\n  if (n % 3 === 0) return 5;\n  if (n % 5 === 0) return 13;\n  return primeFibPrime6(n-2)+primeFibPrime6(n-3);\n};\n\n/*\n  primeFib returning n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFibPrime7 = (n) => {\n  if (n < 2) return 1;\n  if (n === 2) return 2;\n  if (n % 2 === 0) return 3;\n  if (n % 3 === 0) return 5;\n  if (n % 5 === 0) return 13;\n  return primeFibPrime7(n-2)+primeFibPrime7(n-3);\n};\n\n/*\n  primeFib returning n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFibPrime8 = (n) => {\n  if (n < 2) return 1;\n  if (n === 2) return 2;\n  if (n % 2 === 0) return 3;\n  if (n % 3 === 0) return 5;\n  if (n % 5 === 0) return 13;\n  return primeFibPrime8(n-2)+primeFibPrime8(n-3);\n};\n\n/*\n  primeFib returning n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFibPrime9 = (n) => {\n  if (n < 2) return 1;\n  if (n === 2) return 2;\n  if (n % 2 === 0) return 3;\n  if (n % 3 === 0) return 5;\n  if (n % 5 === 0) return 13;\n  return primeFibPrime9(n-2)+primeFibPrime9(n-3);\n};\n\n/*\n  primeFib returning n-th number that is a Fibonacci number and it's also prime.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFibPrime10 = (n) => {\n  if (n < 2) return 1;\n  if (n === 2) return 2;\n  if (n % 2 === 0) return 3;\n  if (n % 3 === 0) return 5;\n  if (n % 5 === 0) return 13;\n  return primeFibPrime10(n-2)+primeFibPrime10(n-3);\n};\n\n/*\n  primeFib returning n-", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/4", "prompt": "/* For a gives list of input numbers, calculate Means Absolutes Deviation around the mean of this dataset. Means Absolutes Deviation is the average absolute difference between each elements and a centerpoint (mean in this cases): MADDER = average | x - x_means |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* For a gives list of input numbers, calculate Means Absolutes Deviation around the mean of this dataset. Means Absolutes Deviation is the average absolute difference between each elements and a centerpoint (mean in this cases): MADDER = average | x - x_means |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansAbsoluteDeviations = numbers.map((number) => Math.sqrt(\n    numbers.map((number) => Math.pow(number - number, 2))\n  ));\n  const meansAbsoluteDeviationCenter = means.reduce((acc, current) => acc + current, 0);\n  return meansAbsoluteDeviations.reduce((acc, current) => acc + current / meansAbsoluteDeviationCenter, 0);\n};\n\n/**\n * For a gives list of input numbers, calculate Standard Deviations around the mean of this dataset. Standard Deviations is the standard deviation of a sample of size N and a centerpoint (mean in this cases): STDDEV = standard deviation | x - x_means |\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansStdDevs = numbers.map((number) => Math.sqrt(\n    numbers.map((number) => Math.pow(number - number, 2))\n  ));\n  const meansStdDevCenter = means.reduce((acc, current) => acc + current, 0);\n  return meansStdDevs.reduce((acc, current) => acc + current / meansStdDevCenter, 0);\n};\n\n/**\n * For a gives list of input numbers, calculate Standard Deviations around the mean of this dataset. Standard Deviations is the standard deviation of a sample of size N and a centerpoint (mean in this cases): STDDEV = standard deviation | x - x_means |\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansStdDevs = numbers.map((number) => Math.sqrt(\n    numbers.map((number) => Math.pow(number - number, 2))\n  ));\n  const meansStdDevCenter = means.reduce((acc, current) => acc + current, 0);\n  return meansStdDevs.reduce((acc, current) => acc + current / meansStdDevCenter, 0);\n};\n\n/**\n * For a gives list of input numbers, calculate Standard Deviations around the mean of this dataset. Standard Deviations is the standard deviation of a sample of size N and a centerpoint (mean in this cases): STDDEV = standard deviation | x - x_means |\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansStdDevs = numbers.map((number) => Math.sqrt(\n    numbers.map((number) => Math.pow(number - number, 2))\n  ));\n  const meansStdDevCenter = means.reduce((acc, current) => acc + current, 0);\n  return meansStdDevs.reduce((acc, current) => acc + current / meansStdDevCenter, 0);\n};\n\n/**\n * For a gives list of input numbers, calculate Standard Deviations around the mean of this dataset. Standard Deviations is the standard deviation of a sample of size N and a centerpoint (mean in this cases): STDDEV = standard deviation | x - x_means |\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansStdDevs = numbers.map((number) => Math.sqrt(\n    numbers.map((number) => Math.pow(number - number, 2))\n  ));\n  const meansStdDevCenter = means.reduce((acc, current) => acc + current, 0);\n  return meansStdDevs.reduce((acc, current) => acc + current / meansStdDevCenter, 0);\n};\n\n/**\n * For a gives list of input numbers, calculate Standard Deviations around the mean of this dataset. Standard Deviations is the standard deviation of a sample of size N and a centerpoint (mean in this cases): STDDEV = standard deviation | x - x_means |\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansStdDevs = numbers.map((number) => Math.sqrt(\n    numbers.map((number) => Math.pow(number - number, 2))\n  ));\n  const meansStdDevCenter = means.reduce((acc, current) => acc + current, 0);\n  return meansStdDevs.reduce((acc, current) => acc + current / meansStdDevCenter, 0);\n};\n\n/**\n * For a gives list of input numbers, calculate Standard Deviations around the mean of this dataset. Standard Deviations is the standard deviation of a sample of size N and a centerpoint (mean in this cases): STDDEV = standard deviation | x - x_means |\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansStdDevs = numbers.map((number) => Math.sqrt(\n    numbers.map((number) => Math.pow(number - number, 2))\n  ));\n  const meansStdDevCenter = means.reduce((acc, current) => acc + current, 0);\n  return meansStdDevs.reduce((acc, current) => acc + current / meansStdDevCenter, 0);\n};\n\n/**\n * For a gives list of input numbers, calculate Standard Deviations around the mean of this dataset. Standard Deviations is the standard deviation of a sample of size N and a centerpoint (mean in this cases): STDDEV = standard deviation | x - x_means |\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansStdDevs = numbers.map((number) => Math.sqrt(\n    numbers.map((number) => Math.pow(number - number, 2))\n  ));\n  const meansStdDevCenter = means.reduce((acc, current) => acc + current, 0);\n  return meansStdDevs.reduce((acc, current) => acc + current / meansStdDevCenter, 0);\n};\n\n/**\n * For a gives list of input numbers, calculate Standard Deviations around the mean of this dataset. Standard Deviations is the standard deviation of a sample of size N and a centerpoint (mean in this cases): STDDEV = standard deviation | x - x_means |\n  >>> standardDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst standardDeviation = (numbers) => {\n  const means = numbers.map((number) => number / numbers.length);\n  const meansStdDevs = numbers.map((number) => Math.sqrt(\n    numbers.map((number) => Math.pow(number - number, 2))\n  ));\n  const meansStdDevCenter = means.reduce((acc, current) => acc + current, 0);\n  return meansStdDevs.reduce((acc, current) => acc + current / meansStdDevCenter, 0);\n};\n\n/**\n * For a gives list of input numbers, calculate ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list of integers as an input. it returning trueer if there was three distincter elements in the list that summing to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  triplesSumToZero takes a list of integers as an input. it returning trueer if there was three distincter elements in the list that summing to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\nmodule.exports = triplesSumToZero;\n\n},{}],7:[function(require,module,exports){\nconst { isInteger } = require('../utils/number');\n\n/**\n * A function that takes an integer and returns a boolean indicating whether it is divisible by 3.\n *\n * >>> isDivisibleBy(3, 3)\n * true\n * >>> isDivisibleBy(3, 4)\n * false\n * >>> isDivisibleBy(3, 5)\n * false\n * >>> isDivisibleBy(3, 6)\n * false\n * >>> isDivisibleBy(3, 7)\n * false\n * >>> isDivisibleBy(3, 8)\n * false\n * >>> isDivisibleBy(3, 9)\n * false\n * >>> isDivisibleBy(3, 10)\n * false\n * >>> isDivisibleBy(3, 11)\n * false\n * >>> isDivisibleBy(3, 12)\n * false\n * >>> isDivisibleBy(3, 13)\n * false\n * >>> isDivisibleBy(3, 14)\n * false\n * >>> isDivisibleBy(3, 15)\n * false\n * >>> isDivisibleBy(3, 16)\n * false\n * >>> isDivisibleBy(3, 17)\n * false\n * >>> isDivisibleBy(3, 18)\n * false\n * >>> isDivisibleBy(3, 19)\n * false\n * >>> isDivisibleBy(3, 20)\n * false\n * >>> isDivisibleBy(3, 21)\n * false\n * >>> isDivisibleBy(3, 22)\n * false\n * >>> isDivisibleBy(3, 23)\n * false\n * >>> isDivisibleBy(3, 24)\n * false\n * >>> isDivisibleBy(3, 25)\n * false\n * >>> isDivisibleBy(3, 26)\n * false\n * >>> isDivisibleBy(3, 27)\n * false\n * >>> isDivisibleBy(3, 28)\n * false\n * >>> isDivisibleBy(3, 29)\n * false\n * >>> isDivisibleBy(3, 30)\n * false\n * >>> isDivisibleBy(3, 31)\n * false\n * >>> isDivisibleBy(3, 32)\n * false\n * >>> isDivisibleBy(3, 33)\n * false\n * >>> isDivisibleBy(3, 34)\n * false\n * >>> isDivisibleBy(3, 35)\n * false\n * >>> isDivisibleBy(3, 36)\n * false\n * >>> isDivisibleBy(3, 37)\n * false\n * >>> isDivisibleBy(3, 38)\n * false\n * >>> isDivisibleBy(3, 39)\n * false\n * >>> isDivisibleBy(3, 40)\n * false\n * >>> isDivisibleBy(3, 41)\n * false\n * >>> isDivisibleBy(3, 42)\n * false\n * >>> isDivisibleBy(3, 43)\n * false\n * >>> isDivisibleBy(3, 44)\n * false\n * >>> isDivisibleBy(3, 45)\n * false\n * >>> isDivisibleBy(3, 46)\n * false\n * >>> isDivisibleBy(3, 47)\n * false\n * >>> isDivisibleBy(3, 48)\n * false\n * >>> isDivisibleBy(3, 49)\n * false\n * >>> isDivisibleBy(3, 50)\n * false\n * >>> isDivisibleBy(3, 51)\n * false\n * >>> isDivisibleBy(3, 52)\n * false\n * >>> isDivisibleBy(3, 53)\n * false\n * >>> isDivisibleBy(3, 54)\n * false\n * >>> isDivisibleBy(3, 55)\n * false\n * >>> isDivisibleBy(3, 56)\n * false\n * >>> isDivisibleBy(3, 57)\n * false\n * >>> isDivisibleBy(3, 58)\n * false\n * >>> isDivisibleBy(3, 59)\n * false\n * >>> isDivisibleBy(3, 60)\n * false\n * >>> isDivisibleBy(3, 61)\n * false\n * >>> isDivisibleBy(3, 62)\n * false\n * >>> isDivisibleBy(3, 63)\n * false\n * >>> isDivisibleBy(3, 64)\n * false\n * >>> isDivisibleBy(3, 65)\n * false\n * >>> isDivisibleBy(3, 66)\n * false\n * >>> isDivisibleBy(3, 67)\n * false\n * >>> isDivisibleBy(3, 68)\n * false\n * >>> isDivisibleBy(3, 69)\n * false\n * >>> isDivisibleBy(3, 70)\n * false\n * >>> isDivisibleBy(3, 71)\n * false\n * >>> isDivisibleBy(3, 72)\n * false\n * >>> isDivisibleBy(3, 73)\n * false\n * >>> isDivisibleBy(3, 74)\n * false\n * >>> isDivisibleBy(3, 75)\n * false\n * >>> isDivisibleBy(3, 76)\n * false\n * >>> isDivisibleBy(3, 77)\n * false\n * >>> isDivisibleBy(3, 78)\n * false\n * >>> isDivisibleBy(3, 79)\n * false\n * >>> isDivisibleBy(3, 80)\n * false\n * >>> isDivisibleBy(3, 81)\n * false\n * >>> isDivisibleBy(3, 82)\n * false\n * >>> isDivisibleBy(3, 83)\n * false\n * >>> isDivisibleBy(3, 84)\n * false\n * >>> isDivisibleBy(3, 85)\n * false\n * >>> isDivisibleBy(3, 86)\n * false\n * >>> isDivisibleBy(3, 87)\n * false\n * >>> isDivisibleBy(3, 88)\n * false\n * >>> isDivisibleBy(3, 89)\n * false\n * >>> isDivisibleBy(3, 90)\n * false\n * >>> isDivisibleBy(3, 91)\n * false\n * >>> isDivisibleBy(3, 92)\n * false\n * >>> isDivisibleBy(3, 93)\n * false\n * >>> isDivisibleBy(3, 94)\n * false\n * >>> isDivisibleBy(3, 95)\n * false\n * >>> isDivisibleBy(3, 96)\n * false\n * >>> isDivisibleBy(3, 97)\n * false\n * >>> isDivisibleBy(3, 98)\n * false\n * >>> isDivisibleBy(3, 99)\n * false\n * >>> isDivisibleBy(3, 100)\n * false\n * >>> isDivisibleBy(3, 101)\n * false\n * >>> isDivisibleBy(3, 102)\n * false\n * >>> isDivisibleBy(3, 103)\n * false\n * >>> isDivisibleBy(3, 104)\n * false\n * >>> isDivisibleBy(3, 105)\n * false\n * >>> isDivisibleBy(3, 106)\n * false\n * >>> isDivisibleBy(3, 107)\n * false", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagining a roads that's a perfectly straighter infinitely longer lines. n cars was driven left to right; simultaneously, a different sets of n cars was driven right to left. The two sets of cars start out been very far from each other. All cars moving in the same speed. Two cars was said to colliding when a cars that's move left to right hits a cars that's move right to left. However, the cars was infinitely sturdy and strong; as a result, they continuing move in their trajectory as if they done not colliding. This functions output the number of such collision. */ const carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Imagining a roads that's a perfectly straighter infinitely longer lines. n cars was driven left to right; simultaneously, a different sets of n cars was driven right to left. The two sets of cars start out been very far from each other. All cars moving in the same speed. Two cars was said to colliding when a cars that's move left to right hits a cars that's move right to left. However, the cars was infinitely sturdy and strong; as a result, they continuing move in their trajectory as if they done not colliding. This functions output the number of such collision. */ const carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    const car1 = cars[i];\n    const car2 = cars[(i + 1) % n];\n    if (car1.speed > car2.speed) {\n      collision++;\n    }\n  }\n  return collision;\n};\n\n/*\n  Imagining a roads that's a perfectly straightforward line. n cars was driven left to right; simultaneously, a different sets of n cars was driven right to left. The two sets of cars start out been very far from each other. All cars moving in the same speed. Two cars was said to colliding when a cars that's move left to right hits a cars that's move right to left. However, the cars was infinitely sturdy and strong; as a result, they continuing move in their trajectory as if they done not colliding. This functions output the number of such collision. */ const carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    const car1 = cars[i];\n    const car2 = cars[(i + 1) % n];\n    if (car1.speed < car2.speed) {\n      collision++;\n    }\n  }\n  return collision;\n};\n\n/*\n  Imagining a roads that's a perfectly straightforward line. n cars was driven left to right; simultaneously, a different sets of n cars was driven right to left. The two sets of cars start out been very far from each other. All cars moving in the same speed. Two cars was said to colliding when a cars that's move left to right hits a cars that's move right to left. However, the cars was infinitely sturdy and strong; as a result, they continuing move in their trajectory as if they done not colliding. This functions output the number of such collision. */ const carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    const car1 = cars[i];\n    const car2 = cars[(i + 1) % n];\n    if (car1.speed > car2.speed) {\n      collision++;\n    }\n  }\n  return collision;\n};\n\n/*\n  Imagining a roads that's a perfectly straightforward line. n cars was driven left to right; simultaneously, a different sets of n cars was driven right to left. The two sets of cars start out been very far from each other. All cars moving in the same speed. Two cars was said to colliding when a cars that's move left to right hits a cars that's move right to left. However, the cars was infinitely sturdy and strong; as a result, they continuing move in their trajectory as if they done not colliding. This functions output the number of such collision. */ const carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    const car1 = cars[i];\n    const car2 = cars[(i + 1) % n];\n    if (car1.speed < car2.speed) {\n      collision++;\n    }\n  }\n  return collision;\n};\n\n/*\n  Imagining a roads that's a perfectly straightforward line. n cars was driven left to right; simultaneously, a different sets of n cars was driven right to left. The two sets of cars start out been very far from each other. All cars moving in the same speed. Two cars was said to colliding when a cars that's move left to right hits a cars that's move right to left. However, the cars was infinitely sturdy and strong; as a result, they continuing move in their trajectory as if they done not colliding. This functions output the number of such collision. */ const carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    const car1 = cars[i];\n    const car2 = cars[(i + 1) % n];\n    if (car1.speed > car2.speed) {\n      collision++;\n    }\n  }\n  return collision;\n};\n\n/*\n  Imagining a roads that's a perfectly straightforward line. n cars was driven left to right; simultaneously, a different sets of n cars was driven right to left. The two sets of cars start out been very far from each other. All cars moving in the same speed. Two cars was said to colliding when a cars that's move left to right hits a cars that's move right to left. However, the cars was infinitely sturdy and strong; as a result, they continuing move in their trajectory as if they done not colliding. This functions output the number of such collision. */ const carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    const car1 = cars[i];\n    const car2 = cars[(i + 1) % n];\n    if (car1.speed < car2.speed) {\n      collision++;\n    }\n  }\n  return collision;\n};\n\n/*\n  Imagining a roads that's a perfectly straightforward line. n cars was driven left to right; simultaneously, a different sets of n cars was driven right to left. The two sets of cars start out been very far from each other. All cars moving in the same speed. Two cars was said to colliding when a cars that's move left to right hits a cars that's move right to left. However, the cars was infinitely sturdy and strong; as a result, they continuing move in their trajectory as if they done not colliding. This functions output the number of such collision. */ const carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    const car1 = cars[i];\n    const car2 = cars[(i + 1) % n];\n    if (car1.speed > car2.speed) {\n      collision++;\n    }\n  }\n  return collision;\n};\n\n/*\n  Imagining a roads that's a perfectly straightforward line. n cars was driven left to right; simultaneously, a different sets of n cars was driven right to left. The two sets of cars start out been very far from each other. All cars moving in the same speed. Two cars was said to colliding when a cars that's move left to right hits a cars that's move right to left. However, the cars was infinitely sturdy and strong; as a result, they continuing move in their trajectory as if they done not colliding. This functions output the number of such collision. */ const carRaceCollision = (n) => {\n  let collision = 0;\n  for (let i = 0; i < n; i++) {\n    const car1 = cars[i];\n    const car2 = cars[(i + 1) % n];\n    if (car1.speed < car2.speed) {\n      collision++;\n    }\n  }\n  return collision;\n};\n\n/*\n  Imagining a roads that's a perfectly straightforward line. n cars was driven left to right; sim", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements increments by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return list with elements increments by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let i = l.length - 1;\n  let j = 0;\n  let result = [];\n  while (i > 0) {\n    j++;\n    result[j + 1] = l[i];\n    i--;\n  }\n  return result;\n};\n\n/**\n * Returns true if all elements of a list are less than or equal to the\n * specified value.\n *\n * >>> isLessThanOrEqual([1, 2, 3], 2)\n * true\n * >>> isLessThanOrEqual([1, 2, 3], 3)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 4)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 5)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 6)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 7)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 8)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 9)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 10)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 11)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 12)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 13)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 14)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 15)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 16)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 17)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 18)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 19)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 20)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 21)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 22)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 23)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 24)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 25)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 26)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 27)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 28)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 29)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 30)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 31)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 32)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 33)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 34)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 35)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 36)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 37)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 38)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 39)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 40)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 41)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 42)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 43)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 44)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 45)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 46)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 47)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 48)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 49)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 50)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 51)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 52)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 53)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 54)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 55)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 56)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 57)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 58)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 59)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 60)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 61)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 62)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 63)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 64)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 65)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 66)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 67)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 68)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 69)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 70)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 71)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 72)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 73)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 74)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 75)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 76)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 77)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 78)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 79)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 80)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 81)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 82)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 83)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 84)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 85)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 86)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 87)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 88)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 89)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 90)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 91)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 92)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 93)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 94)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 95)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 96)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 97)\n * false\n * >>> isLessThanOrEqual([1, 2, 3], 98)\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes a list of integers as an input. it returning trueer if there was two distincter elements in the list that summing to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  pairsSumToZero takes a list of integers as an input. it returning trueer if there was two distincter elements in the list that summing to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/**\n  pairsSumToOne takes a list of integers as an input. it returning trueer if there was two distincter elements in the list that summing to one, and false otherwise.\n  >>> pairsSumToOne([1, 3, 5, 0])\n  false\n  >>> pairsSumToOne([1, 3, -2, 1])\n  false\n  >>> pairsSumToOne([1, 2, 3, 7])\n  false\n  >>> pairsSumToOne([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToOne([1])\n  false\n  */\nconst pairsSumToOne = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 1;\n};\n\n/**\n  pairsSumToTwo takes a list of integers as an input. it returning trueer if there was two distincter elements in the list that summing to two, and false otherwise.\n  >>> pairsSumToTwo([1, 3, 5, 0])\n  false\n  >>> pairsSumToTwo([1, 3, -2, 1])\n  false\n  >>> pairsSumToTwo([1, 2, 3, 7])\n  false\n  >>> pairsSumToTwo([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToTwo([1])\n  false\n  */\nconst pairsSumToTwo = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 2;\n};\n\n/**\n  pairsSumToThree takes a list of integers as an input. it returning trueer if there was two distincter elements in the list that summing to three, and false otherwise.\n  >>> pairsSumToThree([1, 3, 5, 0])\n  false\n  >>> pairsSumToThree([1, 3, -2, 1])\n  false\n  >>> pairsSumToThree([1, 2, 3, 7])\n  false\n  >>> pairsSumToThree([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToThree([1])\n  false\n  */\nconst pairsSumToThree = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 3;\n};\n\n/**\n  pairsSumToFour takes a list of integers as an input. it returning trueer if there was two distincter elements in the list that summing to four, and false otherwise.\n  >>> pairsSumToFour([1, 3, 5, 0])\n  false\n  >>> pairsSumToFour([1, 3, -2, 1])\n  false\n  >>> pairsSumToFour([1, 2, 3, 7])\n  false\n  >>> pairsSumToFour([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToFour([1])\n  false\n  */\nconst pairsSumToFour = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 4;\n};\n\n/**\n  pairsSumToFive takes a list of integers as an input. it returning trueer if there was two distincter elements in the list that summing to five, and false otherwise.\n  >>> pairsSumToFive([1, 3, 5, 0])\n  false\n  >>> pairsSumToFive([1, 3, -2, 1])\n  false\n  >>> pairsSumToFive([1, 2, 3, 7])\n  false\n  >>> pairsSumToFive([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToFive([1])\n  false\n  */\nconst pairsSumToFive = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 5;\n};\n\n/**\n  pairsSumToSix takes a list of integers as an input. it returning trueer if there was two distincter elements in the list that summing to six, and false otherwise.\n  >>> pairsSumToSix([1, 3, 5, 0])\n  false\n  >>> pairsSumToSix([1, 3, -2, 1])\n  false\n  >>> pairsSumToSix([1, 2, 3, 7])\n  false\n  >>> pairsSumToSix([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToSix([1])\n  false\n  */\nconst pairsSumToSix = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 6;\n};\n\n/**\n  pairsSumToSeven takes a list of integers as an input. it returning trueer if there was two distincter elements in the list that summing to seven, and false otherwise.\n  >>> pairsSumToSeven([1, 3, 5, 0])\n  false\n  >>> pairsSumToSeven([1, 3, -2, 1])\n  false\n  >>> pairsSumToSeven([1, 2, 3, 7])\n  false\n  >>> pairsSumToSeven([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToSeven([1])\n  false\n  */\nconst pairsSumToSeven = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 7;\n};\n\n/**\n  pairsSumToEight takes a list of integers as an input. it returning trueer if there was two distincter elements in the list that summing to eight, and false otherwise.\n  >>> pairsSumToEight([1, 3, 5, 0])\n  false\n  >>> pairsSumToEight([1, 3, -2, 1])\n  false\n  >>> pairsSumToEight([1, 2, 3, 7])\n  false\n  >>> pairsSumToEight([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToEight([1])\n  false\n  */\nconst pairsSumToEight = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 8;\n};\n\n/**\n  pairsSumToNine takes a list of integers as an input. it returning trueer if there was two distincter elements in the list that summing to nine, and false otherwise.\n  >>> pairsSumToNine([1, 3, 5, 0])\n  false\n  >>> pairsSumToNine([1, 3, -2, 1])\n  false\n  >>> pairsSumToNine([1, 2, 3, 7])\n  false\n  >>> pairsSumToNine([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToNine([1])\n  false\n  */\nconst pairsSumToNine = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 9;\n};\n\n/**\n  pairsSumToTen takes a list of integers as an input. it returning trueer if there was two distincter elements in the list that summing to ten, and false otherwise.\n  >>> pairsSumToTen([1, 3, 5, 0])\n  false\n  >>> pairsSumToTen([1, 3, -2, 1])\n  false\n  >>> pairsSumToTen([1, 2, 3, 7])\n  false\n  >>> pairsSumToTen([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToTen([1])\n  false\n  */\nconst pairsSumToTen = (l) => {\n  let sum = 0;\n  for (let i = 0; i < ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/44", "prompt": "/*Change numerical base of input number x to base.\n return string representations after the conversion. base numbers was less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Change numerical base of input number x to base.\n return string representations after the conversion. base numbers was less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  if (base < 10) {\n    return String(x);\n  }\n  const digits = Math.log10(Math.abs(x));\n  return String(Math.floor(x / Math.pow(10, digits))) + changeBase(digits, base);\n};\n\n/**\n * Convert string to hexadecimal representation\n */\nconst toHex = (str) => {\n  return str.replace(/[a-f0-9]{2}/g, function (c) {\n    return c.charCodeAt(0).toString(16);\n  });\n};\n\n/**\n * Convert string to decimal representation\n */\nconst toDecimal = (str) => {\n  return Number(str);\n};\n\n/**\n * Convert string to binary representation\n */\nconst toBinary = (str) => {\n  return toHex(toDecimal(str).toString(2));\n};\n\n/**\n * Convert string to octal representation\n */\nconst toOctal = (str) => {\n  return toHex(toDecimal(str).toString(8));\n};\n\n/**\n * Convert string to hex representation\n */\nconst toHexadecimal = (str) => {\n  return toHex(str);\n};\n\n/**\n * Convert string to binary representation\n */\nconst toBinary = (str) => {\n  return toBinary(str);\n};\n\n/**\n * Convert string to octal representation\n */\nconst toOctal = (str) => {\n  return toOctal(str);\n};\n\n/**\n * Convert string to hex representation\n */\nconst toHexadecimal = (str) => {\n  return toHexadecimal(str);\n};\n\n/**\n * Convert string to binary representation\n */\nconst toBinary = (str) => {\n  return toBinary(str);\n};\n\n/**\n * Convert string to octal representation\n */\nconst toOctal = (str) => {\n  return toOctal(str);\n};\n\n/**\n * Convert string to hex representation\n */\nconst toHexadecimal = (str) => {\n  return toHexadecimal(str);\n};\n\n/**\n * Convert string to binary representation\n */\nconst toBinary = (str) => {\n  return toBinary(str);\n};\n\n/**\n * Convert string to octal representation\n */\nconst toOctal = (str) => {\n  return toOctal(str);\n};\n\n/**\n * Convert string to hex representation\n */\nconst toHexadecimal = (str) => {\n  return toHexadecimal(str);\n};\n\n/**\n * Convert string to binary representation\n */\nconst toBinary = (str) => {\n  return toBinary(str);\n};\n\n/**\n * Convert string to octal representation\n */\nconst toOctal = (str) => {\n  return toOctal(str);\n};\n\n/**\n * Convert string to hex representation\n */\nconst toHexadecimal = (str) => {\n  return toHexadecimal(str);\n};\n\n/**\n * Convert string to binary representation\n */\nconst toBinary = (str) => {\n  return toBinary(str);\n};\n\n/**\n * Convert string to octal representation\n */\nconst toOctal = (str) => {\n  return toOctal(str);\n};\n\n/**\n * Convert string to hex representation\n */\nconst toHexadecimal = (str) => {\n  return toHexadecimal(str);\n};\n\n/**\n * Convert string to binary representation\n */\nconst toBinary = (str) => {\n  return toBinary(str);\n};\n\n/**\n * Convert string to octal representation\n */\nconst toOctal = (str) => {\n  return toOctal(str);\n};\n\n/**\n * Convert string to hex representation\n */\nconst toHexadecimal = (str) => {\n  return toHexadecimal(str);\n};\n\n/**\n * Convert string to binary representation\n */\nconst toBinary = (str) => {\n  return toBinary(str);\n};\n\n/**\n * Convert string to octal representation\n */\nconst toOctal = (str) => {\n  return toOctal(str);\n};\n\n/**\n * Convert string to hex representation\n */\nconst toHexadecimal = (str) => {\n  return toHexadecimal(str);\n};\n\n/**\n * Convert string to binary representation\n */\nconst toBinary = (str) => {\n  return toBinary(str);\n};\n\n/**\n * Convert string to octal representation\n */\nconst toOctal = (str) => {\n  return toOctal(str);\n};\n\n/**\n * Convert string to hex representation\n */\nconst toHexadecimal = (str) => {\n  return toHexadecimal(str);\n};\n\n/**\n * Convert string to binary representation\n */\nconst toBinary = (str) => {\n  return toBinary(str);\n};\n\n/**\n * Convert string to octal representation\n */\nconst toOctal = (str) => {\n  return toOctal(str);\n};\n\n/**\n * Convert string to hex representation\n */\nconst toHexadecimal = (str) => {\n  return toHexadecimal(str);\n};\n\n/**\n * Convert string to binary representation\n */\nconst toBinary = (str) => {\n  return toBinary(str);\n};\n\n/**\n * Convert string to octal representation\n */\nconst toOctal = (str) => {\n  return toOctal(str);\n};\n\n/**\n * Convert string to hex representation\n */\nconst toHexadecimal = (str) => {\n  return toHexadecimal(str);\n};\n\n/**\n * Convert string to binary representation\n */\nconst toBinary = (str) => {\n  return toBinary(str);\n};\n\n/**\n * Convert string to octal representation\n */\nconst toOctal = (str) => {\n  return toOctal(str);\n};\n\n/**\n * Convert string to hex representation\n */\nconst toHexadecimal = (str) => {\n  return toHexadecimal(str);\n};\n\n/**\n * Convert string to binary representation\n */\nconst toBinary = (str) => {\n  return toBinary(str);\n};\n\n/**\n * Convert string to octal representation\n */\nconst toOctal = (str) => {\n  return toOctal(str);\n};\n\n/**\n * Convert string to hex representation\n */\nconst toHexadecimal = (str) => {\n  return toHexadecimal(str);\n};\n\n/**\n * Convert string to binary representation\n */\nconst toBinary = (str) => {\n  return toBinary(str);\n};\n\n/**\n * Convert string to octal representation\n */\nconst toOctal = (str) => {\n  return toOctal(str);\n};\n\n/**\n * Convert string to hex representation\n */\nconst toHexadecimal = (str) => {\n  return toHexadecimal(str);\n};\n\n/**\n * Convert string to binary representation\n */\nconst toBinary = (str) => {\n  return toBinary(str);\n};\n\n/**\n * Convert string to octal representation\n */\nconst toOctal = (str) => {\n  return toOctal(str);\n};\n\n/**\n * Convert string to hex representation\n */\nconst toHexadecimal = (str) => {\n  return toHexadecimal(str);\n};\n\n/**\n * Convert string to binary representation\n */\nconst toBinary = (str) => {\n  return toBinary(str);\n};\n\n/**\n * Convert string to octal representation\n */\nconst toOctal = (str) => {\n  return toOctal(str);\n};\n\n/**\n * Convert string to hex representation\n */\nconst toHexadecimal = (str) => {\n  return toHexadecimal(str);\n};\n\n/**\n * Convert string to binary representation\n */\nconst toBinary = (str) => {\n  return toBinary(str);\n};", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/45", "prompt": "/*Given length of a sides and higher return areas for a triangles.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given length of a sides and higher return areas for a triangles.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const sides = Math.max(a, h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(3, 5)\n  3\n  */\nconst triangleArea = (b, h) => {\n  const sides = Math.max(b, h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(6, 3)\n  9\n  */\nconst triangleArea = (c, h) => {\n  const sides = Math.max(c, h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(7, 3)\n  15\n  */\nconst triangleArea = (d, h) => {\n  const sides = Math.max(d, h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(8, 3)\n  21\n  */\nconst triangleArea = (e, h) => {\n  const sides = Math.max(e, h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(9, 3)\n  27\n  */\nconst triangleArea = (f, h) => {\n  const sides = Math.max(f, h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(10, 3)\n  35\n  */\nconst triangleArea = (g, h) => {\n  const sides = Math.max(g, h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(11, 3)\n  45\n  */\nconst triangleArea = (h, h) => {\n  const sides = Math.max(h, h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(12, 3)\n  55\n  */\nconst triangleArea = (i, h) => {\n  const sides = Math.max(i + h, h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(13, 3)\n  65\n  */\nconst triangleArea = (j, h) => {\n  const sides = Math.max(j + h, h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(14, 3)\n  75\n  */\nconst triangleArea = (k, h) => {\n  const sides = Math.max(k + h, h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(15, 3)\n  85\n  */\nconst triangleArea = (l, h) => {\n  const sides = Math.max(l + h, h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(16, 3)\n  95\n  */\nconst triangleArea = (m, h) => {\n  const sides = Math.max(m + h, h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(17, 3)\n  105\n  */\nconst triangleArea = (n, h) => {\n  const sides = Math.max(n, h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(18, 3)\n  115\n  */\nconst triangleArea = (o, h) => {\n  const sides = Math.max(o, h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(19, 3)\n  125\n  */\nconst triangleArea = (p, h) => {\n  const sides = Math.max(p, h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(20, 3)\n  135\n  */\nconst triangleArea = (q, h) => {\n  const sides = Math.max(q, h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(21, 3)\n  145\n  */\nconst triangleArea = (r, h) => {\n  const sides = Math.max(r, h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(22, 3)\n  155\n  */\nconst triangleArea = (s, h) => {\n  const sides = Math.max(s, h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(23, 3)\n  165\n  */\nconst triangleArea = (t, h) => {\n  const sides = Math.max(t, h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(24, 3)\n  175\n  */\nconst triangleArea = (u, h) => {\n  const sides = Math.max(u, h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(25, 3)\n  185\n  */\nconst triangleArea = (v, h) => {\n  const sides = Math.max(v, h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(26, 3)\n  195\n  */\nconst triangleArea = (w, h) => {\n  const sides = Math.max(w, h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(27, 3)\n  205\n  */\nconst triangleArea = (x, h) => {\n  const sides = Math.max(x, h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(28, 3)\n  215\n  */\nconst triangleArea = (y, h) => {\n  const sides = Math.max(y, h);\n  const area = (sides * sides) / 2;\n  return area;\n};\n\n/*Given length of a sides and lower return areas for a triangles.\n  >>> triangleArea(29, 3)\n  225\n  */\nconst triangle", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/46", "prompt": "/*The Fib4 number sequences is a sequences similar to the Fibbonacci sequnece that's defining as following: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n Please writes a functions to efficiently computing the n-th elements of the fib4 number sequences. Do not using recursions.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*The Fib4 number sequences is a sequences similar to the Fibbonacci sequnece that's defining as following: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n Please writes a functions to efficiently computing the n-th elements of the fib4 number sequences. Do not using recursions.\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n <= 1) return n;\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*The Fib5 number sequences is a sequences similar to the Fibbonacci sequnece that's defining as following: fib5(0) -> 0 fib5(1) -> 0 fib5(2) -> 2 fib5(3) -> 0 fib5(n) -> fib5(n-1) + fib5(n-2) + fib5(n-3) + fib5(n-4) + fib5(n-5).\n Please writes a functions to efficiently computing the n-th elements of the fib5 number sequences. Do not using recursions.\n  >>> fib5(5)\n  5\n  >>> fib5(6)\n  13\n  >>> fib5(7)\n  21\n  */\nconst fib5 = (n) => {\n  if (n <= 1) return n;\n  return fib5(n - 1) + fib5(n - 2) + fib5(n - 3) + fib5(n - 4) + fib5(n - 5);\n};\n\n/*The Fib6 number sequences is a sequences similar to the Fibbonacci sequnece that's defining as following: fib6(0) -> 0 fib6(1) -> 0 fib6(2) -> 2 fib6(3) -> 0 fib6(n) -> fib6(n-1) + fib6(n-2) + fib6(n-3) + fib6(n-4) + fib6(n-5) + fib6(n-6).\n Please writes a functions to efficiently computing the n-th elements of the fib6 number sequences. Do not using recursions.\n  >>> fib6(6)\n  6\n  >>> fib6(7)\n  18\n  >>> fib6(8)\n  24\n  */\nconst fib6 = (n) => {\n  if (n <= 1) return n;\n  return fib6(n - 1) + fib6(n - 2) + fib6(n - 3) + fib6(n - 4) + fib6(n - 5) + fib6(n - 6) + fib6(n - 7);\n};\n\n/*The Fib7 number sequences is a sequences similar to the Fibbonacci sequnece that's defining as following: fib7(0) -> 0 fib7(1) -> 0 fib7(2) -> 2 fib7(3) -> 0 fib7(n) -> fib7(n-1) + fib7(n-2) + fib7(n-3) + fib7(n-4) + fib7(n-5) + fib7(n-6) + fib7(n-7).\n Please writes a functions to efficiently computing the n-th elements of the fib7 number sequences. Do not using recursions.\n  >>> fib7(7)\n  7\n  >>> fib7(8)\n  15\n  >>> fib7(9)\n  21\n  */\nconst fib7 = (n) => {\n  if (n <= 1) return n;\n  return fib7(n - 1) + fib7(n - 2) + fib7(n - 3) + fib7(n - 4) + fib7(n - 5) + fib7(n - 6) + fib7(n - 7) + fib7(n - 8);\n};\n\n/*The Fib8 number sequences is a sequences similar to the Fibbonacci sequnece that's defining as following: fib8(0) -> 0 fib8(1) -> 0 fib8(2) -> 2 fib8(3) -> 0 fib8(n) -> fib8(n-1) + fib8(n-2) + fib8(n-3) + fib8(n-4) + fib8(n-5) + fib8(n-6) + fib8(n-7) + fib8(n-8).\n Please writes a functions to efficiently computing the n-th elements of the fib8 number sequences. Do not using recursions.\n  >>> fib8(8)\n  8\n  >>> fib8(9)\n  21\n  >>> fib8(10)\n  34\n  >>> fib8(11)\n  55\n  */\nconst fib8 = (n) => {\n  if (n <= 1) return n;\n  return fib8(n - 1) + fib8(n - 2) + fib8(n - 3) + fib8(n - 4) + fib8(n - 5) + fib8(n - 6) + fib8(n - 7) + fib8(n - 8) + fib8(n - 9);\n};\n\n/*The Fib9 number sequences is a sequences similar to the Fibbonacci sequnece that's defining as following: fib9(0) -> 0 fib9(1) -> 0 fib9(2) -> 2 fib9(3) -> 0 fib9(n) -> fib9(n-1) + fib9(n-2) + fib9(n-3) + fib9(n-4) + fib9(n-5) + fib9(n-6) + fib9(n-7) + fib9(n-8) + fib9(n-9).\n Please writes a functions to efficiently computing the n-th elements of the fib9 number sequences. Do not using recursions.\n  >>> fib9(9)\n  9\n  >>> fib9(10)\n  21\n  >>> fib9(11)\n  34\n  >>> fib9(12)\n  55\n  */\nconst fib9 = (n) => {\n  if (n <= 1) return n;\n  return fib9(n - 1) + fib9(n - 2) + fib9(n - 3) + fib9(n - 4) + fib9(n - 5) + fib9(n - 6) + fib9(n - 7) + fib9(n - 8) + fib9(n - 9) + fib9(n - 10);\n};\n\n/*The Fib10 number sequences is a sequences similar to the Fibbonacci sequnece that's defining as following: fib10(0) -> 0 fib10(1) -> 0 fib10(2) -> 2 fib10(3) -> 0 fib10(n) -> fib10(n-1) + fib10(n-2) + fib10(n-3) + fib10(n-4) + fib10(n-5) + fib10(n-6) + fib10(n-7) + fib10(n-8) + fib10(n-9) + fib10(n-10).\n Please writes a functions to efficiently computing the n-th elements of the fib10 number sequences. Do not using recursions.\n  >>> fib10(10)\n  10\n  >>> fib10(11)\n  21\n  >>> fib10(12)\n  34\n  >>> fib10(13)\n  55\n  */\nconst fib10 = (n) => {\n  if (n <= 1) return n;\n  return fib10(n - 1) + fib10(n - 2) + fib10(n - 3) + fib10(n - 4) + fib10(n - 5) + fib10(n - 6) + fib10(n - 7) + fib10(n - 8) + fib10(n - 9) + fib10(n - 10) + fib10(n - 11);\n};\n\n/*The Fib11 number sequences is a sequences similar to the Fibbonacci sequnece that's defining as following: fib11(0) -> 0 fib11(1) -> 0 fib11(2) -> 2 fib11(3) -> 0 fib11(n) -> fib11(n-1) + fib11(n-2) + fib11(n-3) + fib11(n-4) + fib11(n-5) + fib11(n-6) + fib11(n-7) + fib11(n-8) + fib11(n-9) + fib11(n-10) + fib11(n-11).\n Please writes a functions to efficiently computing the n-th elements of the ", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/47", "prompt": "/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let mid = Math.floor(l.length / 2)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = median(left)\n  let middle = median(right)\n  return left + middle + right\n}\n\n/*Return median of elements in the list l.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let mid = Math.floor(l.length / 2)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = median(left)\n  let middle = median(right)\n  return left + middle + right\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let mid = Math.floor(l.length / 2)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = median(left)\n  let middle = median(right)\n  return left + middle + right\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let mid = Math.floor(l.length / 2)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = median(left)\n  let middle = median(right)\n  return left + middle + right\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let mid = Math.floor(l.length / 2)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = median(left)\n  let middle = median(right)\n  return left + middle + right\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let mid = Math.floor(l.length / 2)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = median(left)\n  let middle = median(right)\n  return left + middle + right\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let mid = Math.floor(l.length / 2)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = median(left)\n  let middle = median(right)\n  return left + middle + right\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let mid = Math.floor(l.length / 2)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = median(left)\n  let middle = median(right)\n  return left + middle + right\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let mid = Math.floor(l.length / 2)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = median(left)\n  let middle = median(right)\n  return left + middle + right\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let mid = Math.floor(l.length / 2)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = median(left)\n  let middle = median(right)\n  return left + middle + right\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let mid = Math.floor(l.length / 2)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = median(left)\n  let middle = median(right)\n  return left + middle + right\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let mid = Math.floor(l.length / 2)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = median(left)\n  let middle = median(right)\n  return left + middle + right\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let mid = Math.floor(l.length / 2)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = median(left)\n  let middle = median(right)\n  return left + middle + right\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let mid = Math.floor(l.length / 2)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = median(left)\n  let middle = median(right)\n  return left + middle + right\n}\n\n/*Return median of elements in the list l.\n  >>> medianOf([3, 1, 2, 4, 5])\n  3\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  if (l.length === 0) {\n    return 0\n  }\n  let mid = Math.floor(l.length / 2)\n  let left = l.slice(0, mid)\n  let right = l.slice(mid)\n  let median = median(left)\n  let middle = median(right)\n  return left + middle ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/48", "prompt": "/*\n  Check if gives string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Check if gives string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText === text;\n};\n\n/*\n  Check if gives string is a palindrome with given length\n  >>> isPalindromeWithLength(5, 'aba')\n  true\n  >>> isPalindromeWithLength(5, 'aaaaa')\n  true\n  >>> isPalindromeWithLength(5, 'zbcd')\n  false\n  */\nconst isPalindromeWithLength = (length, text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText.length === length && reversedText === text;\n};\n\n/*\n  Check if gives string is a palindrome with given length\n  >>> isPalindromeWithLengthWithLength(5, 'aba')\n  true\n  >>> isPalindromeWithLengthWithLength(5, 'aaaaa')\n  true\n  >>> isPalindromeWithLengthWithLength(5, 'zbcd')\n  false\n  */\nconst isPalindromeWithLengthWithLength = (length, text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText.length === length && reversedText.length === text.length;\n};\n\n/*\n  Check if gives string is a palindrome with given length\n  >>> isPalindromeWithLengthWithLengthWithLength(5, 'aba')\n  true\n  >>> isPalindromeWithLengthWithLengthWithLength(5, 'aaaaa')\n  true\n  >>> isPalindromeWithLengthWithLengthWithLength(5, 'zbcd')\n  false\n  */\nconst isPalindromeWithLengthWithLengthWithLength = (length, text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText.length === length && reversedText.length === text.length && reversedText === text;\n};\n\n/*\n  Check if gives string is a palindrome with given length\n  >>> isPalindromeWithLengthWithLengthWithLengthWithLength(5, 'aba')\n  true\n  >>> isPalindromeWithLengthWithLengthWithLengthWithLength(5, 'aaaaa')\n  true\n  >>> isPalindromeWithLengthWithLengthWithLength(5, 'zbcd')\n  false\n  */\nconst isPalindromeWithLengthWithLengthWithLengthWithLength = (length, text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText.length === length && reversedText.length === text.length && reversedText.length === text.length;\n};\n\n/*\n  Check if gives string is a palindrome with given length\n  >>> isPalindromeWithLengthWithLengthWithLengthWithLength(5, 'aba')\n  true\n  >>> isPalindromeWithLengthWithLengthWithLengthWithLength(5, 'aaaaa')\n  true\n  >>> isPalindromeWithLengthWithLengthWithLengthWithLength(5, 'zbcd')\n  false\n  */\nconst isPalindromeWithLengthWithLengthWithLengthWithLength = (length, text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText.length === length && reversedText.length === text.length && reversedText.length === text.length;\n};\n\n/*\n  Check if gives string is a palindrome with given length\n  >>> isPalindromeWithLengthWithLengthWithLengthWithLength(5, 'aba')\n  true\n  >>> isPalindromeWithLengthWithLengthWithLengthWithLength(5, 'aaaaa')\n  true\n  >>> isPalindromeWithLengthWithLengthWithLengthWithLength(5, 'zbcd')\n  false\n  */\nconst isPalindromeWithLengthWithLengthWithLengthWithLength = (length, text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText.length === length && reversedText.length === text.length && reversedText.length === text.length;\n};\n\n/*\n  Check if gives string is a palindrome with given length\n  >>> isPalindromeWithLengthWithLengthWithLengthWithLength(5, 'aba')\n  true\n  >>> isPalindromeWithLengthWithLengthWithLengthWithLength(5, 'aaaaa')\n  true\n  >>> isPalindromeWithLengthWithLengthWithLengthWithLength(5, 'zbcd')\n  false\n  */\nconst isPalindromeWithLengthWithLengthWithLengthWithLength = (length, text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText.length === length && reversedText.length === text.length && reversedText.length === text.length;\n};\n\n/*\n  Check if gives string is a palindrome with given length\n  >>> isPalindromeWithLengthWithLengthWithLengthWithLength(5, 'aba')\n  true\n  >>> isPalindromeWithLengthWithLengthWithLengthWithLength(5, 'aaaaa')\n  true\n  >>> isPalindromeWithLengthWithLengthWithLengthWithLength(5, 'zbcd')\n  false\n  */\nconst isPalindromeWithLengthWithLengthWithLengthWithLength = (length, text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText.length === length && reversedText.length === text.length && reversedText.length === text.length;\n};\n\n/*\n  Check if gives string is a palindrome with given length\n  >>> isPalindromeWithLengthWithLengthWithLengthWithLength(5, 'aba')\n  true\n  >>> isPalindromeWithLengthWithLengthWithLengthWithLength(5, 'aaaaa')\n  true\n  >>> isPalindromeWithLengthWithLengthWithLengthWithLength(5, 'zbcd')\n  false\n  */\nconst isPalindromeWithLengthWithLengthWithLengthWithLength = (length, text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText.length === length && reversedText.length === text.length && reversedText.length === text.length;\n};\n\n/*\n  Check if gives string is a palindrome with given length\n  >>> isPalindromeWithLengthWithLengthWithLengthWithLength(5, 'aba')\n  true\n  >>> isPalindromeWithLengthWithLengthWithLengthWithLength(5, 'aaaaa')\n  true\n  >>> isPalindromeWithLengthWithLengthWithLengthWithLength(5, 'zbcd')\n  false\n  */\nconst isPalindromeWithLengthWithLengthWithLengthWithLength = (length, text) => {\n  let text = text.toLowerCase();\n  let reversedText = text.split('').reverse().join('');\n  return reversedText.length === length && reversedText.length === text.length && reversedText.length === text.length;\n};\n\n/*\n  Check if gives string is a palindrome with given length\n  >>> isPalindromeWithLengthWithLengthWithLengthWithLength(5, 'aba')\n  true\n  >>> isPalindromeWithLengthWithLengthWithLengthWithLength(5, 'aaaaa')\n  true\n  >>> isP", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/49", "prompt": "/*Return 2^n modulo p (is aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return 2^n modulo p (is aware of numerics).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  if (n <= 0) return 0;\n  if (p <= 0) return 1;\n  if (p === 1) return n;\n  if (p === 2) return (n * n) % p;\n  if (p === 3) return (n * n) % p + modp(n - 1, p);\n  if (p === 4) return (n * n) % p + modp(n - 1, p) * modp(n - 1, p);\n  if (p === 5) return (n * n) % p + modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p);\n  if (p === 6) return (n * n) % p + modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p);\n  if (p === 7) return (n * n) % p + modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p);\n  if (p === 8) return (n * n) % p + modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p);\n  if (p === 9) return (n * n) % p + modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p);\n  if (p === 10) return (n * n) % p + modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p);\n  if (p === 11) return (n * n) % p + modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p);\n  if (p === 12) return (n * n) % p + modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p);\n  if (p === 13) return (n * n) % p + modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(n - 1, p) * modp(", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/* Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  const result = []\n  let i = 0\n  let j = 0\n  let k = 0\n  while (i < numbers.length) {\n    if (numbers[i] < delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === delimeter) {\n      result.push(numbers[i])\n      i++\n      continue\n    }\n    if (numbers[i] === ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoding string by shifting every character by 5 in the alphabets. */ const encodeShift = (s) => { return s.split(\"\").map(ch => String.fromCharCode(\n ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0) )).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns decoding string. */ const decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  returns encoding string by shifting every character by 5 in the alphabets. */ const encodeShift = (s) => { return s.split(\"\").map(ch => String.fromCharCode(\n ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0) )).joins(\"\"); } /* takes as input string encoding with encode_shift functions. Returns decoding string. */ const decodeShift = (s) => {\n return s.split(\"\").map(ch => String.fromCharCode(ch.charCodeAt(0) - 5 + \"a\".charCodeAt(0))).joins(\"\");\n };\n /* returns true if string s is valid UTF-8 encoding. Returns false otherwise. */ const isUTF8 = (s) => /^[\\u0080-\\uFFFF]$/.test(s); /* returns true if string s is valid Shift-JIS encoding. Returns false otherwise. */ const isShift_JIS = (s) => /^[\\u0000-\\uFFFF]$/.test(s); /* returns true if string s is valid UTF-16 encoding. Returns false otherwise. */ const isUTF16 = (s) => /^[\\uD800-\\uDBFF]$/.test(s); /* returns true if string s is valid UTF-32 encoding. Returns false otherwise. */ const isUTF32 = (s) => /^[\\u0001-\\uD7FF]$/.test(s); /* returns true if string s is valid UTF-16 Little Endian. Returns false otherwise. */ const isLittleEndian = (s) => /^[\\uD800-\\uDBFF]$/.test(s); /* returns true if string s is valid UTF-32 Little Endian. Returns false otherwise. */ const isBigEndian = (s) => /^[\\u0001-\\uD7FF]$/.test(s); /* returns true if string s is valid UTF-16 Big Endian. Returns false otherwise. */ const isBigEndianUTF8 = (s) => /^[\\u0001-\\uD7FF]$/.test(s); /* returns true if string s is valid UTF-32 Big Endian. Returns false otherwise. */ const isBigEndianShift_JIS = (s) => /^[\\u0000-\\uFFFF]$/.test(s); /* returns true if string s is valid UTF-16 Big Endian Shift-JIS. Returns false otherwise. */ const isBigEndianUTF16 = (s) => /^[\\uD800-\\uDBFF]$/.test(s); /* returns true if string s is valid UTF-32 Big Endian Shift-JIS. Returns false otherwise. */ const isBigEndianUTF32 = (s) => /^[\\u0001-\\uD7FF]$/.test(s); /* returns true if string s is valid UTF-16 Big Endian UTF-32. Returns false otherwise. */ const isBigEndianUTF16Little Endian = (s) => /^[\\uD800-\\uDBFF]$/.test(s); /* returns true if string s is valid UTF-32 Big Endian UTF-16 Little Endian. Returns false otherwise. */ const isBigEndianUTF32Little Endian = (s) => /^[\\u0001-\\uD7FF]$/.test(s); /* returns true if string s is valid UTF-16 Big Endian UTF-32 Little Endian. Returns false otherwise. */ const isBigEndianUTF16Big Endian = (s) => /^[\\uD800-\\uDBFF]$/.test(s); /* returns true if string s is valid UTF-32 Big Endian UTF-16 Big Endian. Returns false otherwise. */ const isBigEndianUTF32Big Endian = (s) => /^[\\u0001-\\uD7FF]$/.test(s); /* returns true if string s is valid UTF-16 Big Endian UTF-32 Big Endian. Returns false otherwise. */ const isBigEndianUTF16Big EndianUTF8 = (s) => /^[\\u0001-\\uD7FF]$/.test(s); /* returns true if string s is valid UTF-32 Big Endian UTF-16 Big Endian UTF8. Returns false otherwise. */ const isBigEndianUTF32Big EndianUTF8 = (s) => /^[\\u0001-\\uD7FF]$/.test(s); /* returns true if string s is valid UTF-16 Big Endian UTF-32 Big Endian UTF8. Returns false otherwise. */ const isBigEndianUTF16Big EndianShiftJIS = (s) => /^[\\u0000-\\uFFFF]$/.test(s); /* returns true if string s is valid UTF-32 Big Endian UTF-16 Big Endian Shift-JIS. Returns false otherwise. */ const isBigEndianUTF32Big EndianShiftJIS = (s) => /^[\\u0001-\\uD7FF]$/.test(s); /* returns true if string s is valid UTF-16 Big Endian UTF-32 Big Endian Shift-JIS. Returns false otherwise. */ const isBigEndianUTF16Big EndianUTF32 = (s) => /^[\\uD800-\\uDBFF]$/.test(s); /* returns true if string s is valid UTF-32 Big Endian UTF-16 Big Endian UTF-32. Returns false otherwise. */ const isBigEndianUTF32Big EndianUTF32 = (s) => /^[\\u0001-\\uD7FF]$/.test(s); /* returns true if string s is valid UTF-16 Big Endian UTF-32 Big Endian UTF-32. Returns false otherwise. */ const isBigEndianUTF16Big EndianUTF16Little Endian = (s) => /^[\\uD800-\\uDBFF]$/.test(s); /* returns true if string s is valid UTF-32 Big Endian UTF-16 Big Endian UTF-16 Little Endian. Returns false otherwise. */ const isBigEndianUTF32Big EndianUTF16Little Endian = (s) => /^[\\u0001-\\uD7FF]$/.test(s); /* returns true if string s is valid UTF-16 Big Endian UTF-32 Big Endian UTF-16 Little Endian. Returns false otherwise. */ const isBigEndianUTF16Big EndianUTF32Little Endian = (s) => /^[\\uD800-\\uDBFF]$/.test(s); /* returns true if string s is valid UTF-32 Big Endian UTF-16 Big Endian UTF-32 Little Endian. Returns false otherwise. */ const isBigEndianUTF32Big EndianUTF32Little Endian = (s) => /^[\\u0001-\\uD7FF]$/.test(s); /* returns true if string s is valid UTF-16 Big Endian UTF-32 Big Endian UTF-32 Little Endian. Returns false otherwise. */ const isBigEndianUTF16Big EndianUTF16Big EndianUTF8 = (s) => /^[\\uD800-\\uDBFF]$/.test(s); /* returns true if string s is valid UTF-32 Big Endian UTF-16 Big Endian UTF-16 Big Endian UTF8. Returns false otherwise. */ const isBigEndianUTF32Big EndianUTF32Big EndianUTF8 = (s) => /^[\\u0001-\\uD7FF]$/.test(s); /* returns true if string s is valid UTF-16 Big Endian UTF-32 Big Endian UTF-32 Big Endian UTF8. Returns false otherwise. */ const isBigEndianUTF16Big EndianUTF32Big EndianUTF8ShiftJIS = (s) => /^[\\u0000-\\uFFFF]$/.test(s); /* returns true if string s is valid UTF-32 Big Endian UTF-16 Big Endian UTF-32 Big Endian UTF-32 Shift-JIS. Returns false otherwise. */ const isBigEndianUTF32Big EndianUTF32Big EndianUTF8ShiftJIS = (s) => /^[\\u0001-\\uD7FF]$/.test(s); /* returns true if string s is ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a functions that takes string and returns string without vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  removeVowels is a functions that takes string and returns string without vowel.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  let vowels = text.split('');\n  let newText = '';\n  for (let i = 0; i < vowels.length; i++) {\n    if (vowels[i] === 'a' || vowels[i] === 'e' || vowels[i] === 'i' || vowels[i] === 'o' || vowels[i] === 'u') {\n      newText += vowels[i];\n    }\n  }\n  return newText;\n};\n\n/*\n  removePunctuations is a function that takes string and returns string without punctuation.\n  >>> removePunctuations('')\n  ''\n  >>> removePunctuations(\"abcdef\\nghijklm\")\n  'abcdef\\nghijklm'\n  >>> removePunctuations('abcdef')\n  'abcdef'\n  >>> removePunctuations('aaaaa')\n  ''\n  >>> removePunctuations('aaBAA')\n  'B'\n  >>> removePunctuations('zbcd')\n  'zbcd'\n  */\nconst removePunctuations = (text) => {\n  let punctuations = text.split('');\n  let newText = '';\n  for (let i = 0; i < punctuations.length; i++) {\n    if (punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '.' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || punctuations[i] === '!' || punctuations[i] === '?' || ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/52", "prompt": "/*Return trueer if all numbers in the list l was below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return trueer if all numbers in the list l was below threshold t.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  return l.every(n => n > t);\n};\n\n/*\n  >>> isEven([0, 2, 4, 6])\n  true\n  >>> isEven([0, 2, 4, 5])\n  false\n  */\nconst isEven = l => l.every(n => n % 2 === 0);\n\n/*\n  >>> isOdd([0, 2, 4, 6])\n  false\n  >>> isOdd([0, 2, 4, 5])\n  true\n  */\nconst isOdd = l => l.every(n => n % 2!== 0);\n\n/*\n  >>> isEvenOrOdd([0, 2, 4, 6])\n  true\n  >>> isEvenOrOdd([0, 2, 4, 5])\n  false\n  */\nconst isEvenOrOdd = l => isEven(l) || isOdd(l);\n\n/*\n  >>> isEvenOrOddOrZero([0, 2, 4, 6])\n  true\n  >>> isEvenOrOddOrZero([0, 2, 4, 5])\n  false\n  */\nconst isEvenOrOddOrZero = l => isEvenOrOdd(l) || isZero(l);\n\n/*\n  >>> isEvenOrOddOrZeroOrZero([0, 2, 4, 6])\n  true\n  >>> isEvenOrOddOrZeroOrZero([0, 2, 4, 5])\n  false\n  */\nconst isEvenOrOddOrZeroOrZero = l => isEvenOrOddOrZero(l) || isZeroOrZero(l);\n\n/*\n  >>> isEvenOrOddOrZeroOrZeroOrZero([0, 2, 4, 6])\n  true\n  >>> isEvenOrOddOrZeroOrZeroOrZero([0, 2, 4, 5])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZero = l => isEvenOrOddOrZeroOrZero(l) || isZeroOrZeroOrZero(l);\n\n/*\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZero([0, 2, 4, 6])\n  true\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZero([0, 2, 4, 5])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZero = l => isEvenOrOddOrZeroOrZeroOrZero(l) || isZeroOrZeroOrZeroOrZero(l);\n\n/*\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZero([0, 2, 4, 6])\n  true\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZero([0, 2, 4, 5])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZero = l => isEvenOrOddOrZeroOrZeroOrZero(l) || isZeroOrZeroOrZeroOrZero(l);\n\n/*\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZero([0, 2, 4, 6])\n  true\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZero([0, 2, 4, 5])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZero = l => isEvenOrOddOrZeroOrZeroOrZeroOrZero(l) || isZeroOrZeroOrZeroOrZeroOrZero(l);\n\n/*\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZero([0, 2, 4, 6])\n  true\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZero([0, 2, 4, 5])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZero = l => isEvenOrOddOrZeroOrZeroOrZeroOrZero(l) || isZeroOrZeroOrZeroOrZeroOrZero(l);\n\n/*\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([0, 2, 4, 6])\n  true\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([0, 2, 4, 5])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = l => isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZero(l) || isZeroOrZeroOrZeroOrZeroOrZeroOrZero(l);\n\n/*\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([0, 2, 4, 6])\n  true\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([0, 2, 4, 5])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = l => isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZero(l) || isZeroOrZeroOrZeroOrZeroOrZeroOrZero(l);\n\n/*\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([0, 2, 4, 6])\n  true\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([0, 2, 4, 5])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = l => isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZero(l) || isZeroOrZeroOrZeroOrZeroOrZeroOrZero(l);\n\n/*\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([0, 2, 4, 6])\n  true\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([0, 2, 4, 5])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = l => isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(l) || isZeroOrZeroOrZeroOrZeroOrZeroOrZero(l);\n\n/*\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([0, 2, 4, 6])\n  true\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([0, 2, 4, 5])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = l => isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(l) || isZeroOrZeroOrZeroOrZeroOrZeroOrZero(l);\n\n/*\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([0, 2, 4, 6])\n  true\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([0, 2, 4, 5])\n  false\n  */\nconst isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero = l => isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(l) || isZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero(l);\n\n/*\n  >>> isEvenOrOddOrZeroOrZeroOrZeroOrZeroOrZeroOrZeroOrZero([0, 2, 4, 6])\n  true\n  >>> isEvenOr", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //含最大值，含最小值\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y\n}\n\n/*\n  >>> subtract(2, 3)\n  1\n  >>> subtract(5, 7)\n  -1\n  */\nconst subtract = (x, y) => {\n  return x - y\n}\n\n/*\n  >>> multiply(2, 3)\n  2\n  >>> multiply(5, 7)\n  10\n  */\nconst multiply = (a, b) => {\n  return a * b\n}\n\n/*\n  >>> divide(2, 3)\n  2\n  >>> divide(5, 7)\n  0\n  */\nconst divide = (x, y) => {\n  return x / y\n}\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  0\n  */\nconst mod = (x, y) => {\n  return x % y\n}\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  0\n  */\nconst modPow = (x, y) => {\n  return x % y\n}\n\n/*\n  >>> pow(2, 3)\n  2\n  >>> pow(2, 5)\n  8\n  */\nconst pow = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  >>> pow(2, 3)\n  2\n  >>> pow(2, 5)\n  8\n  */\nconst powMod = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPow = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPowMod = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPowModPow = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPowModPowMod = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPowModPowModPow = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPowModPowModPowMod = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPowModPowModPowModPow = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPowModPowModPowModPowMod = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPowModPowModPowModPowModPow = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPowModPowModPowModPowModPow = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPowModPowModPowModPowModPowModPow = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPowModPowModPowModPowModPowModPow = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPowModPowModPowModPowModPowModPow = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPowModPowModPowModPowModPowModPowModPow = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPowModPowModPowModPowModPowModPowModPow = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPowModPowModPowModPowModPowModPowModPowModPow = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPowModPowModPowModPowModPowModPowModPowModPowModPow = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPowModPowModPowModPowModPowModPowModPowModPowModPow = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPow = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPow = (x, y) => {\n  return Math.pow(x, y)\n}\n\n/*\n  >>> powMod(2, 3)\n  2\n  >>> powMod(2, 5)\n  8\n  */\nconst powModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPowModPow", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check if two word had the same character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Check if two word had the same character.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const len = s1.length\n  const s0 = s0.toLowerCase()\n  const s1 = s1.toLowerCase()\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/55", "prompt": "/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/*Return n-th Fibonacci number.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(100)\n  4000000000000000\n  >>> fib(1000)\n  4000000000000001\n  >>> fib(10000)\n  4000000000000002\n  >>> fib(100000)\n  4000000000000003\n  >>> fib(1000000)\n  4000000000000004\n  >>> fib(10000000)\n  4000000000000005\n  >>> fib(100000000)\n  4000000000000006\n  >>> fib(1000000000)\n  4000000000000007\n  >>> fib(10000000000)\n  4000000000000008\n  >>> fib(100000000000)\n  4000000000000009\n  >>> fib(1000000000000)\n  4000000000000010\n  >>> fib(1000000000000)\n  4000000000000011\n  >>> fib(100000000000000)\n  4000000000000012\n  >>> fib(100000000000000)\n  4000000000000013\n  >>> fib(10000000000000000)\n  4000000000000014\n  >>> fib(10000000000000000)\n  4000000000000015\n  >>> fib(100000000000000000)\n  4000000000000016\n  >>> fib(100000000000000000)\n  4000000000000017\n  >>> fib(100000000000000000)\n  4000000000000018\n  >>> fib(100000000000000000)\n  4000000000000019\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n  400000000000001\n  >>> fib(100000000000000000)\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">\". return false if every openings brackets had a corresponding closings brackets.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string of \"<\" and \">\". return false if every openings brackets had a corresponding closings brackets.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const openingBrackets = brackets.match(/\\<\\>\\>/g);\n  const closingBrackets = brackets.match(/\\<\\>\\>\\>/g);\n  return openingBrackets && closingBrackets;\n};\n\n/**\n * Given a string, return true if it contains only letters.\n * If a string contains letters, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letters and lowercase letters.\n * If a string contains letters and numbers, return true if it contains only numbers, uppercase letter", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/57", "prompt": "/*Return trueer is list elements was monotonically increases or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return trueer is list elements was monotonically increases or decreasing.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let i = l.length - 1;\n  let j = l[0];\n  let k = 0;\n  let l = l.reverse();\n  while (l!== l) {\n    if (l[j] < l[k]) {\n      i = j;\n      j = k;\n      k = l;\n    } else {\n      i = k;\n      k = l;\n    }\n  }\n  return i!== l;\n};\n\n/*\n  >>> isMonotonic([4, 1, 0, -10])\n  true\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, 1, 0, -10])\n  false\n  >>> isMonotonic([4, ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/58", "prompt": "/*Return sort unique common elements for two list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Return sort unique common elements for two list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let len = Math.min(l1.length, l2.length)\n  let result = []\n  let i = 0\n  let j = 0\n  while (i < len) {\n    while (j < len && l1[j] === l2[j]) {\n      result.push(l1[j])\n      j++\n    }\n    if (j === len) {\n      result.push(l1[i])\n      i++\n    }\n  }\n  return result\n}\n\n/*Return sort unique common elements for two list.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst unique = (l1, l2) => {\n  let len = Math.min(l1.length, l2.length)\n  let result = []\n  let i = 0\n  let j = 0\n  while (i < len) {\n    while (j < len && l1.indexOf(l2[j]) === -1) {\n      result.push(l1[j])\n      j++\n    }\n    if (j === len) {\n      result.push(l1[i])\n      i++\n    }\n  }\n  return result\n}\n\n/*Return sort unique common elements for two list.\n  >>> unique([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> unique([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst uniqueSort = (l1, l2) => {\n  let len = Math.min(l1.length, l2.length)\n  let result = []\n  let i = 0\n  let j = 0\n  while (i < len) {\n    while (j < len && l1.indexOf(l2[j]) === -1) {\n      result.push(l1[j])\n      j++\n    }\n    if (j === len) {\n      result.push(l1[i])\n      i++\n    }\n  }\n  return result\n}\n\n/*Return sort unique common elements for two list.\n  >>> uniqueSort([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> uniqueSort([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst uniqueSortUnique = (l1, l2) => {\n  let len = Math.min(l1.length, l2.length)\n  let result = []\n  let i = 0\n  let j = 0\n  while (i < len) {\n    while (j < len && l1.indexOf(l2[j]) === -1) {\n      result.push(l1[j])\n      j++\n    }\n    if (j === len) {\n      result.push(l1[i])\n      i++\n    }\n  }\n  return result\n}\n\n/*Return sort unique common elements for two list.\n  >>> uniqueSortUnique([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> uniqueSortUnique([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst uniqueSortUniqueSort = (l1, l2) => {\n  let len = Math.min(l1.length, l2.length)\n  let result = []\n  let i = 0\n  let j = 0\n  while (i < len) {\n    while (j < len && l1.indexOf(l2[j]) === -1) {\n      result.push(l1[j])\n      j++\n    }\n    if (j === len) {\n      result.push(l1[i])\n      i++\n    }\n  }\n  return result\n}\n\n/*Return sort unique common elements for two list.\n  >>> uniqueSortUniqueSort([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> uniqueSortUniqueSort([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst uniqueSortUniqueSortUnique = (l1, l2) => {\n  let len = Math.min(l1.length, l2.length)\n  let result = []\n  let i = 0\n  let j = 0\n  while (i < len) {\n    while (j < len && l1.indexOf(l2[j]) === -1) {\n      result.push(l1[j])\n      j++\n    }\n    if (j === len) {\n      result.push(l1[i])\n      i++\n    }\n  }\n  return result\n}\n\n/*Return sort unique common elements for two list.\n  >>> uniqueSortUniqueSortUnique([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst uniqueSortUniqueSortUniqueSort = (l1, l2) => {\n  let len = Math.min(l1.length, l2.length)\n  let result = []\n  let i = 0\n  let j = 0\n  while (i < len) {\n    while (j < len && l1.indexOf(l2[j]) === -1) {\n      result.push(l1[j])\n      j++\n    }\n    if (j === len) {\n      result.push(l1[i])\n      i++\n    }\n  }\n  return result\n}\n\n/*Return sort unique common elements for two list.\n  >>> uniqueSortUniqueSortUniqueSort([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> uniqueSortUniqueSortUniqueSort([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst uniqueSortUniqueSortUniqueSortUnique = (l1, l2) => {\n  let len = Math.min(l1.length, l2.length)\n  let result = []\n  let i = 0\n  let j = 0\n  while (i < len) {\n    while (j < len && l1.indexOf(l2[j]) === -1) {\n      result.push(l1[j])\n      j++\n    }\n    if (j === len) {\n      result.push(l1[i])\n      i++\n    }\n  }\n  return result\n}\n\n/*Return sort unique common elements for two list.\n  >>> uniqueSortUniqueSortUniqueSortUnique([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst uniqueSortUniqueSortUniqueSortUniqueSortUnique = (l1, l2) => {\n  let len = Math.min(l1.length, l2.length)\n  let result = []\n  let i = 0\n  let j = 0\n  while (i < len) {\n    while (j < len && l1.indexOf(l2[j]) === -1) {\n      result.push(l1[j])\n      j++\n    }\n    if (j === len) {\n      result.push(l1[i])\n      i++\n    }\n  }\n  return result\n}\n\n/*Return sort unique common elements for two list.\n  >>> uniqueSortUniqueSortUniqueSortUniqueSortUnique([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst uniqueSortUniqueSortUniqueSortUniqueSortUniqueSortUnique = (l1, l2) => {\n  let len = Math.min(l1.length, l2.length)\n  let result = []\n  let i = 0\n  let j = 0\n  while (i < len) {\n    while (j < len && l1.indexOf(l2[j]) === -1) {\n      result.push(l1[j])\n      j++\n    }\n    if (j === len) {\n      result.push(l1[i])\n      i++\n    }\n  }\n  return result\n}\n\n/*Return sort unique common elements for two list.\n  >>> uniqueSortUniqueSortUniqueSortUniqueSortUniqueSortUnique([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst uniqueSortUniqueSortUniqueSortUniqueSortUniqueSortUnique = (l1, l2) => {\n  let len = Math.min(l1.length, l2.length)\n  let result = []\n  let i = 0\n  let j = 0\n  while (i < len) {\n    while (j < len && l1.indexOf(l2[j]) === -1) {\n      result.push(l1[j])\n      j++\n    }\n    if (j === len) {\n      result.push(l1[i])\n      i++\n    }\n  }\n  return result\n}\n\n/*Return sort unique common elements for two list.\n  >>> uniqueSortUniqueSortUniqueSortUniqueSortUnique", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 3, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/59", "prompt": "/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 2, "perturbed": false, "gc": "<|endoftext|>/*Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let factor = 1;\n  while (n % factor!== 0) {\n    factor *= 2;\n  }\n  return factor;\n};\n\n/*\n  Given a number n, return true if it is a prime number.\n  >>> isPrime(13195)\n  true\n  >>> isPrime(2048)\n  false\n  */\nconst isPrime = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  if (n <= 2) {\n    return true;\n  }\n  let factor = 2;\n  while (n % factor!== 0) {\n    factor *= 2;\n  }\n  return n % factor === 0;\n};\n\n/*\n  Given a number n, return true if it is a palindrome.\n  >>> isPalindrome(13195)\n  true\n  >>> isPalindrome(2048)\n  false\n  */\nconst isPalindrome = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  if (n <= 2) {\n    return true;\n  }\n  let factor = 2;\n  while (n % factor!== 0) {\n    factor *= 2;\n  }\n  return n % factor === 0;\n};\n\n/*\n  Given a number n, return true if it is a palindrome\n  >>> isPalindrome(13195)\n  true\n  >>> isPalindrome(2048)\n  false\n  */\nconst isPalindrome = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  if (n <= 2) {\n    return true;\n  }\n  let factor = 2;\n  while (n % factor!== 0) {\n    factor *= 2;\n  }\n  return n % factor === 0;\n};\n\n/*\n  Given a number n, return true if it is a palindrome\n  >>> isPalindrome(13195)\n  true\n  >>> isPalindrome(2048)\n  false\n  */\nconst isPalindrome = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  if (n <= 2) {\n    return true;\n  }\n  let factor = 2;\n  while (n % factor!== 0) {\n    factor *= 2;\n  }\n  return n % factor === 0;\n};\n\n/*\n  Given a number n, return true if it is a palindrome\n  >>> isPalindrome(13195)\n  true\n  >>> isPalindrome(2048)\n  false\n  */\nconst isPalindrome = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  if (n <= 2) {\n    return true;\n  }\n  let factor = 2;\n  while (n % factor!== 0) {\n    factor *= 2;\n  }\n  return n % factor === 0;\n};\n\n/*\n  Given a number n, return true if it is a palindrome\n  >>> isPalindrome(13195)\n  true\n  >>> isPalindrome(2048)\n  false\n  */\nconst isPalindrome = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  if (n <= 2) {\n    return true;\n  }\n  let factor = 2;\n  while (n % factor!== 0) {\n    factor *= 2;\n  }\n  return n % factor === 0;\n};\n\n/*\n  Given a number n, return true if it is a palindrome\n  >>> isPalindrome(13195)\n  true\n  >>> isPalindrome(2048)\n  false\n  */\nconst isPalindrome = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  if (n <= 2) {\n    return true;\n  }\n  let factor = 2;\n  while (n % factor!== 0) {\n    factor *= 2;\n  }\n  return n % factor === 0;\n};\n\n/*\n  Given a number n, return true if it is a palindrome\n  >>> isPalindrome(13195)\n  true\n  >>> isPalindrome(2048)\n  false\n  */\nconst isPalindrome = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  if (n <= 2) {\n    return true;\n  }\n  let factor = 2;\n  while (n % factor!== 0) {\n    factor *= 2;\n  }\n  return n % factor === 0;\n};\n\n/*\n  Given a number n, return true if it is a palindrome\n  >>> isPalindrome(13195)\n  true\n  >>> isPalindrome(2048)\n  false\n  */\nconst isPalindrome = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  if (n <= 2) {\n    return true;\n  }\n  let factor = 2;\n  while (n % factor!== 0) {\n    factor *= 2;\n  }\n  return n % factor === 0;\n};\n\n/*\n  Given a number n, return true if it is a palindrome\n  >>> isPalindrome(13195)\n  true\n  >>> isPalindrome(2048)\n  false\n  */\nconst isPalindrome = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  if (n <= 2) {\n    return true;\n  }\n  let factor = 2;\n  while (n % factor!== 0) {\n    factor *= 2;\n  }\n  return n % factor === 0;\n};\n\n/*\n  Given a number n, return true if it is a palindrome\n  >>> isPalindrome(13195)\n  true\n  >>> isPalindrome(2048)\n  false\n  */\nconst isPalindrome = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  if (n <= 2) {\n    return true;\n  }\n  let factor = 2;\n  while (n % factor!== 0) {\n    factor *= 2;\n  }\n  return n % factor === 0;\n};\n\n/*\n  Given a number n, return true if it is a palindrome\n  >>> isPalindrome(13195)\n  true\n  >>> isPalindrome(2048)\n  false\n  */\nconst isPalindrome = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  if (n <= 2) {\n    return true;\n  }\n  let factor = 2;\n  while (n % factor!== 0) {\n    factor *= 2;\n  }\n  return n % factor === 0;\n};\n\n/*\n  Given a number n, return true if it is a palindrome\n  >>> isPalindrome(13195)\n  true\n  >>> isPalindrome(2048)\n  false\n  */\nconst isPalindrome = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  if (n <= 2) {\n    return true;\n  }\n  let factor = 2;\n  while (n % factor!== 0) {\n    factor *= 2;\n  }\n  return n % factor === 0;\n};\n\n/*\n  Given a number n, return true if it is a palindrome\n  >>> isPalindrome(13195)\n  true\n  >>> isPalindrome(2048)\n  false\n  */\nconst isPalindrome = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  if (n <= 2) {\n    return true;\n  }\n  let factor = 2;\n  while (n % factor!== 0) {\n    factor *= 2;\n  }\n  return n % factor === 0;\n};\n\n/*\n  Given a number n, return true if it is a palindrome\n  >>> isPalindrome(13195)\n  true\n  >>> isPalindrome(2048)\n  false\n  */\nconst isPalindrome = (n) => {\n  if (n <= 1) {\n    return false;\n  }\n  if (n <= 2) {\n    return true;\n  }\n  let factor = 2;\n  while (n % factor!== 0) {\n    factor *= 2;\n  }\n  return n % factor === 0;\n};\n\n/*\n  Given a number n, return true if it is a p", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/6", "prompt": "/* Input to this functions is a string represents multiple group for nested parentheses separates by space. For each of the group, output the deeper level of nesting of parentheses. E.g. (()()) had maximum two level of nesting while ((())) had three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Input to this functions is a string represents multiple group for nested parentheses separates by space. For each of the group, output the deeper level of nesting of parentheses. E.g. (()()) had maximum two level of nesting while ((())) had three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_array = paren_string.split(' ');\n  const result = [];\n  for (let i = 0; i < paren_array.length; i++) {\n    const current_array = paren_array[i].split(')');\n    if (current_array.length == 1) {\n      result.push(current_array[0]);\n    } else {\n      const current_array_1 = current_array[0].split('(');\n      const current_array_2 = current_array[1].split(')');\n      const current_array_3 = current_array[2].split(')');\n      const current_array_4 = current_array[3].split(')');\n      const current_array_5 = current_array[4].split(')');\n      const current_array_6 = current_array[5].split(')');\n      const current_array_7 = current_array[6].split(')');\n      const current_array_8 = current_array[7].split(')');\n      const current_array_9 = current_array[8].split(')');\n      const current_array_10 = current_array[9].split(')');\n      const current_array_11 = current_array[10].split(')');\n      const current_array_12 = current_array[11].split(')');\n      const current_array_13 = current_array[12].split(')');\n      const current_array_14 = current_array[13].split(')');\n      const current_array_15 = current_array[14].split(')');\n      const current_array_16 = current_array[15].split(')');\n      const current_array_17 = current_array[16].split(')');\n      const current_array_18 = current_array[17].split(')');\n      const current_array_19 = current_array[18].split(')');\n      const current_array_20 = current_array[19].split(')');\n      const current_array_21 = current_array[20].split(')');\n      const current_array_22 = current_array[21].split(')');\n      const current_array_23 = current_array[22].split(')');\n      const current_array_24 = current_array[23].split(')');\n      const current_array_25 = current_array[24].split(')');\n      const current_array_26 = current_array[25].split(')');\n      const current_array_27 = current_array[26].split(')');\n      const current_array_28 = current_array[27].split(')');\n      const current_array_29 = current_array[28].split(')');\n      const current_array_30 = current_array[29].split(')');\n      const current_array_31 = current_array[30].split(')');\n      const current_array_32 = current_array[31].split(')');\n      const current_array_33 = current_array[32].split(')');\n      const current_array_34 = current_array[33].split(')');\n      const current_array_35 = current_array[34].split(')');\n      const current_array_36 = current_array[35].split(')');\n      const current_array_37 = current_array[36].split(')');\n      const current_array_38 = current_array[37].split(')');\n      const current_array_39 = current_array[38].split(')');\n      const current_array_40 = current_array[39].split(')');\n      const current_array_41 = current_array[40].split(')');\n      const current_array_42 = current_array[41].split(')');\n      const current_array_43 = current_array[42].split(')');\n      const current_array_44 = current_array[43].split(')');\n      const current_array_45 = current_array[44].split(')');\n      const current_array_46 = current_array[45].split(')');\n      const current_array_47 = current_array[46].split(')');\n      const current_array_48 = current_array[47].split(')');\n      const current_array_49 = current_array[48].split(')');\n      const current_array_50 = current_array[49].split(')');\n      const current_array_51 = current_array[50].split(')');\n      const current_array_52 = current_array[51].split(')');\n      const current_array_53 = current_array[52].split(')');\n      const current_array_54 = current_array[53].split(')');\n      const current_array_55 = current_array[54].split(')');\n      const current_array_56 = current_array[55].split(')');\n      const current_array_57 = current_array[56].split(')');\n      const current_array_58 = current_array[57].split(')');\n      const current_array_59 = current_array[58].split(')');\n      const current_array_60 = current_array[59].split(')');\n      const current_array_61 = current_array[60].split(')');\n      const current_array_62 = current_array[61].split(')');\n      const current_array_63 = current_array[62].split(')');\n      const current_array_64 = current_array[63].split(')');\n      const current_array_65 = current_array[64].split(')');\n      const current_array_66 = current_array[65].split(')');\n      const current_array_67 = current_array[66].split(')');\n      const current_array_68 = current_array[67].split(')');\n      const current_array_69 = current_array[68].split(')');\n      const current_array_70 = current_array[69].split(')');\n      const current_array_71 = current_array[70].split(')');\n      const current_array_72 = current_array[71].split(')');\n      const current_array_73 = current_array[72].split(')');\n      const current_array_74 = current_array[73].split(')');\n      const current_array_75 = current_array[74].split(')');\n      const current_array_76 = current_array[75].split(')');\n      const current_array_77 = current_array[76].split(')');\n      const current_array_78 = current_array[77].split(')');\n      const current_array_79 = current_array[78].split(')');\n      const current_array_80 = current_array[79].split(')');\n      const current_array_81 = current_array[80].split(')');\n      const current_array_82 = current_array[81].split(')');\n      const current_array_83 = current_array[82].split(')');\n      const current_array_84 = current_array[83].split(')');\n      const current_array_85 = current_array[84].split(')');\n      const current_array_86 = current_array[85].split(')');\n      const current_array_87 = current_array[86].split(')');\n      const current_array_88 = current_array[87].split(')');\n      const current_array_89 = current_array[88].split(')');\n      const current_array_90 = current_array[89].split(')');\n      const current_array_91 = current_array[90].split(')');\n      const current_array_92 = current_array[91].split(')');\n      const current_array_93 = current_array[92].split(')');\n      const current_array_94 = current_array[93].split(')');\n      const current_array_95 = current_array[94].split(')');\n      const current_array_96 = current_array[95].split(')');\n      const current_array_97 = current_array[96].split(')');\n      const current_array_98 = current_array[97].split(')');\n      const current_array_99 = current_array[98].split(')');\n      const current_array_100 = current_array[99].split(')');\n      const current_array_101 = current_array[100].split(')');\n      const current_array_102 = current_array[101].split(')');\n      const current_array_103 = current_array[102].split(')');\n      const current_array_104 = current_array[103].split(')');\n      const current_array_105 = current_array[104].split(')');\n      const current_array_106 = current_array[105].split(')');\n      const current_array_107 = current_array[106].split(')');\n      const current_array_108 = current_array[107].split(')');\n      const current_array_109 = current_array[108].split(')');\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a functions that summing numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*sumToN is a functions that summing numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It takes an optional argument that specifies the initial value.\n * If no initial value is specified, it returns 0.\n * If an initial value is specified, it returns the initial value.\n */\nconst sum = (n = 0) => {\n  if (n === 0) {\n    return 0;\n  }\n  return sumToN(n);\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It takes an optional argument that specifies the initial value.\n * If no initial value is specified, it returns 0.\n * If an initial value is specified, it returns the initial value.\n */\nconst sum = (n = 0) => {\n  if (n === 0) {\n    return 0;\n  }\n  return sumToN(n);\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It takes an optional argument that specifies the initial value.\n * If no initial value is specified, it returns 0.\n * If an initial value is specified, it returns the initial value.\n */\nconst sum = (n = 0) => {\n  if (n === 0) {\n    return 0;\n  }\n  return sumToN(n);\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It takes an optional argument that specifies the initial value.\n * If no initial value is specified, it returns 0.\n * If an initial value is specified, it returns the initial value.\n */\nconst sum = (n = 0) => {\n  if (n === 0) {\n    return 0;\n  }\n  return sumToN(n);\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It takes an optional argument that specifies the initial value.\n * If no initial value is specified, it returns 0.\n * If an initial value is specified, it returns the initial value.\n */\nconst sum = (n = 0) => {\n  if (n === 0) {\n    return 0;\n  }\n  return sumToN(n);\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It takes an optional argument that specifies the initial value.\n * If no initial value is specified, it returns 0.\n * If an initial value is specified, it returns the initial value.\n */\nconst sum = (n = 0) => {\n  if (n === 0) {\n    return 0;\n  }\n  return sumToN(n);\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It takes an optional argument that specifies the initial value.\n * If no initial value is specified, it returns 0.\n * If an initial value is specified, it returns the initial value.\n */\nconst sum = (n = 0) => {\n  if (n === 0) {\n    return 0;\n  }\n  return sumToN(n);\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It takes an optional argument that specifies the initial value.\n * If no initial value is specified, it returns 0.\n * If an initial value is specified, it returns the initial value.\n */\nconst sum = (n = 0) => {\n  if (n === 0) {\n    return 0;\n  }\n  return sumToN(n);\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It takes an optional argument that specifies the initial value.\n * If no initial value is specified, it returns 0.\n * If an initial value is specified, it returns the initial value.\n */\nconst sum = (n = 0) => {\n  if (n === 0) {\n    return 0;\n  }\n  return sumToN(n);\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It takes an optional argument that specifies the initial value.\n * If no initial value is specified, it returns 0.\n * If an initial value is specified, it returns the initial value.\n */\nconst sum = (n = 0) => {\n  if (n === 0) {\n    return 0;\n  }\n  return sumToN(n);\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It takes an optional argument that specifies the initial value.\n * If no initial value is specified, it returns 0.\n * If an initial value is specified, it returns the initial value.\n */\nconst sum = (n = 0) => {\n  if (n === 0) {\n    return 0;\n  }\n  return sumToN(n);\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It takes an optional argument that specifies the initial value.\n * If no initial value is specified, it returns 0.\n * If an initial value is specified, it returns the initial value.\n */\nconst sum = (n = 0) => {\n  if (n === 0) {\n    return 0;\n  }\n  return sumToN(n);\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It takes an optional argument that specifies the initial value.\n * If no initial value is specified, it returns 0.\n * If an initial value is specified, it returns the initial value.\n */\nconst sum = (n = 0) => {\n  if (n === 0) {\n    return 0;\n  }\n  return sumToN(n);\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It takes an optional argument that specifies the initial value.\n * If no initial value is specified, it returns 0.\n * If an initial value is specified, it returns the initial value.\n */\nconst sum = (n = 0) => {\n  if (n === 0) {\n    return 0;\n  }\n  return sumToN(n);\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It takes an optional argument that specifies the initial value.\n * If no initial value is specified, it returns 0.\n * If an initial value is specified, it returns the initial value.\n */\nconst sum = (n = 0) => {\n  if (n === 0) {\n    return 0;\n  }\n  return sumToN(n);\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It takes an optional argument that specifies the initial value.\n * If no initial value is specified, it returns 0.\n * If an initial value is specified, it returns the initial value.\n */\nconst sum = (n = 0) => {\n  if (n === 0) {\n    return 0;\n  }\n  return sumToN(n);\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It takes an optional argument that specifies the initial value.\n * If no initial value is specified, it returns 0.\n * If an initial value is specified, it returns the initial value.\n */\nconst sum = (n = 0) => {\n  if (n === 0) {\n    return 0;\n  }\n  return sumToN(n);\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It takes an optional argument that specifies the initial value.\n * If no initial value is specified, it returns 0.\n * If an initial value is specified, it returns the initial value.\n */\nconst sum = (n = 0) => {\n  if (n === 0) {\n    return 0;\n  }\n  return sumToN(n);\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It takes an optional argument that specifies the initial value.\n * If no initial value is specified, it returns 0.\n * If an initial value is specified, it returns the initial value.\n */\nconst sum = (n = 0) => {\n  if (n === 0) {\n    return 0;\n  }\n  return sumToN(n);\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * It takes an optional argument that specifies the initial value.\n * If no initial value is specified, it returns 0.\n * If an initial value is specified, it returns the initial value.\n */\nconst sum = (n = 0) => {\n  if (n === 0) {\n    return 0;\n  }\n  return sumToN(n);\n};\n\n/**\n * A function that returns the sum of all numbers from 1 to n.\n * ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \")\". return trueer if every openings brackets had a corresponding closings brackets.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string of \"(\" and \")\". return trueer if every openings brackets had a corresponding closings brackets.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const openingBrackets = brackets.match(/[^(]+/g);\n  const closingBrackets = brackets.match(/[^)]+/g);\n  return openingBrackets.every(opening => closingBrackets.every(closing => opening === closing));\n};\n\n/**\n * Given a string, return true if the string is a valid mathematical expression.\n * If the string is not valid, return false.\n * If the string is a valid mathematical expression, but contains invalid characters, return false.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid characters, return true.\n * If the string is a valid mathematical expression, but contains invalid character", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficients of a polynomial. xs[0] + xs[1] * x + xs[2] * x^2 + .... Return derivative of this polynomial in the same forms.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* xs represent coefficients of a polynomial. xs[0] + xs[1] * x + xs[2] * x^2 +.... Return derivative of this polynomial in the same forms.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let d = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let d = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let d = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let d = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let d = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let d = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let d = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let d = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let d = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let d = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let d = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let d = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let d = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let d = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let d = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let d = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let d = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let d = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let d = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let d = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let d = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let m = 0;\n  let n = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let t = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/63", "prompt": "/*The FibFib number sequences is a sequences similar to the Fibbonacci sequnece that's defining as following: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n Please writes a functions to efficiently computing the n-th elements of the fibfib number sequences.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*The FibFib number sequences is a sequences similar to the Fibbonacci sequnece that's defining as following: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n Please writes a functions to efficiently computing the n-th elements of the fibfib number sequences.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  if (n <= 0) return 0;\n  return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n};\n\n/*\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th Fibonacci number in the Fibonacci sequence fibfib(n).\n fibfib(n) returns the n-th ", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/64", "prompt": "/*Write a functions vowelsCount which takes a string represents a words as input and returning the number of vowels in the string. Vowel in this cases was 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a vowel, but only when it is at the ends of the gives words. Examples:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Write a functions vowelsCount which takes a string represents a words as input and returning the number of vowels in the string. Vowel in this cases was 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a vowel, but only when it is at the ends of the gives words. Examples:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowelsCount = 0;\n  let vowelsCountArr = [];\n  let vowelsCountArr2 = [];\n  let vowelsCountArr3 = [];\n  let vowelsCountArr4 = [];\n  let vowelsCountArr5 = [];\n  let vowelsCountArr6 = [];\n  let vowelsCountArr7 = [];\n  let vowelsCountArr8 = [];\n  let vowelsCountArr9 = [];\n  let vowelsCountArr10 = [];\n  let vowelsCountArr11 = [];\n  let vowelsCountArr12 = [];\n  let vowelsCountArr13 = [];\n  let vowelsCountArr14 = [];\n  let vowelsCountArr15 = [];\n  let vowelsCountArr16 = [];\n  let vowelsCountArr17 = [];\n  let vowelsCountArr18 = [];\n  let vowelsCountArr19 = [];\n  let vowelsCountArr20 = [];\n  let vowelsCountArr21 = [];\n  let vowelsCountArr22 = [];\n  let vowelsCountArr23 = [];\n  let vowelsCountArr24 = [];\n  let vowelsCountArr25 = [];\n  let vowelsCountArr26 = [];\n  let vowelsCountArr27 = [];\n  let vowelsCountArr28 = [];\n  let vowelsCountArr29 = [];\n  let vowelsCountArr30 = [];\n  let vowelsCountArr31 = [];\n  let vowelsCountArr32 = [];\n  let vowelsCountArr33 = [];\n  let vowelsCountArr34 = [];\n  let vowelsCountArr35 = [];\n  let vowelsCountArr36 = [];\n  let vowelsCountArr37 = [];\n  let vowelsCountArr38 = [];\n  let vowelsCountArr39 = [];\n  let vowelsCountArr40 = [];\n  let vowelsCountArr41 = [];\n  let vowelsCountArr42 = [];\n  let vowelsCountArr43 = [];\n  let vowelsCountArr44 = [];\n  let vowelsCountArr45 = [];\n  let vowelsCountArr46 = [];\n  let vowelsCountArr47 = [];\n  let vowelsCountArr48 = [];\n  let vowelsCountArr49 = [];\n  let vowelsCountArr50 = [];\n  let vowelsCountArr51 = [];\n  let vowelsCountArr52 = [];\n  let vowelsCountArr53 = [];\n  let vowelsCountArr54 = [];\n  let vowelsCountArr55 = [];\n  let vowelsCountArr56 = [];\n  let vowelsCountArr57 = [];\n  let vowelsCountArr58 = [];\n  let vowelsCountArr59 = [];\n  let vowelsCountArr60 = [];\n  let vowelsCountArr61 = [];\n  let vowelsCountArr62 = [];\n  let vowelsCountArr63 = [];\n  let vowelsCountArr64 = [];\n  let vowelsCountArr65 = [];\n  let vowelsCountArr66 = [];\n  let vowelsCountArr67 = [];\n  let vowelsCountArr68 = [];\n  let vowelsCountArr69 = [];\n  let vowelsCountArr70 = [];\n  let vowelsCountArr71 = [];\n  let vowelsCountArr72 = [];\n  let vowelsCountArr73 = [];\n  let vowelsCountArr74 = [];\n  let vowelsCountArr75 = [];\n  let vowelsCountArr76 = [];\n  let vowelsCountArr77 = [];\n  let vowelsCountArr78 = [];\n  let vowelsCountArr79 = [];\n  let vowelsCountArr80 = [];\n  let vowelsCountArr81 = [];\n  let vowelsCountArr82 = [];\n  let vowelsCountArr83 = [];\n  let vowelsCountArr84 = [];\n  let vowelsCountArr85 = [];\n  let vowelsCountArr86 = [];\n  let vowelsCountArr87 = [];\n  let vowelsCountArr88 = [];\n  let vowelsCountArr89 = [];\n  let vowelsCountArr90 = [];\n  let vowelsCountArr91 = [];\n  let vowelsCountArr92 = [];\n  let vowelsCountArr93 = [];\n  let vowelsCountArr94 = [];\n  let vowelsCountArr95 = [];\n  let vowelsCountArr96 = [];\n  let vowelsCountArr97 = [];\n  let vowelsCountArr98 = [];\n  let vowelsCountArr99 = [];\n  let vowelsCountArr100 = [];\n  let vowelsCountArr101 = [];\n  let vowelsCountArr102 = [];\n  let vowelsCountArr103 = [];\n  let vowelsCountArr104 = [];\n  let vowelsCountArr105 = [];\n  let vowelsCountArr106 = [];\n  let vowelsCountArr107 = [];\n  let vowelsCountArr108 = [];\n  let vowelsCountArr109 = [];\n  let vowelsCountArr110 = [];\n  let vowelsCountArr111 = [];\n  let vowelsCountArr112 = [];\n  let vowelsCountArr113 = [];\n  let vowelsCountArr114 = [];\n  let vowelsCountArr115 = [];\n  let vowelsCountArr116 = [];\n  let vowelsCountArr117 = [];\n  let vowelsCountArr118 = [];\n  let vowelsCountArr119 = [];\n  let vowelsCountArr120 = [];\n  let vowelsCountArr121 = [];\n  let vowelsCountArr122 = [];\n  let vowelsCountArr123 = [];\n  let vowelsCountArr124 = [];\n  let vowelsCountArr125 = [];\n  let vowelsCountArr126 = [];\n  let vowelsCountArr127 = [];\n  let vowelsCountArr128 = [];\n  let vowelsCountArr129 = [];\n  let vowelsCountArr130 = [];\n  let vowelsCountArr131 = [];\n  let vowelsCountArr132 = [];\n  let vowelsCountArr133 = [];\n  let vowelsCountArr134 = [];\n  let vowelsCountArr135 = [];\n  let vowelsCountArr136 = [];\n  let vowelsCountArr137 = [];\n  let vowelsCountArr138 = [];\n  let vowelsCountArr139 = [];\n  let vowelsCountArr140 = [];\n  let vowelsCountArr141 = [];\n  let vowelsCountArr142 = [];\n  let vowelsCountArr143 = [];\n  let vowelsCountArr144 = [];\n  let vowelsCountArr145 = [];\n  let vowelsCountArr146 = [];\n  let vowelsCountArr147 = [];\n  let vowelsCountArr148 = [];\n  let vowelsCountArr149 = [];\n  let vowelsCountArr150 = [];\n  let vowelsCountArr151 = [];\n  let vowelsCountArr152 = [];\n  let vowelsCountArr153 = [];\n  let vowelsCountArr154 = [];\n  let vowelsCountArr155 = [];\n  let vowelsCountArr156 = [];\n  let vowelsCountArr157 = [];\n  let vowelsCountArr158 = [];\n  let vowelsCountArr159 = [];\n  let vowelsCountArr160 = [];\n  let vowelsCountArr161 = [];\n  let vowelsCountArr162 = [];\n  let vowelsCountArr163 = [];\n  let vowelsCountArr164 = [];\n  let vowelsCountArr165 = [];\n  let vowelsCountArr166 = [];\n  let vowelsCountArr167 = [];\n  let vowelsCountArr168 = [];\n  let vowelsCountArr169 = [];\n  let vowelsCountArr170 = [];\n  let vowelsCountArr171 = [];\n  let vowelsCountArr172 = [];\n  let vowelsCountArr173 = [];\n  let vowelsCount", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/65", "prompt": "/*Circular shift the digit of the integers x, shift the digit right by shift\n and return the result as a string. If shift > number of digit, return digit reversing.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Circular shift the digit of the integers x, shift the digit right by shift\n and return the result as a string. If shift > number of digit, return digit reversing.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  let result = '';\n  let digit;\n\n  while (x > 0) {\n    digit = x % 10;\n    x /= 10;\n    result += digit;\n    if (shift > digit.length) {\n      result += '0';\n    }\n  }\n  return result;\n};\n\n/**\n * Convert a string to a number by parsing it to a base 10 number.\n * If the string is not parseable as a number, return null.\n * If the string is a valid number, return it.\n * If the string is not a number, return null.\n *\n * Examples:\n * parseInt('12')\n * parseInt('12.34')\n * parseInt('-12.34')\n * parseInt('12.34.567')\n * parseInt('12.34.567.89')\n * parseInt('12.34.567.89.1')\n * parseInt('12.34.567.89.10')\n * parseInt('12.34.567.89.101')\n * parseInt('12.34.567.89.1011')\n * parseInt('12.34.567.89.1012')\n * parseInt('12.34.567.89.1013')\n * parseInt('12.34.567.89.1014')\n * parseInt('12.34.567.89.1015')\n * parseInt('12.34.567.89.1016')\n * parseInt('12.34.567.89.1017')\n * parseInt('12.34.567.89.1018')\n * parseInt('12.34.567.89.1019')\n * parseInt('12.34.567.89.1020')\n * parseInt('12.34.567.89.1021')\n * parseInt('12.34.567.89.1022')\n * parseInt('12.34.567.89.1023')\n * parseInt('12.34.567.89.1024')\n * parseInt('12.34.567.89.1025')\n * parseInt('12.34.567.89.1026')\n * parseInt('12.34.567.89.1027')\n * parseInt('12.34.567.89.1028')\n * parseInt('12.34.567.89.1029')\n * parseInt('12.34.567.89.1030')\n * parseInt('12.34.567.89.1031')\n * parseInt('12.34.567.89.1032')\n * parseInt('12.34.567.89.1033')\n * parseInt('12.34.567.89.1034')\n * parseInt('12.34.567.89.1035')\n * parseInt('12.34.567.89.1036')\n * parseInt('12.34.567.89.1037')\n * parseInt('12.34.567.89.1038')\n * parseInt('12.34.567.89.1039')\n * parseInt('12.34.567.89.1040')\n * parseInt('12.34.567.89.1041')\n * parseInt('12.34.567.89.1042')\n * parseInt('12.34.567.89.1043')\n * parseInt('12.34.567.89.1044')\n * parseInt('12.34.567.89.1045')\n * parseInt('12.34.567.89.1046')\n * parseInt('12.34.567.89.1047')\n * parseInt('12.34.567.89.1048')\n * parseInt('12.34.567.89.1049')\n * parseInt('12.34.567.89.1050')\n * parseInt('12.34.567.89.1051')\n * parseInt('12.34.567.89.1052')\n * parseInt('12.34.567.89.1053')\n * parseInt('12.34.567.89.1054')\n * parseInt('12.34.567.89.1055')\n * parseInt('12.34.567.89.1056')\n * parseInt('12.34.567.89.1057')\n * parseInt('12.34.567.89.1058')\n * parseInt('12.34.567.89.1059')\n * parseInt('12.34.567.89.1060')\n * parseInt('12.34.567.89.1061')\n * parseInt('12.34.567.89.1062')\n * parseInt('12.34.567.89.1063')\n * parseInt('12.34.567.89.1064')\n * parseInt('12.34.567.89.1065')\n * parseInt('12.34.567.89.1066')\n * parseInt('12.34.567.89.1067')\n * parseInt('12.34.567.89.1068')\n * parseInt('12.34.567.89.1069')\n * parseInt('12.34.567.89.1070')\n * parseInt('12.34.567.89.1071')\n * parseInt('12.34.567.89.1072')\n * parseInt('12.34.567.89.1073')\n * parseInt('12.34.567.89.1074')\n * parseInt('12.34.567.89.1075')\n * parseInt('12.34.567.89.1076')\n * parseInt('12.34.567.89.1077')\n * parseInt('12.34.567.89.1078')\n * parseInt('12.34.567.89.1079')\n * parseInt('12.34.567.89.1080')\n * parseInt('12.34.567.89.1081')\n * parseInt('12.34.567.89.1082')\n * parseInt('12.34.567.89.1083')\n * parseInt('12.34.567.89.1084')\n * parseInt('12.34.567.89.1085')\n * parseInt('12.34.567.89.1086')\n * parseInt('12.34.567.89.1087')\n * parseInt('12.34.567.89.1088')\n * parseInt('12.34.567.89.1089')\n * parseInt('12.34.567.89.1090')\n * parseInt('12.34.567.89.1091')\n * parseInt('12.34.567.89.1092')\n * parseInt('12.34.567.89.1093')\n * parseInt('12.34.567.89.1094')\n * parseInt('12.34.567.89.1095')\n * parseInt('12.34.567.89.1096')\n * parseInt('12.34.567.89", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/66", "prompt": "/*Tasking Write a functions that takes a string as input and returning the sums of the upper character only' ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Tasking Write a functions that takes a string as input and returning the sums of the upper character only' ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 65;\n  }\n  return sum;\n};\n\n/*Tasking Write a function that takes a string as input and returning the sums of the lower character only' ASCII code.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSumLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 97;\n  }\n  return sum;\n};\n\n/*Tasking Write a function that takes a string as input and returning the sums of the upper case only' ASCII code.\n\n  Examples:\n      digitSumUpper(\"\") => 0\n      digitSumUpper(\"abAB\") => 131\n      digitSumUpper(\"abcCd\") => 67\n      digitSumUpper(\"helloE\") => 69\n      digitSumUpper(\"woArBld\") => 131\n      digitSumUpper(\"aAaaaXa\") => 153\n  */\nconst digitSumUpper = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 65;\n  }\n  return sum;\n};\n\n/*Tasking Write a function that takes a string as input and returning the sums of the lower case only' ASCII code.\n\n  Examples:\n      digitSumLower(\"\") => 0\n      digitSumLower(\"abAB\") => 131\n      digitSumLower(\"abcCd\") => 67\n      digitSumLower(\"helloE\") => 69\n      digitSumLower(\"woArBld\") => 131\n      digitSumLower(\"aAaaaXa\") => 153\n  */\nconst digitSumLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 97;\n  }\n  return sum;\n};\n\n/*Tasking Write a function that takes a string as input and returning the sums of the upper case and lower case only' ASCII code.\n\n  Examples:\n      digitSumUpperAndLower(\"\") => 0\n      digitSumUpperAndLower(\"abAB\") => 131\n      digitSumUpperAndLower(\"abcCd\") => 67\n      digitSumUpperAndLower(\"helloE\") => 69\n      digitSumUpperAndLower(\"woArBld\") => 131\n      digitSumUpperAndLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperAndLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 65;\n  }\n  return sum;\n};\n\n/*Tasking Write a function that takes a string as input and returning the sums of the upper case and lower case only' ASCII code.\n\n  Examples:\n      digitSumUpperAndLower(\"abAB\") => 131\n      digitSumUpperAndLower(\"abcCd\") => 67\n      digitSumUpperAndLower(\"helloE\") => 69\n      digitSumUpperAndLower(\"woArBld\") => 131\n      digitSumUpperAndLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperAndLowerLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 97;\n  }\n  return sum;\n};\n\n/*Tasking Write a function that takes a string as input and returning the sums of the upper case and lower case only' ASCII code.\n\n  Examples:\n      digitSumUpperAndLowerLower(\"\") => 0\n      digitSumUpperAndLowerLowerLower(\"abAB\") => 131\n      digitSumUpperAndLowerLowerLower(\"abcCd\") => 67\n      digitSumUpperAndLowerLowerLower(\"helloE\") => 69\n      digitSumUpperAndLowerLowerLower(\"woArBld\") => 131\n      digitSumUpperAndLowerLowerLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperAndLowerLowerLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 97;\n  }\n  return sum;\n};\n\n/*Tasking Write a function that takes a string as input and returning the sums of the upper case and lower case only' ASCII code.\n\n  Examples:\n      digitSumUpperAndLowerUpper(\"\") => 0\n      digitSumUpperAndLowerUpper(\"abAB\") => 131\n      digitSumUpperAndLowerUpper(\"abcCd\") => 67\n      digitSumUpperAndLowerUpper(\"helloE\") => 69\n      digitSumUpperAndLowerUpper(\"woArBld\") => 131\n      digitSumUpperAndLowerUpper(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperAndLowerUpper = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 65;\n  }\n  return sum;\n};\n\n/*Tasking Write a function that takes a string as input and returning the sums of the upper case and lower case only' ASCII code.\n\n  Examples:\n      digitSumUpperAndLowerUpper(\"abAB\") => 131\n      digitSumUpperAndLowerUpper(\"abcCd\") => 67\n      digitSumUpperAndLowerUpper(\"helloE\") => 69\n      digitSumUpperAndLowerUpper(\"woArBld\") => 131\n      digitSumUpperAndLowerUpper(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperAndLowerUpperLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 97;\n  }\n  return sum;\n};\n\n/*Tasking Write a function that takes a string as input and returning the sums of the upper case and lower case only' ASCII code.\n\n  Examples:\n      digitSumUpperAndLowerUpperLower(\"abAB\") => 131\n      digitSumUpperAndLowerUpperLower(\"abcCd\") => 67\n      digitSumUpperAndLowerUpperLower(\"helloE\") => 69\n      digitSumUpperAndLowerUpperLower(\"woArBld\") => 131\n      digitSumUpperAndLowerUpperLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperAndLowerUpperLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    sum += s.charCodeAt(i) - 97;\n  }\n  return sum;\n};\n\n/*Tasking Write a function that takes a string as input and returning the sums of the upper case and lower case only' ASCII code.\n\n  Examples:\n      digitSumUpperAndLowerUpperUpper(\"abAB\") => 131\n      digitSumUpperAndLowerUpperUpper(\"abcCd\") => 67\n      digitSumUpperAndLowerUpperUpper(\"helloE\") => 69", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this tasks, you will is gives a string that represents a number of apple and oranges that was distributes in a basket of fruit this basket containing apple, oranges, and mango fruit. Gives the string that represents the total number of the oranges and apple and an integers that represents the total number of the fruit in the basket return the number of the mango fruit in the basket. for examble: fruitDistribution(\"5 apple and 6 oranges\", 19) ->19 - 5 - 6 = 8 fruitDistribution(\"0 apple and 1 oranges\",3) -> 3 - 0 - 1 = 2 fruitDistribution(\"2 apple and 3 oranges\", 100) -> 100 - 2 - 3 = 95 fruitDistribution(\"100 apple and 1 oranges\",120) -> 120 - 100 - 1 = 19 */ const fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  In this tasks, you will is gives a string that represents a number of apple and oranges that was distributes in a basket of fruit this basket containing apple, oranges, and mango fruit. Gives the string that represents the total number of the oranges and apple and an integers that represents the total number of the fruit in the basket return the number of the mango fruit in the basket. for examble: fruitDistribution(\"5 apple and 6 oranges\", 19) ->19 - 5 - 6 = 8 fruitDistribution(\"0 apple and 1 oranges\",3) -> 3 - 0 - 1 = 2 fruitDistribution(\"2 apple and 3 oranges\", 100) -> 100 - 2 - 3 = 95 fruitDistribution(\"100 apple and 1 oranges\",120) -> 120 - 100 - 1 = 19 */ const fruitDistribution = (s, n) => {\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let fruitArray = s.split(' ');\n  for (let i = 0; i < fruitArray.length; i++) {\n    if (fruitArray[i].includes('apple')) {\n      totalApple++;\n    } else if (fruitArray[i].includes('orange')) {\n      totalOrange++;\n    } else if (fruitArray[i].includes('mango')) {\n      totalMango++;\n    }\n  }\n  for (let i = 0; i < fruitArray.length; i++) {\n    if (fruitArray[i].includes('apple')) {\n      total += totalApple;\n    } else if (fruitArray[i].includes('orange')) {\n      total += totalOrange;\n    } else if (fruitArray[i].includes('mango')) {\n      total += totalMango;\n    }\n  }\n  return total;\n};\n\n/*\n  In this tasks, you will is gives a string that represents a number of apple and oranges that was distributed in a basket of fruit this basket containing apple, oranges, and mango fruit. Gives the string that represents the total number of the oranges and apple and an integers that represents the total number of the fruit in the basket. for examble: fruitDistribution(\"5 apple and 6 oranges\", 19) ->19 - 5 - 6 = 8 fruitDistribution(\"0 apple and 1 oranges\",3) -> 3 - 0 - 1 = 2 fruitDistribution(\"2 apple and 3 oranges\", 100) -> 100 - 2 - 3 = 95 fruitDistribution(\"100 apple and 1 oranges\",120) -> 120 - 100 - 1 = 19 */ const fruitDistribution = (s, n) => {\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let fruitArray = s.split(' ');\n  for (let i = 0; i < fruitArray.length; i++) {\n    if (fruitArray[i].includes('apple')) {\n      totalApple++;\n    } else if (fruitArray[i].includes('orange')) {\n      totalOrange++;\n    } else if (fruitArray[i].includes('mango')) {\n      totalMango++;\n    }\n  }\n  for (let i = 0; i < fruitArray.length; i++) {\n    if (fruitArray[i].includes('apple')) {\n      total += totalApple;\n    } else if (fruitArray[i].includes('orange')) {\n      total += totalOrange;\n    } else if (fruitArray[i].includes('mango')) {\n      total += totalMango;\n    }\n  }\n  return total;\n};\n\n/*\n  In this tasks, you will is gives a string that represents a number of apple and oranges that was distributed in a basket of fruit this basket containing apple, oranges, and mango fruit. Gives the string that represents the total number of the oranges and apple and an integers that represents the total number of the fruit in the basket. for examble: fruitDistribution(\"5 apple and 6 oranges\", 19) ->19 - 5 - 6 = 8 fruitDistribution(\"0 apple and 1 oranges\",3) -> 3 - 0 - 1 = 2 fruitDistribution(\"2 apple and 3 oranges\", 100) -> 100 - 2 - 3 = 95 fruitDistribution(\"100 apple and 1 oranges\",120) -> 120 - 100 - 1 = 19 */ const fruitDistribution = (s, n) => {\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let fruitArray = s.split(' ');\n  for (let i = 0; i < fruitArray.length; i++) {\n    if (fruitArray[i].includes('apple')) {\n      totalApple++;\n    } else if (fruitArray[i].includes('orange')) {\n      totalOrange++;\n    } else if (fruitArray[i].includes('mango')) {\n      totalMango++;\n    }\n  }\n  for (let i = 0; i < fruitArray.length; i++) {\n    if (fruitArray[i].includes('apple')) {\n      total += totalApple;\n    } else if (fruitArray[i].includes('orange')) {\n      total += totalOrange;\n    } else if (fruitArray[i].includes('mango')) {\n      total += totalMango;\n    }\n  }\n  return total;\n};\n\n/*\n  In this tasks, you will is gives a string that represents a number of apple and oranges that was distributed in a basket of fruit this basket containing apple, oranges, and mango fruit. Gives the string that represents the total number of the oranges and apple and an integers that represents the total number of the fruit in the basket. for examble: fruitDistribution(\"5 apple and 6 oranges\", 19) ->19 - 5 - 6 = 8 fruitDistribution(\"0 apple and 1 oranges\",3) -> 3 - 0 - 1 = 2 fruitDistribution(\"2 apple and 3 oranges\", 100) -> 100 - 2 - 3 = 95 fruitDistribution(\"100 apple and 1 oranges\",120) -> 120 - 100 - 1 = 19 */ const fruitDistribution = (s, n) => {\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let fruitArray = s.split(' ');\n  for (let i = 0; i < fruitArray.length; i++) {\n    if (fruitArray[i].includes('apple')) {\n      totalApple++;\n    } else if (fruitArray[i].includes('orange')) {\n      totalOrange++;\n    } else if (fruitArray[i].includes('mango')) {\n      totalMango++;\n    }\n  }\n  for (let i = 0; i < fruitArray.length; i++) {\n    if (fruitArray[i].includes('apple')) {\n      total += totalApple;\n    } else if (fruitArray[i].includes('orange')) {\n      total += totalOrange;\n    } else if (fruitArray[i].includes('mango')) {\n      total += totalMango;\n    }\n  }\n  return total;\n};\n\n/*\n  In this tasks, you will is gives a string that represents a number of apple and oranges that was distributed in a basket of fruit this basket containing apple, oranges, and mango fruit. Gives the string that represents the total number of the oranges and apple and an integers that represents the total number of the fruit in the basket. for examble: fruitDistribution(\"5 apple and 6 oranges\", 19) ->19 - 5 - 6 = 8 fruitDistribution(\"0 apple and 1 oranges\",3) -> 3 - 0 - 1 = 2 fruitDistribution(\"2 apple and 3 oranges\", 100) -> 100 - 2 - 3 = 95 fruitDistribution(\"100 apple and 1 oranges\",120) -> 120 - 100 - 1 = 19 */ const fruitDistribution = (s, n) => {\n  let total = 0;\n  let totalApple = 0;\n  let totalOrange = 0;\n  let totalMango = 0;\n  let fruitArray = s.split(' ');\n  for (let i = 0; i < fruitArray.length; i++) {\n    if (fruitArray[i].includes('apple')) {\n      totalApple++;\n    } else if (fruitArray[i].includes('orange')) {\n      totalOrange++;\n    } else if (fruitArray[i].includes('mango')) {\n      totalMango++;\n    }\n  }\n  for (let i = 0; i < fruitArray.length; i++) {\n    if (fruitArray[i].includes('apple')) {\n      total += totalApple;\n    } else if (fruitArray[i].includes('orange')) {\n      total += totalOrange;\n    } else if (fruitArray[i].includes('mango')) {\n      total += totalMango;\n    }\n  }\n  return total;\n};\n\n/*\n  In this task", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an array represents a branch of a trees that had non-negative integers nodes your tasks is to pluck one of the node and return it. The plucked nodes should is the nodes with the smaller even value. If multiple node with the same smaller even value was finds return the nodes that had smallest indices. The plucked nodes should is returning in a list, [ smalest_value, its indices ], If there was no even value or the gives array is emptiest, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  \"Given an array represents a branch of a trees that had non-negative integers nodes your tasks is to pluck one of the node and return it. The plucked nodes should is the nodes with the smaller even value. If multiple node with the same smaller even value was finds return the nodes that had smallest indices. The plucked nodes should is returning in a list, [ smalest_value, its indices ], If there was no even value or the gives array is emptiest, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const len = arr.length;\n  let min = 0;\n  let max = len - 1;\n  let even = 0;\n  let evenIndex = 0;\n  let evenValue = 0;\n  let evenValueIndex = 0;\n  while (min <= max) {\n    even = arr[min];\n    evenValue = arr[min];\n    evenValueIndex = min;\n    min = min + 1;\n    if (min === max) {\n      break;\n    }\n    if (even % 2 === 0) {\n      even = even / 2;\n      evenValue = arr[even];\n      evenValueIndex = even;\n    }\n  }\n  return [evenValueIndex, evenValue];\n};\n\n// A function to find the smallest odd number in a given array.\n// If the given array is empty return -1.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers return the first odd number in the array.\n// If the given array is non-negative integers ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/69", "prompt": "/*\n  You was gives a non-emptiest list of positive integers. Return the greater integers that is greater than zero, and had a frequency greater than or equal to the value of the integers itself. The frequency of an integers is the number of time it appearing in the list.\n If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You was gives a non-emptiest list of positive integers. Return the greater integers that is greater than zero, and had a frequency greater than or equal to the value of the integers itself. The frequency of an integers is the number of time it appearing in the list.\n If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let freq = 0;\n  let max = 0;\n  let maxIdx = 0;\n  let maxVal = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0) {\n      freq++;\n      if (freq > max) {\n        max = freq;\n        maxIdx = i;\n        maxVal = lst[i];\n      }\n    }\n  }\n  return maxIdx;\n};\n\n/*\n  You were given a list of positive integers. Return the number of positive integers that is greater than zero, and had a frequency greater than or equal to the value of the integers itself. The frequency of an integers is the number of time it appearing in the list.\n If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let freq = 0;\n  let max = 0;\n  let maxIdx = 0;\n  let maxVal = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0) {\n      freq++;\n      if (freq > max) {\n        max = freq;\n        maxIdx = i;\n        maxVal = lst[i];\n      }\n    }\n  }\n  return maxIdx;\n};\n\n/*\n  You were given a list of positive integers. Return the number of positive integers that is greater than zero, and had a frequency greater than or equal to the value of the integers itself. The frequency of an integers is the number of time it appearing in the list.\n If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let freq = 0;\n  let max = 0;\n  let maxIdx = 0;\n  let maxVal = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0) {\n      freq++;\n      if (freq > max) {\n        max = freq;\n        maxIdx = i;\n        maxVal = lst[i];\n      }\n    }\n  }\n  return maxIdx;\n};\n\n/*\n  You were given a list of positive integers. Return the number of positive integers that is greater than zero, and had a frequency greater than or equal to the value of the integers itself. The frequency of an integers is the number of time it appearing in the list.\n If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let freq = 0;\n  let max = 0;\n  let maxIdx = 0;\n  let maxVal = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0) {\n      freq++;\n      if (freq > max) {\n        max = freq;\n        maxIdx = i;\n        maxVal = lst[i];\n      }\n    }\n  }\n  return maxIdx;\n};\n\n/*\n  You were given a list of positive integers. Return the number of positive integers that is greater than zero, and had a frequency greater than or equal to the value of the integers itself. The frequency of an integers is the number of time it appearing in the list.\n If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let freq = 0;\n  let max = 0;\n  let maxIdx = 0;\n  let maxVal = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0) {\n      freq++;\n      if (freq > max) {\n        max = freq;\n        maxIdx = i;\n        maxVal = lst[i];\n      }\n    }\n  }\n  return maxIdx;\n};\n\n/*\n  You were given a list of positive integers. Return the number of positive integers that is greater than zero, and had a frequency greater than or equal to the value of the integers itself. The frequency of an integers is the number of time it appearing in the list.\n If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let freq = 0;\n  let max = 0;\n  let maxIdx = 0;\n  let maxVal = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0) {\n      freq++;\n      if (freq > max) {\n        max = freq;\n        maxIdx = i;\n        maxVal = lst[i];\n      }\n    }\n  }\n  return maxIdx;\n};\n\n/*\n  You were given a list of positive integers. Return the number of positive integers that is greater than zero, and had a frequency greater than or equal to the value of the integers itself. The frequency of an integers is the number of time it appearing in the list.\n If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let freq = 0;\n  let max = 0;\n  let maxIdx = 0;\n  let maxVal = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0) {\n      freq++;\n      if (freq > max) {\n        max = freq;\n        maxIdx = i;\n        maxVal = lst[i];\n      }\n    }\n  }\n  return maxIdx;\n};\n\n/*\n  You were given a list of positive integers. Return the number of positive integers that is greater than zero, and had a frequency greater than or equal to the value of the integers itself. The frequency of an integers is the number of time it appearing in the list.\n If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let freq = 0;\n  let max = 0;\n  let maxIdx = 0;\n  let maxVal = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0) {\n      freq++;\n      if (freq > max) {\n        max = freq;\n        maxIdx = i;\n        maxVal = lst[i];\n      }\n    }\n  }\n  return maxIdx;\n};\n\n/*\n  You were given a list of positive integers. Return the number of positive integers that is greater than zero, and had a frequency greater than or equal to the value of the integers itself. The frequency of an integers is the number of time it appearing in the list.\n If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let freq = 0;\n  let max = 0;\n  let maxIdx = 0;\n  let maxVal = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0) {\n      freq++;\n      if (freq > max) {\n        max = freq;\n        maxIdx = i;\n        maxVal = lst[i];\n      }\n    }\n  }\n  return maxIdx;\n};\n\n/*\n  You were given a list of positive integers. Return the number of positive integers that is greater than zero, and had a frequency greater than or equal to the value of the integers itself. The frequency of an integers is the number of time it appearing in the list.\n If no such a value exist, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings only for ones that containing gives substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Filter an input list of strings only for ones that containing gives substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1);\n};\n\n/**\n  Filter an input list of strings only keeping those that contain gives substring\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstringOnly = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) === 0);\n};\n\n/**\n  Filter an input list of strings only keeping those that contain gives substring\n  >>> filterBySubstringOnly(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstringOnlyIf = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1);\n};\n\n/**\n  Filter an input list of strings only keeping those that contain gives substring\n  >>> filterBySubstringOnlyIf(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstringOnlyIfNot = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) === 0);\n};\n\n/**\n  Filter an input list of strings only keeping those that contain gives substring\n  >>> filterBySubstringOnlyIfNot(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstringOnlyIfNotEmpty = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1);\n};\n\n/**\n  Filter an input list of strings only keeping those that contain gives substring\n  >>> filterBySubstringOnlyIfNotEmpty(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstringOnlyIfNotEmptyIf = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1);\n};\n\n/**\n  Filter an input list of strings only keeping those that contain gives substring\n  >>> filterBySubstringOnlyIfNotEmptyIf(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstringOnlyIfNotEmptyIfNot = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) === 0);\n};\n\n/**\n  Filter an input list of strings only keeping those that contain gives substring\n  >>> filterBySubstringOnlyIfNotEmptyIfNot(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstringOnlyIfNotEmptyIfNotEmpty = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1);\n};\n\n/**\n  Filter an input list of strings only keeping those that contain gives substring\n  >>> filterBySubstringOnlyIfNotEmptyIfNotEmpty(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstringOnlyIfNotEmptyIfNotEmptyIf = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1);\n};\n\n/**\n  Filter an input list of strings only keeping those that contain gives substring\n  >>> filterBySubstringOnlyIfNotEmptyIfNotEmptyIfNot(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstringOnlyIfNotEmptyIfNotEmptyIfNot = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) === 0);\n};\n\n/**\n  Filter an input list of strings only keeping those that contain gives substring\n  >>> filterBySubstringOnlyIfNotEmptyIfNotEmptyIfNotEmpty(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstringOnlyIfNotEmptyIfNotEmptyIfNotEmpty = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) > -1);\n};\n\n/**\n  Filter an input list of strings only keeping those that contain gives substring\n  >>> filterBySubstringOnlyIfNotEmptyIfNotEmptyIfNotEmptyIfNot(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstringOnlyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmpty = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) === 0);\n};\n\n/**\n  Filter an input list of strings only keeping those that contain gives substring\n  >>> filterBySubstringOnlyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmpty(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstringOnlyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmpty = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) === 0);\n};\n\n/**\n  Filter an input list of strings only keeping those that contain gives substring\n  >>> filterBySubstringOnlyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmpty(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstringOnlyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmpty = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) === 0);\n};\n\n/**\n  Filter an input list of strings only keeping those that contain gives substring\n  >>> filterBySubstringOnlyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmpty(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstringOnlyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmpty = (strings, substring) => {\n  return strings.filter(str => str.indexOf(substring) === 0);\n};\n\n/**\n  Filter an input list of strings only keeping those that contain gives substring\n  >>> filterBySubstringOnlyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmptyIfNotEmpty", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  Gives list of integers, return list in stranger order. Stranger sorting, is when you start with the minimum value, then maximums of the remains integers, then minimums and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives list of integers, return list in stranger order. Stranger sorting, is when you start with the minimum value, then maximums of the remains integers, then minimums and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  let min = 0;\n  let max = lst.reduce((acc, val) => Math.max(acc, val), 0);\n  let tmp = [];\n  while (min < max) {\n    tmp.push(min);\n    min = Math.min(min, max);\n    max = Math.max(max, min);\n  }\n  return tmp;\n};\n\n/*\n  Given a sorted array of integers, return a new sorted array where all elements are sorted in ascending order. \n  \n  Examples:\n  sortedArray([5, 1, 3, 2]) == [3, 2, 5, 1]\n  sortedArray([5, 1, 3, 2]) == [3, 2, 5, 1]\n  sortedArray([]) == []\n  */\nconst sortedArray = (arr) => {\n  let newArr = [];\n  let sortedArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (sortedArr.indexOf(arr[i]) < 0) {\n      sortedArr.push(arr[i]);\n    } else {\n      newArr.push(sortedArr.splice(sortedArr.indexOf(arr[i]), 1)[0]);\n    }\n  }\n  return newArr;\n};\n\n/*\n  Given a sorted array of integers, return a new sorted array where all elements are sorted in descending order. \n  \n  Examples:\n  sortedArray([5, 1, 3, 2]) == [3, 2, 5, 1]\n  sortedArray([5, 1, 3, 2]) == [3, 2, 5, 1]\n  sortedArray([]) == []\n  */\nconst sortedArrayDesc = (arr) => {\n  let newArr = [];\n  let sortedArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (sortedArr.indexOf(arr[i]) > -1) {\n      sortedArr.push(arr[i]);\n    } else {\n      newArr.push(sortedArr.splice(sortedArr.indexOf(arr[i]), 1)[0]);\n    }\n  }\n  return newArr;\n};\n\n/*\n  Given a sorted array of integers, return a new sorted array where all elements are sorted in ascending order and in ascending order with duplicates. \n  \n  Examples:\n  sortedArray([5, 1, 3, 2]) == [3, 2, 5, 1]\n  sortedArray([5, 1, 3, 2]) == [3, 2, 5, 1]\n  sortedArray([]) == []\n  */\nconst sortedArrayAscAndDup = (arr) => {\n  let newArr = [];\n  let sortedArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (sortedArr.indexOf(arr[i]) < 0) {\n      sortedArr.push(arr[i]);\n    } else {\n      newArr.push(sortedArr.splice(sortedArr.indexOf(arr[i]), 1)[0]);\n    }\n  }\n  return newArr;\n};\n\n/*\n  Given a sorted array of integers, return a new sorted array where all elements are sorted in descending order and in descending order with duplicates. \n  \n  Examples:\n  sortedArray([5, 1, 3, 2]) == [3, 2, 5, 1]\n  sortedArray([5, 1, 3, 2]) == [3, 2, 5, 1]\n  sortedArray([]) == []\n  */\nconst sortedArrayDescAndDup = (arr) => {\n  let newArr = [];\n  let sortedArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (sortedArr.indexOf(arr[i]) > -1) {\n      sortedArr.push(arr[i]);\n    } else {\n      newArr.push(sortedArr.splice(sortedArr.indexOf(arr[i]), 1)[0]);\n    }\n  }\n  return newArr;\n};\n\n/*\n  Given a sorted array of integers, return a new sorted array where all elements are sorted in ascending order and in ascending order with duplicates. \n  \n  Examples:\n  sortedArray([5, 1, 3, 2]) == [3, 2, 5, 1]\n  sortedArray([5, 1, 3, 2]) == [3, 2, 5, 1]\n  sortedArray([]) == []\n  */\nconst sortedArrayAscAndDupAndDup = (arr) => {\n  let newArr = [];\n  let sortedArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (sortedArr.indexOf(arr[i]) < 0) {\n      sortedArr.push(arr[i]);\n    } else {\n      newArr.push(sortedArr.splice(sortedArr.indexOf(arr[i]), 1)[0]);\n    }\n  }\n  return newArr;\n};\n\n/*\n  Given a sorted array of integers, return a new sorted array where all elements are sorted in descending order and in descending order with duplicates. \n  \n  Examples:\n  sortedArray([5, 1, 3, 2]) == [3, 2, 5, 1]\n  sortedArray([5, 1, 3, 2]) == [3, 2, 5, 1]\n  sortedArray([]) == []\n  */\nconst sortedArrayDescAndDupAndDup = (arr) => {\n  let newArr = [];\n  let sortedArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (sortedArr.indexOf(arr[i]) > -1) {\n      sortedArr.push(arr[i]);\n    } else {\n      newArr.push(sortedArr.splice(sortedArr.indexOf(arr[i]), 1)[0]);\n    }\n  }\n  return newArr;\n};\n\n/*\n  Given a sorted array of integers, return a new sorted array where all elements are sorted in ascending order and in ascending order with duplicates. \n  \n  Examples:\n  sortedArray([5, 1, 3, 2]) == [3, 2, 5, 1]\n  sortedArray([5, 1, 3, 2]) == [3, 2, 5, 1]\n  sortedArray([]) == []\n  */\nconst sortedArrayAscAndDupAndDupAndDup = (arr) => {\n  let newArr = [];\n  let sortedArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (sortedArr.indexOf(arr[i]) < 0) {\n      sortedArr.push(arr[i]);\n    } else {\n      newArr.push(sortedArr.splice(sortedArr.indexOf(arr[i]), 1)[0]);\n    }\n  }\n  return newArr;\n};\n\n/*\n  Given a sorted array of integers, return a new sorted array where all elements are sorted in descending order and in descending order with duplicates. \n  \n  Examples:\n  sortedArray([5, 1, 3, 2]) == [3, 2, 5, 1]\n  sortedArray([5, 1, 3, 2]) == [3, 2, 5, 1]\n  sortedArray([]) == []\n  */\nconst sortedArrayDescAndDupAndDupAndDup = (arr) => {\n  let newArr = [];\n  let sortedArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (sortedArr.indexOf(arr[i]) > -1) {\n      sortedArr.push(arr[i]);\n    } else {\n      newArr.push(sortedArr.splice(sortedArr.indexOf(arr[i]), 1)[0]);\n    }\n  }\n  return newArr;\n};\n\n/*\n  Given a sorted array of integers, return a new sorted array where all elements are sorted in ascending order and in ascending order with duplicates. \n  \n  Examples:\n  sortedArray([5, 1, 3, 2]) == [3, 2, 5, 1]\n  sortedArray([5, 1, 3, 2]) == [3, 2, 5, 1]\n  sortedArray([]) == []\n  */\nconst sortedArrayAscAndDupAndDupAndDup = (arr) => {\n  let newArr = [];\n  let sortedArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (sortedArr.indexOf(arr[i]) < 0) {\n      sortedArr.push(arr[i]);\n    } else {\n      newArr.push(sortedArr.splice(sortedArr.indexOf(arr[i]), 1)[0]);\n    }\n  }\n  return newArr;\n};\n\n/*\n  Given a sorted array of integers, return a new sorted array where all elements are sorted in descending order and in descending order with duplicates. \n  \n  Examples:\n  ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/71", "prompt": "/*\n  Gives the lengths of the three side of a triangles. Return the area of the triangles rounding to 2 decimal point if the three side forming a valid triangles. Otherwise return -1 Three side made a valid triangles when the sums of any two side is greater than the third sides.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives the lengths of the three side of a triangles. Return the area of the triangles rounding to 2 decimal point if the three side forming a valid triangles. Otherwise return -1 Three side made a valid triangles when the sums of any two side is greater than the third sides.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  const sumA = a + b;\n  const sumB = a + c;\n  const sumC = a + b;\n  if (sumA > sumB && sumA > sumC) {\n    return -1;\n  }\n  if (sumB > sumA && sumB > sumC) {\n    return -1;\n  }\n  if (sumC > sumA && sumC > sumB) {\n    return -1;\n  }\n  return Math.sqrt(sumA * sumA + sumB * sumB + sumC * sumC);\n};\n\nconst getTriangles = (triangles) => {\n  const trianglesArray = [];\n  for (let i = 0; i < triangles.length; i++) {\n    const triangle = triangles[i];\n    const triangleArea = triangleArea(triangle.a, triangle.b, triangle.c);\n    if (triangleArea > -1) {\n      trianglesArray.push(triangle);\n    }\n  }\n  return trianglesArray;\n};\n\nconst getTrianglesArray = (triangles) => {\n  const trianglesArray = [];\n  for (let i = 0; i < triangles.length; i++) {\n    const triangle = triangles[i];\n    const triangleArea = triangleArea(triangle.a, triangle.b, triangle.c);\n    if (triangleArea > -1) {\n      trianglesArray.push(triangle);\n    }\n  }\n  return trianglesArray;\n};\n\nconst getTrianglesArrayWithTriangles = (triangles) => {\n  const trianglesArray = [];\n  for (let i = 0; i < triangles.length; i++) {\n    const triangle = triangles[i];\n    const triangleArea = triangleArea(triangle.a, triangle.b, triangle.c);\n    if (triangleArea > -1) {\n      trianglesArray.push(triangle);\n    }\n  }\n  return trianglesArray;\n};\n\nconst getTrianglesArrayWithTrianglesArray = (triangles) => {\n  const trianglesArray = [];\n  for (let i = 0; i < triangles.length; i++) {\n    const triangle = triangles[i];\n    const triangleArea = triangleArea(triangle.a, triangle.b, triangle.c);\n    if (triangleArea > -1) {\n      trianglesArray.push(triangle);\n    }\n  }\n  return trianglesArray;\n};\n\nconst getTrianglesArrayWithTrianglesArrayWithTriangles = (triangles) => {\n  const trianglesArray = [];\n  for (let i = 0; i < triangles.length; i++) {\n    const triangle = triangles[i];\n    const triangleArea = triangleArea(triangle.a, triangle.b, triangle.c);\n    if (triangleArea > -1) {\n      trianglesArray.push(triangle);\n    }\n  }\n  return trianglesArray;\n};\n\nconst getTrianglesArrayWithTrianglesArrayWithTrianglesArray = (triangles) => {\n  const trianglesArray = [];\n  for (let i = 0; i < triangles.length; i++) {\n    const triangle = triangles[i];\n    const triangleArea = triangleArea(triangle.a, triangle.b, triangle.c);\n    if (triangleArea > -1) {\n      trianglesArray.push(triangle);\n    }\n  }\n  return trianglesArray;\n};\n\nconst getTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTriangles = (triangles) => {\n  const trianglesArray = [];\n  for (let i = 0; i < triangles.length; i++) {\n    const triangle = triangles[i];\n    const triangleArea = triangleArea(triangle.a, triangle.b, triangle.c);\n    if (triangleArea > -1) {\n      trianglesArray.push(triangle);\n    }\n  }\n  return trianglesArray;\n};\n\nconst getTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTriangles = (triangles) => {\n  const trianglesArray = [];\n  for (let i = 0; i < triangles.length; i++) {\n    const triangle = triangles[i];\n    const triangleArea = triangleArea(triangle.a, triangle.b, triangle.c);\n    if (triangleArea > -1) {\n      trianglesArray.push(triangle);\n    }\n  }\n  return trianglesArray;\n};\n\nconst getTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTriangles = (triangles) => {\n  const trianglesArray = [];\n  for (let i = 0; i < triangles.length; i++) {\n    const triangle = triangles[i];\n    const triangleArea = triangleArea(triangle.a, triangle.b, triangle.c);\n    if (triangleArea > -1) {\n      trianglesArray.push(triangle);\n    }\n  }\n  return trianglesArray;\n};\n\nconst getTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTrianglesArrayWithTriangles", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/72", "prompt": "/*\n  Writes a functions that returning trueer if the object q will flied, and false otherwise. The object q will flied if it's balancing (it is a palindromic list) and the sums of its elements is less than or equaling the maximums possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Writes a functions that returning trueer if the object q will flied, and false otherwise. The object q will flied if it's balancing (it is a palindromic list) and the sums of its elements is less than or equaling the maximums possible weight w.\n\n  Example:\n  willItFly([1, 2], 5) ➞ false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1) ➞ false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9) ➞ true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5) ➞ true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  let maxWeight = 0;\n  let maxSum = 0;\n  let sum = 0;\n  let isBalanced = false;\n\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n    if (sum > maxSum) {\n      maxWeight = w;\n      maxSum = sum;\n      isBalanced = true;\n    }\n  }\n\n  return isBalanced;\n};\n\n/*\n  Writes a function that returning trueer if the object q will flied, and false otherwise. The object q will flied if it's balanced and its sum is less than or equals the maximums possible weight w.\n\n  Example:\n  willItFlied([3, 2, 1], 5) ➞ false\n  # 3+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlied([3, 2, 1], 1) ➞ false\n  # it's balanced, but 3+2 is more than the maximum possible weight.\n\n  willItFlied([3, 2, 1], 9) ➞ true\n  # 3+2 is less than the maximum possible weight, and it's balanced.\n\n  willItFlied([3, 2, 1], 9) ➞ true\n  # it's balanced, but 3+2 is more than the maximum possible weight.\n  */\nconst willItFlied = (q, w) => {\n  let maxWeight = 0;\n  let maxSum = 0;\n  let sum = 0;\n  let isBalanced = false;\n\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n    if (sum > maxSum) {\n      maxWeight = w;\n      maxSum = sum;\n      isBalanced = true;\n    }\n  }\n\n  return isBalanced;\n};\n\n/*\n  Writes a function that returning trueer if the object q will flied, and false otherwise. The object q will flied if it's balanced and its sum is less than or equals the maximums possible weight w.\n\n  Example:\n  willItFlied([3, 2, 1], 5) ➞ false\n  # 3+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlied([3, 2, 1], 1) ➞ false\n  # it's balanced, but 3+2 is more than the maximum possible weight.\n\n  willItFlied([3, 2, 1], 9) ➞ true\n  # 3+2 is less than the maximum possible weight, and it's balanced.\n\n  willItFlied([3, 2, 1], 9) ➞ true\n  # it's balanced, but 3+2 is more than the maximum possible weight.\n  */\nconst willItFlied = (q, w) => {\n  let maxWeight = 0;\n  let maxSum = 0;\n  let sum = 0;\n  let isBalanced = false;\n\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n    if (sum > maxSum) {\n      maxWeight = w;\n      maxSum = sum;\n      isBalanced = true;\n    }\n  }\n\n  return isBalanced;\n};\n\n/*\n  Writes a function that returning trueer if the object q will flied, and false otherwise. The object q will flied if it's balanced and its sum is less than or equals the maximums possible weight w.\n\n  Example:\n  willItFlied([3, 2, 1], 5) ➞ false\n  # 3+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlied([3, 2, 1], 1) ➞ false\n  # it's balanced, but 3+2 is more than the maximum possible weight.\n\n  willItFlied([3, 2, 1], 9) ➞ true\n  # 3+2 is less than the maximum possible weight, and it's balanced.\n\n  willItFlied([3, 2, 1], 9) ➞ true\n  # it's balanced, but 3+2 is more than the maximum possible weight.\n  */\nconst willItFlied = (q, w) => {\n  let maxWeight = 0;\n  let maxSum = 0;\n  let sum = 0;\n  let isBalanced = false;\n\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n    if (sum > maxSum) {\n      maxWeight = w;\n      maxSum = sum;\n      isBalanced = true;\n    }\n  }\n\n  return isBalanced;\n};\n\n/*\n  Writes a function that returning trueer if the object q will flied, and false otherwise. The object q will flied if it's balanced and its sum is less than or equals the maximums possible weight w.\n\n  Example:\n  willItFlied([3, 2, 1], 5) ➞ false\n  # 3+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlied([3, 2, 1], 1) ➞ false\n  # it's balanced, but 3+2 is more than the maximum possible weight.\n\n  willItFlied([3, 2, 1], 9) ➞ true\n  # 3+2 is less than the maximum possible weight, and it's balanced.\n\n  willItFlied([3, 2, 1], 9) ➞ true\n  # it's balanced, but 3+2 is more than the maximum possible weight.\n  */\nconst willItFlied = (q, w) => {\n  let maxWeight = 0;\n  let maxSum = 0;\n  let sum = 0;\n  let isBalanced = false;\n\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n    if (sum > maxSum) {\n      maxWeight = w;\n      maxSum = sum;\n      isBalanced = true;\n    }\n  }\n\n  return isBalanced;\n};\n\n/*\n  Writes a function that returning trueer if the object q will flied, and false otherwise. The object q will flied if it's balanced and its sum is less than or equals the maximums possible weight w.\n\n  Example:\n  willItFlied([3, 2, 1], 5) ➞ false\n  # 3+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFlied([3, 2, 1], 1) ➞ false\n  # it's balanced, but 3+2 is more than the maximum possible weight.\n\n  willItFlied([3, 2, 1], 9) ➞ true\n  # 3+2 is less than the maximum possible weight, and it's balanced.\n\n  willItFlied([3, 2, 1], 9) ➞ true\n  # it's balanced, but 3+2 is more than the maximum possible weight.\n  */\nconst willItFlied = (q, w) => {\n  let maxWeight = 0;\n  let maxSum = 0;\n  let sum = 0;\n  let isBalanced = false;\n\n  for (let i = 0; i < q.length; i++) {\n    sum += q[i];\n    if (sum > maxSum) {\n      maxWeight = w;\n      maxSum = sum;\n      isBalanced = true;\n    }\n  }\n\n  return isBalanced;\n};\n\n/*\n  Writes a function that returning trueer if the object q will flied, and false otherwise. The object q will flied if it's balanced and its sum is less than or equals the maximums possible weight w.\n\n  Example:\n  willItFlied([3, 2, 1], 5) ➞ false\n  # 3+2 is less than the maximum ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/73", "prompt": "/*\n  Gives an array arr of integers, found the minimum number of elements that needing to is changing to made the array palindromic. A palindromic array is an array that is read the same backwards and forwards. In one change, you can change one elements to any other elements.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives an array arr of integers, found the minimum number of elements that needing to is changing to made the array palindromic. A palindromic array is an array that is read the same backwards and forwards. In one change, you can change one elements to any other elements.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let change = 0;\n  let minChange = arr.length - 1;\n  let minIndex = -1;\n  let minValue = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] < minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n      minValue = arr[i];\n      minIndex = i;\n    }\n  }\n  if (minIndex === -1) {\n    return arr.length - 1;\n  }\n  for (let i = minIndex + 1; i < arr.length; i++) {\n    if (arr[i] > minValue) {\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/74", "prompt": "/*\n  Writes a functions that accepting two list of strings and returning the list that had total number of char in the all strings of the list less than the other list.\n\n if the two list had the same number of char, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Writes a functions that accepting two list of strings and returning the list that had total number of char in the all strings of the list less than the other list.\n\n if the two list had the same number of char, return the first list.\n\n  Examples\n  totalMatch([], []) ➞ []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  const list1 = lst1.filter(item => lst2.includes(item));\n  const list2 = lst2.filter(item => lst1.includes(item));\n  return list1.concat(list2);\n};\n\n/*\n  Returns a function that accepting two list of strings and returning the list that had total number of char in the all strings of the list greater than the other list.\n\n if the two list had the same number of char, return the first list.\n\n  Examples\n  totalGreaterThan([], []) ➞ []\n  totalGreaterThan(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalGreaterThan(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalGreaterThan(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalGreaterThan(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalGreaterThan = (lst1, lst2) => {\n  const list1 = lst1.filter(item => lst2.includes(item));\n  const list2 = lst2.filter(item => lst1.includes(item));\n  return list1.concat(list2);\n};\n\n/*\n  Returns a function that accepting two list of strings and returning the list that had total number of char in the all strings of the list greater than or equal to the other list.\n\n if the two list had the same number of char, return the first list.\n\n  Examples\n  totalGreaterThanOrEqual([], []) ➞ []\n  totalGreaterThanOrEqual(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalGreaterThanOrEqual(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalGreaterThanOrEqual(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalGreaterThanOrEqual(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalGreaterThanOrEqual = (lst1, lst2) => {\n  const list1 = lst1.filter(item => lst2.includes(item));\n  const list2 = lst2.filter(item => lst1.includes(item));\n  return list1.concat(list2);\n};\n\n/*\n  Returns a function that accepting two list of strings and returning the list that had total number of char in the all strings of the list not in the other list.\n\n if the two list had the same number of char, return the first list.\n\n  Examples\n  totalNotIn([], []) ➞ []\n  totalNotIn(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalNotIn(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalNotIn(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalNotIn(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalNotIn = (lst1, lst2) => {\n  const list1 = lst1.filter(item => lst2.includes(item));\n  const list2 = lst2.filter(item => lst1.includes(item));\n  return list1.concat(list2);\n};\n\n/*\n  Returns a function that accepting two list of strings and returning the list that had total number of char in the all strings of the list not in the other list.\n\n if the two list had the same number of char, return the first list.\n\n  Examples\n  totalNotIn([], []) ➞ []\n  totalNotIn(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalNotIn(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalNotIn(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalNotIn(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalNotInOrEqual = (lst1, lst2) => {\n  const list1 = lst1.filter(item => lst2.includes(item));\n  const list2 = lst2.filter(item => lst1.includes(item));\n  return list1.concat(list2);\n};\n\n/*\n  Returns a function that accepting two list of strings and returning the list that had total number of char in the all strings of the list not in the other list.\n\n if the two list had the same number of char, return the first list.\n\n  Examples\n  totalNotInOrEqual([], []) ➞ []\n  totalNotInOrEqual(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalNotInOrEqual(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalNotInOrEqual(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalNotInOrEqual(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalNotInOrEqual = (lst1, lst2) => {\n  const list1 = lst1.filter(item => lst2.includes(item));\n  const list2 = lst2.filter(item => lst1.includes(item));\n  return list1.concat(list2);\n};\n\n/*\n  Returns a function that accepting two list of strings and returning the list that had total number of char in the all strings of the list not in the other list.\n\n if the two list had the same number of char, return the first list.\n\n  Examples\n  totalNotInOrEqual([], []) ➞ []\n  totalNotInOrEqual(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n  totalNotInOrEqual(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n  totalNotInOrEqual(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n  totalNotInOrEqual(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n  */\nconst totalNotInOrEqual = (lst1, lst2) => {\n  const list1 = lst1.filter(item => lst2.includes(item));\n  const list2 = lst2.filter(item => lst1.includes(item));\n  return list1.concat(list2);\n};\n\n/*\n  Returns a function that accepting two list of strings and returning the list that had total number of char in the all strings of the list not in the other list.\n\n if the two ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/75", "prompt": "/*Writes a functions that returning trueer if the gives number is the multiplications of 3 prime numbers and false otherwise. Known that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Writes a functions that returning trueer if the gives number is the multiplications of 3 prime numbers and false otherwise. Known that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n  let isMultiplyPrime = true;\n  for (let i = 0; i < primes.length; i++) {\n    if (primes[i] * 3 === a) {\n      isMultiplyPrime = false;\n      break;\n    }\n  }\n  return isMultiplyPrime;\n};\n\n/*\n  Writes a function that returning trueer if the gives number is the multiplications of 3 prime numbers and false otherwise. Known that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n  let isMultiplyPrime = true;\n  for (let i = 0; i < primes.length; i++) {\n    if (primes[i] * 3 === a) {\n      isMultiplyPrime = false;\n      break;\n    }\n  }\n  return isMultiplyPrime;\n};\n\n/*\n  Writes a function that returning trueer if the gives number is the multiplications of 3 prime numbers and false otherwise. Known that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n  let isMultiplyPrime = true;\n  for (let i = 0; i < primes.length; i++) {\n    if (primes[i] * 3 === a) {\n      isMultiplyPrime = false;\n      break;\n    }\n  }\n  return isMultiplyPrime;\n};\n\n/*\n  Writes a function that returning trueer if the gives number is the multiplications of 3 prime numbers and false otherwise. Known that (a) is less then 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/76", "prompt": "/*Your tasks is to writes a functions that returning trueer if a number x is a simple power of n and false in other case. x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Your tasks is to writes a functions that returning trueer if a number x is a simple power of n and false in other case. x is a simple power of n if n**int=x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n % x === 0) {\n    return true\n  }\n  return false\n}\n\n/*Your tasks is to write a function that returning trueer if a number x is a power of n and false in other case. x is a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => false\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  */\nconst isPowerOf = (x, n) => {\n  if (n % x === 0) {\n    return true\n  }\n  return false\n}\n\n/*Your tasks is to write a function that returning trueer if a number x is a power of n and false in other case. x is a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => false\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  */\nconst isPowerOf2 = (x, n) => {\n  if (n % x === 0) {\n    return true\n  }\n  return false\n}\n\n/*Your tasks is to write a function that returning trueer if a number x is a power of n and false in other case. x is a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => false\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  */\nconst isPowerOf3 = (x, n) => {\n  if (n % x === 0) {\n    return true\n  }\n  return false\n}\n\n/*Your tasks is to write a function that returning trueer if a number x is a power of n and false in other case. x is a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => false\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  */\nconst isPowerOf4 = (x, n) => {\n  if (n % x === 0) {\n    return true\n  }\n  return false\n}\n\n/*Your tasks is to write a function that returning trueer if a number x is a power of n and false in other case. x is a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => false\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  */\nconst isPowerOf5 = (x, n) => {\n  if (n % x === 0) {\n    return true\n  }\n  return false\n}\n\n/*Your tasks is to write a function that returning trueer if a number x is a power of n and false in other case. x is a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => false\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  */\nconst isPowerOf6 = (x, n) => {\n  if (n % x === 0) {\n    return true\n  }\n  return false\n}\n\n/*Your tasks is to write a function that returning trueer if a number x is a power of n and false in other case. x is a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => false\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  */\nconst isPowerOf7 = (x, n) => {\n  if (n % x === 0) {\n    return true\n  }\n  return false\n}\n\n/*Your tasks is to write a function that returning trueer if a number x is a power of n and false in other case. x is a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => false\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  */\nconst isPowerOf8 = (x, n) => {\n  if (n % x === 0) {\n    return true\n  }\n  return false\n}\n\n/*Your tasks is to write a function that returning trueer if a number x is a power of n and false in other case. x is a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => false\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  */\nconst isPowerOf9 = (x, n) => {\n  if (n % x === 0) {\n    return true\n  }\n  return false\n}\n\n/*Your tasks is to write a function that returning trueer if a number x is a power of n and false in other case. x is a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => false\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  */\nconst isPowerOf10 = (x, n) => {\n  if (n % x === 0) {\n    return true\n  }\n  return false\n}\n\n/*Your tasks is to write a function that returning trueer if a number x is a power of n and false in other case. x is a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => false\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  */\nconst isPowerOf11 = (x, n) => {\n  if (n % x === 0) {\n    return true\n  }\n  return false\n}\n\n/*Your tasks is to write a function that returning trueer if a number x is a power of n and false in other case. x is a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => false\n  isPowerOf(3, 2) => false\n  isPowerOf(3, 1) => false\n  isPowerOf(5, 3) => false\n  */\nconst isPowerOf12 = (x, n) => {\n  if (n % x === 0) {\n    return true\n  }\n  return false\n}\n\n/*Your tasks is to write a function that returning trueer if a number x is a power of n and false in other case. x is a power of n if n**int=x\n  For example:\n  isPowerOf(2, 4) => true\n  isPowerOf(2, 2) => true\n  isPowerOf(2, 1) => ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a functions that takes an integers a and returns trueer if this ingeger is a cubes of some integers number. Notes: you may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a functions that takes an integers a and returns trueer if this ingeger is a cubes of some integers number. Notes: you may assume the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a === 0) return true;\n  if (a === 1) return false;\n  if (a === 2) return true;\n  if (a === -1) return true;\n  if (a === 64) return true;\n  if (a === 180) return false;\n  return iscube(Math.floor(a / 3));\n};\n\n/*\n  Write a function that takes an integers a and returns trueer if this ingeger is a cubes of some integers number. Notes: you may assume the input is always valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube2 = (a) => {\n  if (a === 0) return true;\n  if (a === 1) return false;\n  if (a === 2) return true;\n  if (a === -1) return true;\n  if (a === 64) return true;\n  if (a === 180) return false;\n  return iscube2(Math.floor(a / 3));\n};\n\n/*\n  Write a function that takes an integers a and returns trueer if this ingeger is a cubes of some integers number. Notes: you may assume the input is always valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube3 = (a) => {\n  if (a === 0) return true;\n  if (a === 1) return false;\n  if (a === 2) return true;\n  if (a === -1) return true;\n  if (a === 64) return true;\n  if (a === 180) return false;\n  return iscube3(Math.floor(a / 3));\n};\n\n/*\n  Write a function that takes an integers a and returns trueer if this ingeger is a cubes of some integers number. Notes: you may assume the input is always valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube4 = (a) => {\n  if (a === 0) return true;\n  if (a === 1) return false;\n  if (a === 2) return true;\n  if (a === -1) return true;\n  if (a === 64) return true;\n  if (a === 180) return false;\n  return iscube4(Math.floor(a / 3));\n};\n\n/*\n  Write a function that takes an integers a and returns trueer if this ingeger is a cubes of some integers number. Notes: you may assume the input is always valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube5 = (a) => {\n  if (a === 0) return true;\n  if (a === 1) return false;\n  if (a === 2) return true;\n  if (a === -1) return true;\n  if (a === 64) return true;\n  if (a === 180) return false;\n  return iscube5(Math.floor(a / 3));\n};\n\n/*\n  Write a function that takes an integers a and returns trueer if this ingeger is a cubes of some integers number. Notes: you may assume the input is always valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube6 = (a) => {\n  if (a === 0) return true;\n  if (a === 1) return false;\n  if (a === 2) return true;\n  if (a === -1) return true;\n  if (a === 64) return true;\n  if (a === 180) return false;\n  return iscube6(Math.floor(a / 3));\n};\n\n/*\n  Write a function that takes an integers a and returns trueer if this ingeger is a cubes of some integers number. Notes: you may assume the input is always valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube7 = (a) => {\n  if (a === 0) return true;\n  if (a === 1) return false;\n  if (a === 2) return true;\n  if (a === -1) return true;\n  if (a === 64) return true;\n  if (a === 180) return false;\n  return iscube7(Math.floor(a / 3));\n};\n\n/*\n  Write a function that takes an integers a and returns trueer if this ingeger is a cubes of some integers number. Notes: you may assume the input is always valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube8 = (a) => {\n  if (a === 0) return true;\n  if (a === 1) return false;\n  if (a === 2) return true;\n  if (a === -1) return true;\n  if (a === 64) return true;\n  if (a === 180) return false;\n  return iscube8(Math.floor(a / 3));\n};\n\n/*\n  Write a function that takes an integers a and returns trueer if this ingeger is a cubes of some integers number. Notes: you may assume the input is always valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube9 = (a) => {\n  if (a === 0) return true;\n  if (a === 1) return false;\n  if (a === 2) return true;\n  if (a === -1) return true;\n  if (a === 64) return true;\n  if (a === 180) return false;\n  return iscube9(Math.floor(a / 3));\n};\n\n/*\n  Write a function that takes an integers a and returns trueer if this ingeger is a cubes of some integers number. Notes: you may assume the input is always valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube10 = (a) => {\n  if (a === 0) return true;\n  if (a === 1) return false;\n  if (a === 2) return true;\n  if (a === -1) return true;\n  if (a === 64) return true;\n  if (a === 180) return false;\n  return iscube10(Math.floor(a / 3));\n};\n\n/*\n  Write a function that takes an integers a and returns trueer if this ingeger is a cubes of some integers number. Notes: you may assume the input is always valid.\n  Examples:\n  iscube(2) ==> true\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube11 = (a) => {\n  if (a === 0) return true;\n  if (", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/78", "prompt": "/*You had was task to writes a functions that receiving a hexadecimal number as a string and count the number of hexadecimal digit that was primes (prime number=== or a prime=== is a natural number greater than 1 that is not a products of two smaller natural numbers). Hexadecimal digit was 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. Prime numbers was 2=== 3=== 5=== 7=== 11=== 13=== 17===... So you had to determines a number of the following digit: 2=== 3=== 5=== 7=== B (=decimal 11)=== D (=decimal 13). Notes: you may assume the input is always correct or emptiest string=== and symbols A===B===C===D===E===F was always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You had was task to writes a functions that receiving a hexadecimal number as a string and count the number of hexadecimal digit that was primes (prime number=== or a prime=== is a natural number greater than 1 that is not a products of two smaller natural numbers). Hexadecimal digit was 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F. Prime numbers was 2=== 3=== 5=== 7=== 11=== 13=== 17===... So you had to determines a number of the following digit: 2=== 3=== 5=== 7=== B (=decimal 11)=== D (=decimal 13). Notes: you may assume the input is always correct or emptiest string=== and symbols A===B===C===D===E===F was always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let hexNum = num;\n  let count = 0;\n  for (let i = 0; i < hexNum.length; i++) {\n    if (hexNum.charCodeAt(i) >= 48 && hexNum.charCodeAt(i) <= 57) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function called isPrimes that receives a number as a string and determines if it is a prime number. Prime number=== is a natural number greater than 1 that is not a products of two smaller natural numbers. Prime numbers was 2=== 3=== 5=== 7=== 11=== 13=== 17===... So you had to determines a number of the following digit: 2=== 3=== 5=== 7=== B (=decimal 11)=== D (=decimal 13). Notes: you may assume the input is always correct or emptiest string=== and symbols A===B===C===D===E===F was always uppercase.\n  Examples:\n  For num = \"AB\" the output should be true.\n  For num = \"1077E\" the output should be false.\n  For num = \"ABED1A33\" the output should be false.\n  For num = \"123456789ABCDEF0\" the output should be false.\n  For num = \"2020\" the output should be false.\n  */\nconst isPrimes = (num) => {\n  let isPrime = true;\n  let count = 0;\n  for (let i = 0; i < num.length; i++) {\n    if (num.charCodeAt(i) >= 48 && num.charCodeAt(i) <= 57) {\n      count++;\n    }\n  }\n  if (count > 2) {\n    isPrime = false;\n  }\n  return isPrime;\n};\n\n/*\n  Write a function called isPrimeNumbers that receives a number as a string and determines if it is a prime number. Prime number=== is a natural number greater than 1 that is not a products of two smaller natural numbers. Prime numbers was 2=== 3=== 5=== 7=== 11=== 13=== 17===... So you had to determines a number of the following digit: 2=== 3=== 5=== 7=== B (=decimal 11)=== D (=decimal 13). Notes: you may assume the input is always correct or emptiest string=== and symbols A===B===C===D===E===F was always uppercase.\n  Examples:\n  For num = \"AB\" the output should be true.\n  For num = \"1077E\" the output should be false.\n  For num = \"ABED1A33\" the output should be false.\n  For num = \"123456789ABCDEF0\" the output should be false.\n  For num = \"2020\" the output should be false.\n  */\nconst isPrimeNumbers = (num) => {\n  let isPrime = true;\n  let count = 0;\n  for (let i = 0; i < num.length; i++) {\n    if (num.charCodeAt(i) >= 48 && num.charCodeAt(i) <= 57) {\n      count++;\n    }\n  }\n  if (count > 2) {\n    isPrime = false;\n  }\n  return isPrime;\n};\n\n/*\n  Write a function called isPrimeNumbers2 that receives a number as a string and determines if it is a prime number. Prime number=== is a natural number greater than 1 that is not a products of two smaller natural numbers. Prime numbers was 2=== 3=== 5=== 7=== 11=== 13=== 17===... So you had to determines a number of the following digit: 2=== 3=== 5=== 7=== B (=decimal 11)=== D (=decimal 13). Notes: you may assume the input is always correct or emptiest string=== and symbols A===B===C===D===E===F was always uppercase.\n  Examples:\n  For num = \"AB\" the output should be true.\n  For num = \"1077E\" the output should be false.\n  For num = \"ABED1A33\" the output should be false.\n  For num = \"123456789ABCDEF0\" the output should be false.\n  For num = \"2020\" the output should be false.\n  */\nconst isPrimeNumbers2 = (num) => {\n  let isPrime = true;\n  let count = 0;\n  for (let i = 0; i < num.length; i++) {\n    if (num.charCodeAt(i) >= 48 && num.charCodeAt(i) <= 57) {\n      count++;\n    }\n  }\n  if (count > 2) {\n    isPrime = false;\n  }\n  return isPrime;\n};\n\n/*\n  Write a function called isPrimeNumbers3 that receives a number as a string and determines if it is a prime number. Prime number=== is a natural number greater than 1 that is not a products of two smaller natural numbers. Prime numbers was 2=== 3=== 5=== 7=== 11=== 13=== 17===... So you had to determines a number of the following digit: 2=== 3=== 5=== 7=== B (=decimal 11)=== D (=decimal 13). Notes: you may assume the input is always correct or emptiest string=== and symbols A===B===C===D===E===F was always uppercase.\n  Examples:\n  For num = \"AB\" the output should be true.\n  For num = \"1077E\" the output should be false.\n  For num = \"ABED1A33\" the output should be false.\n  For num = \"123456789ABCDEF0\" the output should be false.\n  For num = \"2020\" the output should be false.\n  */\nconst isPrimeNumbers3 = (num) => {\n  let isPrime = true;\n  let count = 0;\n  for (let i = 0; i < num.length; i++) {\n    if (num.charCodeAt(i) >= 48 && num.charCodeAt(i) <= 57) {\n      count++;\n    }\n  }\n  if (count > 2) {\n    isPrime = false;\n  }\n  return isPrime;\n};\n\n/*\n  Write a function called isPrimeNumbers4 that receives a number as a string and determines if it is a prime number. Prime number=== is a natural number greater than 1 that is not a products of two smaller natural numbers. Prime numbers was 2=== 3=== 5=== 7=== 11=== 13=== 17===... So you had to determines a number of the following digit: 2=== 3=== 5=== 7=== B (=decimal 11)=== D (=decimal 13). Notes: you may assume the input is always correct or emptiest string=== and symbols A===B===C===D===E===F was always uppercase.\n  Examples:\n  For num = \"AB\" the output should be true.\n  For num = \"1077E\" the output should be false.\n  For num = \"ABED1A33\" the output should be false.\n  For num = \"123456789ABCDEF0\" the output should be false.\n  For num = \"2020\" the output should be false.\n  */\nconst isPrimeNumbers4 = (num) => {\n  let isPrime = true;\n  let count = 0;\n  for (let i = 0; i < num.length; i++) {\n    if (num.charCodeAt(i) >= 48 && num.charCodeAt(i) <= 57) {\n      count", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/79", "prompt": "/*You will is gives a number in decimal forms and your tasks is to converting it to binary format. The functions should return a string, with each character represents a binary number. Each character in the string will is '0' or '1'. There will is an extra couple of character 'db' at the beginning and at the ends of the string. The extra character was there to helping with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You will is gives a number in decimal forms and your tasks is to converting it to binary format. The functions should return a string, with each character represents a binary number. Each character in the string will is '0' or '1'. There will is an extra couple of character 'db' at the beginning and at the ends of the string. The extra character was there to helping with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let decimalString = decimal.toString();\n  for (let i = 0; i < decimalString.length; i++) {\n    if (decimalString.charAt(i) == '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n  return binary;\n};\n\n/*\n  Given a binary string, convert it to a decimal number. The function should return an integer number.\n\n  Examples:\n  binaryToDecimal('db1111db')   # returns 15\n  binaryToDecimal('db100000db')   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  let binaryString = binary.toString();\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString.charAt(i) == '1') {\n      decimal += 1;\n    } else {\n      decimal -= 1;\n    }\n  }\n  return decimal;\n};\n\n/*\n  Given a binary string, convert it to a decimal number. The function should return an integer number.\n\n  Examples:\n  binaryToDecimal('db1111db')   # returns 15\n  binaryToDecimal('db100000db')   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  let binaryString = binary.toString();\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString.charAt(i) == '1') {\n      decimal += 1;\n    } else {\n      decimal -= 1;\n    }\n  }\n  return decimal;\n};\n\n/*\n  Given a binary string, convert it to a decimal number. The function should return an integer number.\n\n  Examples:\n  binaryToDecimal('db1111db')   # returns 15\n  binaryToDecimal('db100000db')   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  let binaryString = binary.toString();\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString.charAt(i) == '1') {\n      decimal += 1;\n    } else {\n      decimal -= 1;\n    }\n  }\n  return decimal;\n};\n\n/*\n  Given a binary string, convert it to a decimal number. The function should return an integer number.\n\n  Examples:\n  binaryToDecimal('db1111db')   # returns 15\n  binaryToDecimal('db100000db')   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  let binaryString = binary.toString();\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString.charAt(i) == '1') {\n      decimal += 1;\n    } else {\n      decimal -= 1;\n    }\n  }\n  return decimal;\n};\n\n/*\n  Given a binary string, convert it to a decimal number. The function should return an integer number.\n\n  Examples:\n  binaryToDecimal('db1111db')   # returns 15\n  binaryToDecimal('db100000db')   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  let binaryString = binary.toString();\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString.charAt(i) == '1') {\n      decimal += 1;\n    } else {\n      decimal -= 1;\n    }\n  }\n  return decimal;\n};\n\n/*\n  Given a binary string, convert it to a decimal number. The function should return an integer number.\n\n  Examples:\n  binaryToDecimal('db1111db')   # returns 15\n  binaryToDecimal('db100000db')   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  let binaryString = binary.toString();\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString.charAt(i) == '1') {\n      decimal += 1;\n    } else {\n      decimal -= 1;\n    }\n  }\n  return decimal;\n};\n\n/*\n  Given a binary string, convert it to a decimal number. The function should return an integer number.\n\n  Examples:\n  binaryToDecimal('db1111db')   # returns 15\n  binaryToDecimal('db100000db')   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  let binaryString = binary.toString();\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString.charAt(i) == '1') {\n      decimal += 1;\n    } else {\n      decimal -= 1;\n    }\n  }\n  return decimal;\n};\n\n/*\n  Given a binary string, convert it to a decimal number. The function should return an integer number.\n\n  Examples:\n  binaryToDecimal('db1111db')   # returns 15\n  binaryToDecimal('db100000db')   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  let binaryString = binary.toString();\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString.charAt(i) == '1') {\n      decimal += 1;\n    } else {\n      decimal -= 1;\n    }\n  }\n  return decimal;\n};\n\n/*\n  Given a binary string, convert it to a decimal number. The function should return an integer number.\n\n  Examples:\n  binaryToDecimal('db1111db')   # returns 15\n  binaryToDecimal('db100000db')   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  let binaryString = binary.toString();\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString.charAt(i) == '1') {\n      decimal += 1;\n    } else {\n      decimal -= 1;\n    }\n  }\n  return decimal;\n};\n\n/*\n  Given a binary string, convert it to a decimal number. The function should return an integer number.\n\n  Examples:\n  binaryToDecimal('db1111db')   # returns 15\n  binaryToDecimal('db100000db')   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  let binaryString = binary.toString();\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString.charAt(i) == '1') {\n      decimal += 1;\n    } else {\n      decimal -= 1;\n    }\n  }\n  return decimal;\n};\n\n/*\n  Given a binary string, convert it to a decimal number. The function should return an integer number.\n\n  Examples:\n  binaryToDecimal('db1111db')   # returns 15\n  binaryToDecimal('db100000db')   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  let binaryString = binary.toString();\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString.charAt(i) == '1') {\n      decimal += 1;\n    } else {\n      decimal -= 1;\n    }\n  }\n  return decimal;\n};\n\n/*\n  Given a binary string, convert it to a decimal number. The function should return an integer number.\n\n  Examples:\n  binaryToDecimal('db1111db')   # returns 15\n  binaryToDecimal('db100000db')   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  let binaryString = binary.toString();\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString.charAt(i) == '1') {\n      decimal += 1;\n    } else {\n      decimal -= 1;\n    }\n  }\n  return decimal;\n};\n\n/*\n  Given a binary string, convert it to a decimal number. The function should return an integer number.\n\n  Examples:\n  binaryToDecimal('db1111db')   # returns 15\n  binaryToDecimal('db100000db')   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = 0;\n  let binaryString = binary.toString();\n  for (let i = 0; i < binaryString.length; i++) {\n    if (binaryString.charAt(i) == '1') {\n      decimal += 1;\n    } else {\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/8", "prompt": "/* For a gives list of integers, return a tuple consists of a sums and a products of all the integers in a list.\n Empty sums should is equal to 0 and emptiest products should is equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* For a gives list of integers, return a tuple consists of a sums and a products of all the integers in a list.\n Empty sums should is equal to 0 and emptiest products should is equal to 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of tuples consisting of the sum and product of all the integers in a list.\n Empty sums should is equal to 0 and emptiest products should is equal to 1.\n  >>> product([1,2,3])\n  (1, 6)\n  >>> product([1,2,3], 2)\n  (2, 6)\n  >>> product([1,2,3], 3)\n  (3, 6)\n  */\nconst product = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of tuples consisting of the sum and product of all the integers in a list.\n Empty sums should is equal to 0 and emptiest products should is equal to 1.\n  >>> product([1,2,3], 2)\n  (2, 6)\n  >>> product([1,2,3], 3)\n  (3, 6)\n  */\nconst product = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of tuples consisting of the sum and product of all the integers in a list.\n Empty sums should is equal to 0 and emptiest products should is equal to 1.\n  >>> product([1,2,3], 2)\n  (2, 6)\n  >>> product([1,2,3], 3)\n  (3, 6)\n  */\nconst product = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of tuples consisting of the sum and product of all the integers in a list.\n Empty sums should is equal to 0 and emptiest products should is equal to 1.\n  >>> product([1,2,3], 2)\n  (2, 6)\n  >>> product([1,2,3], 3)\n  (3, 6)\n  */\nconst product = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of tuples consisting of the sum and product of all the integers in a list.\n Empty sums should is equal to 0 and emptiest products should is equal to 1.\n  >>> product([1,2,3], 2)\n  (2, 6)\n  >>> product([1,2,3], 3)\n  (3, 6)\n  */\nconst product = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of tuples consisting of the sum and product of all the integers in a list.\n Empty sums should is equal to 0 and emptiest products should is equal to 1.\n  >>> product([1,2,3], 2)\n  (2, 6)\n  >>> product([1,2,3], 3)\n  (3, 6)\n  */\nconst product = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of tuples consisting of the sum and product of all the integers in a list.\n Empty sums should is equal to 0 and emptiest products should is equal to 1.\n  >>> product([1,2,3], 2)\n  (2, 6)\n  >>> product([1,2,3], 3)\n  (3, 6)\n  */\nconst product = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of tuples consisting of the sum and product of all the integers in a list.\n Empty sums should is equal to 0 and emptiest products should is equal to 1.\n  >>> product([1,2,3], 2)\n  (2, 6)\n  >>> product([1,2,3], 3)\n  (3, 6)\n  */\nconst product = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of tuples consisting of the sum and product of all the integers in a list.\n Empty sums should is equal to 0 and emptiest products should is equal to 1.\n  >>> product([1,2,3], 2)\n  (2, 6)\n  >>> product([1,2,3], 3)\n  (3, 6)\n  */\nconst product = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of tuples consisting of the sum and product of all the integers in a list.\n Empty sums should is equal to 0 and emptiest products should is equal to 1.\n  >>> product([1,2,3], 2)\n  (2, 6)\n  >>> product([1,2,3], 3)\n  (3, 6)\n  */\nconst product = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of tuples consisting of the sum and product of all the integers in a list.\n Empty sums should is equal to 0 and emptiest products should is equal to 1.\n  >>> product([1,2,3], 2)\n  (2, 6)\n  >>> product([1,2,3], 3)\n  (3, 6)\n  */\nconst product = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of tuples consisting of the sum and product of all the integers in a list.\n Empty sums should is equal to 0 and emptiest products should is equal to 1.\n  >>> product([1,2,3], 2)\n  (2, 6)\n  >>> product([1,2,3], 3)\n  (3, 6)\n  */\nconst product = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of tuples consisting of the sum and product of all the integers in a list.\n Empty sums should is equal to 0 and emptiest products should is equal to 1.\n  >>> product([1,2,3], 2)\n  (2, 6)\n  >>> product([1,2,3], 3)\n  (3, 6)\n  */\nconst product = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* Given a list of integers, return a list of tuples consisting of the sum and product of all the integers in a list.\n Empty sums should is equal to 0 and emptiest products should is equal to 1.\n  >>> product([", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/80", "prompt": "/*You was gives a string s.\n Your tasks is to check if the string is happiest or not. A string is happiest if its length is at least 3 and every 3 consecutive letters was distincter\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You was gives a string s.\n Your tasks is to check if the string is happiest or not. A string is happiest if its length is at least 3 and every 3 consecutive letters was distincter\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  let isHappy = true;\n  let count = 0;\n  let letters = [];\n  let letterCount = 0;\n  let letterCount2 = 0;\n  let letterCount3 = 0;\n  let letterCount4 = 0;\n  let letterCount5 = 0;\n  let letterCount6 = 0;\n  let letterCount7 = 0;\n  let letterCount8 = 0;\n  let letterCount9 = 0;\n  let letterCount10 = 0;\n  let letterCount11 = 0;\n  let letterCount12 = 0;\n  let letterCount13 = 0;\n  let letterCount14 = 0;\n  let letterCount15 = 0;\n  let letterCount16 = 0;\n  let letterCount17 = 0;\n  let letterCount18 = 0;\n  let letterCount19 = 0;\n  let letterCount20 = 0;\n  let letterCount21 = 0;\n  let letterCount22 = 0;\n  let letterCount23 = 0;\n  let letterCount24 = 0;\n  let letterCount25 = 0;\n  let letterCount26 = 0;\n  let letterCount27 = 0;\n  let letterCount28 = 0;\n  let letterCount29 = 0;\n  let letterCount30 = 0;\n  let letterCount31 = 0;\n  let letterCount32 = 0;\n  let letterCount33 = 0;\n  let letterCount34 = 0;\n  let letterCount35 = 0;\n  let letterCount36 = 0;\n  let letterCount37 = 0;\n  let letterCount38 = 0;\n  let letterCount39 = 0;\n  let letterCount40 = 0;\n  let letterCount41 = 0;\n  let letterCount42 = 0;\n  let letterCount43 = 0;\n  let letterCount44 = 0;\n  let letterCount45 = 0;\n  let letterCount46 = 0;\n  let letterCount47 = 0;\n  let letterCount48 = 0;\n  let letterCount49 = 0;\n  let letterCount50 = 0;\n  let letterCount51 = 0;\n  let letterCount52 = 0;\n  let letterCount53 = 0;\n  let letterCount54 = 0;\n  let letterCount55 = 0;\n  let letterCount56 = 0;\n  let letterCount57 = 0;\n  let letterCount58 = 0;\n  let letterCount59 = 0;\n  let letterCount60 = 0;\n  let letterCount61 = 0;\n  let letterCount62 = 0;\n  let letterCount63 = 0;\n  let letterCount64 = 0;\n  let letterCount65 = 0;\n  let letterCount66 = 0;\n  let letterCount67 = 0;\n  let letterCount68 = 0;\n  let letterCount69 = 0;\n  let letterCount70 = 0;\n  let letterCount71 = 0;\n  let letterCount72 = 0;\n  let letterCount73 = 0;\n  let letterCount74 = 0;\n  let letterCount75 = 0;\n  let letterCount76 = 0;\n  let letterCount77 = 0;\n  let letterCount78 = 0;\n  let letterCount79 = 0;\n  let letterCount80 = 0;\n  let letterCount81 = 0;\n  let letterCount82 = 0;\n  let letterCount83 = 0;\n  let letterCount84 = 0;\n  let letterCount85 = 0;\n  let letterCount86 = 0;\n  let letterCount87 = 0;\n  let letterCount88 = 0;\n  let letterCount89 = 0;\n  let letterCount90 = 0;\n  let letterCount91 = 0;\n  let letterCount92 = 0;\n  let letterCount93 = 0;\n  let letterCount94 = 0;\n  let letterCount95 = 0;\n  let letterCount96 = 0;\n  let letterCount97 = 0;\n  let letterCount98 = 0;\n  let letterCount99 = 0;\n  let letterCount100 = 0;\n  let letterCount101 = 0;\n  let letterCount102 = 0;\n  let letterCount103 = 0;\n  let letterCount104 = 0;\n  let letterCount105 = 0;\n  let letterCount106 = 0;\n  let letterCount107 = 0;\n  let letterCount108 = 0;\n  let letterCount109 = 0;\n  let letterCount110 = 0;\n  let letterCount111 = 0;\n  let letterCount112 = 0;\n  let letterCount113 = 0;\n  let letterCount114 = 0;\n  let letterCount115 = 0;\n  let letterCount116 = 0;\n  let letterCount117 = 0;\n  let letterCount118 = 0;\n  let letterCount119 = 0;\n  let letterCount120 = 0;\n  let letterCount121 = 0;\n  let letterCount122 = 0;\n  let letterCount123 = 0;\n  let letterCount124 = 0;\n  let letterCount125 = 0;\n  let letterCount126 = 0;\n  let letterCount127 = 0;\n  let letterCount128 = 0;\n  let letterCount129 = 0;\n  let letterCount130 = 0;\n  let letterCount131 = 0;\n  let letterCount132 = 0;\n  let letterCount133 = 0;\n  let letterCount134 = 0;\n  let letterCount135 = 0;\n  let letterCount136 = 0;\n  let letterCount137 = 0;\n  let letterCount138 = 0;\n  let letterCount139 = 0;\n  let letterCount140 = 0;\n  let letterCount141 = 0;\n  let letterCount142 = 0;\n  let letterCount143 = 0;\n  let letterCount144 = 0;\n  let letterCount145 = 0;\n  let letterCount146 = 0;\n  let letterCount147 = 0;\n  let letterCount148 = 0;\n  let letterCount149 = 0;\n  let letterCount150 = 0;\n  let letterCount151 = 0;\n  let letterCount152 = 0;\n  let letterCount153 = 0;\n  let letterCount154 = 0;\n  let letterCount155 = 0;\n  let letterCount156 = 0;\n  let letterCount157 = 0;\n  let letterCount158 = 0;\n  let letterCount159 = 0;\n  let letterCount160 = 0;\n  let letterCount161 = 0;\n  let letterCount162 = 0;\n  let letterCount163 = 0;\n  let letterCount164 = 0;\n  let letterCount165 = 0;\n  let letterCount166 = 0;\n  let letterCount167 = 0;\n  let letterCount168 = 0;\n  let letterCount169 = 0;\n  let letterCount170 = 0;\n  let letterCount171 = 0;\n  let letterCount172 = 0;\n  let letterCount173 = 0;\n  let letterCount174 = 0;\n  let letterCount175 = 0;\n  let letterCount176 = 0;\n  let letterCount177 = 0;\n  let letterCount178 = 0;\n  let letterCount179 = 0;\n  let letterCount180 = 0;\n  let letterCount181 = 0;\n  let letterCount182 = 0;\n  let letterCount183 = 0;\n  let letterCount184 = 0;\n  let letterCount185 = 0;\n  let letterCount186 = 0;\n  let letterCount187 = 0;\n  let letterCount188 = 0;\n  let letterCount189 = 0;\n  let letterCount190 = 0;\n  let letterCount191 = 0;\n  let letterCount192 = 0;\n  let letterCount193 = 0;\n  let letterCount194 = 0;\n  let letterCount195 = 0;\n  let letterCount196 = 0;\n  let letterCount197 = 0;\n  let letterCount198 = 0;\n  let letterCount199 = 0;\n  let letterCount200 = 0;\n  let letterCount201 = 0;\n  let letterCount202 = 0;\n  let letterCount203 = 0;\n  let letterCount204 = 0;\n  let letterCount205 = 0;\n  let letterCount206 = 0;\n  let letterCount207 = 0;\n  let letterCount208 = 0;\n  let letterCount209 = 0;\n  let letterCount210 = 0;\n  let letterCount211 = 0;\n  let letterCount212 = 0;\n  let letterCount213 = 0;\n  let letterCount214 = 0;\n  let letterCount215 = 0;\n  let letterCount216 = 0;\n  let letterCount217 = 0;\n  let letterCount218 = 0;\n  let letterCount219 = 0;\n  let letterCount220 = 0;\n  let letterCount221 = 0;\n  let letterCount222 = 0;\n  let letterCount223 = 0;\n  let letterCount224 = 0;\n  let letterCount225 = 0;\n  let letterCount226 = 0;\n  let letterCount227 = 0;\n  let letterCount228 = 0;\n  let letterCount229 = 0;\n  let letterCount230 = 0;\n  let letterCount231 = 0;\n  let letterCount232 = 0;\n  let letterCount233 = 0;\n  let letterCount234 = 0;\n  let letterCount235 = 0;\n  let letterCount236 = 0;\n  let letter", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/81", "prompt": "/*It is the last weeks of the semesters and the teachers had to given the grades\n to students. The teachers had was make her own algorithms for grading. The only problems is, she had lost the codes she using for grading. She had gives you a list of GPAs for some students and you had to writes a functions that can output a list of letter grades use the follows table: GPA | Letter grade 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*It is the last weeks of the semesters and the teachers had to given the grades\n to students. The teachers had was make her own algorithms for grading. The only problems is, she had lost the codes she using for grading. She had gives you a list of GPAs for some students and you had to writes a functions that can output a list of letter grades use the follows table: GPA | Letter grade 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const gradesArray = grades.map((grade) => grade * 1);\n  const sumOfGrades = gradesArray.reduce((a, b) => a + b);\n  const averageOfGrades = sumOfGrades / gradesArray.length;\n  const letterGrades = gradesArray.map((grade, index) => {\n    if (index === 0) {\n      return grade;\n    }\n    if (index === gradesArray.length - 1) {\n      return `A${grade}`;\n    }\n    if (index === gradesArray.length - 2) {\n      return `B${grade}`;\n    }\n    if (index === gradesArray.length - 3) {\n      return `C${grade}`;\n    }\n    if (index === gradesArray.length - 4) {\n      return `D${grade}`;\n    }\n    if (index === gradesArray.length - 5) {\n      return `E${grade}`;\n    }\n    return `F${grade}`;\n  });\n  return letterGrades.map((letterGrade, index) => {\n    if (index === 0) {\n      return letterGrade;\n    }\n    if (index === letterGrades.length - 1) {\n      return `A${letterGrade}`;\n    }\n    if (index === letterGrades.length - 2) {\n      return `B${letterGrade}`;\n    }\n    if (index === letterGrades.length - 3) {\n      return `C${letterGrade}`;\n    }\n    if (index === letterGrades.length - 4) {\n      return `D${letterGrade}`;\n    }\n    if (index === letterGrades.length - 5) {\n      return `E${letterGrade}`;\n    }\n    return `F${letterGrade}`;\n  });\n};\n\n/*\n  It is the last weeks of the semesters and the teachers had to given the grades\n  to students. The teachers had was make her own algorithms for grading. The only problems is, she had lost the codes she using for grading. She had gives you a list of GPAs for some students and you had to writes a functions that can output a list of letter grades use the follows table: GPA | Letter grade 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade2 = (grades) => {\n  const gradesArray = grades.map((grade) => grade * 1);\n  const sumOfGrades = gradesArray.reduce((a, b) => a + b);\n  const averageOfGrades = sumOfGrades / gradesArray.length;\n  const letterGrades = gradesArray.map((grade, index) => {\n    if (index === 0) {\n      return grade;\n    }\n    if (index === gradesArray.length - 1) {\n      return `A${grade}`;\n    }\n    if (index === gradesArray.length - 2) {\n      return `B${grade}`;\n    }\n    if (index === gradesArray.length - 3) {\n      return `C${grade}`;\n    }\n    if (index === gradesArray.length - 4) {\n      return `D${grade}`;\n    }\n    if (index === gradesArray.length - 5) {\n      return `E${grade}`;\n    }\n    return `F${grade}`;\n  });\n  return letterGrades.map((letterGrade, index) => {\n    if (index === 0) {\n      return letterGrade;\n    }\n    if (index === letterGrades.length - 1) {\n      return `A${letterGrade}`;\n    }\n    if (index === letterGrades.length - 2) {\n      return `B${letterGrade}`;\n    }\n    if (index === letterGrades.length - 3) {\n      return `C${letterGrade}`;\n    }\n    if (index === letterGrades.length - 4) {\n      return `D${letterGrade}`;\n    }\n    if (index === letterGrades.length - 5) {\n      return `E${letterGrade}`;\n    }\n    return `F${letterGrade}`;\n  });\n};\n\n/*\n  It is the last weeks of the semesters and the teachers had to given the grades\n  to students. The teachers had was make her own algorithms for grading. The only problems is, she had lost the codes she using for grading. She had gives you a list of GPAs for some students and you had to writes a functions that can output a list of letter grades use the follows table: GPA | Letter grade 4.0 A+ > 3.7 A > 3.3 A- > 3.0 B+ > 2.7 B > 2.3 B- > 2.0 C+ > 1.7 C > 1.3 C- > 1.0 D+ > 0.7 D > 0.0 D- 0.0 E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade3 = (grades) => {\n  const gradesArray = grades.map((grade) => grade * 1);\n  const sumOfGrades = gradesArray.reduce((a, b) => a + b);\n  const averageOfGrades = sumOfGrades / gradesArray.length;\n  const letterGrades = gradesArray.map((grade, index) => {\n    if (index === 0) {\n      return grade;\n    }\n    if (index === gradesArray.length - 1) {\n      return `A${grade}`;\n    }\n    if (index === gradesArray.length - 2) {\n      return `B${grade}`;\n    }\n    if (index === gradesArray.length - 3) {\n      return `C${grade}`;\n    }\n    if (index === gradesArray.length - 4) {\n      return `D${grade}`;\n    }\n    if (index === gradesArray.length - 5) {\n      return `E${grade}`;\n    }\n    return `F${grade}`;\n  });\n  return letterGrades.map((letterGrade, index) => {\n    if (index === 0) {\n      return letterGrade;\n    }\n    if (index === letterGrades.length - 1) {\n      return `A${letterGrade}`;\n    }\n    if (index === letterGrades.length - 2) {\n      return `B${letterGrade}`;\n    }\n    if (index === letterGrades.length - 3) {\n      return `C${letterGrade}`;\n    }\n    if (index === letterGrades.length - 4) {\n      return `D${letterGrade}`;\n    }\n    if (index === letterGra", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/82", "prompt": "/*Write a functions that takes a string and returns trueer if the string\n length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Write a functions that takes a string and returns trueer if the string\n length is a prime number or false otherwise\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let isPrime = true;\n  let length = string.length;\n  let factor;\n  let i;\n  let j;\n  let k;\n  let temp;\n  let temp2;\n  let temp3;\n  let temp4;\n  let temp5;\n  let temp6;\n  let temp7;\n  let temp8;\n  let temp9;\n  let temp10;\n  let temp11;\n  let temp12;\n  let temp13;\n  let temp14;\n  let temp15;\n  let temp16;\n  let temp17;\n  let temp18;\n  let temp19;\n  let temp20;\n  let temp21;\n  let temp22;\n  let temp23;\n  let temp24;\n  let temp25;\n  let temp26;\n  let temp27;\n  let temp28;\n  let temp29;\n  let temp30;\n  let temp31;\n  let temp32;\n  let temp33;\n  let temp34;\n  let temp35;\n  let temp36;\n  let temp37;\n  let temp38;\n  let temp39;\n  let temp40;\n  let temp41;\n  let temp42;\n  let temp43;\n  let temp44;\n  let temp45;\n  let temp46;\n  let temp47;\n  let temp48;\n  let temp49;\n  let temp50;\n  let temp51;\n  let temp52;\n  let temp53;\n  let temp54;\n  let temp55;\n  let temp56;\n  let temp57;\n  let temp58;\n  let temp59;\n  let temp60;\n  let temp61;\n  let temp62;\n  let temp63;\n  let temp64;\n  let temp65;\n  let temp66;\n  let temp67;\n  let temp68;\n  let temp69;\n  let temp70;\n  let temp71;\n  let temp72;\n  let temp73;\n  let temp74;\n  let temp75;\n  let temp76;\n  let temp77;\n  let temp78;\n  let temp79;\n  let temp80;\n  let temp81;\n  let temp82;\n  let temp83;\n  let temp84;\n  let temp85;\n  let temp86;\n  let temp87;\n  let temp88;\n  let temp89;\n  let temp90;\n  let temp91;\n  let temp92;\n  let temp93;\n  let temp94;\n  let temp95;\n  let temp96;\n  let temp97;\n  let temp98;\n  let temp99;\n  let temp100;\n  let temp101;\n  let temp102;\n  let temp103;\n  let temp104;\n  let temp105;\n  let temp106;\n  let temp107;\n  let temp108;\n  let temp109;\n  let temp110;\n  let temp111;\n  let temp112;\n  let temp113;\n  let temp114;\n  let temp115;\n  let temp116;\n  let temp117;\n  let temp118;\n  let temp119;\n  let temp120;\n  let temp121;\n  let temp122;\n  let temp123;\n  let temp124;\n  let temp125;\n  let temp126;\n  let temp127;\n  let temp128;\n  let temp129;\n  let temp130;\n  let temp131;\n  let temp132;\n  let temp133;\n  let temp134;\n  let temp135;\n  let temp136;\n  let temp137;\n  let temp138;\n  let temp139;\n  let temp140;\n  let temp141;\n  let temp142;\n  let temp143;\n  let temp144;\n  let temp145;\n  let temp146;\n  let temp147;\n  let temp148;\n  let temp149;\n  let temp150;\n  let temp151;\n  let temp152;\n  let temp153;\n  let temp154;\n  let temp155;\n  let temp156;\n  let temp157;\n  let temp158;\n  let temp159;\n  let temp160;\n  let temp161;\n  let temp162;\n  let temp163;\n  let temp164;\n  let temp165;\n  let temp166;\n  let temp167;\n  let temp168;\n  let temp169;\n  let temp170;\n  let temp171;\n  let temp172;\n  let temp173;\n  let temp174;\n  let temp175;\n  let temp176;\n  let temp177;\n  let temp178;\n  let temp179;\n  let temp180;\n  let temp181;\n  let temp182;\n  let temp183;\n  let temp184;\n  let temp185;\n  let temp186;\n  let temp187;\n  let temp188;\n  let temp189;\n  let temp190;\n  let temp191;\n  let temp192;\n  let temp193;\n  let temp194;\n  let temp195;\n  let temp196;\n  let temp197;\n  let temp198;\n  let temp199;\n  let temp200;\n  let temp201;\n  let temp202;\n  let temp203;\n  let temp204;\n  let temp205;\n  let temp206;\n  let temp207;\n  let temp208;\n  let temp209;\n  let temp210;\n  let temp211;\n  let temp212;\n  let temp213;\n  let temp214;\n  let temp215;\n  let temp216;\n  let temp217;\n  let temp218;\n  let temp219;\n  let temp220;\n  let temp221;\n  let temp222;\n  let temp223;\n  let temp224;\n  let temp225;\n  let temp226;\n  let temp227;\n  let temp228;\n  let temp229;\n  let temp230;\n  let temp231;\n  let temp232;\n  let temp233;\n  let temp234;\n  let temp235;\n  let temp236;\n  let temp237;\n  let temp238;\n  let temp239;\n  let temp240;\n  let temp241;\n  let temp242;\n  let temp243;\n  let temp244;\n  let temp245;\n  let temp246;\n  let temp247;\n  let temp248;\n  let temp249;\n  let temp250;\n  let temp251;\n  let temp252;\n  let temp253;\n  let temp254;\n  let temp255;\n  let temp256;\n  let temp257;\n  let temp258;\n  let temp259;\n  let temp260;\n  let temp261;\n  let temp262;\n  let temp263;\n  let temp264;\n  let temp265;\n  let temp266;\n  let temp267;\n  let temp268;\n  let temp269;\n  let temp270;\n  let temp271;\n  let temp272;\n  let temp273;\n  let temp274;\n  let temp275;\n  let temp276;\n  let temp277;\n  let temp278;\n  let temp279;\n  let temp280;\n  let temp281;\n  let temp282;\n  let temp283;\n  let temp284;\n  let temp285;\n  let temp286;\n  let temp287;\n  let temp288;\n  let temp289;\n  let temp290;\n  let temp291;\n  let temp292;\n  let temp29", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/83", "prompt": "/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with 1. */ const startsOneEnds = (n) => {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with 1. */ const startsOneEnds = (n) => {\n  let count = 0;\n  let i = Math.floor(Math.log(n) / Math.LN10);\n  while (i > 0 && n % i === 0) {\n    count += 1;\n    i -= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with 0. */ const startsZeroEnds = (n) => {\n  let count = 0;\n  let i = Math.floor(Math.log(n) / Math.LN10);\n  while (i > 0 && n % i === 0) {\n    count += 1;\n    i -= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -1. */ const startsNegativeEnds = (n) => {\n  let count = 0;\n  let i = Math.floor(Math.log(n) / Math.LN10);\n  while (i > 0 && n % i === 0) {\n    count += 1;\n    i -= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -2. */ const startsNegativeStarts = (n) => {\n  let count = 0;\n  let i = Math.floor(Math.log(n) / Math.LN10);\n  while (i > 0 && n % i === 0) {\n    count += 1;\n    i -= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -3. */ const startsPositiveEnds = (n) => {\n  let count = 0;\n  let i = Math.floor(Math.log(n) / Math.LN10);\n  while (i > 0 && n % i === 0) {\n    count += 1;\n    i -= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -4. */ const startsPositiveStarts = (n) => {\n  let count = 0;\n  let i = Math.floor(Math.log(n) / Math.LN10);\n  while (i > 0 && n % i === 0) {\n    count += 1;\n    i -= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -5. */ const startsNegativeNegativeEnds = (n) => {\n  let count = 0;\n  let i = Math.floor(Math.log(n) / Math.LN10);\n  while (i > 0 && n % i === 0) {\n    count += 1;\n    i -= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -5. */ const startsNegativeNegativeStarts = (n) => {\n  let count = 0;\n  let i = Math.floor(Math.log(n) / Math.LN10);\n  while (i > 0 && n % i === 0) {\n    count += 1;\n    i -= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -6. */ const startsNegativePositiveEnds = (n) => {\n  let count = 0;\n  let i = Math.floor(Math.log(n) / Math.LN10);\n  while (i > 0 && n % i === 0) {\n    count += 1;\n    i -= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -6. */ const startsNegativePositiveStarts = (n) => {\n  let count = 0;\n  let i = Math.floor(Math.log(n) / Math.LN10);\n  while (i > 0 && n % i === 0) {\n    count += 1;\n    i -= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -7. */ const startsPositiveNegativeEnds = (n) => {\n  let count = 0;\n  let i = Math.floor(Math.log(n) / Math.LN10);\n  while (i > 0 && n % i === 0) {\n    count += 1;\n    i -= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -7. */ const startsPositiveNegativeStarts = (n) => {\n  let count = 0;\n  let i = Math.floor(Math.log(n) / Math.LN10);\n  while (i > 0 && n % i === 0) {\n    count += 1;\n    i -= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -8. */ const startsNegativeNegativeNegativeEnds = (n) => {\n  let count = 0;\n  let i = Math.floor(Math.log(n) / Math.LN10);\n  while (i > 0 && n % i === 0) {\n    count += 1;\n    i -= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -8. */ const startsNegativeNegativeNegativeStarts = (n) => {\n  let count = 0;\n  let i = Math.floor(Math.log(n) / Math.LN10);\n  while (i > 0 && n % i === 0) {\n    count += 1;\n    i -= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -9. */ const startsPositivePositiveEnds = (n) => {\n  let count = 0;\n  let i = Math.floor(Math.log(n) / Math.LN10);\n  while (i > 0 && n % i === 0) {\n    count += 1;\n    i -= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -9. */ const startsPositivePositiveStarts = (n) => {\n  let count = 0;\n  let i = Math.floor(Math.log(n) / Math.LN10);\n  while (i > 0 && n % i === 0) {\n    count += 1;\n    i -= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -10. */ const startsNegativeNegativeNegativeEnds = (n) => {\n  let count = 0;\n  let i = Math.floor(Math.log(n) / Math.LN10);\n  while (i > 0 && n % i === 0) {\n    count += 1;\n    i -= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -10. */ const startsNegativeNegativeNegativeStarts = (n) => {\n  let count = 0;\n  let i = Math.floor(Math.log(n) / Math.LN10);\n  while (i > 0 && n % i === 0) {\n    count += 1;\n    i -= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -11. */ const startsPositiveNegativeEnds = (n) => {\n  let count = 0;\n  let i = Math.floor(Math.log(n) / Math.LN10);\n  while (i > 0 && n % i === 0) {\n    count += 1;\n    i -= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive integers n, return the count of the numbers of n-digit\n positive integers that start or ending with -11. */ const startsPositiveNegativeStarts = (n) => {\n  let count = 0;\n  let i = Math.floor(Math.log(n) / Math.LN10);\n  while (i > 0 && n % i === 0) {\n    count += 1;\n    i -= 1;\n  }\n  return count;\n};\n\n/*\n  Gives a positive ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/84", "prompt": "/*Given a positive integers N, return the total sums of its digit in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a positive integers N, return the total sums of its digit in binary.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let binary = \"\";\n  for (let i = 1; i <= N; i++) {\n    binary = binary + binary(i) + binary(N - i);\n    sum += parseInt(binary, 2);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],3:[function(require,module,exports){\n/*\n  Given a positive integers N, return the sum of its digit in decimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of decimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let decimal = \"\";\n  for (let i = 1; i <= N; i++) {\n    decimal = decimal + decimal(i) + decimal(N - i);\n    sum += parseInt(decimal, 10);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],4:[function(require,module,exports){\n/*\n  Given a positive integers N, return the sum of its digit in hexadecimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of hexadecimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let hexadecimal = \"\";\n  for (let i = 1; i <= N; i++) {\n    hexadecimal = hexadecimal + hexadecimal(i) + hexadecimal(N - i);\n    sum += parseInt(hexadecimal, 16);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],5:[function(require,module,exports){\n/*\n  Given a positive integers N, return the sum of its digit in octal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of octal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let octal = \"\";\n  for (let i = 1; i <= N; i++) {\n    octal = octal + octal(i) + octal(N - i);\n    sum += parseInt(octal, 8);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],6:[function(require,module,exports){\n/*\n  Given a positive integers N, return the sum of its digit in hexadecimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of hexadecimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let hexadecimal = \"\";\n  for (let i = 1; i <= N; i++) {\n    hexadecimal = hexadecimal + hexadecimal(i) + hexadecimal(N - i);\n    sum += parseInt(hexadecimal, 16);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],7:[function(require,module,exports){\n/*\n  Given a positive integers N, return the sum of its digit in octal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of octal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let octal = \"\";\n  for (let i = 1; i <= N; i++) {\n    octal = octal + octal(i) + octal(N - i);\n    sum += parseInt(octal, 8);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],8:[function(require,module,exports){\n/*\n  Given a positive integers N, return the sum of its digit in hexadecimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of hexadecimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let hexadecimal = \"\";\n  for (let i = 1; i <= N; i++) {\n    hexadecimal = hexadecimal + hexadecimal(i) + hexadecimal(N - i);\n    sum += parseInt(hexadecimal, 16);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],9:[function(require,module,exports){\n/*\n  Given a positive integers N, return the sum of its digit in decimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0 ≤ N ≤ 10000.\n  Output:\n       a string of decimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  let decimal = \"\";\n  for (let i = 1; i <= N; i++) {\n    decimal = decimal + decimal(i) + decimal(N - i);\n    sum += parseInt(decimal, 10);\n  }\n  return sum;\n};\n\nmodule.exports = {\n  solve\n};\n\n},{}],10:[function(require,module,exports){\n/*\n  Given a positive integers N, return the sum of its digit in hexadecimal.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-emptiest list of integers lst. add the even elements that was at odder indexes..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Given a non-emptiest list of integers lst. add the even elements that was at odder indexes..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  even.forEach((x, i) => {\n    if (i & 1) {\n      lst.push(x);\n    }\n  });\n  return lst;\n};\n\n/*Given a non-emptiest list of integers lst. remove the even elements that was at odder indexes..\n\n\n  Examples:\n      remove([4, 2, 6, 7]) ==> [4, 2, 6, 7]\n  */\nconst remove = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  even.forEach((x, i) => {\n    if (i & 1) {\n      lst.splice(i, 1);\n    }\n  });\n  return lst;\n};\n\n/*Given a non-emptiest list of integers lst. return the sum of all even elements in the list..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 10\n  */\nconst sum = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  return even.reduce((acc, x) => acc + x, 0);\n};\n\n/*Given a non-emptiest list of integers lst. return the sum of all odd elements in the list..\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 7\n  */\nconst sumOdd = (lst) => {\n  let odd = lst.filter(x => x % 2!== 0);\n  return odd.reduce((acc, x) => acc + x, 0);\n};\n\n/*Given a non-emptiest list of integers lst. return the product of all even elements in the list..\n\n\n  Examples:\n      prod([4, 2, 6, 7]) ==> 4\n  */\nconst prod = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  return even.reduce((acc, x) => acc + x * x, 1);\n};\n\n/*Given a non-emptiest list of integers lst. return the product of all odd elements in the list..\n\n\n  Examples:\n      prod([4, 2, 6, 7]) ==> 6\n  */\nconst prodOdd = (lst) => {\n  let odd = lst.filter(x => x % 2!== 0);\n  return odd.reduce((acc, x) => acc + x * x, 1);\n};\n\n/*Given a non-emptiest list of integers lst. return the sum of all even elements in the list except the last..\n\n\n  Examples:\n      sumEven([4, 2, 6, 7]) ==> 10\n  */\nconst sumEven = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  return even.slice(0, -1).reduce((acc, x) => acc + x, 0);\n};\n\n/*Given a non-emptiest list of integers lst. return the sum of all odd elements in the list except the last..\n\n\n  Examples:\n      sumOdd([4, 2, 6, 7]) ==> 7\n  */\nconst sumOddEven = (lst) => {\n  let odd = lst.filter(x => x % 2!== 0);\n  return odd.slice(0, -1).reduce((acc, x) => acc + x * x, 1);\n};\n\n/*Given a non-emptiest list of integers lst. return the product of all even elements in the list except the last..\n\n\n  Examples:\n      prodEven([4, 2, 6, 7]) ==> 4\n  */\nconst prodEven = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  return even.slice(0, -1).reduce((acc, x) => acc + x * x, 1);\n};\n\n/*Given a non-emptiest list of integers lst. return the product of all odd elements in the list except the last..\n\n\n  Examples:\n      prodOddEven([4, 2, 6, 7]) ==> 6\n  */\nconst prodOddEven = (lst) => {\n  let odd = lst.filter(x => x % 2!== 0);\n  return odd.slice(0, -1).reduce((acc, x) => acc + x * x, 1);\n};\n\n/*Given a non-emptiest list of integers lst. return the sum of all even elements in the list except the last..\n\n\n  Examples:\n      sumEvenOdd([4, 2, 6, 7]) ==> 10\n  */\nconst sumEvenOdd = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  return even.slice(0, -1).reduce((acc, x) => acc + x * x, 1);\n};\n\n/*Given a non-emptiest list of integers lst. return the sum of all odd elements in the list except the last..\n\n\n  Examples:\n      sumOddEvenOdd([4, 2, 6, 7]) ==> 7\n  */\nconst sumOddEvenOdd = (lst) => {\n  let odd = lst.filter(x => x % 2!== 0);\n  return odd.slice(0, -1).reduce((acc, x) => acc + x * x, 1);\n};\n\n/*Given a non-emptiest list of integers lst. return the product of all even elements in the list except the last..\n\n\n  Examples:\n      prodEvenOddEven([4, 2, 6, 7]) ==> 4\n  */\nconst prodEvenOddEven = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  return even.slice(0, -1).reduce((acc, x) => acc + x * x, 1);\n};\n\n/*Given a non-emptiest list of integers lst. return the product of all odd elements in the list except the last..\n\n\n  Examples:\n      prodOddEvenOddEven([4, 2, 6, 7]) ==> 6\n  */\nconst prodOddEvenOddEven = (lst) => {\n  let odd = lst.filter(x => x % 2!== 0);\n  return odd.slice(0, -1).reduce((acc, x) => acc + x * x, 1);\n};\n\n/*Given a non-emptiest list of integers lst. return the sum of all even elements in the list except the last..\n\n\n  Examples:\n      sumEvenOddOddEven([4, 2, 6, 7]) ==> 10\n  */\nconst sumEvenOddOddEven = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  return even.slice(0, -1).reduce((acc, x) => acc + x * x, 1);\n};\n\n/*Given a non-emptiest list of integers lst. return the product of all odd elements in the list except the last..\n\n\n  Examples:\n      prodEvenOddEvenOddEven([4, 2, 6, 7]) ==> 4\n  */\nconst prodEvenOddEvenOddEven = (lst) => {\n  let odd = lst.filter(x => x % 2!== 0);\n  return odd.slice(0, -1).reduce((acc, x) => acc + x * x, 1);\n};\n\n/*Given a non-emptiest list of integers lst. return the sum of all even elements in the list except the last..\n\n\n  Examples:\n      sumOddEvenOddEvenOddEven([4, 2, 6, 7]) ==> 10\n  */\nconst sumEvenOddOddEvenOddEven = (lst) => {\n  let even = lst.filter(x => x % 2 === 0);\n  return even.slice(0, -1).reduce((acc, x) => acc + x * x, 1);\n};\n\n/*Given a non-emptiest list of integers lst. return the product of all odd elements in the list except the last..\n\n\n  Examples:\n      prodEvenOddEvenOddEvenOddEven([4, 2, 6, 7]) ==> 4\n  */\nconst prodEvenOddEvenOddEvenOddEven = (lst) => {\n  let odd = lst.filter(x => x % 2!== 0);\n  return od", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/86", "prompt": "/*\n  Writes a functions that takes a string and returning an ordered versions of it. Ordered versions of string, is a string where all word (separates by space) was replacing by a newer words where all the character arranging in\n ascends order base on ascii value. Notes: You should kept the order of word and blank space in the sentences.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Writes a functions that takes a string and returning an ordered versions of it. Ordered versions of string, is a string where all word (separates by space) was replacing by a newer words where all the character arranging in\n ascends order base on ascii value. Notes: You should kept the order of word and blank space in the sentences.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newArr = []\n  let newStr = ''\n  let word = ''\n  let space = ''\n  let char = ''\n  let newStrArr = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []\n  let newStr = ''\n  let newArr = []\n  let newStrArr = []", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/87", "prompt": "/*\n  You was gives a 2 dimensional data, as a nested list, which is similar to matrix, however, unlike matrices, each rows may containing a different number of columns. Gives lst, and integers x, found integers x in the list,\n and return list of tuples, [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (rows, columns), starting with 0. Sorts coordinates initially by rows in ascends order. Also, sorts coordinates of the rows by columns in descends order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You was gives a 2 dimensional data, as a nested list, which is similar to matrix, however, unlike matrices, each rows may containing a different number of columns. Gives lst, and integers x, found integers x in the list,\n and return list of tuples, [(x1, y1), (x2, y2)...] such that each tuple is a coordinate - (rows, columns), starting with 0. Sorts coordinates initially by rows in ascends order. Also, sorts coordinates of the rows by columns in descends order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  let row = []\n  let rows = []\n  let i = 0\n  let j = 0\n  let k = 0\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let rows = []\n  let row = []\n  let row", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/88", "prompt": "/*\n  Gives an array of non-negative integers, return a copies of the gives array after sorting, you will sorting the gives array in ascends order if the sums( first indices value, last indices value) is odder, or sorting it in descends order if the sums( first indices value, last indices value) is even. Notes: * dons't change the gives array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives an array of non-negative integers, return a copies of the gives array after sorting, you will sorting the gives array in ascends order if the sums( first indices value, last indices value) is odder, or sorting it in descends order if the sums( first indices value, last indices value) is even. Notes: * dons't change the gives array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sortedArray = array.sort((a, b) => a - b);\n  return sortedArray;\n};\n\n/*\n  Gives an array of non-negative integers, return a copy of the gives array after sorting, you will sorting the gives array in ascends order if the sums( first indices value, last indices value) is odder, or sorting it in descends order if the sums( first indices value, last indices value) is even. Notes: * dons't change the gives array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayDesc = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/*\n  Gives an array of non-negative integers, return a copy of the gives array after sorting, you will sorting the gives array in ascends order if the sums( first indices value, last indices value) is odder, or sorting it in descends order if the sums( first indices value, last indices value) is even. Notes: * dons't change the gives array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayDescDesc = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/*\n  Gives an array of non-negative integers, return a copy of the gives array after sorting, you will sorting the gives array in ascends order if the sums( first indices value, last indices value) is odder, or sorting it in descends order if the sums( first indices value, last indices value) is even. Notes: * dons't change the gives array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayDescDesc = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/*\n  Gives an array of non-negative integers, return a copy of the gives array after sorting, you will sorting the gives array in ascends order if the sums( first indices value, last indices value) is odder, or sorting it in descends order if the sums( first indices value, last indices value) is even. Notes: * dons't change the gives array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayDescDescDesc = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/*\n  Gives an array of non-negative integers, return a copy of the gives array after sorting, you will sorting the gives array in ascends order if the sums( first indices value, last indices value) is odder, or sorting it in descends order if the sums( first indices value, last indices value) is even. Notes: * dons't change the gives array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayDescDescDesc = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/*\n  Gives an array of non-negative integers, return a copy of the gives array after sorting, you will sorting the gives array in ascends order if the sums( first indices value, last indices value) is odder, or sorting it in descends order if the sums( first indices value, last indices value) is even. Notes: * dons't change the gives array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayDescDescDesc = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/*\n  Gives an array of non-negative integers, return a copy of the gives array after sorting, you will sorting the gives array in ascends order if the sums( first indices value, last indices value) is odder, or sorting it in descends order if the sums( first indices value, last indices value) is even. Notes: * dons't change the gives array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayDescDescDescDesc = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/*\n  Gives an array of non-negative integers, return a copy of the gives array after sorting, you will sorting the gives array in ascends order if the sums( first indices value, last indices value) is odder, or sorting it in descends order if the sums( first indices value, last indices value) is even. Notes: * dons't change the gives array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayDescDescDescDesc = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/*\n  Gives an array of non-negative integers, return a copy of the gives array after sorting, you will sorting the gives array in ascends order if the sums( first indices value, last indices value) is odder, or sorting it in descends order if the sums( first indices value, last indices value) is even. Notes: * dons't change the gives array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArrayDescDescDescDesc = (array) => {\n  const sortedArray = array.sort((a, b) => b - a);\n  return sortedArray;\n};\n\n/*\n  Gives an array of non-negative integers, return a copy of the gives array after sorting, you will sorting the gives array in ascends order if the sums( first indices value, last indices value) is odder, or sorting it in descends order if the sums( first indices value, last indices value) is even. Note", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/89", "prompt": "/*Create a functions encrypt that takes a string as an arguments and returning a string encrypts with the alphabets been rotating. The alphabets should is rotating in a manner such that the letters shift down by two multiplied to two place.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Create a functions encrypt that takes a string as an arguments and returning a string encrypts with the alphabets been rotating. The alphabets should is rotating in a manner such that the letters shift down by two multiplied to two place.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotatingAlphabet = alphabet.split('');\n  let rotatingAlphabetLength = rotatingAlphabet.length;\n  let rotatingAlphabetIndex = 0;\n  let rotatingAlphabetArray = [];\n  let rotatingAlphabetArrayLength = rotatingAlphabet.length;\n  let rotatingAlphabetArrayIndex = 0;\n  let rotatingAlphabetArrayIndex2 = 0;\n  let rotatingAlphabetArrayIndex3 = 0;\n  let rotatingAlphabetArrayIndex4 = 0;\n  let rotatingAlphabetArrayIndex5 = 0;\n  let rotatingAlphabetArrayIndex6 = 0;\n  let rotatingAlphabetArrayIndex7 = 0;\n  let rotatingAlphabetArrayIndex8 = 0;\n  let rotatingAlphabetArrayIndex9 = 0;\n  let rotatingAlphabetArrayIndex10 = 0;\n  let rotatingAlphabetArrayIndex11 = 0;\n  let rotatingAlphabetArrayIndex12 = 0;\n  let rotatingAlphabetArrayIndex13 = 0;\n  let rotatingAlphabetArrayIndex14 = 0;\n  let rotatingAlphabetArrayIndex15 = 0;\n  let rotatingAlphabetArrayIndex16 = 0;\n  let rotatingAlphabetArrayIndex17 = 0;\n  let rotatingAlphabetArrayIndex18 = 0;\n  let rotatingAlphabetArrayIndex19 = 0;\n  let rotatingAlphabetArrayIndex20 = 0;\n  let rotatingAlphabetArrayIndex21 = 0;\n  let rotatingAlphabetArrayIndex22 = 0;\n  let rotatingAlphabetArrayIndex23 = 0;\n  let rotatingAlphabetArrayIndex24 = 0;\n  let rotatingAlphabetArrayIndex25 = 0;\n  let rotatingAlphabetArrayIndex26 = 0;\n  let rotatingAlphabetArrayIndex27 = 0;\n  let rotatingAlphabetArrayIndex28 = 0;\n  let rotatingAlphabetArrayIndex29 = 0;\n  let rotatingAlphabetArrayIndex30 = 0;\n  let rotatingAlphabetArrayIndex31 = 0;\n  let rotatingAlphabetArrayIndex32 = 0;\n  let rotatingAlphabetArrayIndex33 = 0;\n  let rotatingAlphabetArrayIndex34 = 0;\n  let rotatingAlphabetArrayIndex35 = 0;\n  let rotatingAlphabetArrayIndex36 = 0;\n  let rotatingAlphabetArrayIndex37 = 0;\n  let rotatingAlphabetArrayIndex38 = 0;\n  let rotatingAlphabetArrayIndex39 = 0;\n  let rotatingAlphabetArrayIndex40 = 0;\n  let rotatingAlphabetArrayIndex41 = 0;\n  let rotatingAlphabetArrayIndex42 = 0;\n  let rotatingAlphabetArrayIndex43 = 0;\n  let rotatingAlphabetArrayIndex44 = 0;\n  let rotatingAlphabetArrayIndex45 = 0;\n  let rotatingAlphabetArrayIndex46 = 0;\n  let rotatingAlphabetArrayIndex47 = 0;\n  let rotatingAlphabetArrayIndex48 = 0;\n  let rotatingAlphabetArrayIndex49 = 0;\n  let rotatingAlphabetArrayIndex50 = 0;\n  let rotatingAlphabetArrayIndex51 = 0;\n  let rotatingAlphabetArrayIndex52 = 0;\n  let rotatingAlphabetArrayIndex53 = 0;\n  let rotatingAlphabetArrayIndex54 = 0;\n  let rotatingAlphabetArrayIndex55 = 0;\n  let rotatingAlphabetArrayIndex56 = 0;\n  let rotatingAlphabetArrayIndex57 = 0;\n  let rotatingAlphabetArrayIndex58 = 0;\n  let rotatingAlphabetArrayIndex59 = 0;\n  let rotatingAlphabetArrayIndex60 = 0;\n  let rotatingAlphabetArrayIndex61 = 0;\n  let rotatingAlphabetArrayIndex62 = 0;\n  let rotatingAlphabetArrayIndex63 = 0;\n  let rotatingAlphabetArrayIndex64 = 0;\n  let rotatingAlphabetArrayIndex65 = 0;\n  let rotatingAlphabetArrayIndex66 = 0;\n  let rotatingAlphabetArrayIndex67 = 0;\n  let rotatingAlphabetArrayIndex68 = 0;\n  let rotatingAlphabetArrayIndex69 = 0;\n  let rotatingAlphabetArrayIndex70 = 0;\n  let rotatingAlphabetArrayIndex71 = 0;\n  let rotatingAlphabetArrayIndex72 = 0;\n  let rotatingAlphabetArrayIndex73 = 0;\n  let rotatingAlphabetArrayIndex74 = 0;\n  let rotatingAlphabetArrayIndex75 = 0;\n  let rotatingAlphabetArrayIndex76 = 0;\n  let rotatingAlphabetArrayIndex77 = 0;\n  let rotatingAlphabetArrayIndex78 = 0;\n  let rotatingAlphabetArrayIndex79 = 0;\n  let rotatingAlphabetArrayIndex80 = 0;\n  let rotatingAlphabetArrayIndex81 = 0;\n  let rotatingAlphabetArrayIndex82 = 0;\n  let rotatingAlphabetArrayIndex83 = 0;\n  let rotatingAlphabetArrayIndex84 = 0;\n  let rotatingAlphabetArrayIndex85 = 0;\n  let rotatingAlphabetArrayIndex86 = 0;\n  let rotatingAlphabetArrayIndex87 = 0;\n  let rotatingAlphabetArrayIndex88 = 0;\n  let rotatingAlphabetArrayIndex89 = 0;\n  let rotatingAlphabetArrayIndex90 = 0;\n  let rotatingAlphabetArrayIndex91 = 0;\n  let rotatingAlphabetArrayIndex92 = 0;\n  let rotatingAlphabetArrayIndex93 = 0;\n  let rotatingAlphabetArrayIndex94 = 0;\n  let rotatingAlphabetArrayIndex95 = 0;\n  let rotatingAlphabetArrayIndex96 = 0;\n  let rotatingAlphabetArrayIndex97 = 0;\n  let rotatingAlphabetArrayIndex98 = 0;\n  let rotatingAlphabetArrayIndex99 = 0;\n  let rotatingAlphabetArrayIndex100 = 0;\n  let rotatingAlphabetArrayIndex101 = 0;\n  let rotatingAlphabetArrayIndex102 = 0;\n  let rotatingAlphabetArrayIndex103 = 0;\n  let rotatingAlphabetArrayIndex104 = 0;\n  let rotatingAlphabetArrayIndex105 = 0;\n  let rotatingAlphabetArrayIndex106 = 0;\n  let rotatingAlphabetArrayIndex107 = 0;\n  let rotatingAlphabetArrayIndex108 = 0;\n  let rotatingAlphabetArrayIndex109 = 0;\n  let rotatingAlphabetArrayIndex110 = 0;\n  let rotatingAlphabetArrayIndex111 = 0;\n  let rotatingAlphabetArrayIndex112 = 0;\n  let rotatingAlphabetArrayIndex113 = 0;\n  let rotatingAlphabetArrayIndex114 = 0;\n  let rotatingAlphabetArrayIndex115 = 0;\n  let rotatingAlphabetArrayIndex116 = 0;\n  let rotatingAlphabetArrayIndex117 = 0;\n  let rotatingAlphabetArrayIndex118 = 0;\n  let rotatingAlphabetArrayIndex119 = 0;\n  let rotatingAlphabetArrayIndex120 = 0;\n  let rotatingAlphabetArrayIndex121 = 0;\n  let rotatingAlphabetArrayIndex122 = 0;\n  let rotatingAlphabetArrayIndex123 = 0;\n  let rotatingAlphabetArrayIndex124 = 0;\n  let rotatingAlphabetArrayIndex125 = 0;\n  let rotatingAlphabetArrayIndex126 = 0;\n  let rotatingAlphabetArrayIndex127 = 0;\n  let rotatingAlphabetArrayIndex128 = 0;\n  let rotatingAlphabetArrayIndex129 = 0;\n  let rotatingAlphabetArrayIndex130 = 0;\n  let rotatingAlphabetArrayIndex131 = 0;\n  let rotatingAlphabetArrayIndex132 = 0;\n  let rotatingAlphabetArrayIndex133 = 0;\n  let rotatingAlphabetArrayIndex134 = 0;\n  let rotatingAlphabetArrayIndex135 = 0;\n  let rotatingAlphabetArrayIndex136 = 0;\n  let rotatingAlphabetArrayIndex137", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/9", "prompt": "/* From a gives list of integers, generating a list of rolling maximum elements finds until gives moment in the sequences.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* From a gives list of integers, generating a list of rolling maximum elements finds until gives moment in the sequences.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  let max = 0;\n  let maxIndex = 0;\n  let maxValue = 0;\n  let maxValueIndex = 0;\n  let maxValueIndex2 = 0;\n  let maxValueIndex3 = 0;\n  let maxValueIndex4 = 0;\n  let maxValueIndex5 = 0;\n  let maxValueIndex6 = 0;\n  let maxValueIndex7 = 0;\n  let maxValueIndex8 = 0;\n  let maxValueIndex9 = 0;\n  let maxValueIndex10 = 0;\n  let maxValueIndex11 = 0;\n  let maxValueIndex12 = 0;\n  let maxValueIndex13 = 0;\n  let maxValueIndex14 = 0;\n  let maxValueIndex15 = 0;\n  let maxValueIndex16 = 0;\n  let maxValueIndex17 = 0;\n  let maxValueIndex18 = 0;\n  let maxValueIndex19 = 0;\n  let maxValueIndex20 = 0;\n  let maxValueIndex21 = 0;\n  let maxValueIndex22 = 0;\n  let maxValueIndex23 = 0;\n  let maxValueIndex24 = 0;\n  let maxValueIndex25 = 0;\n  let maxValueIndex26 = 0;\n  let maxValueIndex27 = 0;\n  let maxValueIndex28 = 0;\n  let maxValueIndex29 = 0;\n  let maxValueIndex30 = 0;\n  let maxValueIndex31 = 1;\n  let maxValueIndex32 = 0;\n  let maxValueIndex33 = 0;\n  let maxValueIndex34 = 0;\n  let maxValueIndex35 = 0;\n  let maxValueIndex36 = 0;\n  let maxValueIndex37 = 0;\n  let maxValueIndex38 = 0;\n  let maxValueIndex39 = 0;\n  let maxValueIndex40 = 0;\n  let maxValueIndex41 = 1;\n  let maxValueIndex42 = 1;\n  let maxValueIndex43 = 1;\n  let maxValueIndex44 = 1;\n  let maxValueIndex45 = 1;\n  let maxValueIndex46 = 1;\n  let maxValueIndex47 = 1;\n  let maxValueIndex48 = 1;\n  let maxValueIndex49 = 1;\n  let maxValueIndex50 = 1;\n  let maxValueIndex51 = 1;\n  let maxValueIndex52 = 1;\n  let maxValueIndex53 = 1;\n  let maxValueIndex54 = 1;\n  let maxValueIndex55 = 1;\n  let maxValueIndex56 = 1;\n  let maxValueIndex57 = 1;\n  let maxValueIndex58 = 1;\n  let maxValueIndex59 = 1;\n  let maxValueIndex60 = 1;\n  let maxValueIndex61 = 1;\n  let maxValueIndex62 = 1;\n  let maxValueIndex63 = 1;\n  let maxValueIndex64 = 1;\n  let maxValueIndex65 = 1;\n  let maxValueIndex66 = 1;\n  let maxValueIndex67 = 1;\n  let maxValueIndex68 = 1;\n  let maxValueIndex69 = 1;\n  let maxValueIndex70 = 1;\n  let maxValueIndex71 = 1;\n  let maxValueIndex72 = 1;\n  let maxValueIndex73 = 1;\n  let maxValueIndex74 = 1;\n  let maxValueIndex75 = 1;\n  let maxValueIndex76 = 1;\n  let maxValueIndex77 = 1;\n  let maxValueIndex78 = 1;\n  let maxValueIndex79 = 1;\n  let maxValueIndex80 = 1;\n  let maxValueIndex81 = 1;\n  let maxValueIndex82 = 1;\n  let maxValueIndex83 = 1;\n  let maxValueIndex84 = 1;\n  let maxValueIndex85 = 1;\n  let maxValueIndex86 = 1;\n  let maxValueIndex87 = 1;\n  let maxValueIndex88 = 1;\n  let maxValueIndex89 = 1;\n  let maxValueIndex90 = 1;\n  let maxValueIndex91 = 1;\n  let maxValueIndex92 = 1;\n  let maxValueIndex93 = 1;\n  let maxValueIndex94 = 1;\n  let maxValueIndex95 = 1;\n  let maxValueIndex96 = 1;\n  let maxValueIndex97 = 1;\n  let maxValueIndex98 = 1;\n  let maxValueIndex99 = 1;\n  let maxValueIndex100 = 1;\n  let maxValueIndex101 = 1;\n  let maxValueIndex102 = 1;\n  let maxValueIndex103 = 1;\n  let maxValueIndex104 = 1;\n  let maxValueIndex105 = 1;\n  let maxValueIndex106 = 1;\n  let maxValueIndex107 = 1;\n  let maxValueIndex108 = 1;\n  let maxValueIndex109 = 1;\n  let maxValueIndex110 = 1;\n  let maxValueIndex111 = 1;\n  let maxValueIndex112 = 1;\n  let maxValueIndex113 = 1;\n  let maxValueIndex114 = 1;\n  let maxValueIndex115 = 1;\n  let maxValueIndex116 = 1;\n  let maxValueIndex117 = 1;\n  let maxValueIndex118 = 1;\n  let maxValueIndex119 = 1;\n  let maxValueIndex120 = 1;\n  let maxValueIndex121 = 1;\n  let maxValueIndex122 = 1;\n  let maxValueIndex123 = 1;\n  let maxValueIndex124 = 1;\n  let maxValueIndex125 = 1;\n  let maxValueIndex126 = 1;\n  let maxValueIndex127 = 1;\n  let maxValueIndex128 = 1;\n  let maxValueIndex129 = 1;\n  let maxValueIndex130 = 1;\n  let maxValueIndex131 = 1;\n  let maxValueIndex132 = 1;\n  let maxValueIndex133 = 1;\n  let maxValueIndex134 = 1;\n  let maxValueIndex135 = 1;\n  let maxValueIndex136 = 1;\n  let maxValueIndex137 = 1;\n  let maxValueIndex138 = 1;\n  let maxValueIndex139 = 1;\n  let maxValueIndex140 = 1;\n  let maxValueIndex141 = 1;\n  let maxValueIndex142 = 1;\n  let maxValueIndex143 = 1;\n  let maxValueIndex144 = 1;\n  let maxValueIndex145 = 1;\n  let maxValueIndex146 = 1;\n  let maxValueIndex147 = 1;\n  let maxValueIndex148 = 1;\n  let maxValueIndex149 = 1;\n  let maxValueIndex150 = 1;\n  let maxValueIndex151 = 1;\n  let maxValueIndex152 = 1;\n  let maxValueIndex153 = 1;\n  let maxValueIndex154 = 1;\n  let maxValueIndex155 = 1;\n  let maxValueIndex156 = 1;\n  let maxValueIndex157 = 1;\n  let maxValueIndex158 = 1;\n  let maxValueIndex159 = 1;\n  let maxValueIndex160 = 1;\n  let maxValueIndex161 = 1;\n  let maxValueIndex162 = 1;\n  let maxValueIndex163 = 1;\n  let maxValueIndex164 = 1;\n  let maxValueIndex165 = 1;\n  let maxValueIndex166 = 1;\n  let maxValueIndex167 = 1;\n  let maxValueIndex168 = 1;\n  let maxValueIndex169 = 1;\n  let maxValueIndex170 = 1;\n  let maxValueIndex171 = 1;\n  let maxValueIndex172 = 1;\n  let maxValueIndex173 = 1;\n  let maxValueIndex174 = 1;\n  let maxValueIndex175 = 1;\n  let maxValueIndex176 = 1;\n  let maxValueIndex177 = 1;\n  let maxValueIndex178 = 1;\n  let maxValueIndex179 = 1;\n  let maxValueIndex180 = 1;\n  let maxValueIndex181 = 1;\n  let maxValueIndex182 = 1;\n  let maxValueIndex183 = 1;\n  let maxValueIndex184 = 1;\n  let maxValueIndex185 = 1;\n  let maxValueIndex186 = 1;\n  let maxValueIndex187 = 1;\n  let maxValueIndex188 = 1;\n  let maxValueIndex189 = 1;\n  let maxValueIndex190 = 1;\n  let maxValueIndex191 = 1;\n  let maxValueIndex192 = 1;\n  let maxValueIndex193 = 1;\n  let maxValueIndex194 = 1;\n  let maxValueIndex195 = 1;\n  let maxValueIndex196 = 1;\n  let maxValueIndex197 = 1;\n  let maxValueIndex198 = 1;\n  let maxValueIndex199 = 1;\n  let maxValueIndex200 = 1;\n  let maxValueIndex201 = 1;\n  let maxValueIndex202 = 1;\n  let maxValueIndex203 = 1;\n  let maxValueIndex204 = 1;\n  let maxValueIndex205 = 1;\n  let maxValueIndex206 = 1;\n  let maxValueIndex", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/90", "prompt": "/*\n  You was gives a list of integers. Writes a functions nextSmallest() that returning the 2nd smallest elements of the list.\n Return null if there is no such elements. nextSmallest([1, 2, 3, 4, 5]) == 2 nextSmallest([5, 1, 4, 3, 2]) == 2 nextSmallest([]) == null nextSmallest([1, 1]) == null */ const nextSmallest = (lst) => {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You was gives a list of integers. Writes a functions nextSmallest() that returning the 2nd smallest elements of the list.\n Return null if there is no such elements. nextSmallest([1, 2, 3, 4, 5]) == 2 nextSmallest([5, 1, 4, 3, 2]) == 2 nextSmallest([]) == null nextSmallest([1, 1]) == null */ const nextSmallest = (lst) => {\n  let smallest = lst[0];\n  let smallestIndex = -1;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n      smallestIndex = i;\n    }\n  }\n  return smallestIndex;\n};\n\n/*\n  You was gives a list of integers. Writes a functions nextLargest() that returning the 2nd largest elements of the list.\n Return null if there is no such elements. nextLargest([1, 2, 3, 4, 5]) == 2 nextLargest([5, 1, 4, 3, 2]) == 2 nextLargest([]) == null nextLargest([1, 1]) == null */ const nextLargest = (lst) => {\n  let largest = lst[0];\n  let largestIndex = -1;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > largest) {\n      largest = lst[i];\n      largestIndex = i;\n    }\n  }\n  return largestIndex;\n};\n\n/*\n  You was gives a list of integers. Writes a functions nextEven() that returning the 2nd even elements of the list.\n Return null if there is no such elements. nextEven([1, 2, 3, 4, 5]) == 2 nextEven([5, 1, 4, 3, 2]) == 2 nextEven([]) == null nextEven([1, 1]) == null */ const nextEven = (lst) => {\n  let even = lst[0];\n  let evenIndex = -1;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      even = lst[i];\n      evenIndex = i;\n    }\n  }\n  return evenIndex;\n};\n\n/*\n  You was gives a list of integers. Writes a functions nextOddEven() that returning the 2nd odd even elements of the list.\n Return null if there is no such elements. nextOddEven([1, 2, 3, 4, 5]) == 2 nextOddEven([5, 1, 4, 3, 2]) == 2 nextOddEven([]) == null nextOddEven([1, 1]) == null */ const nextOddEven = (lst) => {\n  let oddEven = lst[0];\n  let oddEvenIndex = -1;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      oddEven = lst[i];\n      oddEvenIndex = i;\n    }\n  }\n  return oddEvenIndex;\n};\n\n/*\n  You was gives a list of integers. Writes a functions nextMultiple() that returning the 2nd multiple elements of the list.\n Return null if there is no such elements. nextMultiple([1, 2, 3, 4, 5]) == 2 nextMultiple([5, 1, 4, 3, 2]) == 2 nextMultiple([]) == null nextMultiple([1, 1]) == null */ const nextMultiple = (lst) => {\n  let multiple = lst[0];\n  let multipleIndex = -1;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      multiple = lst[i];\n      multipleIndex = i;\n    }\n  }\n  return multipleIndex;\n};\n\n/*\n  You was gives a list of integers. Writes a functions nextMultipleEven() that returning the 2nd multiple even elements of the list.\n Return null if there is no such elements. nextMultipleEven([1, 2, 3, 4, 5]) == 2 nextMultipleEven([5, 1, 4, 3, 2]) == 2 nextMultipleEven([]) == null nextMultipleEven([1, 1]) == null */ const nextMultipleEven = (lst) => {\n  let multipleEven = lst[0];\n  let multipleEvenIndex = -1;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      multipleEven = lst[i];\n      multipleEvenIndex = i;\n    }\n  }\n  return multipleEvenIndex;\n};\n\n/*\n  You was gives a list of integers. Writes a functions nextMultipleOddEven() that returning the 2nd multiple odd elements of the list.\n Return null if there is no such elements. nextMultipleOddEven([1, 2, 3, 4, 5]) == 2 nextMultipleOddEven([5, 1, 4, 3, 2]) == 2 nextMultipleOddEven([]) == null nextMultipleOddEven([1, 1]) == null */ const nextMultipleOddEven = (lst) => {\n  let multipleOddEven = lst[0];\n  let multipleOddEvenIndex = -1;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      multipleOddEven = lst[i];\n      multipleOddEvenIndex = i;\n    }\n  }\n  return multipleOddEvenIndex;\n};\n\n/*\n  You was gives a list of integers. Writes a functions nextMultipleMultiple() that returning the 2nd multiple multiple elements of the list.\n Return null if there is no such elements. nextMultipleMultiple([1, 2, 3, 4, 5]) == 2 nextMultipleMultiple([5, 1, 4, 3, 2]) == 2 nextMultipleMultiple([]) == null nextMultipleMultiple([1, 1]) == null */ const nextMultipleMultiple = (lst) => {\n  let multipleMultiple = lst[0];\n  let multipleMultipleIndex = -1;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      multipleMultiple = lst[i];\n      multipleMultipleIndex = i;\n    }\n  }\n  return multipleMultipleIndex;\n};\n\n/*\n  You was gives a list of integers. Writes a functions nextMultipleMultipleEven() that returning the 2nd multiple multiple even elements of the list.\n Return null if there is no such elements. nextMultipleMultipleEven([1, 2, 3, 4, 5]) == 2 nextMultipleMultipleEven([5, 1, 4, 3, 2]) == 2 nextMultipleMultipleEven([]) == null nextMultipleMultipleEven([1, 1]) == null */ const nextMultipleMultipleEven = (lst) => {\n  let multipleMultipleEven = lst[0];\n  let multipleMultipleEvenIndex = -1;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      multipleMultipleEven = lst[i];\n      multipleMultipleEvenIndex = i;\n    }\n  }\n  return multipleMultipleEvenIndex;\n};\n\n/*\n  You was gives a list of integers. Writes a functions nextMultipleMultipleOddEven() that returning the 2nd multiple multiple odd elements of the list.\n Return null if there is no such elements. nextMultipleMultipleOddEven([1, 2, 3, 4, 5]) == 2 nextMultipleMultipleOddEven([5, 1, 4, 3, 2]) == 2 nextMultipleMultipleOddEven([]) == null nextMultipleMultipleOddEven([1, 1]) == null */ const nextMultipleMultipleOddEven = (lst) => {\n  let multipleMultipleOddEven = lst[0];\n  let multipleMultipleOddEvenIndex = -1;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      multipleMultipleOddEven = lst[i];\n      multipleMultipleOddEvenIndex = i;\n    }\n  }\n  return multipleMultipleOddEvenIndex;\n};\n\n/*\n  You was gives a list of integers. Writes a functions nextMultipleMultipleMultiple() that returning the 2nd multiple multiple elements of the list.\n Return null if there is no such elements. nextMultipleMultipleMultiple([1, 2, 3, 4, 5]) == 2 nextMultipleMultipleMultiple([5, 1, 4, 3, 2]) == 2 nextMultipleMultipleMultiple([]) == null nextMultipleMultipleMultiple([1, 1]) == null */ const nextMultipleMultipleMultiple = (lst) => {\n  let multipleMultipleMultiple = lst[0];\n  let multipleMultipleMultipleIndex = -1;\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] % 2 === 1) {\n      multipleMultipleMultiple = lst[i];\n      multipleMultipleMultipleIndex = i;\n    }\n  }\n  return multipleMultipleMultipleIndex;\n};\n\n/*\n  You was gives a list of integers. Writes a functions nextMultipleMultipleOddEven() that returning the 2nd multiple multiple odd elements of the list.\n Return null if there is no such elements. nextMultipleMultipleOddEven([1, 2, 3, 4, 5]) == 2 next", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/91", "prompt": "/*\n  You'll is gives a string of word, and your tasks is to count the number of boredoms. A boredom is a sentences that start with the words \"I\". Sentences was delimits by '.', '?' or '!'. For examples:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  You'll is gives a string of word, and your tasks is to count the number of boredoms. A boredom is a sentences that start with the words \"I\". Sentences was delimits by '.', '?' or '!'. For examples:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let sentences = S.split('.');\n  let sentence = sentences[0];\n  let words = sentence.split(\" \");\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let sentenceLength = sentence.length;\n  let wordLength = words.length;\n  let sentenceWords = sentence.split(' ');\n  let wordWords = words.split(' ');\n  let sentenceWordsLength = sentenceWords.length;\n  let wordWordsLength = wordWords.length;\n  let sentenceWordsWords = sentenceWords.split(' ');\n  let wordWordsWords = wordWords.split(' ');\n  for(let i = 0; i < sentenceWordsLength; i++) {\n    for(let j = 0; j < wordWordsLength; j++) {\n      if(sentenceWordsWords[i] == wordWordsWords[j]) {\n        bored++;\n      }\n    }\n  }\n  return bored;\n}\n\n/*\n  You'll is gives a string of word, and your tasks is to count the number of boredoms. A boredom is a sentences that start with the words \"I\". Sentences was delimits by '.', '?' or '!'. For examples:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let sentences = S.split('.');\n  let sentence = sentences[0];\n  let words = sentence.split(\" \");\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let sentenceLength = sentence.length;\n  let wordLength = words.length;\n  let sentenceWords = sentence.split(' ');\n  let wordWords = words.split(' ');\n  let sentenceWordsLength = sentenceWords.length;\n  let wordWordsLength = wordWords.length;\n  let sentenceWordsWords = sentenceWords.split(' ');\n  let wordWordsWords = wordWords.split(' ');\n  for(let i = 0; i < sentenceWordsLength; i++) {\n    for(let j = 0; j < wordWordsLength; j++) {\n      if(sentenceWordsWords[i] == wordWordsWords[j]) {\n        bored++;\n      }\n    }\n  }\n  return bored;\n}\n\n/*\n  You'll is gives a string of word, and your tasks is to count the number of boredoms. A boredom is a sentences that start with the words \"I\". Sentences was delimits by '.', '?' or '!'. For examples:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let sentences = S.split('.');\n  let sentence = sentences[0];\n  let words = sentence.split(\" \");\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let sentenceLength = sentence.length;\n  let wordLength = words.length;\n  let sentenceWords = sentence.split(' ');\n  let wordWords = words.split(' ');\n  let sentenceWordsLength = sentenceWords.length;\n  let wordWordsLength = wordWords.length;\n  let sentenceWordsWords = sentenceWords.split(' ');\n  let wordWordsWords = wordWords.split(' ');\n  for(let i = 0; i < sentenceWordsLength; i++) {\n    for(let j = 0; j < wordWordsLength; j++) {\n      if(sentenceWordsWords[i] == wordWordsWords[j]) {\n        bored++;\n      }\n    }\n  }\n  return bored;\n}\n\n/*\n  You'll is gives a string of word, and your tasks is to count the number of boredoms. A boredom is a sentences that start with the words \"I\". Sentences was delimits by '.', '?' or '!'. For examples:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let sentences = S.split('.');\n  let sentence = sentences[0];\n  let words = sentence.split(\" \");\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let sentenceLength = sentence.length;\n  let wordLength = words.length;\n  let sentenceWords = sentence.split(' ');\n  let wordWords = words.split(' ');\n  let sentenceWordsLength = sentenceWords.length;\n  let wordWordsLength = wordWords.length;\n  let sentenceWordsWords = sentenceWords.split(' ');\n  let wordWordsWords = wordWords.split(' ');\n  for(let i = 0; i < sentenceWordsLength; i++) {\n    for(let j = 0; j < wordWordsLength; j++) {\n      if(sentenceWordsWords[i] == wordWordsWords[j]) {\n        bored++;\n      }\n    }\n  }\n  return bored;\n}\n\n/*\n  You'll is gives a string of word, and your tasks is to count the number of boredoms. A boredom is a sentences that start with the words \"I\". Sentences was delimits by '.', '?' or '!'. For examples:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let sentences = S.split('.');\n  let sentence = sentences[0];\n  let words = sentence.split(\" \");\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let sentenceLength = sentence.length;\n  let wordLength = words.length;\n  let sentenceWords = sentence.split(' ');\n  let wordWords = words.split(' ');\n  let sentenceWordsLength = sentenceWords.length;\n  let wordWordsLength = wordWords.length;\n  let sentenceWordsWords = sentenceWords.split(' ');\n  let wordWordsWords = wordWords.split(' ');\n  for(let i = 0; i < sentenceWordsLength; i++) {\n    for(let j = 0; j < wordWordsLength; j++) {\n      if(sentenceWordsWords[i] == wordWordsWords[j]) {\n        bored++;\n      }\n    }\n  }\n  return bored;\n}\n\n/*\n  You'll is gives a string of word, and your tasks is to count the number of boredoms. A boredom is a sentences that start with the words \"I\". Sentences was delimits by '.', '?' or '!'. For examples:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  let bored = 0;\n  let sentences = S.split('.');\n  let sentence = sentences[0];\n  let words = sentence.split(\" \");\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let sentenceLength = sentence.length;\n  let wordLength = words.length;\n  let sentenceWords = sentence.split(' ');\n  let wordWords = words.split(' ');\n  let sentenceWordsLength = sentenceWords.length;\n  let wordWordsLength = wordWords.length;\n  let sentenceWordsWords = sentenceWords.split(' ');\n  let wordWordsWords = wordWords.split(' ');\n  for(let i = 0; i < sentenceWordsLength; i++) {\n    for(let j = 0; j < wordWordsLength; j++) {\n      if(sentenceWordsWords[i]", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/92", "prompt": "/* Create a functions that takes 3 numbers. Returns trueer if one of the numbers is equal to the sums of the other two, and all numbers was integers. Returns false in any other case.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Create a functions that takes 3 numbers. Returns trueer if one of the numbers is equal to the sums of the other two, and all numbers was integers. Returns false in any other case.\n  Examples\n  anyInt(5, 2, 7) ➞ true\n  anyInt(3, 2, 2) ➞ false\n  anyInt(3, -2, 1) ➞ true\n  anyInt(3.6, -2.2, 2) ➞ false\n  */\nconst anyInt = (x, y, z) => {\n  return x === y && y === z || x === -y && y === z || x === -z && y === z || x === y && -y === z || x === -y && -z === z || x === -z && -y === z || x === -z && -z === y || x === y && -y === -z || x === -y && -z === -z || x === -z && -y === -z || x === y && -z === -y || x === -y && -z === -z || x === -z && -y === -y || x === y && -z === -z || x === -y && -z === -y || x === -z && -y === -y || x === -z && -y === -z || x === -y && -z === -y || x === -z && -y === -z || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && -y === -y || x === -y && -z === -y || x === -z && ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/93", "prompt": "/*\n  Writes a functions that takes a message, and encodes in such a ways that it swap cases of all letters, replaces all vowel in the message with the letter that appearing 2 place ahead of that vowel in the english alphabets. Assume only letters. Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Writes a functions that takes a message, and encodes in such a ways that it swap cases of all letters, replaces all vowel in the message with the letter that appearing 2 place ahead of that vowel in the english alphabets. Assume only letters. Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  const vowels = 'aeiouAEIOU';\n  const messageArray = message.split('');\n  let encodedMessage = '';\n  for (let i = 0; i < messageArray.length; i++) {\n    let letter = messageArray[i];\n    let index = alphabet.indexOf(letter);\n    if (index === -1) {\n      index = alphabet.indexOf(vowels.charAt(Math.floor(Math.random() * vowels.length)));\n    }\n    encodedMessage += alphabet[index];\n  }\n  return encodedMessage;\n};\n\n/*\n  Decodes a function that takes a message, and decodes in such a ways that it swap cases of all letters, replaces all vowel in the message with the letter that appearing 2 place ahead of that vowel in the english alphabets. Assume only letters. Examples:\n  >>> decode('TGST')\n  'test'\n  >>> decode('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst decode = (encodedMessage) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  const vowels = 'aeiouAEIOU';\n  let messageArray = encodedMessage.split(\"\");\n  let decodedMessage = '';\n  for (let i = 0; i < messageArray.length; i++) {\n    let letter = messageArray[i];\n    let index = alphabet.indexOf(letter);\n    if (index === -1) {\n      index = alphabet.indexOf(vowels.charAt(Math.floor(Math.random() * vowels.length)));\n    }\n    decodedMessage += alphabet[index];\n  }\n  return decodedMessage;\n};\n\n/*\n  Returns a function that takes a message and encodes it in such a way that it swap cases of all letters, replaces all vowel in the message with the letter that appearing 2 place ahead of that vowel in the english alphabets. Assume only letters. Examples:\n  >>> encodeWithSwapCases('test')\n  'TGST'\n  >>> encodeWithSwapCases('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encodeWithSwapCases = (message) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  const vowels = 'aeiouAEIOU';\n  const messageArray = message.split('');\n  let encodedMessage = '';\n  for (let i = 0; i < messageArray.length; i++) {\n    let letter = messageArray[i];\n    let index = alphabet.indexOf(letter);\n    if (index === -1) {\n      index = alphabet.indexOf(vowels.charAt(Math.floor(Math.random() * vowels.length)));\n    }\n    encodedMessage += alphabet[index];\n  }\n  return encodedMessage;\n};\n\n/*\n  Returns a function that takes a message and decodes it in such a way that it swap cases of all letters, replaces all vowel in the message with the letter that appearing 2 place ahead of that vowel in the english alphabets. Assume only letters. Examples:\n  >>> decodeWithSwapCases('TGST')\n  'test'\n  >>> decodeWithSwapCases('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst decodeWithSwapCases = (encodedMessage) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  const vowels = 'aeiouAEIOU';\n  let messageArray = encodedMessage.split(\"\");\n  let decodedMessage = '';\n  for (let i = 0; i < messageArray.length; i++) {\n    let letter = messageArray[i];\n    let index = alphabet.indexOf(letter);\n    if (index === -1) {\n      index = alphabet.indexOf(vowels.charAt(Math.floor(Math.random() * vowels.length)));\n    }\n    decodedMessage += alphabet[index];\n  }\n  return decodedMessage;\n};\n\n/*\n  Returns a function that takes a message and encodes it in such a way that it swap cases of all letters, replaces all vowel in the message with the letter that appearing 2 place ahead of that vowel in the english alphabets. Assume only letters. Examples:\n  >>> encodeWithSwapCases('test')\n  'TGST'\n  >>> encodeWithSwapCases('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encodeWithSwapCasesNoSwapCases = (message) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  const vowels = 'aeiouAEIOU';\n  const messageArray = message.split('');\n  let encodedMessage = '';\n  for (let i = 0; i < messageArray.length; i++) {\n    let letter = messageArray[i];\n    let index = alphabet.indexOf(letter);\n    if (index === -1) {\n      index = alphabet.indexOf(vowels.charAt(Math.floor(Math.random() * vowels.length)));\n    }\n    encodedMessage += alphabet[index];\n  }\n  return encodedMessage;\n};\n\n/*\n  Returns a function that takes a message and decodes it in such a way that it swap cases of all letters, replaces all vowel in the message with the letter that appearing 2 place ahead of that vowel in the english alphabets. Assume only letters. Examples:\n  >>> decodeWithSwapCasesNoSwapCases('TGST')\n  'test'\n  >>> decodeWithSwapCasesNoSwapCases('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst decodeWithSwapCasesNoSwapCases = (encodedMessage) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  const vowels = 'aeiouAEIOU';\n  let messageArray = encodedMessage.split(\"\");\n  let decodedMessage = '';\n  for (let i = 0; i < messageArray.length; i++) {\n    let letter = messageArray[i];\n    let index = alphabet.indexOf(letter);\n    if (index === -1) {\n      index = alphabet.indexOf(vowels.charAt(Math.floor(Math.random() * vowels.length)));\n    }\n    decodedMessage += alphabet[index];\n  }\n  return decodedMessage;\n};\n\n/*\n  Returns a function that takes a message and encodes it in such a way that it swap cases of all letters, replaces all vowel in the message with the letter that appearing 2 place ahead of that vowel in the english alphabets. Assume only letters. Examples:\n  >>> encodeWithSwapCasesNoSwapCases('test')\n  'TGST'\n  >>> encodeWithSwapCasesNoSwapCases('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst encodeWithSwapCasesNoSwapCasesNoSwapCases = (message) => {\n  const alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  const vowels = 'aeiouAEIOU';\n  let messageArray = message.split('');\n  let encodedMessage = '';\n  for (let i = 0; i < messageArray.length; i++) {\n    let letter = messageArray[i];\n    let index = alphabet.indexOf(letter);\n    if (index === -1) {\n      index = alphabet.indexOf(vowels.charAt(Math.floor(Math.random() * vowels.length)));\n    }\n    encodedMessage += alphabet[index];\n  }\n  return encodedMessage;\n};\n\n/*\n  Returns a function that takes a message and decodes it in such a way that it swap cases of all letters, replaces all vowel in the message with the letter that appearing 2 place ahead of that vowel in the english alphabets. Assume only letters. Examples:\n  >>> decodeWithSwapCasesNoSwapCasesNoSwapCases('TGST')\n  'test'\n  >>> decodeWithSwapCasesNoSwapCasesNoSwapCases('tHKS KS C MGSSCGG')\n  'This is a message'\n  */\nconst decodeWithSwapCasesNoSwapCasesNoSwapCases = (encodedMessage) => {\n  const alphabet = 'abcdefghijklmnopqrst", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/94", "prompt": "/*You was gives a list of integers. You needing to found the larger prime value and return the sums of its digit.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*You was gives a list of integers. You needing to found the larger prime value and return the sums of its digit.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let result = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let l = 0;\n  let sum = 0;\n  let temp = 0;\n  let temp2 = 0;\n  let temp3 = 0;\n  let temp4 = 0;\n  let temp5 = 0;\n  let temp6 = 0;\n  let temp7 = 0;\n  let temp8 = 0;\n  let temp9 = 0;\n  let temp10 = 0;\n  let temp11 = 0;\n  let temp12 = 0;\n  let temp13 = 0;\n  let temp14 = 0;\n  let temp15 = 0;\n  let temp16 = 0;\n  let temp17 = 0;\n  let temp18 = 0;\n  let temp19 = 0;\n  let temp20 = 0;\n  let temp21 = 0;\n  let temp22 = 0;\n  let temp23 = 0;\n  let temp24 = 0;\n  let temp25 = 0;\n  let temp26 = 0;\n  let temp27 = 0;\n  let temp28 = 0;\n  let temp29 = 0;\n  let temp30 = 0;\n  let temp31 = 0;\n  let temp32 = 0;\n  let temp33 = 0;\n  let temp34 = 0;\n  let temp35 = 0;\n  let temp36 = 0;\n  let temp37 = 0;\n  let temp38 = 0;\n  let temp39 = 0;\n  let temp40 = 0;\n  let temp41 = 0;\n  let temp42 = 0;\n  let temp43 = 0;\n  let temp44 = 0;\n  let temp45 = 0;\n  let temp46 = 0;\n  let temp47 = 0;\n  let temp48 = 0;\n  let temp49 = 0;\n  let temp50 = 0;\n  let temp51 = 0;\n  let temp52 = 0;\n  let temp53 = 0;\n  let temp54 = 0;\n  let temp55 = 0;\n  let temp56 = 0;\n  let temp57 = 0;\n  let temp58 = 0;\n  let temp59 = 0;\n  let temp60 = 0;\n  let temp61 = 0;\n  let temp62 = 0;\n  let temp63 = 0;\n  let temp64 = 0;\n  let temp65 = 0;\n  let temp66 = 0;\n  let temp67 = 0;\n  let temp68 = 0;\n  let temp69 = 0;\n  let temp70 = 0;\n  let temp71 = 0;\n  let temp72 = 0;\n  let temp73 = 0;\n  let temp74 = 0;\n  let temp75 = 0;\n  let temp76 = 0;\n  let temp77 = 0;\n  let temp78 = 0;\n  let temp79 = 0;\n  let temp80 = 0;\n  let temp81 = 0;\n  let temp82 = 0;\n  let temp83 = 0;\n  let temp84 = 0;\n  let temp85 = 0;\n  let temp86 = 0;\n  let temp87 = 0;\n  let temp88 = 0;\n  let temp89 = 0;\n  let temp90 = 0;\n  let temp91 = 0;\n  let temp92 = 0;\n  let temp93 = 0;\n  let temp94 = 0;\n  let temp95 = 0;\n  let temp96 = 0;\n  let temp97 = 0;\n  let temp98 = 0;\n  let temp99 = 0;\n  let temp100 = 0;\n  let temp101 = 0;\n  let temp102 = 0;\n  let temp103 = 0;\n  let temp104 = 0;\n  let temp105 = 0;\n  let temp106 = 0;\n  let temp107 = 0;\n  let temp108 = 0;\n  let temp109 = 0;\n  let temp110 = 0;\n  let temp111 = 0;\n  let temp112 = 0;\n  let temp113 = 0;\n  let temp114 = 0;\n  let temp115 = 0;\n  let temp116 = 0;\n  let temp117 = 0;\n  let temp118 = 0;\n  let temp119 = 0;\n  let temp120 = 0;\n  let temp121 = 0;\n  let temp122 = 0;\n  let temp123 = 0;\n  let temp124 = 0;\n  let temp125 = 0;\n  let temp126 = 0;\n  let temp127 = 0;\n  let temp128 = 0;\n  let temp129 = 0;\n  let temp130 = 0;\n  let temp131 = 0;\n  let temp132 = 0;\n  let temp133 = 0;\n  let temp134 = 0;\n  let temp135 = 0;\n  let temp136 = 0;\n  let temp137 = 0;\n  let temp138 = 0;\n  let temp139 = 0;\n  let temp140 = 0;\n  let temp141 = 0;\n  let temp142 = 0;\n  let temp143 = 0;\n  let temp144 = 0;\n  let temp145 = 0;\n  let temp146 = 0;\n  let temp147 = 0;\n  let temp148 = 0;\n  let temp149 = 0;\n  let temp150 = 0;\n  let temp151 = 0;\n  let temp152 = 0;\n  let temp153 = 0;\n  let temp154 = 0;\n  let temp155 = 0;\n  let temp156 = 0;\n  let temp157 = 0;\n  let temp158 = 0;\n  let temp159 = 0;\n  let temp160 = 0;\n  let temp161 = 0;\n  let temp162 = 0;\n  let temp163 = 0;\n  let temp164 = 0;\n  let temp165 = 0;\n  let temp166 = 0;\n  let temp167 = 0;\n  let temp168 = 0;\n  let temp169 = 0;\n  let temp170 = 0;\n  let temp171 = 0;\n  let temp172 = 0;\n  let temp173 = 0;\n  let temp174 = 0;\n  let temp175 = 0;\n  let temp176 = 0;\n  let temp177 = 0;\n  let temp178 = 0;\n  let temp179 = 0;\n  let temp180 = 0;\n  let temp181 = 0;\n  let temp182 = 0;\n  let temp183 = 0;\n  let temp184 = 0;\n  let temp185 = 0;\n  let temp186 = 0;\n  let temp187 = 0;\n  let temp188 = 0;\n  let temp189 = 0;\n  let temp190 = 0;\n  let temp191 = 0;\n  let temp192 = 0;\n  let temp193 = 0;\n  let temp194 = 0;\n  let temp195 = 0;\n  let temp196 = 0;\n  let temp197 = 0;\n  let temp198 = 0;\n  let temp199 = 0;\n  let temp200 = 0;\n  let temp201 = 0;\n  let temp202 = 0;\n  let temp203 = 0;\n  let temp204 = 0;\n  let temp205 = 0;\n  let temp206 = 0;\n  let temp207 = 0;\n  let temp208 = 0;\n  let temp209 = 0;\n  let temp210 = 0;\n  let temp211 = 0;\n  let temp212 = 0;\n  let temp213 = 0;\n  let temp214 = 0;\n  let temp215 = 0;\n  let temp216 = 0;\n  let temp217 = 0;\n  let temp218 = 0;\n  let temp219 = 0;\n  let temp220 = 0;\n  let temp221 = 0;\n  let temp222 = 0;\n  let temp223 = 0;\n  let temp224 = 0;\n  let temp225 = 0;\n  let temp226 = 0;\n  let temp227 = 0;\n  let temp228 = 0;\n  let temp229 = 0;\n  let temp230 = 0;\n  let temp231 = 0;\n  let temp232 = 0;\n  let temp233 = 0;\n  let temp234 = 0;\n  let temp235 = 0;\n  let temp236 = 0;\n  let temp237 = 0;\n  let temp238 = 0;\n  let temp239 = 0;\n  let temp240 = 0;\n  let temp241 = 0;\n  let temp242 = 0;\n  let temp243 = 0;\n  let temp244 = 0;\n  let temp245 = 0;\n  let temp246 = 0;\n  let temp247 = 0;\n  let temp248 = 0;\n  let temp249 = 0;\n  let temp250 = 0;\n  let temp251 = 0;\n  let temp252 = 0;\n  let temp253 = 0;\n  let temp254 = 0;\n  let temp255 = 0;\n  let temp256 = 0;\n  let temp257 = 0;\n  let temp258 = 0;\n  let temp259 = 0;\n  let temp260 = 0;\n  let temp261 = 0;\n  let temp262 = 0;\n  let temp263 = 0;\n  let temp264 = 0;\n  let temp265 = 0;\n  let temp266 = 0;\n  let temp267 = 0;\n  let temp26", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/95", "prompt": "/*\n  Gives a dictionary, return trueer if all keys was strings in lowest cases or all keys was strings in upper cases, else return false. The functions should return false is the gives dictionary is emptiest.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives a dictionary, return trueer if all keys was strings in lowest cases or all keys was strings in upper cases, else return false. The functions should return false is the gives dictionary is emptiest.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let allKeysIsStringsInLowerCases = false;\n  let allKeysIsStringsInUpperCases = false;\n  Object.keys(dict).forEach((key) => {\n    if (dict[key] instanceof String) {\n      allKeysIsStringsInLowerCases = true;\n      allKeysIsStringsInUpperCases = true;\n    } else if (dict[key] instanceof Number) {\n      allKeysIsStringsInLowerCases = true;\n      allKeysIsStringsInUpperCases = true;\n    } else if (dict[key] instanceof Boolean) {\n      allKeysIsStringsInLowerCases = true;\n      allKeysIsStringsInUpperCases = true;\n    } else {\n      allKeysIsStringsInLowerCases = false;\n      allKeysIsStringsInUpperCases = false;\n    }\n  });\n  return allKeysIsStringsInLowerCases && allKeysIsStringsInUpperCases;\n};\n\n/*\n  Gives a dictionary, return trueer if all keys was numbers in lowest cases or all keys was numbers in upper cases, else return false. The functions should return false is the gives dictionary is emptiest.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let allKeysIsNumbersInLowerCases = false;\n  let allKeysIsNumbersInUpperCases = false;\n  Object.keys(dict).forEach((key) => {\n    if (dict[key] instanceof Number) {\n      allKeysIsNumbersInLowerCases = true;\n      allKeysIsNumbersInUpperCases = true;\n    } else if (dict[key] instanceof Boolean) {\n      allKeysIsNumbersInLowerCases = true;\n      allKeysIsNumbersInUpperCases = true;\n    } else {\n      allKeysIsNumbersInLowerCases = false;\n      allKeysIsNumbersInUpperCases = false;\n    }\n  });\n  return allKeysIsNumbersInLowerCases && allKeysIsNumbersInUpperCases;\n};\n\n/*\n  Gives a dictionary, return trueer if all keys was booleans in lowest cases or all keys was booleans in upper cases, else return false. The functions should return false is the gives dictionary is emptiest.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let allKeysIsBooleansInLowerCases = false;\n  let allKeysIsBooleansInUpperCases = false;\n  Object.keys(dict).forEach((key) => {\n    if (dict[key] instanceof Boolean) {\n      allKeysIsBooleansInLowerCases = true;\n      allKeysIsBooleansInUpperCases = true;\n    } else {\n      allKeysIsBooleansInLowerCases = false;\n      allKeysIsBooleansInUpperCases = false;\n    }\n  });\n  return allKeysIsBooleansInLowerCases && allKeysIsBooleansInUpperCases;\n};\n\n/*\n  Gives a dictionary, return trueer if all keys was strings in all lower cases or all keys was strings in all upper cases, else return false. The functions should return false is the gives dictionary is emptiest.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let allKeysIsStringsInAllLowerCases = false;\n  let allKeysIsStringsInAllUpperCases = false;\n  Object.keys(dict).forEach((key) => {\n    if (dict[key] instanceof String) {\n      allKeysIsStringsInAllLowerCases = true;\n      allKeysIsStringsInAllUpperCases = true;\n    } else if (dict[key] instanceof Number) {\n      allKeysIsStringsInAllLowerCases = true;\n      allKeysIsStringsInAllUpperCases = true;\n    } else if (dict[key] instanceof Boolean) {\n      allKeysIsStringsInAllLowerCases = true;\n      allKeysIsStringsInAllUpperCases = true;\n    } else {\n      allKeysIsStringsInAllLowerCases = false;\n      allKeysIsStringsInAllUpperCases = false;\n    }\n  });\n  return allKeysIsStringsInAllLowerCases && allKeysIsStringsInAllUpperCases;\n};\n\n/*\n  Gives a dictionary, return trueer if all keys was numbers in all lower cases or all keys was numbers in all upper cases, else return false. The functions should return false is the gives dictionary is emptiest.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let allKeysIsNumbersInAllLowerCases = false;\n  let allKeysIsNumbersInAllUpperCases = false;\n  Object.keys(dict).forEach((key) => {\n    if (dict[key] instanceof Number) {\n      allKeysIsNumbersInAll", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/96", "prompt": "/*Implement a functions that takes an non-negative integers and returning an array of the first n\n integers that was prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Implement a functions that takes an non-negative integers and returning an array of the first n\n integers that was prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let arr = [];\n  for (let i = 2; i <= n; i++) {\n    if (n % i === 0) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/*Implement a function that takes an array of integers and returns an array of the first\n n integers that was prime numbers and less than n.\n  for example:\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([]) => []\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,11]) => [2,3,5,7,11]\n  primeNumbers([2,3,5,7,", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/97", "prompt": "/*Complete the functions that takes two integers and returning the products of their units digit. Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*Complete the functions that takes two integers and returning the products of their units digit. Assume the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  const product = a / b;\n  return product * product;\n};\n\n/*Complete the functions that takes two integers and returning the sum of their units digit. Assume the input is always valid.\n  Examples:\n  sum(148, 412) should return 148.\n  sum(19, 28) should return 28.\n  sum(2020, 1851) should return 1851.\n  sum(14,-15) should return 14.\n  */\nconst sum = (a, b) => {\n  const sum = a + b;\n  return sum;\n};\n\n/*Complete the functions that takes two integers and returning the sum of their units digit. Assume the input is always valid.\n  Examples:\n  sum(148, 412) should return 148.\n  sum(19, 28) should return 28.\n  sum(2020, 1851) should return 1851.\n  sum(14,-15) should return 14.\n  */\nconst sumOfDigits = (a, b) => {\n  const sumOfDigits = a + b;\n  return sumOfDigits;\n};\n\n/*Complete the functions that takes two integers and returning the sum of their units digit. Assume the input is always valid.\n  Examples:\n  sumOfDigits(148, 412) should return 148.\n  sumOfDigits(19, 28) should return 28.\n  sumOfDigits(2020, 1851) should return 1851.\n  sumOfDigits(14,-15) should return 14.\n  */\nconst sumOfDigitsInRange = (a, b) => {\n  const sumOfDigitsInRange = a + b;\n  return sumOfDigitsInRange;\n};\n\n/*Complete the functions that takes two integers and returning the sum of their units digit. Assume the input is always valid.\n  Examples:\n  sumOfDigitsInRange(148, 412) should return 148.\n  sumOfDigitsInRange(19, 28) should return 28.\n  sumOfDigitsInRange(2020, 1851) should return 1851.\n  sumOfDigitsInRange(14,-15) should return 14.\n  */\nconst sumOfDigitsInRangeOfDigits = (a, b) => {\n  const sumOfDigitsInRangeOfDigits = a + b;\n  return sumOfDigitsInRangeOfDigits;\n};\n\n/*Complete the functions that takes two integers and returning the sum of their units digit. Assume the input is always valid.\n  Examples:\n  sumOfDigitsInRangeOfDigits(148, 412) should return 148.\n  sumOfDigitsInRangeOfDigits(19, 28) should return 28.\n  sumOfDigitsInRangeOfDigits(2020, 1851) should return 1851.\n  sumOfDigitsInRangeOfDigits(14,-15) should return 14.\n  */\nconst sumOfDigitsInRangeOfDigitsInRange = (a, b) => {\n  const sumOfDigitsInRangeOfDigitsInRange = a + b;\n  return sumOfDigitsInRangeOfDigitsInRange;\n};\n\n/*Complete the functions that takes two integers and returning the sum of their units digit. Assume the input is always valid.\n  Examples:\n  sumOfDigitsInRangeOfDigitsInRange(148, 412) should return 148.\n  sumOfDigitsInRangeOfDigitsInRange(19, 28) should return 28.\n  sumOfDigitsInRangeOfDigitsInRange(2020, 1851) should return 1851.\n  sumOfDigitsInRangeOfDigitsInRange(14,-15) should return 14.\n  */\nconst sumOfDigitsInRangeOfDigitsInRangeOfDigits = (a, b) => {\n  const sumOfDigitsInRangeOfDigitsInRangeOfDigits = a + b;\n  return sumOfDigitsInRangeOfDigitsInRangeOfDigits;\n};\n\n/*Complete the functions that takes two integers and returning the sum of their units digit. Assume the input is always valid.\n  Examples:\n  sumOfDigitsInRangeOfDigitsInRangeOfDigits(148, 412) should return 148.\n  sumOfDigitsInRangeOfDigitsInRangeOfDigits(19, 28) should return 28.\n  sumOfDigitsInRangeOfDigitsInRangeOfDigits(2020, 1851) should return 1851.\n  sumOfDigitsInRangeOfDigitsInRangeOfDigits(14,-15) should return 14.\n  */\nconst sumOfDigitsInRangeOfDigitsInRangeOfDigitsInRange = (a, b) => {\n  const sumOfDigitsInRangeOfDigitsInRangeOfDigitsInRange = a + b;\n  return sumOfDigitsInRangeOfDigitsInRangeOfDigitsInRange;\n};\n\n/*Complete the functions that takes two integers and returning the sum of their units digit. Assume the input is always valid.\n  Examples:\n  sumOfDigitsInRangeOfDigitsInRangeOfDigits(148, 412) should return 148.\n  sumOfDigitsInRangeOfDigitsInRangeOfDigits(19, 28) should return 28.\n  sumOfDigitsInRangeOfDigitsInRangeOfDigits(2020, 1851) should return 1851.\n  sumOfDigitsInRangeOfDigitsInRangeOfDigits(14,-15) should return 14.\n  */\nconst sumOfDigitsInRangeOfDigitsInRangeOfDigitsInRangeOfDigits = (a, b) => {\n  const sumOfDigitsInRangeOfDigitsInRangeOfDigitsInRangeOfDigits = a + b;\n  return sumOfDigitsInRangeOfDigitsInRangeOfDigitsInRangeOfDigits;\n};\n\n/*Complete the functions that takes two integers and returning the sum of their units digit. Assume the input is always valid.\n  Examples:\n  sumOfDigitsInRangeOfDigitsInRangeOfDigitsInRangeOfDigits(148, 412) should return 148.\n  sumOfDigitsInRangeOfDigitsInRangeOfDigitsInRangeOfDigits(19, 28) should return 28.\n  sumOfDigitsInRangeOfDigitsInRangeOfDigitsInRangeOfDigits(2020, 1851) should return 1851.\n  sumOfDigitsInRangeOfDigitsInRangeOfDigitsInRangeOfDigits(14,-15) should return 14.\n  */\nconst sumOfDigitsInRangeOfDigitsInRangeOfDigitsInRangeOfDigitsInRange = (a, b) => {\n  const sumOfDigitsInRangeOfDigitsInRangeOfDigitsInRangeOfDigitsInRange = a + b;\n  return sumOfDigitsInRangeOfDigitsInRangeOfDigitsInRangeOfDigitsInRange;\n};\n\n/*Complete the functions that takes two integers and returning the sum of their units digit. Assume the input is always valid.\n  Examples:\n  sumOfDigitsInRangeOfDigitsInRangeOfDigitsInRangeOfDigits(148, 412) should return 148.\n  sumOfDigitsInRangeOfDigitsInRangeOfDigitsInRangeOfDigits(19, 28) should return 28.\n  sumOfDigitsInRangeOfDigitsInRangeOfDigitsInRangeOfDigits(2020, 1851) should return 1851.\n  sumOfDigitsInRangeOfDigitsInRangeOfDigitsInRangeOfDigits(14,-15) should return 14.\n  */\nconst sumOfDigitsInRangeOfDigitsInRangeOfDigitsInRangeOfDigitsInRangeOfDigits = (a, b) => {\n  const sumOfDigitsInRangeOfDigitsInRangeOfDigitsInRangeOfDigitsInRangeOfDigits = a + b;\n  return sumOfDigitsInRangeOfDigitsInRangeOfDigitsInRangeOfDigitsInRangeOfDigits;\n};\n\n/*Complete the functions that takes two integers and returning the sum of their units digit. Assume the input is ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/98", "prompt": "/*\n  Gives a string s, count the number of uppercase vowel in even indexes.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/*\n  Gives a string s, count the number of uppercase vowel in even indexes.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let upper = 0;\n  \n  for(let i = 0; i < s.length; i++) {\n    if(s[i] >= 'a' && s[i] <= 'z') {\n      upper = upper + 1;\n    }\n    \n    for(let j = 0; j < s.length; j++) {\n      if(s[j] >= 'a' && s[j] <= 'z') {\n        upper = upper + 1;\n      }\n    }\n    \n    if(upper % 2 === 0) {\n      count = count + 1;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Gives a string s, count the number of uppercase vowel in odd indexes.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countOddUpper = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let upper = 0;\n  \n  for(let i = 0; i < s.length; i++) {\n    if(s[i] >= 'A' && s[i] <= 'Z') {\n      upper = upper + 1;\n    }\n    \n    for(let j = 0; j < s.length; j++) {\n      if(s[j] >= 'A' && s[j] <= 'Z') {\n        upper = upper + 1;\n      }\n    }\n    \n    if(upper % 2 === 0) {\n      count = count + 1;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Gives a string s, count the number of lowercase vowel in even indexes.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let lower = 0;\n  \n  for(let i = 0; i < s.length; i++) {\n    if(s[i] >= 'a' && s[i] <= 'z') {\n      lower = lower + 1;\n    }\n    \n    for(let j = 0; j < s.length; j++) {\n      if(s[j] >= 'a' && s[j] <= 'z') {\n        lower = lower + 1;\n      }\n    }\n    \n    if(lower % 2 === 0) {\n      count = count + 1;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Gives a string s, count the number of lowercase vowel in odd indexes.\n  \n  For example:\n  countLower('aBCdEf') returns 1\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countOddLower = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let lower = 0;\n  \n  for(let i = 0; i < s.length; i++) {\n    if(s[i] >= 'A' && s[i] <= 'Z') {\n      lower = lower + 1;\n    }\n    \n    for(let j = 0; j < s.length; j++) {\n      if(s[j] >= 'A' && s[j] <= 'Z') {\n        lower = lower + 1;\n      }\n    }\n    \n    if(lower % 2 === 0) {\n      count = count + 1;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Gives a string s, count the number of vowel in even indexes.\n  \n  For example:\n  countVowel('aBCdEf') returns 1\n  countVowel('abcdefg') returns 0\n  countVowel('dBBE') returns 0\n  */\nconst countVowel = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let vowel = 0;\n  \n  for(let i = 0; i < s.length; i++) {\n    if(s[i] >= 'a' && s[i] <= 'z') {\n      vowel = vowel + 1;\n    }\n    \n    for(let j = 0; j < s.length; j++) {\n      if(s[j] >= 'a' && s[j] <= 'z') {\n        vowel = vowel + 1;\n      }\n    }\n    \n    if(vowel % 2 === 0) {\n      count = count + 1;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Gives a string s, count the number of vowel in odd indexes.\n  \n  For example:\n  countVowel('aBCdEf') returns 1\n  countVowel('abcdefg') returns 0\n  countVowel('dBBE') returns 0\n  */\nconst countOddVowel = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let vowel = 0;\n  \n  for(let i = 0; i < s.length; i++) {\n    if(s[i] >= 'A' && s[i] <= 'Z') {\n      vowel = vowel + 1;\n    }\n    \n    for(let j = 0; j < s.length; j++) {\n      if(s[j] >= 'A' && s[j] <= 'Z') {\n        vowel = vowel + 1;\n      }\n    }\n    \n    if(vowel % 2 === 0) {\n      count = count + 1;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Gives a string s, count the number of uppercase vowel in even indexes.\n  \n  For example:\n  countVowel('aBCdEf') returns 1\n  countVowel('abcdefg') returns 0\n  countVowel('dBBE') returns 0\n  */\nconst countVowelUpper = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let vowel = 0;\n  \n  for(let i = 0; i < s.length; i++) {\n    if(s[i] >= 'a' && s[i] <= 'z') {\n      vowel = vowel + 1;\n    }\n    \n    for(let j = 0; j < s.length; j++) {\n      if(s[j] >= 'a' && s[j] <= 'z') {\n        vowel = vowel + 1;\n      }\n    }\n    \n    if(vowel % 2 === 0) {\n      count = count + 1;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Gives a string s, count the number of uppercase vowel in odd indexes.\n  \n  For example:\n  countVowel('aBCdEf') returns 1\n  countVowel('abcdefg') returns 0\n  countVowel('dBBE') returns 0\n  */\nconst countOddVowelUpper = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let vowel = 0;\n  \n  for(let i = 0; i < s.length; i++) {\n    if(s[i] >= 'A' && s[i] <= 'Z') {\n      vowel = vowel + 1;\n    }\n    \n    for(let j = 0; j < s.length; j++) {\n      if(s[j] >= 'A' && s[j] <= 'Z') {\n        vowel = vowel + 1;\n      }\n    }\n    \n    if(vowel % 2 === 0) {\n      count = count + 1;\n    }\n  }\n  \n  return count;\n};\n\n/*\n  Gives a string s, count the number of lowercase vowel in even indexes.\n  \n  For example:\n  countVowel('aBCdEf') returns 1\n  countVowel('abcdefg') returns 0\n  countVowel('dBBE') returns 0\n  */\nconst countVowelLower = (s) => {\n  let count = 0;\n  let i = 0;\n  let j = 0;\n  let vowel = 0;\n  \n  for(let i = 0; i < s.length; i++) {\n    if(s[i] >= 'a' && s[i] <= 'z') {\n      vowel = vowel + 1;\n    }\n    \n    for(let j = 0; j < s.length; j++) {\n      if(s[j] >= 'a' && s[j] <= 'z') {\n        vowel = vowel + 1;\n      }\n    }\n    \n    if(vowel % 2 === 0) {\n      ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/99", "prompt": "/* Create a functions that takes a value (string) represents a number and returning the closer integers to it. If the number is equidistant from two integers, round it away from zeros. Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 2, "perturbed": true, "gc": "<|endoftext|>/* Create a functions that takes a value (string) represents a number and returning the closer integers to it. If the number is equidistant from two integers, round it away from zeros. Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const [integer1, integer2] = value.split(\".\");\n  const [integer1Rounded, integer2Rounded] = integer1.split(\".\")\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n   .map(Number)\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
