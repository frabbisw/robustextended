{"task_id": "JavaScript/0", "prompt": "/* Check that in the given list of numbers, any two numbers are closer together than the given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n", "canonical_solution": "  for (let i = 0; i < numbers.length; i++) {\n    for (let j = 0; j < numbers.length; j++) {\n      if (i != j) {\n        let distance = Math.abs(numbers[i] - numbers[j]);\n        if (distance < threshold) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) === true)\n  console.assert(\n    hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) === false\n  )\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) === true)\n  console.assert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) === false)\n  console.assert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) === true)\n  console.assert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) === false)\n}\n\ntestHasCloseElements()\n", "declaration": "\nconst hasCloseElements = (numbers, threshold) => {\n", "example_test": "const testHasCloseElements = () => {\n  console.assert(hasCloseElements([1.0, 2.0, 3.0], 0.5) === false)\n  console.assert(\n    hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) === true\n  )\n}\ntestHasCloseElements()\n", "entry_point": "hasCloseElements", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Check that in the given list of numbers, any two numbers are closer together than the given threshold.\n  >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n  false\n  >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n  true\n  */\nconst hasCloseElements = (numbers, threshold) => {\n  const closest = numbers.reduce((prev, curr) => {\n    return Math.abs(curr - prev) < Math.abs(curr - threshold)? curr : prev;\n  }, Number.POSITIVE_INFINITY);\n  return numbers.indexOf(closest)!== -1;\n};\n\n/**\n * Given a string, convert it to a list of numbers, removing any leading or trailing whitespace.\n * If the string contains only whitespace, return an empty list.\n * If the string contains multiple whitespaces, return a list of all of them.\n * If the string contains only digits, return a list of all of them.\n * If the string contains letters, return a list of all of them.\n * If the string contains punctuation, return a list of all of them.\n * If the string contains symbols, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains other characters, return a list of all of them.\n * If the string contains ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/1", "prompt": "/* Input to this function is a string containing multiple groups of nested brackets, the goal of which is to separate this group into separate strings and return the list of them. Separate groups are balanced (each open bracket is properly closed), not nested Ignore spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n", "canonical_solution": "  var result = [];\n  var current_string = [];\n  var current_depth = 0;\n\n  for (const c of paren_string) {\n    if (c == '(') {\n      current_depth += 1;\n      current_string.push(c);\n    } else if (c == ')') {\n      current_depth -= 1;\n      current_string.push(c);\n      if (current_depth == 0) {\n        result.push(current_string.join(''));\n        current_string = [];\n      }\n    }\n  }\n\n  return result;\n}\n\n", "test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('(()()) ((())) () ((())()())')) ===\n      JSON.stringify(['(()())', '((()))', '()', '((())()())'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('() (()) ((())) (((())))')) ===\n      JSON.stringify(['()', '(())', '((()))', '(((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('(()(())((())))')) ===\n      JSON.stringify(['(()(())((())))'])\n  )\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\n\ntestSeparateParenGroups()\n", "declaration": "\nconst separateParenGroups = (paren_string) => {\n", "example_test": "const testSeparateParenGroups = () => {\n  console.assert(\n    JSON.stringify(separateParenGroups('( ) (( )) (( )( ))')) ===\n      JSON.stringify(['()', '(())', '(()())'])\n  )\n}\ntestSeparateParenGroups()\n", "entry_point": "separateParenGroups", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Input to this function is a string containing multiple groups of nested brackets, the goal of which is to separate this group into separate strings and return the list of them. Separate groups are balanced (each open bracket is properly closed), not nested Ignore spaces in the input string.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroups = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]+)\\)/g);\n  const paren_group_strings = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const paren_group = paren_groups[i];\n    const paren_group_string = '';\n    for (let j = 0; j < paren_group.length; j++) {\n      const char = paren_group.charAt(j);\n      if (char === '(') {\n        paren_group_string += char;\n      } else if (char === ')') {\n        paren_group_string += char;\n        paren_group_strings.push(paren_group_string);\n        paren_group_string = '';\n      } else {\n        paren_group_string += char;\n      }\n    }\n    paren_group_strings.push(paren_group_string);\n  }\n  return paren_group_strings;\n};\n\n/**\n * Given a string containing multiple groups of nested brackets, this function will return the list of strings that make up the groups of nested brackets.\n  >>> separateParenGroups('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroupsStrings = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]+)\\)/g);\n  const paren_group_strings = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const paren_group = paren_groups[i];\n    const paren_group_string = '';\n    for (let j = 0; j < paren_group.length; j++) {\n      const char = paren_group.charAt(j);\n      if (char === '(') {\n        paren_group_string += char;\n      } else if (char === ')') {\n        paren_group_string += char;\n        paren_group_strings.push(paren_group_string);\n        paren_group_string = '';\n      } else {\n        paren_group_string += char;\n      }\n    }\n    paren_group_strings.push(paren_group_string);\n  }\n  return paren_group_strings;\n};\n\n/**\n * Given a string containing multiple groups of nested brackets, this function will return the list of strings that make up the groups of nested brackets.\n  >>> separateParenGroupsStrings('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroupsStringsIgnoreSpaces = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]+)\\)/g);\n  const paren_group_strings = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const paren_group = paren_groups[i];\n    const paren_group_string = '';\n    for (let j = 0; j < paren_group.length; j++) {\n      const char = paren_group.charAt(j);\n      if (char === '(') {\n        paren_group_string += char;\n      } else if (char === ')') {\n        paren_group_string += char;\n        paren_group_strings.push(paren_group_string);\n        paren_group_string = '';\n      } else {\n        paren_group_string += char;\n      }\n    }\n    paren_group_strings.push(paren_group_string);\n  }\n  return paren_group_strings;\n};\n\n/**\n * Given a string containing multiple groups of nested brackets, this function will return the list of strings that make up the groups of nested brackets.\n  >>> separateParenGroupsStringsIgnoreSpaces('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroupsStringsIgnoreSpacesIgnoreSpaces = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]+)\\)/g);\n  const paren_group_strings = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const paren_group = paren_groups[i];\n    const paren_group_string = '';\n    for (let j = 0; j < paren_group.length; j++) {\n      const char = paren_group.charAt(j);\n      if (char === '(') {\n        paren_group_string += char;\n      } else if (char === ')') {\n        paren_group_string += char;\n        paren_group_strings.push(paren_group_string);\n        paren_group_string = '';\n      } else {\n        paren_group_string += char;\n      }\n    }\n    paren_group_strings.push(paren_group_string);\n  }\n  return paren_group_strings;\n};\n\n/**\n * Given a string containing multiple groups of nested brackets, this function will return the list of strings that make up the groups of nested brackets.\n  >>> separateParenGroupsStringsIgnoreSpacesIgnoreSpaces('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroupsStringsIgnoreSpacesIgnoreSpacesIgnoreSpaces = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]+)\\)/g);\n  const paren_group_strings = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const paren_group = paren_groups[i];\n    const paren_group_string = '';\n    for (let j = 0; j < paren_group.length; j++) {\n      const char = paren_group.charAt(j);\n      if (char === '(') {\n        paren_group_string += char;\n      } else if (char === ')') {\n        paren_group_string += char;\n        paren_group_strings.push(paren_group_string);\n        paren_group_string = '';\n      } else {\n        paren_group_string += char;\n      }\n    }\n    paren_group_strings.push(paren_group_string);\n  }\n  return paren_group_strings;\n};\n\n/**\n * Given a string containing multiple groups of nested brackets, this function will return the list of strings that make up the groups of nested brackets.\n  >>> separateParenGroupsStringsIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpaces('( ) (( )) (( )( ))')\n  ['()', '(())', '(()())']\n  */\nconst separateParenGroupsStringsIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpaces = (paren_string) => {\n  const paren_groups = paren_string.match(/\\(([^()]+)\\)/g);\n  const paren_group_strings = [];\n  for (let i = 0; i < paren_groups.length; i++) {\n    const paren_group = paren_groups[i];\n    const paren_group_string = '';\n    for (let j = 0; j < paren_group.length; j++) {\n      const char = paren_group.charAt(j);\n      if (char === '(') {\n        paren_group_string += char;\n      } else if (char === ')') {\n        paren_group_string += char;\n        paren_group_strings.push(paren_group_string);\n        paren_group_string = '';\n      } else {\n        paren_group_string += char;\n      }\n    }\n    paren_group_strings.push(paren_group_string);\n  }\n  return paren_group_strings;\n};\n\n/**\n * Given a string containing multiple groups of nested brackets, this function will return the list of strings that make up the groups of nested brackets.\n  >>> separateParenGroupsStringsIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnoreSpacesIgnore", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/10", "prompt": "/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n", "canonical_solution": "  if (string == '')\n    return '';\n  var beginning_of_suffix = 0;\n  while (!isPalindrome(string.slice(beginning_of_suffix)))\n    beginning_of_suffix += 1;\n  return string + string.slice(0, beginning_of_suffix).split('').reverse().join('');\n}\n\n", "test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('x') === 'x')\n  console.assert(makePalindrome('xyz') === 'xyzyx')\n  console.assert(makePalindrome('xyx') === 'xyx')\n  console.assert(makePalindrome('jerry') === 'jerryrrej')\n}\n\ntestmakePalindrome()\n", "declaration": "const isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\nconst makePalindrome = (string) => {\n", "example_test": "const testmakePalindrome = () => {\n  console.assert(makePalindrome('') === '')\n  console.assert(makePalindrome('cat') === 'catac')\n  console.assert(makePalindrome('cata') === 'catac')\n}\ntestmakePalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/* Test if gniven strig is a palindrome */\nconst isPalindrome = (string) => {\n  return string == string.split('').reverse().join('');\n}\n\n/* Find the shortest palindrome that begins with a supplied string.\n  Algorithm idea is simple:\n  - Find the longest postfix of supplied string that is a palindrome.\n  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n  >>> makePalindrome('')\n  ''\n  >>> makePalindrome('cat')\n  'catac'\n  >>> makePalindrome('cata')\n  'catac'\n  */\nconst makePalindrome = (string) => {\n  let longestPalindrome = '';\n  let palindrome = '';\n  let reversedString = '';\n  let prefix = '';\n  let suffix = '';\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      palindrome += string[i];\n    }\n  }\n\n  /* Find longest palindrome that begins with a supplied string */\n  for (let i = 0; i < string.length; i++) {\n    if (isPalindrome(string[i])) {\n      ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/100", "prompt": "/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = n; i < n * 3; i += 2) {\n    t.push(i)\n  }\n  return t\n}\n\n", "test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n  console.assert(JSON.stringify(makeAPile(4)) === JSON.stringify([4, 6, 8, 10]))\n  console.assert(\n    JSON.stringify(makeAPile(5)) === JSON.stringify([5, 7, 9, 11, 13])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(6)) === JSON.stringify([6, 8, 10, 12, 14, 16])\n  )\n  console.assert(\n    JSON.stringify(makeAPile(8)) ===\n    JSON.stringify([8, 10, 12, 14, 16, 18, 20, 22])\n  )\n}\n\ntestMakeAPile()\n", "declaration": "\nconst makeAPile = (n) => {\n", "example_test": "const testMakeAPile = () => {\n  console.assert(JSON.stringify(makeAPile(3)) === JSON.stringify([3, 5, 7]))\n}\ntestMakeAPile()\n", "entry_point": "makeAPile", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  let level = 1;\n  while (level < n) {\n    result.push(level);\n    level += 1;\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  let level = 1;\n  while (level < n) {\n    result.push(level);\n    level += 1;\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  let level = 1;\n  while (level < n) {\n    result.push(level);\n    level += 1;\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  let level = 1;\n  while (level < n) {\n    result.push(level);\n    level += 1;\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  let level = 1;\n  while (level < n) {\n    result.push(level);\n    level += 1;\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  let level = 1;\n  while (level < n) {\n    result.push(level);\n    level += 1;\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  let level = 1;\n  while (level < n) {\n    result.push(level);\n    level += 1;\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  let level = 1;\n  while (level < n) {\n    result.push(level);\n    level += 1;\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  let level = 1;\n  while (level < n) {\n    result.push(level);\n    level += 1;\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  let level = 1;\n  while (level < n) {\n    result.push(level);\n    level += 1;\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if n is even.\n  Return the number of stones in each level in a list, where element at index\n  i represents the number of stones in the level (i+1).\n\n  Examples:\n  >>> makeAPile(3)\n  [3, 5, 7]\n  */\nconst makeAPile = (n) => {\n  const result = [];\n  let level = 1;\n  while (level < n) {\n    result.push(level);\n    level += 1;\n  }\n  return result;\n};\n\n/*\n  Given a positive integer n, you have to make a pile of n levels of stones.\n  The first level has n stones.\n  The number of stones in the next level is:\n      - the next odd number if n is odd.\n      - the next even number if ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/101", "prompt": "/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n", "canonical_solution": "  let t = ''\n  let p = []\n  let k = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] == ' ' || s[i] == ',') {\n      if (k == 0) {\n        k = 1;\n        p.push(t);\n        t = '';\n      }\n    }\n    else {\n      k = 0;\n      t += s[i]\n    }\n  }\n  if (t != '') {\n    p.push(t);\n  }\n  return p\n}\n\n", "test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name')) ===\n    JSON.stringify(['Hi', 'my', 'name'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One,, two, three, four, five, six,')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n  console.assert(JSON.stringify(wordsString('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(wordsString('ahmed     , gamal')) ===\n    JSON.stringify(['ahmed', 'gamal'])\n  )\n}\n\ntestWordsString()\n", "declaration": "\nconst wordsString = (s) => {\n", "example_test": "const testWordsString = () => {\n  console.assert(\n    JSON.stringify(wordsString('Hi, my name is John')) ===\n    JSON.stringify(['Hi', 'my', 'name', 'is', 'John'])\n  )\n  console.assert(\n    JSON.stringify(wordsString('One, two, three, four, five, six')) ===\n    JSON.stringify(['One', 'two', 'three', 'four', 'five', 'six'])\n  )\n}\ntestWordsString()\n", "entry_point": "wordsString", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by commas or spaces. Your task is to split the string into words and return an array of words.\n  \n  For example:\n  wordsString(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n  wordsString(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n  */\nconst wordsString = (s) => {\n  const words = s.split(',').map(w => w.trim());\n  return words;\n};\n\n/*\n  You get a set of words separated by ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/102", "prompt": "/*TIts function takes two positive numbers x and y and returns the largest even integer, which is in the range [x, y]. If there is no such number, the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n", "canonical_solution": "  for (let i = y; i >= x; i--) {\n    if (i % 2 == 0) {return i }\n  }\n  return -1\n}\n\n", "test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n  console.assert(chooseNum(33, 12354) === 12354)\n  console.assert(chooseNum(5234, 5233) === -1)\n  console.assert(chooseNum(6, 29) === 28)\n  console.assert(chooseNum(27, 10) === -1)\n  console.assert(chooseNum(7, 7) === -1)\n  console.assert(chooseNum(546, 546) === 546)\n}\n\ntestChooseNum()\n", "declaration": "\nconst chooseNum = (x, y) => {\n", "example_test": "const testChooseNum = () => {\n  console.assert(chooseNum(12, 15) === 14)\n  console.assert(chooseNum(13, 12) === -1)\n}\ntestChooseNum()\n", "entry_point": "chooseNum", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*TIts function takes two positive numbers x and y and returns the largest even integer, which is in the range [x, y]. If there is no such number, the function should return -1.\n\n  For example:\n  chooseNum(12, 15) = 14\n  chooseNum(13, 12) = -1\n  */\nconst chooseNum = (x, y) => {\n  if (x === 0 || y === 0) {\n    return -1;\n  }\n  if (x % 2 === 0 && y % 2 === 0) {\n    return x;\n  }\n  return y;\n};\n\n/**\n  Returns true if the number is even, false otherwise.\n\n  For example:\n  evenNumberIsEven(12) = true\n  evenNumberIsEven(13) = false\n  */\nconst evenNumberIsEven = number => {\n  return number % 2 === 0;\n};\n\n/**\n  Returns true if the number is odd, false otherwise.\n\n  For example:\n  oddNumberIsOdd(12) = false\n  oddNumberIsOdd(13) = true\n  */\nconst oddNumberIsOdd = number => {\n  return number % 2!== 0;\n};\n\n/**\n  Returns the sum of two numbers.\n\n  For example:\n  sumOfTwoNumbers(5, 10) = 15\n  */\nconst sumOfTwoNumbers = (a, b) => {\n  return a + b;\n};\n\n/**\n  Returns the difference of two numbers.\n\n  For example:\n  differenceOfTwoNumbers(5, 10) = 5\n  */\nconst differenceOfTwoNumbers = (a, b) => {\n  return a - b;\n};\n\n/**\n  Returns the product of two numbers.\n\n  For example:\n  productOfTwoNumbers(5, 10) = 25\n  */\nconst productOfTwoNumbers = (a, b) => {\n  return a * b;\n};\n\n/**\n  Returns the quotient of two numbers.\n\n  For example:\n  quotientOfTwoNumbers(5, 10) = 2.5\n  */\nconst quotientOfTwoNumbers = (a, b) => {\n  return a / b;\n};\n\n/**\n  Returns the remainder of two numbers.\n\n  For example:\n  remainderOfTwoNumbers(5, 10) = 5\n  */\nconst remainderOfTwoNumbers = (a, b) => {\n  return a % b;\n};\n\n/**\n  Returns the absolute value of a number.\n\n  For example:\n  absoluteValue(5) = -5\n  */\nconst absoluteValue = number => {\n  return Math.abs(number);\n};\n\n/**\n  Returns the square root of a number.\n\n  For example:\n  squareRoot(5) = 25\n  */\nconst squareRoot = number => {\n  return Math.sqrt(number);\n};\n\n/**\n  Returns the square of a number.\n\n  For example:\n  square(5) = 5 * 5\n  */\nconst square = number => {\n  return number * number;\n};\n\n/**\n  Returns the cubed of a number.\n\n  For example:\n  cube(5) = 25\n  */\nconst cube = number => {\n  return number * number * number;\n};\n\n/**\n  Returns the cube root of a number.\n\n  For example:\n  cubeRoot(5) = 25\n  */\nconst cubeRoot = number => {\n  return Math.pow(number, 1 / 3);\n};\n\n/**\n  Returns the natural logarithm of a number.\n\n  For example:\n  naturalLogarithm(5) = log(5)\n  */\nconst naturalLogarithm = number => {\n  return Math.log(number) / Math.LN10;\n};\n\n/**\n  Returns the inverse of a number.\n\n  For example:\n  inverse(5) = 1 / 5\n  */\nconst inverse = number => {\n  return 1 / number;\n};\n\n/**\n  Returns the inverse square root of a number.\n\n  For example:\n  inverseSquareRoot(5) = 25 / 5\n  */\nconst inverseSquareRoot = number => {\n  return Math.pow(number, 1 / 3);\n};\n\n/**\n  Returns the inverse cube root of a number.\n\n  For example:\n  inverseCubeRoot(5) = 25 / 5\n  */\nconst inverseCubeRoot = number => {\n  return Math.pow(number, 1 / 6);\n};\n\n/**\n  Returns the inverse natural logarithm of a number.\n\n  For example:\n  inverseNaturalLogarithm(5) = log(5) / log(10)\n  */\nconst inverseNaturalLogarithm = number => {\n  return Math.log(number) / Math.LN10;\n};\n\n/**\n  Returns the square root of a number raised to the power of a number.\n\n  For example:\n  raisedToPower(5, 2) = 25\n  */\nconst raisedToPower = (base, exponent) => {\n  return Math.pow(base, exponent);\n};\n\n/**\n  Returns the square of a number raised to the power of a number.\n\n  For example:\n  raisedToPower(5, 2) = 5\n  */\nconst raisedToPowerOf = base => {\n  return raisedToPower(base, 2);\n};\n\n/**\n  Returns the cube of a number raised to the power of a number.\n\n  For example:\n  raisedToPower(5, 2) = 25\n  */\nconst raisedToPowerOfTwo = base => {\n  return raisedToPower(base, 3);\n};\n\n/**\n  Returns the natural logarithm of a number raised to the power of a number.\n\n  For example:\n  raisedToPowerOf(2, 5) = log(5) / log(2)\n  */\nconst raisedToPowerOfTwoLogarithm = base => {\n  return Math.log(base) / Math.LN2;\n};\n\n/**\n  Returns the inverse of a number raised to the power of a number.\n\n  For example:\n  raisedToPowerOf(2, 5) = 1 / log(5) / log(2)\n  */\nconst raisedToPowerOfTwoInverse = base => {\n  return 1 / raisedToPowerOfTwoLogarithm(base);\n};\n\n/**\n  Returns the inverse square root of a number raised to the power of a number.\n\n  For example:\n  raisedToPowerOfTwoInverse(5) = 25 / log(5) / log(2)\n  */\nconst raisedToPowerOfTwoInverseSquareRoot = base => {\n  return 1 / raisedToPowerOfTwoInverse(base);\n};\n\n/**\n  Returns the inverse cube root of a number raised to the power of a number.\n\n  For example:\n  raisedToPowerOfTwoInverseCubeRoot(5) = 25 / log(5) / log(2)\n  */\nconst raisedToPowerOfTwoInverseCubeRoot = base => {\n  return 1 / raisedToPowerOfTwoInverseSquareRoot(base);\n};\n\n/**\n  Returns the inverse natural logarithm of a number raised to the power of a number.\n\n  For example:\n  raisedToPowerOfTwoInverseNaturalLogarithm(5) = log(5) / log(2)\n  */\nconst raisedToPowerOfTwoInverseNaturalLogarithm = base => {\n  return 1 / raisedToPowerOfTwoInverseCubeRoot(base);\n};\n\n/**\n  Returns the square root of a number raised to the power of a number raised to the power of a number.\n\n  For example:\n  raisedToPowerOfTwoPowerOf(2, 5) = 25 / log(5) / log(2) / log(2)\n  */\nconst raisedToPowerOfTwoPowerOf = base => {\n  return raisedToPowerOfTwoPower(base, 2);\n};\n\n/**\n  Returns the square of a number raised to the power of a number raised to the power of a number.\n\n  For example:\n  raisedToPowerOfTwoPowerOf(2, 5) = 5\n  */\nconst raisedToPowerOfTwoPowerOfTwo = base => {\n  return raisedToPowerOfTwoPower(base, 3);\n};\n\n/**\n  Returns the cube of a number raised to the power of a number raised to the power of a number.\n\n  For example:\n  raisedToPowerOfTwoPowerOf(2, 5) = 25\n  */\nconst raisedToPowerOfTwoPowerOfTwo = base => {\n  return raisedToPowerOfTwoPower(base, 4);\n};\n\n/**\n  Returns the natural logarithm of a number raised to the power of a number raised to the power of a number.\n\n  For example:\n  raisedToPowerOfTwoPowerOf(2, 5) = log(5) / log(", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/103", "prompt": "/*YYou get two positive integers n and m, and your task is to calculate the average of integers from n to m (including n and m). Round up the answer to the next integer and convert it to binaries. If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n", "canonical_solution": "  if (n > m) { return -1 }\n  let k = (n + m) / 2\n  if (k % 1 != 0) { k = (n + m + 1) / 2 }\n  return '0b' + k.toString(2)\n}\n\n", "test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(964, 977) === '0b1111001011')\n  console.assert(roundedAvg(996, 997) === '0b1111100101')\n  console.assert(roundedAvg(560, 851) === '0b1011000010')\n  console.assert(roundedAvg(185, 546) === '0b101101110')\n  console.assert(roundedAvg(362, 496) === '0b110101101')\n  console.assert(roundedAvg(350, 902) === '0b1001110010')\n  console.assert(roundedAvg(197, 233) === '0b11010111')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(5, 1) === -1)\n  console.assert(roundedAvg(5, 5) === '0b101')\n}\n\ntestRoundedAvg()\n", "declaration": "\nconst roundedAvg = (n, m) => {\n", "example_test": "const testRoundedAvg = () => {\n  console.assert(roundedAvg(1, 5) === '0b11')\n  console.assert(roundedAvg(7, 13) === '0b1010')\n  console.assert(roundedAvg(7, 5) === -1)\n  console.assert(roundedAvg(10,20) === \"0b1111\")\n  console.assert(roundedAvg(20,33) === '0b11011')\n}\ntestRoundedAvg()\n", "entry_point": "roundedAvg", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*YYou get two positive integers n and m, and your task is to calculate the average of integers from n to m (including n and m). Round up the answer to the next integer and convert it to binaries. If n is greater than m, return -1.\n  Example:\n  roundedAvg(1, 5) => \"0b11\"\n  roundedAvg(7, 5) => -1\n  roundedAvg(10, 20) => \"0b1111\"\n  roundedAvg(20, 33) => \"0b11010\"\n  */\nconst roundedAvg = (n, m) => {\n  let sum = 0;\n  let rounded = 0;\n  let binary = \"\";\n  let binaries = \"\";\n  let decimal = 0;\n  let decimals = \"\";\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;\n  let decimalPlaces = \"\";\n  let decimalPlace = 0;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/104", "prompt": "/*GWhen creating a list of positive integers x, return a sorted list of all elements that do not have an even digit. Note: The returned list should be sorted in increasing order. Example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < x.length; i++) {\n    let h = x[i]\n    let boo = 1\n    while (h > 0) {\n      let r = h % 10\n      if (r % 2 == 0) {\n        boo = 0;\n        break;\n      }\n      h = (h - r) / 10\n    }\n    if (boo) {\n      p.push(x[i])\n    }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([12345, 2033, 111, 151])) ===\n    JSON.stringify([111, 151])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([135, 103, 31])) === JSON.stringify([31, 135])\n  )\n}\n\ntestUniqueDigits()\n", "declaration": "\nconst uniqueDigits = (x) => {\n", "example_test": "const testUniqueDigits = () => {\n  console.assert(\n    JSON.stringify(uniqueDigits([15, 33, 1422, 1])) ===\n    JSON.stringify([1, 15, 33])\n  )\n  console.assert(\n    JSON.stringify(uniqueDigits([152, 323, 1422, 10])) === JSON.stringify([])\n  )\n}\ntestUniqueDigits()\n", "entry_point": "uniqueDigits", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*GWhen creating a list of positive integers x, return a sorted list of all elements that do not have an even digit. Note: The returned list should be sorted in increasing order. Example:\n  >>> uniqueDigits([15, 33, 1422, 1])\n  [1, 15, 33]\n  >>> uniqueDigits([152, 323, 1422, 10])\n  []\n  */\nconst uniqueDigits = (x) => {\n  let digits = x.filter(x => x % 2 === 0);\n  return digits.sort((a, b) => a - b);\n};\n\n/**\n * Given a string, return the string with all the characters in it replaced with their corresponding ASCII characters. Note: The returned string should be in lowercase.\n * Example:\n  >>> replaceAll('Hello World', 'Hello', 'World')\n  'Hello World'\n  */\nconst replaceAll = (str, from, to) => {\n  return str.replace(new RegExp(from, 'g'), to);\n};\n\n/**\n * Given a string, return the string with all the characters in it replaced with their corresponding ASCII characters. Note: The returned string should be in lowercase.\n * Example:\n  >>> replaceAll('Hello World', 'Hello', 'World')\n  'Hello World'\n  */\nconst replaceAllLower = (str) => {\n  return str.toLowerCase().replace(new RegExp(/[&<>]/g, 'g'),'');\n};\n\n/**\n * Given a string, return the string with all the characters in it replaced with their corresponding ASCII characters. Note: The returned string should be in lowercase.\n * Example:\n  >>> replaceAll('Hello World', 'Hello', 'World')\n  'Hello World'\n  */\nconst replaceAllUpper = (str) => {\n  return str.toUpperCase().replace(new RegExp(/[&<>]/g, 'g'),'');\n};\n\n/**\n * Given a string, return the string with all the characters in it replaced with their corresponding ASCII characters. Note: The returned string should be in lowercase.\n * Example:\n  >>> replaceAll('Hello World', 'Hello', 'World')\n  'Hello World'\n  */\nconst replaceAllWithSpaces = (str) => {\n  return str.replace(/[&<>]/g,'');\n};\n\n/**\n * Given a string, return the string with all the characters in it replaced with their corresponding ASCII characters. Note: The returned string should be in lowercase.\n * Example:\n  >>> replaceAll('Hello World', 'Hello', 'World')\n  'Hello World'\n  */\nconst replaceAllWithUnderscores = (str) => {\n  return str.replace(/_/g,'');\n};\n\n/**\n * Given a string, return the string with all the characters in it replaced with their corresponding ASCII characters. Note: The returned string should be in lowercase.\n * Example:\n  >>> replaceAll('Hello World', 'Hello', 'World')\n  'Hello World'\n  */\nconst replaceAllWithDash = (str) => {\n  return str.replace(/-/g,'');\n};\n\n/**\n * Given a string, return the string with all the characters in it replaced with their corresponding ASCII characters. Note: The returned string should be in lowercase.\n * Example:\n  >>> replaceAll('Hello World', 'Hello', 'World')\n  'Hello World'\n  */\nconst replaceAllWithUnderscoresAndDash = (str) => {\n  return str.replace(/_/g,'').replace(/-/g,'');\n};\n\n/**\n * Given a string, return the string with all the characters in it replaced with their corresponding ASCII characters. Note: The returned string should be in lowercase.\n * Example:\n  >>> replaceAll('Hello World', 'Hello', 'World')\n  'Hello World'\n  */\nconst replaceAllWithUnderscoresAndSpaces = (str) => {\n  return str.replace(/_/g,'').replace(/-/g,'');\n};\n\n/**\n * Given a string, return the string with all the characters in it replaced with their corresponding ASCII characters. Note: The returned string should be in lowercase.\n * Example:\n  >>> replaceAll('Hello World', 'Hello', 'World')\n  'Hello World'\n  */\nconst replaceAllWithUnderscoresAndUnderscore = (str) => {\n  return str.replace(/_/g,'').replace(/_/g,'');\n};\n\n/**\n * Given a string, return the string with all the characters in it replaced with their corresponding ASCII characters. Note: The returned string should be in lowercase.\n * Example:\n  >>> replaceAll('Hello World', 'Hello', 'World')\n  'Hello World'\n  */\nconst replaceAllWithUnderscoresAndDashAndSpaces = (str) => {\n  return str.replace(/_/g,'').replace(/-/g,'').replace(/_/g,'');\n};\n\n/**\n * Given a string, return the string with all the characters in it replaced with their corresponding ASCII characters. Note: The returned string should be in lowercase.\n * Example:\n  >>> replaceAll('Hello World', 'Hello', 'World')\n  'Hello World'\n  */\nconst replaceAllWithUnderscoresAndUnderscoreAndDash = (str) => {\n  return str.replace(/_/g,'').replace(/_/g,'').replace(/-/g,'');\n};\n\n/**\n * Given a string, return the string with all the characters in it replaced with their corresponding ASCII characters. Note: The returned string should be in lowercase.\n * Example:\n  >>> replaceAll('Hello World', 'Hello', 'World')\n  'Hello World'\n  */\nconst replaceAllWithUnderscoresAndUnderscoreAndSpaces = (str) => {\n  return str.replace(/_/g,'').replace(/_/g,'').replace(/-/g,'');\n};\n\n/**\n * Given a string, return the string with all the characters in it replaced with their corresponding ASCII characters. Note: The returned string should be in lowercase.\n * Example:\n  >>> replaceAll('Hello World', 'Hello', 'World')\n  'Hello World'\n  */\nconst replaceAllWithUnderscoresAndUnderscoreAndUnderscore = (str) => {\n  return str.replace(/_/g,'').replace(/_/g,'').replace(/_/g,'');\n};\n\n/**\n * Given a string, return the string with all the characters in it replaced with their corresponding ASCII characters. Note: The returned string should be in lowercase.\n * Example:\n  >>> replaceAll('Hello World', 'Hello', 'World')\n  'Hello World'\n  */\nconst replaceAllWithUnderscoresAndUnderscoreAndUnderscoreAndDash = (str) => {\n  return str.replace(/_/g,'').replace(/_/g,'').replace(/_/g,'').replace(/-/g,'');\n};\n\n/**\n * Given a string, return the string with all the characters in it replaced with their corresponding ASCII characters. Note: The returned string should be in lowercase.\n * Example:\n  >>> replaceAll('Hello World', 'Hello', 'World')\n  'Hello World'\n  */\nconst replaceAllWithUnderscoresAndUnderscoreAndUnderscoreAndDashAndSpaces = (str) => {\n  return str.replace(/_/g,'').replace(/_/g,'').replace(/_/g,'').replace(/-/g,'');\n};\n\n/**\n * Given a string, return the string with all the characters in it replaced with their corresponding ASCII characters. Note: The returned string should be in lowercase.\n * Example:\n  >>> replaceAll('Hello World', 'Hello', 'World')\n  'Hello World'\n  */\nconst replaceAllWithUnderscoresAndUnderscoreAndUnderscoreAndUnderscoreAndDash = (str) => {\n  return str.replace(/_/g,'').replace(/_/g,'').replace(/_/g,'').replace(/_/g,'').replace(/-/g,'');\n};\n\n/**\n * Given a string, return the string with all the characters in it replaced with their corresponding ASCII characters. Note: The returned string should be in lowercase.\n * Example:\n  >>> replaceAll('Hello World', 'Hello', 'World')\n  'Hello World'\n  */\nconst replaceAllWithUnderscoresAndUnderscoreAndUnderscoreAndUnderscoreAndDashAndSpaces = (str) => {\n  return str.replace(/_/g,'').replace(/_/g,'').replace(/_/g,'').replace(/_/g,'').replace(/-/g,'');\n};\n\n/**\n * Given a string, return the string with all the characters in it replaced with their corresponding ASCII characters. Note: The returned ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/105", "prompt": "/*\n  For an array of integers, you sort the integers that lie between 1 and 9, reverse the resulting array, and then replace each digit with its corresponding name of \"one,\" \"two,\" \"three,\" \"four,\" \"five,\" \"six,\" \"seven,\" \"eight,\" \"nine.\"\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1 , 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n", "canonical_solution": "  p = []\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] < 10) { p.push(arr[i]) }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] > p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  let l = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine']\n  let t = []\n  for (let j = 0; j < p.length; j++) {\n    t.push(l[p[j]-1])\n  }\n  return t\n}\n\n", "test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([1, -1, 3, 2])) ===\n    JSON.stringify(['Three', 'Two', 'One'])\n  )\n  console.assert(\n    JSON.stringify(byLength([9, 4, 8])) ===\n    JSON.stringify(['Nine', 'Eight', 'Four'])\n  )\n}\n\ntestByLength()\n", "declaration": "\nconst byLength = (arr) => {\n", "example_test": "const testByLength = () => {\n  console.assert(\n    JSON.stringify(byLength([2, 1, 1, 4, 5, 8, 2, 3])) ===\n    JSON.stringify([\n      'Eight',\n      'Five',\n      'Four',\n      'Three',\n      'Two',\n      'Two',\n      'One',\n      'One',\n    ])\n  )\n  console.assert(JSON.stringify(byLength([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(byLength([1, -1, 55])) === JSON.stringify(['One'])\n  )\n}\ntestByLength()\n", "entry_point": "byLength", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  For an array of integers, you sort the integers that lie between 1 and 9, reverse the resulting array, and then replace each digit with its corresponding name of \"one,\" \"two,\" \"three,\" \"four,\" \"five,\" \"six,\" \"seven,\" \"eight,\" \"nine.\"\n\n  For example:\n    arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n          -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n          -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n    return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n  \n    If the array is empty, return an empty array:\n    arr = []\n    return []\n  \n    If the array has any strange number ignore it:\n    arr = [1, -1, 55] \n          -> sort arr -> [-1, 1, 55]\n          -> reverse arr -> [55, 1, -1]\n    return = ['One']\n  */\nconst byLength = (arr) => {\n  let sortedArr = [];\n  let reversedArr = [];\n  let arrLength = arr.length;\n  let i;\n  let j;\n  let temp;\n  let temp2;\n  let temp3;\n  let temp4;\n  let temp5;\n  let temp6;\n  let temp7;\n  let temp8;\n  let temp9;\n  let temp10;\n  let temp11;\n  let temp12;\n  let temp13;\n  let temp14;\n  let temp15;\n  let temp16;\n  let temp17;\n  let temp18;\n  let temp19;\n  let temp20;\n  let temp21;\n  let temp22;\n  let temp23;\n  let temp24;\n  let temp25;\n  let temp26;\n  let temp27;\n  let temp28;\n  let temp29;\n  let temp30;\n  let temp31;\n  let temp32;\n  let temp33;\n  let temp34;\n  let temp35;\n  let temp36;\n  let temp37;\n  let temp38;\n  let temp39;\n  let temp40;\n  let temp41;\n  let temp42;\n  let temp43;\n  let temp44;\n  let temp45;\n  let temp46;\n  let temp47;\n  let temp48;\n  let temp49;\n  let temp50;\n  let temp51;\n  let temp52;\n  let temp53;\n  let temp54;\n  let temp55;\n  let temp56;\n  let temp57;\n  let temp58;\n  let temp59;\n  let temp60;\n  let temp61;\n  let temp62;\n  let temp63;\n  let temp64;\n  let temp65;\n  let temp66;\n  let temp67;\n  let temp68;\n  let temp69;\n  let temp70;\n  let temp71;\n  let temp72;\n  let temp73;\n  let temp74;\n  let temp75;\n  let temp76;\n  let temp77;\n  let temp78;\n  let temp79;\n  let temp80;\n  let temp81;\n  let temp82;\n  let temp83;\n  let temp84;\n  let temp85;\n  let temp86;\n  let temp87;\n  let temp88;\n  let temp89;\n  let temp90;\n  let temp91;\n  let temp92;\n  let temp93;\n  let temp94;\n  let temp95;\n  let temp96;\n  let temp97;\n  let temp98;\n  let temp99;\n  let temp100;\n  let temp101;\n  let temp102;\n  let temp103;\n  let temp104;\n  let temp105;\n  let temp106;\n  let temp107;\n  let temp108;\n  let temp109;\n  let temp110;\n  let temp111;\n  let temp112;\n  let temp113;\n  let temp114;\n  let temp115;\n  let temp116;\n  let temp117;\n  let temp118;\n  let temp119;\n  let temp120;\n  let temp121;\n  let temp122;\n  let temp123;\n  let temp124;\n  let temp125;\n  let temp126;\n  let temp127;\n  let temp128;\n  let temp129;\n  let temp130;\n  let temp131;\n  let temp132;\n  let temp133;\n  let temp134;\n  let temp135;\n  let temp136;\n  let temp137;\n  let temp138;\n  let temp139;\n  let temp140;\n  let temp141;\n  let temp142;\n  let temp143;\n  let temp144;\n  let temp145;\n  let temp146;\n  let temp147;\n  let temp148;\n  let temp149;\n  let temp150;\n  let temp151;\n  let temp152;\n  let temp153;\n  let temp154;\n  let temp155;\n  let temp156;\n  let temp157;\n  let temp158;\n  let temp159;\n  let temp160;\n  let temp161;\n  let temp162;\n  let temp163;\n  let temp164;\n  let temp165;\n  let temp166;\n  let temp167;\n  let temp168;\n  let temp169;\n  let temp170;\n  let temp171;\n  let temp172;\n  let temp173;\n  let temp174;\n  let temp175;\n  let temp176;\n  let temp177;\n  let temp178;\n  let temp179;\n  let temp180;\n  let temp181;\n  let temp182;\n  let temp183;\n  let temp184;\n  let temp185;\n  let temp186;\n  let temp187;\n  let temp188;\n  let temp189;\n  let temp190;\n  let temp191;\n  let temp192;\n  let temp193;\n  let temp194;\n  let temp195;\n  let temp196;\n  let temp197;\n  let temp198;\n  let temp199;\n  let temp200;\n  let temp201;\n  let temp202;\n  let temp203;\n  let temp204;\n  let temp205;\n  let temp206;\n  let temp207;\n  let temp208;\n  let temp209;\n  let temp210;\n  let temp211;\n  let temp212;\n  let temp213;\n  let temp214;\n  let temp215;\n  let temp216;\n  let temp217;\n  let temp218;\n  let temp219;\n  let temp220;\n  let temp221;\n  let temp222;\n  let temp223;\n  let temp224;\n  let temp225;\n  let temp226;\n  let temp227;\n  let temp228;\n  let temp229;\n  let temp230;\n  let temp231;\n  let temp232;\n  let temp233;\n  let temp234;\n  let temp235;\n  let temp236;\n  let temp237;\n  let temp238;\n  let temp239;\n  let temp240;\n  let temp241;\n  let temp242;\n  let temp243;\n  let temp244;\n  let temp245;\n  let temp246;\n  let temp247;\n  let temp248;\n  let temp249;\n  let temp250;\n  let temp251;\n  let temp252;\n  let temp253;\n  let temp254;\n  let temp255;\n  let temp256;\n  let temp257;\n  let temp258;\n  let temp259;\n  let temp260;\n  let temp261;\n  let temp262;\n  let temp263;\n  let temp264;\n  let temp265;\n  let temp266;\n  let temp267;\n  let temp268;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/106", "prompt": "/* Implement function f, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the factorial of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n", "canonical_solution": "  let f = 1\n  let p = 0\n  let k = []\n  for (let i = 1; i <= n; i++) {\n    p += i;\n    f *= i;\n    if (i % 2 == 0) { k.push(f) }\n    else { k.push(p) }\n  }\n  return k\n}\n\n", "test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n  console.assert(\n    JSON.stringify(f(7)) === JSON.stringify([1, 2, 6, 24, 15, 720, 28])\n  )\n  console.assert(JSON.stringify(f(1)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(f(3)) === JSON.stringify([1, 2, 6]))\n}\n\ntestF()\n", "declaration": "\nconst f = (n) => {\n", "example_test": "const testF = () => {\n  console.assert(JSON.stringify(f(5)) === JSON.stringify([1, 2, 6, 24, 15]))\n}\ntestF()\n", "entry_point": "f", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Implement function f, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the factorial of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The factorial of i is the multiplication of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  f(5) == [1, 2, 6, 24, 15]\n  */\nconst f = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/* Implement function g, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  g(5) == [1, 2, 6, 24, 15]\n  */\nconst g = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/* Implement function h, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  h(5) == [1, 2, 6, 24, 15]\n  */\nconst h = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/* Implement function i, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  i(5) == [1, 2, 6, 24, 15]\n  */\nconst i = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/* Implement function j, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  j(5) == [1, 2, 6, 24, 15]\n  */\nconst j = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/* Implement function k, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  k(5) == [1, 2, 6, 24, 15]\n  */\nconst k = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/* Implement function l, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  l(5) == [1, 2, 6, 24, 15]\n  */\nconst l = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/* Implement function m, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  m(5) == [1, 2, 6, 24, 15]\n  */\nconst m = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/* Implement function n, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  n(5) == [1, 2, 6, 24, 15]\n  */\nconst n = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/* Implement function o, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  o(5) == [1, 2, 6, 24, 15]\n  */\nconst o = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/* Implement function p, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  p(i) == [1, 2, 6, 24, 15]\n  */\nconst p = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/* Implement function q, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  q(i) == [1, 2, 6, 24, 15]\n  */\nconst q = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }\n  return result;\n};\n\n/* Implement function r, which takes n as parameter, and return a list of the size n, so that the value of the element at index i is the greatest common divisor of i if i is even, or the sum of the numbers from 1 to i. i starts with 1. The greatest common divisor of i is the product of the numbers from 1 to i (1 * 2 *... * i).\n  Example:\n  r(i) == [1, 2, 6, 24, 15]\n  */\nconst r = (n) => {\n  let result = [];\n  for (let i = 1; i <= n; i++) {\n    if (i % 2 === 0) {\n      result.push(i);\n    }\n  }", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/107", "prompt": "/*\n  If you return a positive integer n, you return a tuple with the number of even and odd integer palindromes within the range (1, n), including.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n", "canonical_solution": "  let e = 0\n  let o = 0\n  for (let i = 1; i <= n; i++) {\n    let k = i.toString()\n    let p = 1\n    for (let j = 0; j < k.length; j++) {\n      if (k[j] != k[k.length - j - 1]) {\n        p = 0;\n        break;\n      }\n    }\n    if (p == 1) {\n      if (k % 2 == 0) { e++ }\n      else { o++ }\n    }\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(123)) === JSON.stringify((8, 13))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(63)) === JSON.stringify((6, 8))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(25)) === JSON.stringify((5, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(19)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(9)) === JSON.stringify((4, 5))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(1)) === JSON.stringify((0, 1))\n  )\n}\n\ntestEvenOddPalindrome()\n", "declaration": "\nconst evenOddPalindrome = (n) => {\n", "example_test": "const testEvenOddPalindrome = () => {\n  console.assert(\n    JSON.stringify(evenOddPalindrome(12)) === JSON.stringify((4, 6))\n  )\n  console.assert(\n    JSON.stringify(evenOddPalindrome(3)) === JSON.stringify((1, 2))\n  )\n}\ntestEvenOddPalindrome()\n", "entry_point": "evenOddPalindrome", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  If you return a positive integer n, you return a tuple with the number of even and odd integer palindromes within the range (1, n), including.\n\n  Example 1:\n\n      Input: 3\n      Output: (1, 2)\n      Explanation:\n      Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n  Example 2:\n\n      Input: 12\n      Output: (4, 6)\n      Explanation:\n      Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n  Note:\n      1. 1 <= n <= 10^3\n      2. returned tuple has the number of even and odd integer palindromes respectively.\n  */\nconst evenOddPalindrome = (n) => {\n  const evenPalindromes = [];\n  const oddPalindromes = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      evenPalindromes.push(i);\n    } else {\n      oddPalindromes.push(i);\n    }\n  }\n  return [evenPalindromes, oddPalindromes];\n};\n\n/*\n  Given a string of digits, return the largest palindrome made from the digits. Return the empty string if there is no palindrome.\n\n  Example 1:\n\n      Input: \"23\"\n      Output: \"23\"\n      Explanation:\n      23 is the largest palindrome made from the digits of 23.\n\n  Example 2:\n\n      Input: \"987654321\"\n      Output: \"\"\n      Explanation:\n      There is no palindrome made from the digits of 987654321.\n\n  Note:\n      You may assume that the given string is made up of only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no spaces.\n      You may assume that the given string contains only digits and no space", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/108", "prompt": "/*\n  Write a function countNums that takes an array of integers and returns the number of elements that have a sum of digits > 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < arr.length; i++) {\n    let h = arr[i]\n    if (h > 0) {\n      p++;\n      continue;\n    }\n    let k = 0\n    h = -h\n    while (h >= 10) {\n      k += h % 10;\n      h = (h - h % 10) / 10;\n    }\n    k -= h;\n    if (k > 0) { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, -2, 0]) === 0)\n  console.assert(countNums([1, 1, 2, -2, 3, 4, 5]) === 6)\n  console.assert(countNums([1, 6, 9, -6, 0, 1, 5]) === 5)\n  console.assert(countNums([1, 100, 98, -7, 1, -1]) === 4)\n  console.assert(countNums([12, 23, 34, -45, -56, 0]) === 5)\n  console.assert(countNums([-0, 1 ** 0]) === 1)\n  console.assert(countNums([1]) === 1)\n}\n\ntestCountNums()\n", "declaration": "\nconst countNums = (arr) => {\n", "example_test": "const testCountNums = () => {\n  console.assert(countNums([]) === 0)\n  console.assert(countNums([-1, 11, -11]) === 1)\n  console.assert(countNums([1, 1, 2]) === 3)\n}\ntestCountNums()\n", "entry_point": "countNums", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function countNums that takes an array of integers and returns the number of elements that have a sum of digits > 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countNums([]) == 0\n  >>> countNums([-1, 11, -11]) == 1\n  >>> countNums([1, 1, 2]) == 3\n  */\nconst countNums = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countEvens that takes an array of integers and returns the number of elements that have a sum of digits > 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countEvens([]) == 0\n  >>> countEvens([-1, 11, -11]) == 1\n  >>> countEvens([1, 1, 2]) == 2\n  */\nconst countEvens = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      if (arr[i] % 2 === 0) {\n        count += 1;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countOdds that takes an array of integers and returns the number of elements that have a sum of digits > 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countOdds([]) == 0\n  >>> countOdds([-1, 11, -11]) == 1\n  >>> countOdds([1, 1, 2]) == 2\n  */\nconst countOdds = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      if (arr[i] % 2!== 0) {\n        count += 1;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countZeros that takes an array of integers and returns the number of elements that have a sum of digits > 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countZeros([]) == 0\n  >>> countZeros([-1, 11, -11]) == 1\n  >>> countZeros([1, 1, 2]) == 2\n  */\nconst countZeros = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      if (arr[i] === 0) {\n        count += 1;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countNegatives that takes an array of integers and returns the number of elements that have a sum of digits > 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countNegatives([]) == 0\n  >>> countNegatives([-1, 11, -11]) == 1\n  >>> countNegatives([1, 1, 2]) == 2\n  */\nconst countNegatives = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      if (arr[i] < 0) {\n        count += 1;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countZeroAndOnes that takes an array of integers and returns the number of elements that have a sum of digits > 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countZeroAndOnes([]) == 0\n  >>> countZeroAndOnes([-1, 11, -11]) == 1\n  >>> countZeroAndOnes([1, 1, 2]) == 2\n  */\nconst countZeroAndOnes = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      if (arr[i] === 0) {\n        count += 1;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countOnes and countTwos that takes an array of integers and returns the number of elements that have a sum of digits > 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countOnesAndTwos([]) == 0\n  >>> countOnesAndTwos([-1, 11, -11]) == 1\n  >>> countOnesAndTwos([1, 1, 2]) == 2\n  */\nconst countOnesAndTwos = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      if (arr[i] === 1) {\n        count += 1;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countThrees and countFours that takes an array of integers and returns the number of elements that have a sum of digits > 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countThreesAndFours([]) == 0\n  >>> countThreesAndFours([-1, 11, -11]) == 1\n  >>> countThreesAndFours([1, 1, 2]) == 2\n  */\nconst countThreesAndFours = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      if (arr[i] === 3) {\n        count += 1;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countFives and countSixes that takes an array of integers and returns the number of elements that have a sum of digits > 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countFivesAndSixes([]) == 0\n  >>> countFivesAndSixes([-1, 11, -11]) == 1\n  >>> countFivesAndSixes([1, 1, 2]) == 2\n  */\nconst countFivesAndSixes = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      if (arr[i] === 5) {\n        count += 1;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countTens and countElevens that takes an array of integers and returns the number of elements that have a sum of digits > 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countTensAndElevens([]) == 0\n  >>> countTensAndElevens([-1, 11, -11]) == 1\n  >>> countTensAndElevens([1, 1, 2]) == 2\n  */\nconst countTensAndElevens = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      if (arr[i] === 10) {\n        count += 1;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countOnes and countTwos and countThrees and countFours and countFives and countSixes that takes an array of integers and returns the number of elements that have a sum of digits > 0. If a number is negative, its first signed digit is negative: For example, -123 has signed digits -1, 2, and 3.\n  >>> countOnesAndTwosAndThreesAndFoursAndFivesAndSixes([]) == 0\n  >>> countOnesAndTwosAndThreesAndFoursAndFivesAndSixes([-1, 11, -11]) == 1\n  >>> countOnesAndTwosAndThreesAndFoursAndFivesAndSixes([1, 1, 2]) == 2\n  */\nconst countOnesAndTwosAndThreesAndFoursAndFivesAndSixes = (arr) => {\n  let count = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= 0) {\n      if (arr[i] === 1) {\n        count += 1;\n      }\n      if (arr[i] === 2) {\n        count += 1;\n      }\n      if (arr[i] === 3) {\n        count += 1;\n      }\n      if (arr[i] === 4) {\n        count += 1;\n      }\n      if (arr[i] === 5) {\n        count += 1;\n      }\n      if (arr[i] === 6) {\n        count += 1;\n      }\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function countOnes and countTwos and countThrees and countFours and countFives and countSixes that takes an array of integers and returns the number of elements that have a sum of digits ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/109", "prompt": "/*We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return true }\n  let k = 0\n  let len = arr.length\n  for (let i = 0; i < len; i++) {\n    let t = 1;\n    for (let j = 1; j < len; j++) {\n      if (arr[j] < arr[j - 1]) {\n        t = 0;\n        break;\n      }\n    }\n    if (t == 1) {\n      k = 1;\n      break;\n    }\n    arr.push(arr[0]);\n    arr.shift()\n  }\n  if (k == 1) { return true }\n  return false\n}\n\n", "test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 10, 1, 2]) === true)\n  console.assert(moveOneBall([4, 3, 1, 2]) === false)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n  console.assert(moveOneBall([]) === true)\n}\n\ntestMoveOneBall()\n", "declaration": "\nconst moveOneBall = (arr) => {\n", "example_test": "const testMoveOneBall = () => {\n  console.assert(moveOneBall([3, 4, 5, 1, 2]) === true)\n  console.assert(moveOneBall([3, 5, 4, 1, 2]) === false)\n}\ntestMoveOneBall()\n", "entry_point": "moveOneBall", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*We have an array 'arr' of N integers arr[1], arr[2],..., arr[N].The\n  numbers in the array will be randomly ordered. Your task is to determine if\n  it is possible to get an array sorted in non-decreasing order by performing \n  the following operation on the given array:\n      You are allowed to perform right shift operation any number of times.\n  \n  One right shift operation means shifting all elements of the array by one\n  position in the right direction. The last element of the array will be moved to\n  the starting position in the array i.e. 0th index. \n\n  If it is possible to obtain the sorted array by performing the above operation\n  then return true else return false.\n  If the given array is empty then return true.\n\n  Note: The given list is guaranteed to have unique elements.\n\n  For Example:\n  \n  moveOneBall([3, 4, 5, 1, 2])==>true\n  Explanation: By performin 2 right shift operations, non-decreasing order can\n               be achieved for the given array.\n  moveOneBall([3, 5, 4, 1, 2])==>false\n  Explanation:It is not possible to get non-decreasing order for the given\n              array by performing any number of right shift operations.\n              \n  */\nconst moveOneBall = (arr) => {\n  let count = 0;\n  let newArr = [];\n  let newArr1 = [];\n  let newArr2 = [];\n  let newArr3 = [];\n  let newArr4 = [];\n  let newArr5 = [];\n  let newArr6 = [];\n  let newArr7 = [];\n  let newArr8 = [];\n  let newArr9 = [];\n  let newArr10 = [];\n  let newArr11 = [];\n  let newArr12 = [];\n  let newArr13 = [];\n  let newArr14 = [];\n  let newArr15 = [];\n  let newArr16 = [];\n  let newArr17 = [];\n  let newArr18 = [];\n  let newArr19 = [];\n  let newArr20 = [];\n  let newArr21 = [];\n  let newArr22 = [];\n  let newArr23 = [];\n  let newArr24 = [];\n  let newArr25 = [];\n  let newArr26 = [];\n  let newArr27 = [];\n  let newArr28 = [];\n  let newArr29 = [];\n  let newArr30 = [];\n  let newArr31 = [];\n  let newArr32 = [];\n  let newArr33 = [];\n  let newArr34 = [];\n  let newArr35 = [];\n  let newArr36 = [];\n  let newArr37 = [];\n  let newArr38 = [];\n  let newArr39 = [];\n  let newArr40 = [];\n  let newArr41 = [];\n  let newArr42 = [];\n  let newArr43 = [];\n  let newArr44 = [];\n  let newArr45 = [];\n  let newArr46 = [];\n  let newArr47 = [];\n  let newArr48 = [];\n  let newArr49 = [];\n  let newArr50 = [];\n  let newArr51 = [];\n  let newArr52 = [];\n  let newArr53 = [];\n  let newArr54 = [];\n  let newArr55 = [];\n  let newArr56 = [];\n  let newArr57 = [];\n  let newArr58 = [];\n  let newArr59 = [];\n  let newArr60 = [];\n  let newArr61 = [];\n  let newArr62 = [];\n  let newArr63 = [];\n  let newArr64 = [];\n  let newArr65 = [];\n  let newArr66 = [];\n  let newArr67 = [];\n  let newArr68 = [];\n  let newArr69 = [];\n  let newArr70 = [];\n  let newArr71 = [];\n  let newArr72 = [];\n  let newArr73 = [];\n  let newArr74 = [];\n  let newArr75 = [];\n  let newArr76 = [];\n  let newArr77 = [];\n  let newArr78 = [];\n  let newArr79 = [];\n  let newArr80 = [];\n  let newArr81 = [];\n  let newArr82 = [];\n  let newArr83 = [];\n  let newArr84 = [];\n  let newArr85 = [];\n  let newArr86 = [];\n  let newArr87 = [];\n  let newArr88 = [];\n  let newArr89 = [];\n  let newArr90 = [];\n  let newArr91 = [];\n  let newArr92 = [];\n  let newArr93 = [];\n  let newArr94 = [];\n  let newArr95 = [];\n  let newArr96 = [];\n  let newArr97 = [];\n  let newArr98 = [];\n  let newArr99 = [];\n  let newArr100 = [];\n  let newArr101 = [];\n  let newArr102 = [];\n  let newArr103 = [];\n  let newArr104 = [];\n  let newArr105 = [];\n  let newArr106 = [];\n  let newArr107 = [];\n  let newArr108 = [];\n  let newArr109 = [];\n  let newArr110 = [];\n  let newArr111 = [];\n  let newArr112 = [];\n  let newArr113 = [];\n  let newArr114 = [];\n  let newArr115 = [];\n  let newArr116 = [];\n  let newArr117 = [];\n  let newArr118 = [];\n  let newArr119 = [];\n  let newArr120 = [];\n  let newArr121 = [];\n  let newArr122 = [];\n  let newArr123 = [];\n  let newArr124 = [];\n  let newArr125 = [];\n  let newArr126 = [];\n  let newArr127 = [];\n  let newArr128 = [];\n  let newArr129 = [];\n  let newArr130 = [];\n  let newArr131 = [];\n  let newArr132 = [];\n  let newArr133 = [];\n  let newArr134 = [];\n  let newArr135 = [];\n  let newArr136 = [];\n  let newArr137 = [];\n  let newArr138 = [];\n  let newArr139 = [];\n  let newArr140 = [];\n  let newArr141 = [];\n  let newArr142 = [];\n  let newArr143 = [];\n  let newArr144 = [];\n  let newArr145 = [];\n  let newArr146 = [];\n  let newArr147 = [];\n  let newArr148 = [];\n  let newArr149 = [];\n  let newArr150 = [];\n  let newArr151 = [];\n  let newArr152 = [];\n  let newArr153 = [];\n  let newArr154 = [];\n  let newArr155 = [];\n  let newArr156 = [];\n  let newArr157 = [];\n  let newArr158 = [];\n  let newArr159 = [];\n  let newArr160 = [];\n  let newArr161 = [];\n  let newArr162 = [];\n  let newArr163 = [];\n  let newArr164 = [];\n  let newArr165 = [];\n  let newArr166 = [];\n  let newArr167 = [];\n  let newArr168 = [];\n  let newArr169 = [];\n  let newArr170 = [];\n  let newArr171 = [];\n  let newArr172 = [];\n  let newArr173 = [];\n  let newArr174 = [];\n  let newArr175 = [];\n  let newArr176 = [];\n  let newArr177 = [];\n  let newArr178 = [];\n  let newArr179 = [];\n  let newArr180 = [];\n  let newArr181 = [];\n  let newArr182 = [];\n  let newArr183 = [];\n  let newArr184 = [];\n  let newArr185 = [];\n  let newArr186 = [];\n  let newArr187 = [];\n  let newArr188 = [];\n  let newArr189 = [];\n  let newArr190 = [];\n  let newArr191 = [];\n  let newArr192 = [];\n  let newArr193 = [];\n  let newArr194 = [];\n  let newArr195 = [];\n  let newArr196 = [];\n  let newArr197 = [];\n  let newArr198 = [];\n  let newArr199 = [];\n  let newArr200 = [];\n  let newArr201 = [];\n  let newArr202 = [];\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/11", "prompt": "/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary XOR on these inputs and return the result as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n", "canonical_solution": "  var xor = function (i, j) {\n    if (i == j)\n      return '0';\n    else\n      return '1';\n  }\n  return a.split('').map((item, index) => xor(item, b[index])).join('');\n}\n\n", "test": "const testStringXor = () => {\n  console.assert(stringXor('111000', '101010') === '010010')\n  console.assert(stringXor('1', '1') === '0')\n  console.assert(stringXor('0101', '0000') === '0101')\n}\n\ntestStringXor()\n", "declaration": "\nconst stringXor = (a, b) => {\n", "example_test": "const testStringXor = () => {\n  console.assert(stringXor('010', '110') === '100')\n}\ntestStringXor()\n", "entry_point": "stringXor", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Input are two strings a and b, consisting of only 1s and 0s. Execute binary XOR on these inputs and return the result as a string.\n  >>> stringXor('010', '110')\n  '100'\n  */\nconst stringXor = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/**\n  Execute binary XOR on two numbers and return the result as a string.\n  >>> stringXor(123, 456)\n  '123'\n  */\nconst stringXorNumber = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b;\n  }\n  return result;\n};\n\n/**\n  Execute binary XOR on two strings and return the result as a string.\n  >>> stringXor('abc', 'def')\n  'def'\n  */\nconst stringXorString = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b;\n  }\n  return result;\n};\n\n/**\n  Execute binary XOR on two arrays and return the result as a string.\n  >>> stringXor(['a', 'b', 'c'], ['d', 'e', 'f'])\n  'abcdef'\n  */\nconst stringXorArray = (a, b) => {\n  let result = '';\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] ^ b[i];\n  }\n  return result;\n};\n\n/**\n  Execute binary XOR on two objects and return the result as a string.\n  >>> stringXor({a: 'b', c: 'd'}, {a: 'e', d: 'f'})\n  'abcdef'\n  */\nconst stringXorObject = (a, b) => {\n  let result = '';\n  for (let key in a) {\n    result += a[key] ^ b[key];\n  }\n  return result;\n};\n\n/**\n  Execute binary XOR on two arrays and return the result as a string.\n  >>> stringXor(['a', 'b', 'c'], ['d', 'e', 'f'])\n  'abcdef'\n  */\nconst stringXorArrayObject = (a, b) => {\n  let result = '';\n  for (let key in a) {\n    result += a[key] ^ b[key];\n  }\n  return result;\n};\n\n/**\n  Execute binary XOR on two objects and return the result as a string.\n  >>> stringXor({a: 'b', c: 'd'}, {a: 'e', d: 'f'})\n  'abcdef'\n  */\nconst stringXorObjectObject = (a, b) => {\n  let result = '';\n  for (let key in a) {\n    result += a[key] ^ b[key];\n  }\n  return result;\n};\n\n/**\n  Execute binary XOR on two objects and return the result as a string.\n  >>> stringXor({a: 'b', c: 'd'}, {a: 'e', d: 'f'})\n  'abcdef'\n  */\nconst stringXorObjectArrayObject = (a, b) => {\n  let result = '';\n  for (let key in a) {\n    result += a[key] ^ b[key];\n  }\n  return result;\n};\n\n/**\n  Execute binary XOR on two objects and return the result as a string.\n  >>> stringXor({a: 'b', c: 'd'}, {a: 'e', d: 'f'})\n  'abcdef'\n  */\nconst stringXorObjectArrayObjectObject = (a, b) => {\n  let result = '';\n  for (let key in a) {\n    result += a[key] ^ b[key];\n  }\n  return result;\n};\n\n/**\n  Execute binary XOR on two objects and return the result as a string.\n  >>> stringXor({a: 'b', c: 'd'}, {a: 'e', d: 'f'})\n  'abcdef'\n  */\nconst stringXorObjectArrayObjectArrayObject = (a, b) => {\n  let result = '';\n  for (let key in a) {\n    result += a[key] ^ b[key];\n  }\n  return result;\n};\n\n/**\n  Execute binary XOR on two objects and return the result as a string.\n  >>> stringXor({a: 'b', c: 'd'}, {a: 'e', d: 'f'})\n  'abcdef'\n  */\nconst stringXorObjectArrayObjectArrayObjectArrayObject = (a, b) => {\n  let result = '';\n  for (let key in a) {\n    result += a[key] ^ b[key];\n  }\n  return result;\n};\n\n/**\n  Execute binary XOR on two objects and return the result as a string.\n  >>> stringXor({a: 'b', c: 'd'}, {a: 'e', d: 'f'})\n  'abcdef'\n  */\nconst stringXorObjectArrayObjectArrayObjectArrayObjectArrayObject = (a, b) => {\n  let result = '';\n  for (let key in a) {\n    result += a[key] ^ b[key];\n  }\n  return result;\n};\n\n/**\n  Execute binary XOR on two objects and return the result as a string.\n  >>> stringXor({a: 'b', c: 'd'}, {a: 'e', d: 'f'})\n  'abcdef'\n  */\nconst stringXorObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObject = (a, b) => {\n  let result = '';\n  for (let key in a) {\n    result += a[key] ^ b[key];\n  }\n  return result;\n};\n\n/**\n  Execute binary XOR on two objects and return the result as a string.\n  >>> stringXor({a: 'b', c: 'd'}, {a: 'e', d: 'f'})\n  'abcdef'\n  */\nconst stringXorObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObject = (a, b) => {\n  let result = '';\n  for (let key in a) {\n    result += a[key] ^ b[key];\n  }\n  return result;\n};\n\n/**\n  Execute binary XOR on two objects and return the result as a string.\n  >>> stringXor({a: 'b', c: 'd'}, {a: 'e', d: 'f'})\n  'abcdef'\n  */\nconst stringXorObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObject = (a, b) => {\n  let result = '';\n  for (let key in a) {\n    result += a[key] ^ b[key];\n  }\n  return result;\n};\n\n/**\n  Execute binary XOR on two objects and return the result as a string.\n  >>> stringXor({a: 'b', c: 'd'}, {a: 'e', d: 'f'})\n  'abcdef'\n  */\nconst stringXorObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObject = (a, b) => {\n  let result = '';\n  for (let key in a) {\n    result += a[key] ^ b[key];\n  }\n  return result;\n};\n\n/**\n  Execute binary XOR on two objects and return the result as a string.\n  >>> stringXor({a: 'b', c: 'd'}, {a: 'e', d: 'f'})\n  'abcdef'\n  */\nconst stringXorObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObject = (a, b) => {\n  let result = '';\n  for (let key in a) {\n    result += a[key] ^ b[key];\n  }\n  return result;\n};\n\n/**\n  Execute binary XOR on two objects and return the result as a string.\n  >>> stringXor({a: 'b', c: 'd'}, {a: 'e', d: 'f'})\n  'abcdef'\n  */\nconst stringXorObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObject = (a, b) => {\n  let result = '';\n  for (let key in a) {\n    result += a[key] ^ b[key];\n  }\n  return result;\n};\n\n/**\n  Execute binary XOR on two objects and return the result as a string.\n  >>> stringXor({a: 'b', c: 'd'}, {a: 'e', d: 'f'})\n  'abcdef'\n  */\nconst stringXorObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObjectArrayObject = (a, b", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/110", "prompt": "/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an exchange of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of exchanged elements between lst1 and lst2.\n  If it is possible to exchange elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n", "canonical_solution": "  let k = lst1.length\n  let t = 0\n  for (let i = 0; i < lst1.length; i++) {\n    if (lst1[i] % 2 == 0) { t++ }\n  }\n  for (let i = 0; i < lst2.length; i++) {\n    if (lst2[i] % 2 == 0) { t++ }\n  }\n  if (t >= k) { return 'YES' }\n  return 'NO'\n}\n\n", "test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n  console.assert(exchange([1, 2, 3, 4], [2, 1, 4, 3]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 4]) === 'YES')\n  console.assert(exchange([5, 7, 3], [2, 6, 3]) === 'NO')\n  console.assert(exchange([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) === 'NO')\n  console.assert(exchange([100, 200], [200, 200]) === 'YES')\n}\n\ntestExchange()\n", "declaration": "\nconst exchange = (lst1, lst2) => {\n", "example_test": "const testExchange = () => {\n  console.assert(exchange([1, 2, 3, 4], [1, 2, 3, 4]) === 'YES')\n  console.assert(exchange([1, 2, 3, 4], [1, 5, 3, 4]) === 'NO')\n}\ntestExchange()\n", "entry_point": "exchange", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*In this problem, you will implement a function that takes two lists of numbers,\n  and determines whether it is possible to perform an exchange of elements\n  between them to make lst1 a list of only even numbers.\n  There is no limit on the number of exchanged elements between lst1 and lst2.\n  If it is possible to exchange elements between the lst1 and lst2 to make\n  all the elements of lst1 to be even, return \"YES\".\n  Otherwise, return \"NO\".\n  For example:\n  exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n  exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n  It is assumed that the input lists will be non-empty.\n  */\nconst exchange = (lst1, lst2) => {\n  // write your code here\n  let result = \"NO\";\n  if (lst1.length === 0 || lst2.length === 0) {\n    return \"NO\";\n  }\n  if (lst1.length === lst2.length) {\n    for (let i = 0; i < lst1.length; i++) {\n      if (lst1[i] % 2 === 0) {\n        lst1[i] = lst2[i];\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  Write a function that takes an array of numbers and returns true if it\n  is possible to perform an exchange of elements in the array such that the\n  array is sorted in ascending order.\n  For example:\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n  exchange([5, 2, 6, 1]) => false\n  exchange([5, 2, 6, 1]) => true\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/111", "prompt": "/*GIf a string is a lowercase letter separated by spaces, return a dictionary of the letter with the largest repetition and the corresponding number. If several letters have the same occurrence, return all.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n", "canonical_solution": "  let d = {}\n  let t = test.split(/\\s/)\n  if (test == '') { t = [] }\n  for (m in t) {\n    if (t[m] in d) {\n      d[t[m]]++\n    }\n    else {\n      d[t[m]] = 1\n    }\n  }\n  s = Object.keys(d).sort(function (a, b) { return - d[a] + d[b]; });\n  if (s.length == 0) { return {} }\n  let g = d[s[0]]\n  let l = {}\n  for (let ss=0; ss<s.length; ss++) {\n    if (d[s[ss]] == g) {\n      l[s[ss]] = d[s[ss]]\n    }\n  }\n  return l\n}\n\n", "test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(\n    JSON.stringify(histogram('r t g')) === JSON.stringify({ r: 1, t: 1, g: 1 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n  console.assert(JSON.stringify(histogram('a')) === JSON.stringify({ a: 1 }))\n}\n\ntestHistogram()\n", "declaration": "\nconst histogram = (test) => {\n", "example_test": "const testHistogram = () => {\n  console.assert(\n    JSON.stringify(histogram('a b b a')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c a b')) === JSON.stringify({ a: 2, b: 2 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c d g')) ===\n    JSON.stringify({ a: 1, b: 1, c: 1, d: 1, g: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('a b c')) === JSON.stringify({ a: 1, b: 1, c: 1 })\n  )\n  console.assert(\n    JSON.stringify(histogram('b b b b a')) === JSON.stringify({ b: 4 })\n  )\n  console.assert(JSON.stringify(histogram('')) === JSON.stringify({}))\n}\ntestHistogram()\n", "entry_point": "histogram", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*GIf a string is a lowercase letter separated by spaces, return a dictionary of the letter with the largest repetition and the corresponding number. If several letters have the same occurrence, return all.\n  \n  Example:\n  histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n  histogram('a b b a') == {'a': 2, 'b': 2}\n  histogram('a b c a b') == {'a': 2, 'b': 2}\n  histogram('b b b b a') == {'b': 4}\n  histogram('') == {}\n\n  */\nconst histogram = (test) => {\n  const letters = test.split(' ');\n  const letterMap = {};\n  const letterCounts = {};\n  letters.forEach((letter) => {\n    letterMap[letter] = letterCounts[letter] = 0;\n  });\n  letters.forEach((letter) => {\n    letterCounts[letter]++;\n  });\n  return letterMap;\n};\n\n/*\n  Return a list of all possible combinations of n elements. Each element can be either a string or a number.\n  \n  Example:\n  combinations(3) == ['abc', 'def', 'ghi']\n  combinations(4) == ['abc', 'def', 'ghi', 'jkl']\n  combinations(5) == ['abc', 'def', 'ghi', 'jkl','mno']\n  combinations(6) == ['abc', 'def', 'ghi', 'jkl','mno', 'pqrs']\n  combinations(7) == ['abc', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv']\n  combinations(8) == ['abc', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'uvw']\n  combinations(9) == ['abc', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'uvw', 'wxz']\n  combinations(10) == ['abc', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'uvw', 'wxz', 'yzx']\n  combinations(11) == ['abc', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'uvw', 'wxz', 'yzx', 'zxy']\n  combinations(12) == ['abc', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'uvw', 'wxz', 'yzx', 'zxy', 'zyx']\n  combinations(13) == ['abc', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'uvw', 'wxz', 'yzx', 'zxy', 'zyx', 'aac']\n  combinations(14) == ['abc', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'uvw', 'wxz', 'yzx', 'zxy', 'zyx', 'aac', 'bab']\n  combinations(15) == ['abc', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'uvw', 'wxz', 'yzx', 'zxy', 'zyx', 'aac', 'bab', 'baa']\n  combinations(16) == ['abc', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'uvw', 'wxz', 'yzx', 'zxy', 'zyx', 'aac', 'bab', 'baa', 'bab']\n  combinations(17) == ['abc', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'uvw', 'wxz', 'yzx', 'zxy', 'zyx', 'aac', 'bab', 'baa', 'bab', 'baa']\n  combinations(18) == ['abc', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'uvw', 'wxz', 'yzx', 'zxy', 'zyx', 'aac', 'bab', 'baa', 'bab', 'baa', 'bab']\n  combinations(19) == ['abc', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'uvw', 'wxz', 'yzx', 'zxy', 'zyx', 'aac', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa']\n  combinations(20) == ['abc', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'uvw', 'wxz', 'yzx', 'zxy', 'zyx', 'aac', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab']\n  combinations(21) == ['abc', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'uvw', 'wxz', 'yzx', 'zxy', 'zyx', 'aac', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa']\n  combinations(22) == ['abc', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'uvw', 'wxz', 'yzx', 'zxy', 'zyx', 'aac', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa']\n  combinations(23) == ['abc', 'def', 'ghi', 'jkl','mno', 'pqrs', 'tuv', 'uvw', 'wxz', 'yzx', 'zxy', 'zyx', 'aac', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'baa', 'bab', 'ba", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/112", "prompt": "/*Task We get two strings s and c, you have to delete all characters in s that correspond to any character in c, then check if the result string is palindrome. A string is called palindrome if it reads the same backward as forward. You should return a tuple that contains the result string and true / false for verification.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = 1\n    for (let j = 0; j < c.length; j++) {\n      if (s[i] == c[j]) {\n        y = 0\n      }\n    }\n    if (y == 1) {\n      t += s[i]\n    }\n  }\n  let z = 1\n  for (let i = 0; i < t.length; i++) {\n    if (t[i] != t[t.length - i - 1]) {\n      z = 0\n    }\n  }\n  if (z == 0) {\n    return (z, false)\n  }\n  return (z, true)\n}\n\n", "test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n  console.assert(JSON.stringify(reverseDelete('dwik', 'w'))) ===\n    JSON.stringify(['dik', false])\n  console.assert(JSON.stringify(reverseDelete('a', 'a'))) ===\n    JSON.stringify(['', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', ''))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'v'))) ===\n    JSON.stringify(['abcdedcba', true])\n  console.assert(JSON.stringify(reverseDelete('vabba', 'v'))) ===\n    JSON.stringify(['abba', true])\n  console.assert(JSON.stringify(reverseDelete('mamma', 'mia'))) ===\n    JSON.stringify(['', true])\n}\n\ntestReverseDelete()\n", "declaration": "\nconst reverseDelete = (s, c) => {\n", "example_test": "const testReverseDelete = () => {\n  console.assert(JSON.stringify(reverseDelete('abcde', 'ae'))) ===\n    JSON.stringify(['bcd', false])\n  console.assert(JSON.stringify(reverseDelete('abcdef', 'b'))) ===\n    JSON.stringify(['acdef', false])\n  console.assert(JSON.stringify(reverseDelete('abcdedcba', 'ab'))) ===\n    JSON.stringify(['cdedc', true])\n}\ntestReverseDelete()\n", "entry_point": "reverseDelete", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Task We get two strings s and c, you have to delete all characters in s that correspond to any character in c, then check if the result string is palindrome. A string is called palindrome if it reads the same backward as forward. You should return a tuple that contains the result string and true / false for verification.\n  Example\n  For s = \"abcde\", c = \"ae\", the result should be ('bcd',false)\n  For s = \"abcdef\", c = \"b\"  the result should be ('acdef',false)\n  For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',true)\n  */\nconst reverseDelete = (s, c) => {\n  let result = '';\n  let reverse = '';\n  let reverseIndex = 0;\n  let reverseIndex2 = 0;\n  let reverseIndex3 = 0;\n  let reverseIndex4 = 0;\n  let reverseIndex5 = 0;\n  let reverseIndex6 = 0;\n  let reverseIndex7 = 0;\n  let reverseIndex8 = 0;\n  let reverseIndex9 = 0;\n  let reverseIndex10 = 0;\n  let reverseIndex11 = 0;\n  let reverseIndex12 = 0;\n  let reverseIndex13 = 0;\n  let reverseIndex14 = 0;\n  let reverseIndex15 = 0;\n  let reverseIndex16 = 0;\n  let reverseIndex17 = 0;\n  let reverseIndex18 = 0;\n  let reverseIndex19 = 0;\n  let reverseIndex20 = 0;\n  let reverseIndex21 = 0;\n  let reverseIndex22 = 0;\n  let reverseIndex23 = 0;\n  let reverseIndex24 = 0;\n  let reverseIndex25 = 0;\n  let reverseIndex26 = 0;\n  let reverseIndex27 = 0;\n  let reverseIndex28 = 0;\n  let reverseIndex29 = 0;\n  let reverseIndex30 = 0;\n  let reverseIndex31 = 0;\n  let reverseIndex32 = 0;\n  let reverseIndex33 = 0;\n  let reverseIndex34 = 0;\n  let reverseIndex35 = 0;\n  let reverseIndex36 = 0;\n  let reverseIndex37 = 0;\n  let reverseIndex38 = 0;\n  let reverseIndex39 = 0;\n  let reverseIndex40 = 0;\n  let reverseIndex41 = 0;\n  let reverseIndex42 = 0;\n  let reverseIndex43 = 0;\n  let reverseIndex44 = 0;\n  let reverseIndex45 = 0;\n  let reverseIndex46 = 0;\n  let reverseIndex47 = 0;\n  let reverseIndex48 = 0;\n  let reverseIndex49 = 0;\n  let reverseIndex50 = 0;\n  let reverseIndex51 = 0;\n  let reverseIndex52 = 0;\n  let reverseIndex53 = 0;\n  let reverseIndex54 = 0;\n  let reverseIndex55 = 0;\n  let reverseIndex56 = 0;\n  let reverseIndex57 = 0;\n  let reverseIndex58 = 0;\n  let reverseIndex59 = 0;\n  let reverseIndex60 = 0;\n  let reverseIndex61 = 0;\n  let reverseIndex62 = 0;\n  let reverseIndex63 = 0;\n  let reverseIndex64 = 0;\n  let reverseIndex65 = 0;\n  let reverseIndex66 = 0;\n  let reverseIndex67 = 0;\n  let reverseIndex68 = 0;\n  let reverseIndex69 = 0;\n  let reverseIndex70 = 0;\n  let reverseIndex71 = 0;\n  let reverseIndex72 = 0;\n  let reverseIndex73 = 0;\n  let reverseIndex74 = 0;\n  let reverseIndex75 = 0;\n  let reverseIndex76 = 0;\n  let reverseIndex77 = 0;\n  let reverseIndex78 = 0;\n  let reverseIndex79 = 0;\n  let reverseIndex80 = 0;\n  let reverseIndex81 = 0;\n  let reverseIndex82 = 0;\n  let reverseIndex83 = 0;\n  let reverseIndex84 = 0;\n  let reverseIndex85 = 0;\n  let reverseIndex86 = 0;\n  let reverseIndex87 = 0;\n  let reverseIndex88 = 0;\n  let reverseIndex89 = 0;\n  let reverseIndex90 = 0;\n  let reverseIndex91 = 0;\n  let reverseIndex92 = 0;\n  let reverseIndex93 = 0;\n  let reverseIndex94 = 0;\n  let reverseIndex95 = 0;\n  let reverseIndex96 = 0;\n  let reverseIndex97 = 0;\n  let reverseIndex98 = 0;\n  let reverseIndex99 = 0;\n  let reverseIndex100 = 0;\n  let reverseIndex101 = 0;\n  let reverseIndex102 = 0;\n  let reverseIndex103 = 0;\n  let reverseIndex104 = 0;\n  let reverseIndex105 = 0;\n  let reverseIndex106 = 0;\n  let reverseIndex107 = 0;\n  let reverseIndex108 = 0;\n  let reverseIndex109 = 0;\n  let reverseIndex110 = 0;\n  let reverseIndex111 = 0;\n  let reverseIndex112 = 0;\n  let reverseIndex113 = 0;\n  let reverseIndex114 = 0;\n  let reverseIndex115 = 0;\n  let reverseIndex116 = 0;\n  let reverseIndex117 = 0;\n  let reverseIndex118 = 0;\n  let reverseIndex119 = 0;\n  let reverseIndex120 = 0;\n  let reverseIndex121 = 0;\n  let reverseIndex122 = 0;\n  let reverseIndex123 = 0;\n  let reverseIndex124 = 0;\n  let reverseIndex125 = 0;\n  let reverseIndex126 = 0;\n  let reverseIndex127 = 0;\n  let reverseIndex128 = 0;\n  let reverseIndex129 = 0;\n  let reverseIndex130 = 0;\n  let reverseIndex131 = 0;\n  let reverseIndex132 = 0;\n  let reverseIndex133 = 0;\n  let reverseIndex134 = 0;\n  let reverseIndex135 = 0;\n  let reverseIndex136 = 0;\n  let reverseIndex137 = 0;\n  let reverseIndex138 = 0;\n  let reverseIndex139 = 0;\n  let reverseIndex140 = 0;\n  let reverseIndex141 = 0;\n  let reverseIndex142 = 0;\n  let reverseIndex143 = 0;\n  let reverseIndex144 = 0;\n  let reverseIndex145 = 0;\n  let reverseIndex146 = 0;\n  let reverseIndex147 = 0;\n  let reverseIndex148 = 0;\n  let reverseIndex149 = 0;\n  let reverseIndex150 = 0;\n  let reverseIndex151 = 0;\n  let reverseIndex152 = 0;\n  let reverseIndex153 = 0;\n  let reverseIndex154 = 0;\n  let reverseIndex155 = 0;\n  let reverseIndex156 = 0;\n  let reverseIndex157 = 0;\n  let reverseIndex158 = 0;\n  let reverseIndex159 = 0;\n  let reverseIndex160 = 0;\n  let reverseIndex161 = 0;\n  let reverseIndex162 = 0;\n  let reverseIndex163 = 0;\n  let reverseIndex164 = 0;\n  let reverseIndex165 = 0;\n  let reverseIndex166 = 0;\n  let reverseIndex167 = 0;\n  let reverseIndex168 = 0;\n  let reverseIndex169 = 0;\n  let reverseIndex170 = 0;\n  let reverseIndex171 = 0;\n  let reverseIndex172 = 0;\n  let reverseIndex173 = 0;\n  let reverseIndex174 = 0;\n  let reverseIndex175 = 0;\n  let reverseIndex176 = 0;\n  let reverseIndex177 = 0;\n  let reverseIndex178 = 0;\n  let reverseIndex179 = 0;\n  let reverseIndex180 = 0;\n  let reverseIndex181 = 0;\n  let reverseIndex182 = 0;\n  let reverseIndex183 = 0;\n  let reverseIndex184 = 0;\n  let reverseIndex185 = 0;\n  let reverseIndex186 = 0;\n  let reverseIndex187 = 0;\n  let reverseIndex188 = 0;\n  let reverseIndex189 = 0;\n  let reverseIndex190 = 0;\n  let reverseIndex191 = 0;\n  let reverseIndex192 = 0;\n  let reverseIndex193 = 0;\n  let reverseIndex194 = 0;\n  let reverseIndex195 = 0;\n  let reverseIndex196 = 0;\n  let reverseIndex197 = 0;\n  let reverseIndex198 = 0;\n  let reverseIndex199 = 0;\n  let reverseIndex200 = 0;\n  let reverseIndex201 = 0;\n  let reverseIndex202 = 0;\n  let reverseIndex203 = 0;\n  let reverseIndex204 = 0;\n  let reverseIndex205 = 0;\n  let reverseIndex206 = 0;\n  let reverseIndex207 = 0;\n  let reverseIndex208 = 0;\n  let reverseIndex209 = 0;\n  let reverseIndex210 = 0;\n  let reverseIndex211 = 0;\n  let reverseIndex212 = 0;\n  let reverseIndex213 = 0;\n  let reverseIndex214 = 0;\n  let reverseIndex215 = 0;\n  let reverseIndex216 = 0;\n  let reverseIndex217 = 0;\n  let reverseIndex218 = 0;\n  let reverseIndex219 = 0;\n  let reverseIndex220 = 0;\n  let reverseIndex221 = 0;\n  let reverseIndex222 = 0;\n  let reverseIndex223 = 0;\n  let reverseIndex224 = 0;\n  let reverseIndex225 = 0;\n  let reverseIndex226 = 0;\n  let reverseIndex227 = 0;\n  let reverseIndex228 = 0;\n  let reverseIndex229 = 0;\n  let reverseIndex230 = 0;\n  let reverseIndex231 = 0;\n  let reverseIndex232 = 0;\n  let reverseIndex233 = 0;\n  let reverseIndex234 = 0;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/113", "prompt": "/*GIf you create a list of strings in which each string consists only of digits, you return a list. Each element i of the output should be \"the number of odd elements in the string i of input,\" with all i's being replaced by the number of odd digits in the i'th string of input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n", "canonical_solution": "  let d = []\n  for (let i = 0; i < lst.length; i++) {\n    let p = 0;\n    let h = lst[i].length\n    for (let j = 0; j < h; j++) {\n      if (lst[i][j].charCodeAt() % 2 == 1) { p++ }\n    }\n    p = p.toString()\n    d.push('the number of odd elements ' + p + 'n the str' + p + 'ng ' + p + ' of the ' + p + 'nput.')\n  }\n  return d\n}\n\n", "test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n  console.assert(\n    JSON.stringify(oddCount(['271', '137', '314'])) ===\n    JSON.stringify([\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n      'the number of odd elements 3n the str3ng 3 of the 3nput.',\n      'the number of odd elements 2n the str2ng 2 of the 2nput.',\n    ])\n  )\n}\n\ntestOddCount()\n", "declaration": "\nconst oddCount = (lst) => {\n", "example_test": "const testOddCount = () => {\n  console.assert(\n    JSON.stringify(oddCount(['1234567'])) ===\n    JSON.stringify([\n      'the number of odd elements 4n the str4ng 4 of the 4nput.',\n    ])\n  )\n  console.assert(JSON.stringify(\n    oddCount(['3', '11111111'])) ===\n    JSON.stringify([\n      'the number of odd elements 1n the str1ng 1 of the 1nput.',\n      'the number of odd elements 8n the str8ng 8 of the 8nput.',\n    ])\n  )\n}\ntestOddCount()\n", "entry_point": "oddCount", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*GIf you create a list of strings in which each string consists only of digits, you return a list. Each element i of the output should be \"the number of odd elements in the string i of input,\" with all i's being replaced by the number of odd digits in the i'th string of input.\n\n  >>> oddCount(['1234567'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let oddCounts = [];\n  for (let i = 0; i < lst.length; i++) {\n    let oddCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j].match(/\\d/)) {\n        oddCount++;\n      }\n    }\n    oddCounts.push(oddCount);\n  }\n  return oddCounts;\n};\n\n/*\n  Given a string of numbers, return the number of even numbers in the string.\n\n  >>> evenCount(['1','2','3'])\n  [\"the number of even elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even elements 2n the str2ng 2 of the 2nput.\",\n   \"the number of even elements 3n the str3ng 3 of the 3nput.\"]\n  */\nconst evenCount = (lst) => {\n  let evenCounts = [];\n  for (let i = 0; i < lst.length; i++) {\n    let evenCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j].match(/\\d/)) {\n        evenCount++;\n      }\n    }\n    evenCounts.push(evenCount);\n  }\n  return evenCounts;\n};\n\n/*\n  Given a string of numbers, return the number of odd numbers in the string.\n\n  >>> oddCount(['1','2','3'])\n  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n  >>> oddCount(['3',\"11111111\"])\n  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n  */\nconst oddCount = (lst) => {\n  let oddCounts = [];\n  for (let i = 0; i < lst.length; i++) {\n    let oddCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j].match(/\\d/)) {\n        oddCount++;\n      }\n    }\n    oddCounts.push(oddCount);\n  }\n  return oddCounts;\n};\n\n/*\n  Given a string of numbers, return the number of even and odd numbers in the string.\n\n  >>> evenOddCount(['1','2','3'])\n  [\"the number of even and odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even and odd elements 2n the str2ng 2 of the 2nput.\",\n   \"the number of even and odd elements 3n the str3ng 3 of the 3nput.\"]\n  */\nconst evenOddCount = (lst) => {\n  let evenOddCounts = [];\n  for (let i = 0; i < lst.length; i++) {\n    let evenOddCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j].match(/\\d/)) {\n        evenOddCount++;\n      }\n    }\n    evenOddCounts.push(evenOddCount);\n  }\n  return evenOddCounts;\n};\n\n/*\n  Given a string of numbers, return the number of even and odd numbers in the string.\n\n  >>> evenOddCount(['1','2','3'])\n  [\"the number of even and odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even and odd elements 2n the str2ng 2 of the 2nput.\",\n   \"the number of even and odd elements 3n the str3ng 3 of the 3nput.\"]\n  */\nconst evenOddCount = (lst) => {\n  let evenOddCounts = [];\n  for (let i = 0; i < lst.length; i++) {\n    let evenOddCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j].match(/\\d/)) {\n        evenOddCount++;\n      }\n    }\n    evenOddCounts.push(evenOddCount);\n  }\n  return evenOddCounts;\n};\n\n/*\n  Given a string of numbers, return the number of even and odd numbers in the string.\n\n  >>> evenOddCount(['1','2','3'])\n  [\"the number of even and odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even and odd elements 2n the str2ng 2 of the 2nput.\",\n   \"the number of even and odd elements 3n the str3ng 3 of the 3nput.\"]\n  */\nconst evenOddCount = (lst) => {\n  let evenOddCounts = [];\n  for (let i = 0; i < lst.length; i++) {\n    let evenOddCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j].match(/\\d/)) {\n        evenOddCount++;\n      }\n    }\n    evenOddCounts.push(evenOddCount);\n  }\n  return evenOddCounts;\n};\n\n/*\n  Given a string of numbers, return the number of even and odd numbers in the string.\n\n  >>> evenOddCount(['1','2','3'])\n  [\"the number of even and odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even and odd elements 2n the str2ng 2 of the 2nput.\",\n   \"the number of even and odd elements 3n the str3ng 3 of the 3nput.\"]\n  */\nconst evenOddCount = (lst) => {\n  let evenOddCounts = [];\n  for (let i = 0; i < lst.length; i++) {\n    let evenOddCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j].match(/\\d/)) {\n        evenOddCount++;\n      }\n    }\n    evenOddCounts.push(evenOddCount);\n  }\n  return evenOddCounts;\n};\n\n/*\n  Given a string of numbers, return the number of even and odd numbers in the string.\n\n  >>> evenOddCount(['1','2','3'])\n  [\"the number of even and odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even and odd elements 2n the str2ng 2 of the 2nput.\",\n   \"the number of even and odd elements 3n the str3ng 3 of the 3nput.\"]\n  */\nconst evenOddCount = (lst) => {\n  let evenOddCounts = [];\n  for (let i = 0; i < lst.length; i++) {\n    let evenOddCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j].match(/\\d/)) {\n        evenOddCount++;\n      }\n    }\n    evenOddCounts.push(evenOddCount);\n  }\n  return evenOddCounts;\n};\n\n/*\n  Given a string of numbers, return the number of even and odd numbers in the string.\n\n  >>> evenOddCount(['1','2','3'])\n  [\"the number of even and odd elements 1n the str1ng 1 of the 1nput.\",\n   \"the number of even and odd elements 2n the str2ng 2 of the 2nput.\",\n   \"the number of even and odd elements 3n the str3ng 3 of the 3nput.\"]\n  */\nconst evenOddCount = (lst) => {\n  let evenOddCounts = [];\n  for (let i = 0; i < lst.length; i++) {\n    let evenOddCount = 0;\n    for (let j = 0; j < lst[i].length; j++) {\n      if (lst[i][j].match(/\\d/)) {\n        evenOddCount++;\n      }\n    }\n    evenOddCounts.push(evenO", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/114", "prompt": "/*\n  Given an array of integers, search for the minimum sum of all non-empty sub-arrays of numbers.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n", "canonical_solution": "  let min = nums[0]\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j <= nums.length; j++) {\n      let s = 0;\n      for (let k = i; k < j; k++) {\n        s += nums[k]\n      }\n      if (s < min) { min = s }\n    }\n  }\n  return min\n}\n\n", "test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n  console.assert(minSubArraySum([-1, -2, -3, 2, -10]) === -14)\n  console.assert(minSubArraySum([-9999999999999999]) === -9999999999999999)\n  console.assert(minSubArraySum([0, 10, 20, 1000000]) === 0)\n  console.assert(minSubArraySum([-1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([100, -1, -2, -3, 10, -5]) === -6)\n  console.assert(minSubArraySum([10, 11, 13, 8, 3, 4]) === 3)\n  console.assert(minSubArraySum([100, -33, 32, -1, 0, -2]) === -33)\n  console.assert(minSubArraySum([-10]) === -10)\n  console.assert(minSubArraySum([7]) === 7)\n  console.assert(minSubArraySum([1, -1]) === -1)\n}\n\ntestMinSubArraySum()\n", "declaration": "\nconst minSubArraySum = (nums) => {\n", "example_test": "const testMinSubArraySum = () => {\n  console.assert(minSubArraySum([2, 3, 4, 1, 2, 4]) === 1)\n  console.assert(minSubArraySum([-1, -2, -3]) === -6)\n}\ntestMinSubArraySum()\n", "entry_point": "minSubArraySum", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given an array of integers, search for the minimum sum of all non-empty sub-arrays of numbers.\n  Example\n  minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n  minSubArraySum([-1, -2, -3]) == -6\n  */\nconst minSubArraySum = (nums) => {\n  const numsCopy = nums.slice();\n  let sum = 0;\n  for (let i = 0; i < numsCopy.length; i++) {\n    if (numsCopy[i]!== 0) {\n      sum += numsCopy[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers, search for the maximum sum of all non-empty sub-arrays of numbers.\n  Example\n  maxSubArraySum([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArraySum([-1, -2, -3]) == 6\n  */\nconst maxSubArraySum = (nums) => {\n  const numsCopy = nums.slice();\n  let sum = 0;\n  for (let i = 0; i < numsCopy.length; i++) {\n    if (numsCopy[i]!== 0) {\n      sum += numsCopy[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given an array of integers, search for the minimum number of non-empty sub-arrays of numbers.\n  Example\n  minSubArrayCount([2, 3, 4, 1, 2, 4]) == 3\n  minSubArrayCount([-1, -2, -3]) == 2\n  */\nconst minSubArrayCount = (nums) => {\n  const numsCopy = nums.slice();\n  let count = 0;\n  for (let i = 0; i < numsCopy.length; i++) {\n    if (numsCopy[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers, search for the maximum number of non-empty sub-arrays of numbers.\n  Example\n  maxSubArrayCount([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArrayCount([-1, -2, -3]) == 3\n  */\nconst maxSubArrayCount = (nums) => {\n  const numsCopy = nums.slice();\n  let count = 0;\n  for (let i = 0; i < numsCopy.length; i++) {\n    if (numsCopy[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers, search for the minimum number of non-empty sub-arrays of numbers.\n  Example\n  minSubArrayCount([2, 3, 4, 1, 2, 4]) == 3\n  minSubArrayCount([-1, -2, -3]) == 2\n  */\nconst minSubArrayCount = (nums) => {\n  const numsCopy = nums.slice();\n  let count = 0;\n  for (let i = 0; i < numsCopy.length; i++) {\n    if (numsCopy[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers, search for the maximum number of non-empty sub-arrays of numbers.\n  Example\n  maxSubArrayCount([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArrayCount([-1, -2, -3]) == 3\n  */\nconst maxSubArrayCount = (nums) => {\n  const numsCopy = nums.slice();\n  let count = 0;\n  for (let i = 0; i < numsCopy.length; i++) {\n    if (numsCopy[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers, search for the minimum number of non-empty sub-arrays of numbers.\n  Example\n  minSubArrayCount([2, 3, 4, 1, 2, 4]) == 3\n  minSubArrayCount([-1, -2, -3]) == 2\n  */\nconst minSubArrayCount = (nums) => {\n  const numsCopy = nums.slice();\n  let count = 0;\n  for (let i = 0; i < numsCopy.length; i++) {\n    if (numsCopy[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers, search for the maximum number of non-empty sub-arrays of numbers.\n  Example\n  maxSubArrayCount([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArrayCount([-1, -2, -3]) == 3\n  */\nconst maxSubArrayCount = (nums) => {\n  const numsCopy = nums.slice();\n  let count = 0;\n  for (let i = 0; i < numsCopy.length; i++) {\n    if (numsCopy[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers, search for the minimum number of non-empty sub-arrays of numbers.\n  Example\n  minSubArrayCount([2, 3, 4, 1, 2, 4]) == 3\n  minSubArrayCount([-1, -2, -3]) == 2\n  */\nconst minSubArrayCount = (nums) => {\n  const numsCopy = nums.slice();\n  let count = 0;\n  for (let i = 0; i < numsCopy.length; i++) {\n    if (numsCopy[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers, search for the maximum number of non-empty sub-arrays of numbers.\n  Example\n  maxSubArrayCount([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArrayCount([-1, -2, -3]) == 3\n  */\nconst maxSubArrayCount = (nums) => {\n  const numsCopy = nums.slice();\n  let count = 0;\n  for (let i = 0; i < numsCopy.length; i++) {\n    if (numsCopy[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers, search for the minimum number of non-empty sub-arrays of numbers.\n  Example\n  minSubArrayCount([2, 3, 4, 1, 2, 4]) == 3\n  minSubArrayCount([-1, -2, -3]) == 2\n  */\nconst minSubArrayCount = (nums) => {\n  const numsCopy = nums.slice();\n  let count = 0;\n  for (let i = 0; i < numsCopy.length; i++) {\n    if (numsCopy[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers, search for the maximum number of non-empty sub-arrays of numbers.\n  Example\n  maxSubArrayCount([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArrayCount([-1, -2, -3]) == 3\n  */\nconst maxSubArrayCount = (nums) => {\n  const numsCopy = nums.slice();\n  let count = 0;\n  for (let i = 0; i < numsCopy.length; i++) {\n    if (numsCopy[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers, search for the minimum number of non-empty sub-arrays of numbers.\n  Example\n  minSubArrayCount([2, 3, 4, 1, 2, 4]) == 3\n  minSubArrayCount([-1, -2, -3]) == 2\n  */\nconst minSubArrayCount = (nums) => {\n  const numsCopy = nums.slice();\n  let count = 0;\n  for (let i = 0; i < numsCopy.length; i++) {\n    if (numsCopy[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers, search for the maximum number of non-empty sub-arrays of numbers.\n  Example\n  maxSubArrayCount([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArrayCount([-1, -2, -3]) == 3\n  */\nconst maxSubArrayCount = (nums) => {\n  const numsCopy = nums.slice();\n  let count = 0;\n  for (let i = 0; i < numsCopy.length; i++) {\n    if (numsCopy[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers, search for the minimum number of non-empty sub-arrays of numbers.\n  Example\n  minSubArrayCount([2, 3, 4, 1, 2, 4]) == 3\n  minSubArrayCount([-1, -2, -3]) == 2\n  */\nconst minSubArrayCount = (nums) => {\n  const numsCopy = nums.slice();\n  let count = 0;\n  for (let i = 0; i < numsCopy.length; i++) {\n    if (numsCopy[i]!== 0) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Given an array of integers, search for the maximum number of non-empty sub-arrays of numbers.\n  Example\n  maxSubArrayCount([2, 3, 4, 1, 2, 4]) == 4\n  maxSubArrayCount([-1, -2, -3]) == 3\n  */\nconst maxSubArrayCount = (nums) => {\n  const numsCopy = nums.slice();\n  let count = 0;\n  for (let i = 0; i < ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/115", "prompt": "/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < grid.length; i++) {\n    let m = 0\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == 1) { m++ }\n    }\n    while (m > 0) {\n      m -= capacity;\n      p++;\n    }\n  }\n  return p\n}\n\n", "test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      2\n    ) === 4\n  )\n  console.assert(\n    maxFill(\n      [\n        [1, 1, 1, 1],\n        [1, 1, 1, 1],\n      ],\n      9\n    ) === 2\n  )\n}\n\ntestMaxFill()\n", "declaration": "\nconst maxFill = (grid, capacity) => {\n", "example_test": "const testMaxFill = () => {\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [1, 1, 1, 1],\n      ],\n      1\n    ) === 6\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 1, 1],\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 1, 1, 1],\n      ],\n      2\n    ) === 5\n  )\n  console.assert(\n    maxFill(\n      [\n        [0, 0, 0],\n        [0, 0, 0],\n      ],\n      5\n    ) === 0\n  )\n}\ntestMaxFill()\n", "entry_point": "maxFill", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFill = (grid, capacity) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const result = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        result += (grid[i][j] * capacity);\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFillWithBucket = (grid, capacity) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const result = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        result += (grid[i][j] * capacity);\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFillWithBucketWithBucket = (grid, capacity) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const result = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        result += (grid[i][j] * capacity);\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFillWithBucketWithBucketWithBucket = (grid, capacity) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const result = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        result += (grid[i][j] * capacity);\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n          bucket_capacity : 1\n      Output: 6\n\n  Example 2:\n      Input: \n          grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n          bucket_capacity : 2\n      Output: 5\n  \n  Example 3:\n      Input: \n          grid : [[0,0,0], [0,0,0]]\n          bucket_capacity : 5\n      Output: 0\n\n  Constraints:\n      * all wells have the same length\n      * 1 <= grid.length <= 10^2\n      * 1 <= grid[:,1].length <= 10^2\n      * grid[i][j] -> 0 | 1\n      * 1 <= capacity <= 10\n  */\nconst maxFillWithBucketWithBucketWithBucketWithBucket = (grid, capacity) => {\n  const n = grid.length;\n  const m = grid[0].length;\n  const result = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (grid[i][j] === 1) {\n        result += (grid[i][j] * capacity);\n      }\n    }\n  }\n  return result;\n};\n\n/*\n  You are given a rectangular grid of wells. Each row represents a single well,\n  and each 1 in a row represents a single unit of water.\n  Each well has a corresponding bucket that can be used to extract water from it, \n  and all buckets have the same capacity.\n  Your task is to use the buckets to empty the wells.\n  Output the number of times you need to lower the buckets.\n\n  Example 1:\n      Input: \n          grid : [[0,0,1,", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/116", "prompt": "/*\n  In this kata, you must sort an array of non-negative integers by the number of ones in their binary representation in ascending order. If the number of ones is similar, sort by decimal value. It must be implemented as follows:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      let w1 = p[ind].toString(2)\n      let f1 = 0\n      for (let u = 0; u < w1.length; u++) {\n        if (w1[u] == '1') { f1++ }\n      }\n      let w2 = p[k].toString(2)\n      let f2 = 0\n      for (let u = 0; u < w2.length; u++) {\n        if (w2[u] == '1') { f2++ }\n      }\n      if (f2 < f1 || (f1 == f2 && p[k] < p[ind])) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(sortArray([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4])) ===\n    JSON.stringify([2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\n  )\n  console.assert(\n    JSON.stringify(sortArray([3, 6, 44, 12, 32, 5])) ===\n    JSON.stringify([32, 3, 5, 6, 12, 44])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n  console.assert(\n    JSON.stringify(sortArray([2, 4, 8, 16, 32])) ===\n    JSON.stringify([2, 4, 8, 16, 32])\n  )\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (arr) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(\n    JSON.stringify(sortArray([1, 5, 2, 3, 4])) ===\n    JSON.stringify([1, 2, 4, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortArray([-2, -3, -4, -5, -6])) ===\n    JSON.stringify([-4, -2, -6, -5, -3])\n  )\n  console.assert(\n    JSON.stringify(sortArray([1, 0, 2, 3, 4])) ===\n    JSON.stringify([0, 1, 2, 4, 3])\n  )\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  In this kata, you must sort an array of non-negative integers by the number of ones in their binary representation in ascending order. If the number of ones is similar, sort by decimal value. It must be implemented as follows:\n  >>> sortArray([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  >>> sortArray([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  >>> sortArray([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  */\nconst sortArray = (arr) => {\n  const [sortedArr, count] = arr.sort((a, b) => a - b);\n  return [sortedArr, count];\n};\n\n/*\n  Given an array of non-negative integers, return an array of the same length with each element containing the number of ones in its binary representation in ascending order. For example, given [5, 1, 3, 2], return [5, 1, 3, 2, 1].\n  >>> countOnes([5, 1, 3, 2]) == [5, 1, 3, 2, 1]\n  */\nconst countOnes = (arr) => {\n  const [counts, count] = sortArray(arr);\n  return [counts, count];\n};\n\n/*\n  Given an array of non-negative integers, return an array of the same length with each element containing the number of ones in its binary representation in descending order. For example, given [5, 1, 3, 2], return [3, 2, 1, 2, 5].\n  >>> countOnes([5, 1, 3, 2]) == [3, 2, 1, 2, 5].\n  */\nconst countOnesDesc = (arr) => {\n  const [counts, count] = sortArray(arr);\n  return [counts, count];\n};\n\n/*\n  Given an array of non-negative integers, return an array of the same length with each element containing the number of ones in its binary representation in ascending order. For example, given [5, 1, 3, 2], return [5, 1, 3, 2, 1].\n  >>> countOnes([5, 1, 3, 2]) == [5, 1, 3, 2, 1].\n  */\nconst countOnesDesc = (arr) => {\n  const [counts, count] = sortArray(arr);\n  return [counts, count];\n};\n\n/*\n  Given an array of non-negative integers, return an array of the same length with each element containing the number of ones in its binary representation in descending order. For example, given [5, 1, 3, 2], return [3, 2, 1, 2, 5].\n  >>> countOnes([5, 1, 3, 2]) == [3, 2, 1, 2, 5].\n  */\nconst countOnesDesc = (arr) => {\n  const [counts, count] = sortArray(arr);\n  return [counts, count];\n};\n\n/*\n  Given an array of non-negative integers, return an array of the same length with each element containing the number of ones in its binary representation in ascending order. For example, given [5, 1, 3, 2], return [5, 1, 3, 2, 1].\n  >>> countOnes([5, 1, 3, 2]) == [5, 1, 3, 2, 1].\n  */\nconst countOnesDesc = (arr) => {\n  const [counts, count] = sortArray(arr);\n  return [counts, count];\n};\n\n/*\n  Given an array of non-negative integers, return an array of the same length with each element containing the number of ones in its binary representation in descending order. For example, given [5, 1, 3, 2], return [3, 2, 1, 2, 5].\n  >>> countOnes([5, 1, 3, 2]) == [3, 2, 1, 2, 5].\n  */\nconst countOnesDesc = (arr) => {\n  const [counts, count] = sortArray(arr);\n  return [counts, count];\n};\n\n/*\n  Given an array of non-negative integers, return an array of the same length with each element containing the number of ones in its binary representation in ascending order. For example, given [5, 1, 3, 2], return [5, 1, 3, 2, 1].\n  >>> countOnes([5, 1, 3, 2]) == [5, 1, 3, 2, 1].\n  */\nconst countOnesDesc = (arr) => {\n  const [counts, count] = sortArray(arr);\n  return [counts, count];\n};\n\n/*\n  Given an array of non-negative integers, return an array of the same length with each element containing the number of ones in its binary representation in descending order. For example, given [5, 1, 3, 2], return [3, 2, 1, 2, 5].\n  >>> countOnes([5, 1, 3, 2]) == [3, 2, 1, 2, 5].\n  */\nconst countOnesDesc = (arr) => {\n  const [counts, count] = sortArray(arr);\n  return [counts, count];\n};\n\n/*\n  Given an array of non-negative integers, return an array of the same length with each element containing the number of ones in its binary representation in ascending order. For example, given [5, 1, 3, 2], return [5, 1, 3, 2, 1].\n  >>> countOnes([5, 1, 3, 2]) == [5, 1, 3, 2, 1].\n  */\nconst countOnesDesc = (arr) => {\n  const [counts, count] = sortArray(arr);\n  return [counts, count];\n};\n\n/*\n  Given an array of non-negative integers, return an array of the same length with each element containing the number of ones in its binary representation in descending order. For example, given [5, 1, 3, 2], return [3, 2, 1, 2, 5].\n  >>> countOnes([5, 1, 3, 2]) == [3, 2, 1, 2, 5].\n  */\nconst countOnesDesc = (arr) => {\n  const [counts, count] = sortArray(arr);\n  return [counts, count];\n};\n\n/*\n  Given an array of non-negative integers, return an array of the same length with each element containing the number of ones in its binary representation in ascending order. For example, given [5, 1, 3, 2], return [5, 1, 3, 2, 1].\n  >>> countOnes([5, 1, 3, 2]) == [5, 1, 3, 2, 1].\n  */\nconst countOnesDesc = (arr) => {\n  const [counts, count] = sortArray(arr);\n  return [counts, count];\n};\n\n/*\n  Given an array of non-negative integers, return an array of the same length with each element containing the number of ones in its binary representation in descending order. For example, given [5, 1, 3, 2], return [3, 2, 1, 2, 5].\n  >>> countOnes([5, 1, 3, 2]) == [3, 2, 1, 2, 5].\n  */\nconst countOnesDesc = (arr) => {\n  const [counts, count] = sortArray(arr);\n  return [counts, count];\n};\n\n/*\n  Given an array of non-negative integers, return an array of the same length with each element containing the number of ones in its binary representation in ascending order. For example, given [5, 1, 3, 2], return [5, 1, 3, 2, 1].\n  >>> countOnes([5, 1, 3, 2]) == [5, 1, 3, 2, 1].\n  */\nconst countOnesDesc = (arr) => {\n  const [counts, count] = sortArray(arr);\n  return [counts, count];\n};\n\n/*\n  Given an array of non-negative integers, return an array of the same length with each element containing the number of ones in its binary representation in descending order. For example, given [5, 1, 3, 2], return [3, 2, 1, 2, 5].\n  >>> countOnes([5, 1, 3, 2]) == [3, 2, 1, 2, 5].\n  */\nconst countOnesDesc = (arr) => {\n  const [counts, count] = sortArray(arr);\n  return [counts, count];\n};\n\n/*\n  Given an array of non-negative integers, return an array of the same length with each element containing the number of ones in its binary representation in ascending order. For example, given [5, 1, 3, 2], return [5, 1, 3, 2, 1].\n  >>> countOnes([5, 1, 3, 2]) == [5, 1, 3, 2, 1].\n  */\nconst countOnesDesc = (arr) => {\n  const [counts, count] = sortArray(arr);\n  return [counts, count];\n};\n\n/*\n  Given an array of non-negative integers, return an array of the same length with each element containing the number of ones in its binary representation in descending order. For example, given [5, 1, 3, 2], return [3, 2, 1, 2, 5].\n  >>> countOnes([5, 1, 3, 2]) == [3, 2, 1, 2, 5].\n  */\nconst countOne", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/117", "prompt": "/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n", "canonical_solution": "  let t = s.split(/\\s/)\n  if (s == '') { return [] }\n  let k = []\n  for (let i = 0; i < t.length; i++) {\n    let l = 0\n    for (let j = 0; j < t[i].length; j++) {\n      if (t[i][j] != 'a' && t[i][j] != 'e' && t[i][j] != 'i' && t[i][j] != 'o' && t[i][j] != 'u' && t[i][j] != 'A' &&\n        t[i][j] != 'U' && t[i][j] != 'O' && t[i][j] != 'I' && t[i][j] != 'E') {\n        l++\n      }\n    }\n    if (l == n) { k.push(t[i]) }\n  }\n  return k\n}\n\n", "test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('a b c d e f', 1)) ===\n    JSON.stringify(['b', 'c', 'd', 'f'])\n  )\n\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n  console.assert(JSON.stringify(selectWords('', 4)) === JSON.stringify([]))\n}\n\ntestSelectWords()\n", "declaration": "\nconst selectWords = (s, n) => {\n", "example_test": "const testSelectWords = () => {\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 4)) ===\n    JSON.stringify(['little'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('simple white space', 2)) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Hello world', 4)) === JSON.stringify(['world'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Uncle sam', 3)) === JSON.stringify(['Uncle'])\n  )\n  console.assert(\n    JSON.stringify(selectWords('Mary had a little lamb', 3)) ===\n    JSON.stringify(['Mary', 'lamb'])\n  )\n}\ntestSelectWords()\n", "entry_point": "selectWords", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Given a string s and a natural number n, you have been tasked to implement \n  a function that returns a list of all words from string s that contain exactly \n  n consonants, in order these words appear in the string s.\n  If the string s is empty then the function should return an empty list.\n  Note: you may assume the input string contains only letters and spaces.\n  Examples:\n  selectWords(\"Mary had a little lamb\", 4) ==> [\"little\"]\n  selectWords(\"Mary had a little lamb\", 3) ==> [\"Mary\")\n  selectWords(\"simple white space\", 2) ==> []\n  selectWords(\"Hello world\", 4) ==> [\"world\"]\n  selectWords(\"Uncle sam\", 3) ==> [\"Uncle\"]\n  */\nconst selectWords = (s, n) => {\n  let words = [];\n  let word = '';\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let count = 0;\n  let temp = '';\n  let temp2 = '';\n  let temp3 = '';\n  let temp4 = '';\n  let temp5 = '';\n  let temp6 = '';\n  let temp7 = '';\n  let temp8 = '';\n  let temp9 = '';\n  let temp10 = '';\n  let temp11 = '';\n  let temp12 = '';\n  let temp13 = '';\n  let temp14 = '';\n  let temp15 = '';\n  let temp16 = '';\n  let temp17 = '';\n  let temp18 = '';\n  let temp19 = '';\n  let temp20 = '';\n  let temp21 = '';\n  let temp22 = '';\n  let temp23 = '';\n  let temp24 = '';\n  let temp25 = '';\n  let temp26 = '';\n  let temp27 = '';\n  let temp28 = '';\n  let temp29 = '';\n  let temp30 = '';\n  let temp31 = '';\n  let temp32 = '';\n  let temp33 = '';\n  let temp34 = '';\n  let temp35 = '';\n  let temp36 = '';\n  let temp37 = '';\n  let temp38 = '';\n  let temp39 = '';\n  let temp40 = '';\n  let temp41 = '';\n  let temp42 = '';\n  let temp43 = '';\n  let temp44 = '';\n  let temp45 = '';\n  let temp46 = '';\n  let temp47 = '';\n  let temp48 = '';\n  let temp49 = '';\n  let temp50 = '';\n  let temp51 = '';\n  let temp52 = '';\n  let temp53 = '';\n  let temp54 = '';\n  let temp55 = '';\n  let temp56 = '';\n  let temp57 = '';\n  let temp58 = '';\n  let temp59 = '';\n  let temp60 = '';\n  let temp61 = '';\n  let temp62 = '';\n  let temp63 = '';\n  let temp64 = '';\n  let temp65 = '';\n  let temp66 = '';\n  let temp67 = '';\n  let temp68 = '';\n  let temp69 = '';\n  let temp70 = '';\n  let temp71 = '';\n  let temp72 = '';\n  let temp73 = '';\n  let temp74 = '';\n  let temp75 = '';\n  let temp76 = '';\n  let temp77 = '';\n  let temp78 = '';\n  let temp79 = '';\n  let temp80 = '';\n  let temp81 = '';\n  let temp82 = '';\n  let temp83 = '';\n  let temp84 = '';\n  let temp85 = '';\n  let temp86 = '';\n  let temp87 = '';\n  let temp88 = '';\n  let temp89 = '';\n  let temp90 = '';\n  let temp91 = '';\n  let temp92 = '';\n  let temp93 = '';\n  let temp94 = '';\n  let temp95 = '';\n  let temp96 = '';\n  let temp97 = '';\n  let temp98 = '';\n  let temp99 = '';\n  let temp100 = '';\n  let temp101 = '';\n  let temp102 = '';\n  let temp103 = '';\n  let temp104 = '';\n  let temp105 = '';\n  let temp106 = '';\n  let temp107 = '';\n  let temp108 = '';\n  let temp109 = '';\n  let temp110 = '';\n  let temp111 = '';\n  let temp112 = '';\n  let temp113 = '';\n  let temp114 = '';\n  let temp115 = '';\n  let temp116 = '';\n  let temp117 = '';\n  let temp118 = '';\n  let temp119 = '';\n  let temp120 = '';\n  let temp121 = '';\n  let temp122 = '';\n  let temp123 = '';\n  let temp124 = '';\n  let temp125 = '';\n  let temp126 = '';\n  let temp127 = '';\n  let temp128 = '';\n  let temp129 = '';\n  let temp130 = '';\n  let temp131 = '';\n  let temp132 = '';\n  let temp133 = '';\n  let temp134 = '';\n  let temp135 = '';\n  let temp136 = '';\n  let temp137 = '';\n  let temp138 = '';\n  let temp139 = '';\n  let temp140 = '';\n  let temp141 = '';\n  let temp142 = '';\n  let temp143 = '';\n  let temp144 = '';\n  let temp145 = '';\n  let temp146 = '';\n  let temp147 = '';\n  let temp148 = '';\n  let temp149 = '';\n  let temp150 = '';\n  let temp151 = '';\n  let temp152 = '';\n  let temp153 = '';\n  let temp154 = '';\n  let temp155 = '';\n  let temp156 = '';\n  let temp157 = '';\n  let temp158 = '';\n  let temp159 = '';\n  let temp160 = '';\n  let temp161 = '';\n  let temp162 = '';\n  let temp163 = '';\n  let temp164 = '';\n  let temp165 = '';\n  let temp166 = '';\n  let temp167 = '';\n  let temp168 = '';\n  let temp169 = '';\n  let temp170 = '';\n  let temp171 = '';\n  let temp172 = '';\n  let temp173 = '';\n  let temp174 = '';\n  let temp175 = '';\n  let temp176 = '';\n  let temp177 = '';\n  let temp178 = '';\n  let temp179 = '';\n  let temp180 = '';\n  let temp181 = '';\n  let temp182 = '';\n  let temp183 = '';\n  let temp184 = '';\n  let temp185 = '';\n  let temp186 = '';\n  let temp187 = '';\n  let temp188 = '';\n  let temp189 = '';\n  let temp190 = '';\n  let temp191 = '';\n  let temp192 = '';\n  let temp193 = '';\n  let temp194 = '';\n  let temp195 = '';\n  let temp196 = '';\n  let temp197 = '';\n  let temp198 = '';\n  let temp199 = '';\n  let temp200 = '';\n  let temp201 = '';\n  let temp202 = '';\n  let temp203 = '';\n  let temp204 = '';\n  let temp205 = '';\n  let temp206 = '';\n  let temp207 = '';\n  let temp208 = '';\n  let temp209 = '';\n  let temp210 = '';\n  let temp211 = '';\n  let temp212 = '';\n  let temp213 = '';\n  let temp214 = '';\n  let temp215 = '';\n  let temp216 = '';\n  let temp217 = '';\n  let temp218 = '';\n  let temp219 = '';\n  let temp220 = '';\n  let temp221 = '';\n  let temp222 = '';\n  let temp223 = '';\n  let temp224 = '';\n  let temp225 = '';\n  let temp226 = '';\n  let temp227 = '';\n  let temp228 = '';\n  let temp229 = '';\n  let temp230 = '';\n  let temp231 = '';\n  let temp232 = '';\n  let temp233 = '';\n  let temp234 = '';\n  let temp235 = '';\n  let temp236 = '';\n  let temp237 = '';\n  let temp238 = '';\n  let temp239 = '';\n  let temp240 = '';\n  let temp241 = '';\n  let temp242 = '';\n  let temp243 = '';\n  let temp244 = '';\n  let temp245 = '';\n  let temp246 = '';\n  let temp247 = '';\n  let temp248 = '';\n  let temp249 = '';\n  let temp250 = '';\n  let temp251 = '';\n  let temp252 = '';\n  let temp253 = '';\n  let temp254 = '';\n  let temp255 = '';\n  let temp256 = '';\n  let temp257 = '';\n  let temp258 = '';\n  let temp259 = '';\n  let temp260 = '';\n  let temp261 = '';\n  let temp262 = '';\n  let temp263 = '';\n  let temp264 = '';\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/118", "prompt": "/*YYour task is to find the next vowel between two consonants on the right side of the word (case-insensitive), vowels at the beginning and end do not count, and you return an empty string if you have not found a vowel that meets the above condition, and you can assume that the given string contains only English letters.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n", "canonical_solution": "  for (let i = word.length - 2; i > 0; i--) {\n    if (\n      !(word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'A' &&\n        word[i] != 'U' && word[i] != 'O' && word[i] != 'I' && word[i] != 'E')\n      &&\n      (word[i + 1] != 'a' && word[i + 1] != 'e' && word[i + 1] != 'i' && word[i + 1] != 'o' && word[i + 1] != 'u' && word[i + 1] != 'A' &&\n        word[i + 1] != 'U' && word[i + 1] != 'O' && word[i + 1] != 'I' && word[i + 1] != 'E')\n      &&\n      (word[i - 1] != 'a' && word[i - 1] != 'e' && word[i - 1] != 'i' && word[i - 1] != 'o' && word[i - 1] != 'u' && word[i - 1] != 'A' &&\n        word[i - 1] != 'U' && word[i - 1] != 'O' && word[i - 1] != 'I' && word[i - 1] != 'E')\n    ) {\n      return word[i]\n    }\n  }\n  return ''\n}\n\n", "test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('full') === 'u')\n  console.assert(getClosestVowel('easy') === '')\n  console.assert(getClosestVowel('eAsy') === '')\n  console.assert(getClosestVowel('ali') === '')\n  console.assert(getClosestVowel('bad') === 'a')\n  console.assert(getClosestVowel('most') === 'o')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('ba') === '')\n  console.assert(getClosestVowel('quick') === '')\n  console.assert(getClosestVowel('anime') === 'i')\n  console.assert(getClosestVowel('Asia') === '')\n  console.assert(getClosestVowel('Above') === 'o')\n}\n\ntestGetClosestVowel()\n", "declaration": "\nconst getClosestVowel = (word) => {\n", "example_test": "const testGetClosestVowel = () => {\n  console.assert(getClosestVowel('yogurt') === 'u')\n  console.assert(getClosestVowel('FULL') === 'U')\n  console.assert(getClosestVowel('ab') === '')\n  console.assert(getClosestVowel('quick') === '')\n}\ntestGetClosestVowel()\n", "entry_point": "getClosestVowel", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*YYour task is to find the next vowel between two consonants on the right side of the word (case-insensitive), vowels at the beginning and end do not count, and you return an empty string if you have not found a vowel that meets the above condition, and you can assume that the given string contains only English letters.\n\n  Example:\n  getClosestVowel(\"yogurt\") ==> \"u\"\n  getClosestVowel(\"FULL\") ==> \"U\"\n  getClosestVowel(\"quick\") ==> \"\"\n  getClosestVowel(\"ab\") ==> \"\"\n  */\nconst getClosestVowel = (word) => {\n  let vowels = vowelsTable;\n  let vowelsLength = vowels.length;\n  let vowelsIndex = 0;\n  let vowelsIndex2 = 0;\n  let vowelsIndex3 = 0;\n  let vowelsIndex4 = 0;\n  let vowelsIndex5 = 0;\n  let vowelsIndex6 = 0;\n  let vowelsIndex7 = 0;\n  let vowelsIndex8 = 0;\n  let vowelsIndex9 = 0;\n  let vowelsIndex10 = 0;\n  let vowelsIndex11 = 0;\n  let vowelsIndex12 = 0;\n  let vowelsIndex13 = 0;\n  let vowelsIndex14 = 0;\n  let vowelsIndex15 = 0;\n  let vowelsIndex16 = 0;\n  let vowelsIndex17 = 0;\n  let vowelsIndex18 = 0;\n  let vowelsIndex19 = 0;\n  let vowelsIndex20 = 0;\n  let vowelsIndex21 = 0;\n  let vowelsIndex22 = 0;\n  let vowelsIndex23 = 0;\n  let vowelsIndex24 = 0;\n  let vowelsIndex25 = 0;\n  let vowelsIndex26 = 0;\n  let vowelsIndex27 = 0;\n  let vowelsIndex28 = 0;\n  let vowelsIndex29 = 0;\n  let vowelsIndex30 = 0;\n  let vowelsIndex31 = 0;\n  let vowelsIndex32 = 0;\n  let vowelsIndex33 = 0;\n  let vowelsIndex34 = 0;\n  let vowelsIndex35 = 0;\n  let vowelsIndex36 = 0;\n  let vowelsIndex37 = 0;\n  let vowelsIndex38 = 0;\n  let vowelsIndex39 = 0;\n  let vowelsIndex40 = 0;\n  let vowelsIndex41 = 0;\n  let vowelsIndex42 = 0;\n  let vowelsIndex43 = 0;\n  let vowelsIndex44 = 0;\n  let vowelsIndex45 = 0;\n  let vowelsIndex46 = 0;\n  let vowelsIndex47 = 0;\n  let vowelsIndex48 = 0;\n  let vowelsIndex49 = 0;\n  let vowelsIndex50 = 0;\n  let vowelsIndex51 = 0;\n  let vowelsIndex52 = 0;\n  let vowelsIndex53 = 0;\n  let vowelsIndex54 = 0;\n  let vowelsIndex55 = 0;\n  let vowelsIndex56 = 0;\n  let vowelsIndex57 = 0;\n  let vowelsIndex58 = 0;\n  let vowelsIndex59 = 0;\n  let vowelsIndex60 = 0;\n  let vowelsIndex61 = 0;\n  let vowelsIndex62 = 0;\n  let vowelsIndex63 = 0;\n  let vowelsIndex64 = 0;\n  let vowelsIndex65 = 0;\n  let vowelsIndex66 = 0;\n  let vowelsIndex67 = 0;\n  let vowelsIndex68 = 0;\n  let vowelsIndex69 = 0;\n  let vowelsIndex70 = 0;\n  let vowelsIndex71 = 0;\n  let vowelsIndex72 = 0;\n  let vowelsIndex73 = 0;\n  let vowelsIndex74 = 0;\n  let vowelsIndex75 = 0;\n  let vowelsIndex76 = 0;\n  let vowelsIndex77 = 0;\n  let vowelsIndex78 = 0;\n  let vowelsIndex79 = 0;\n  let vowelsIndex80 = 0;\n  let vowelsIndex81 = 0;\n  let vowelsIndex82 = 0;\n  let vowelsIndex83 = 0;\n  let vowelsIndex84 = 0;\n  let vowelsIndex85 = 0;\n  let vowelsIndex86 = 0;\n  let vowelsIndex87 = 0;\n  let vowelsIndex88 = 0;\n  let vowelsIndex89 = 0;\n  let vowelsIndex90 = 0;\n  let vowelsIndex91 = 0;\n  let vowelsIndex92 = 0;\n  let vowelsIndex93 = 0;\n  let vowelsIndex94 = 0;\n  let vowelsIndex95 = 0;\n  let vowelsIndex96 = 0;\n  let vowelsIndex97 = 0;\n  let vowelsIndex98 = 0;\n  let vowelsIndex99 = 0;\n  let vowelsIndex100 = 0;\n  let vowelsIndex101 = 0;\n  let vowelsIndex102 = 0;\n  let vowelsIndex103 = 0;\n  let vowelsIndex104 = 0;\n  let vowelsIndex105 = 0;\n  let vowelsIndex106 = 0;\n  let vowelsIndex107 = 0;\n  let vowelsIndex108 = 0;\n  let vowelsIndex109 = 0;\n  let vowelsIndex110 = 0;\n  let vowelsIndex111 = 0;\n  let vowelsIndex112 = 0;\n  let vowelsIndex113 = 0;\n  let vowelsIndex114 = 0;\n  let vowelsIndex115 = 0;\n  let vowelsIndex116 = 0;\n  let vowelsIndex117 = 0;\n  let vowelsIndex118 = 0;\n  let vowelsIndex119 = 0;\n  let vowelsIndex120 = 0;\n  let vowelsIndex121 = 0;\n  let vowelsIndex122 = 0;\n  let vowelsIndex123 = 0;\n  let vowelsIndex124 = 0;\n  let vowelsIndex125 = 0;\n  let vowelsIndex126 = 0;\n  let vowelsIndex127 = 0;\n  let vowelsIndex128 = 0;\n  let vowelsIndex129 = 0;\n  let vowelsIndex130 = 0;\n  let vowelsIndex131 = 0;\n  let vowelsIndex132 = 0;\n  let vowelsIndex133 = 0;\n  let vowelsIndex134 = 0;\n  let vowelsIndex135 = 0;\n  let vowelsIndex136 = 0;\n  let vowelsIndex137 = 0;\n  let vowelsIndex138 = 0;\n  let vowelsIndex139 = 0;\n  let vowelsIndex140 = 0;\n  let vowelsIndex141 = 0;\n  let vowelsIndex142 = 0;\n  let vowelsIndex143 = 0;\n  let vowelsIndex144 = 0;\n  let vowelsIndex145 = 0;\n  let vowelsIndex146 = 0;\n  let vowelsIndex147 = 0;\n  let vowelsIndex148 = 0;\n  let vowelsIndex149 = 0;\n  let vowelsIndex150 = 0;\n  let vowelsIndex151 = 0;\n  let vowelsIndex152 = 0;\n  let vowelsIndex153 = 0;\n  let vowelsIndex154 = 0;\n  let vowelsIndex155 = 0;\n  let vowelsIndex156 = 0;\n  let vowelsIndex157 = 0;\n  let vowelsIndex158 = 0;\n  let vowelsIndex159 = 0;\n  let vowelsIndex160 = 0;\n  let vowelsIndex161 = 0;\n  let vowelsIndex162 = 0;\n  let vowelsIndex163 = 0;\n  let vowelsIndex164 = 0;\n  let vowelsIndex165 = 0;\n  let vowelsIndex166 = 0;\n  let vowelsIndex167 = 0;\n  let vowelsIndex168 = 0;\n  let vowelsIndex169 = 0;\n  let vowelsIndex170 = 0;\n  let vowelsIndex171 = 0;\n  let vowelsIndex172 = 0;\n  let vowelsIndex173 = 0;\n  let vowelsIndex174 = 0;\n  let vowelsIndex175 = 0;\n  let vowelsIndex176 = 0;\n  let vowelsIndex177 = 0;\n  let vowelsIndex178 = 0;\n  let vowelsIndex179 = 0;\n  let vowelsIndex180 = 0;\n  let vowelsIndex181 = 0;\n  let vowelsIndex182 = 0;\n  let vowelsIndex183 = 0;\n  let vowelsIndex184 = 0;\n  let vowelsIndex185 = 0;\n  let vowelsIndex186 = 0;\n  let vowelsIndex187 = 0;\n  let vowelsIndex188 = 0;\n  let vowelsIndex189 = 0;\n  let vowelsIndex190 = 0;\n  let vowelsIndex191 = 0;\n  let vowelsIndex192 = 0;\n  let vowelsIndex193 = 0;\n  let vowelsIndex194 = 0;\n  let vowelsIndex195 = 0;\n  let vowelsIndex196 = 0;\n  let vowelsIndex197 = 0;\n  let vowelsIndex198 = 0;\n  let vowelsIndex199 = 0;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/119", "prompt": "/* You get a list of two strings, both strings consisting only of open brackets' ('or closed brackets') '. Your task is to check if it is possible to concatenate the two strings in a certain order so that the resulting string is good. A string S is considered good if and only if all the brackets in S are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n", "canonical_solution": "  let w1 = lst[0] + lst[1]\n  let y = 0\n  let u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  w1 = lst[1] + lst[0]\n  y = 0\n  u = 1\n  for (let i = 0; i < w1.length; i++) {\n    if (w1[i] == '(') { y++ }\n    else { y-- }\n    if (y < 0) {\n      u = 0;\n      break;\n    }\n  }\n  if (u == 1 && y == 0) { return 'Yes' }\n  return 'No'\n}\n\n", "test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n  console.assert(matchParens(['(()(())', '())())']) === 'No')\n  console.assert(matchParens([')())', '(()()(']) === 'Yes')\n  console.assert(matchParens(['(())))', '(()())((']) === 'Yes')\n  console.assert(matchParens(['()', '())']) === 'No')\n  console.assert(matchParens(['(()(', '()))()']) === 'Yes')\n  console.assert(matchParens(['((((', '((())']) === 'No')\n  console.assert(matchParens([')(()', '(()(']) === 'No')\n  console.assert(matchParens([')(', ')(']) === 'No')\n  console.assert(matchParens(['(', ')']) === 'Yes')\n  console.assert(matchParens([')', '(']) === 'Yes')\n}\n", "declaration": "\nconst matchParens = (lst) => {\n", "example_test": "const testMatchParens = () => {\n  console.assert(matchParens(['()(', ')']) === 'Yes')\n  console.assert(matchParens([')', ')']) === 'No')\n}\ntestMatchParens()\n", "entry_point": "matchParens", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* You get a list of two strings, both strings consisting only of open brackets' ('or closed brackets') '. Your task is to check if it is possible to concatenate the two strings in a certain order so that the resulting string is good. A string S is considered good if and only if all the brackets in S are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchParens = (lst) => {\n  let result = 'No';\n  let openParens = 0;\n  let closeParens = 0;\n  let openParensCount = 0;\n  let closeParensCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '(') {\n      openParensCount++;\n    } else if (lst[i] === ')') {\n      closeParensCount++;\n    }\n    if (openParensCount === closeParensCount) {\n      if (openParensCount === 1) {\n        result += lst[i];\n      } else if (openParensCount === 2) {\n        result += lst[i] + lst[i + 1];\n      }\n    }\n  }\n  return result;\n};\n\n/* You get a list of two strings, both strings consisting only of open brackets' ('or closed brackets') '. Your task is to check if it is possible to concatenate the two strings in a certain order so that the resulting string is good. A string S is considered good if and only if all the brackets in S are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchParens(['()(', ')']) == 'Yes'\n  matchParens([')', ')']) == 'No'\n  */\nconst matchBrackets = (lst) => {\n  let result = 'No';\n  let openBrackets = 0;\n  let closeBrackets = 0;\n  let openBracketsCount = 0;\n  let closeBracketsCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '[') {\n      openBracketsCount++;\n    } else if (lst[i] === ']') {\n      closeBracketsCount++;\n    }\n    if (openBracketsCount === closeBracketsCount) {\n      if (openBracketsCount === 1) {\n        result += lst[i];\n      } else if (openBracketsCount === 2) {\n        result += lst[i] + lst[i + 1];\n      }\n    }\n  }\n  return result;\n};\n\n/* You get a list of two strings, both strings consisting only of open brackets' ('or closed brackets') '. Your task is to check if it is possible to concatenate the two strings in a certain order so that the resulting string is good. A string S is considered good if and only if all the brackets in S are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchBrackets(['()(', ')']) == 'Yes'\n  matchBrackets([')', ')']) == 'No'\n  */\nconst matchBraces = (lst) => {\n  let result = 'No';\n  let openBraces = 0;\n  let closeBraces = 0;\n  let openBracesCount = 0;\n  let closeBracesCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '{') {\n      openBracesCount++;\n    } else if (lst[i] === '}') {\n      closeBracesCount++;\n    }\n    if (openBracesCount === closeBracesCount) {\n      if (openBracesCount === 1) {\n        result += lst[i];\n      } else if (openBracesCount === 2) {\n        result += lst[i] + lst[i + 1];\n      }\n    }\n  }\n  return result;\n};\n\n/* You get a list of two strings, both strings consisting only of open brackets' ('or closed brackets') '. Your task is to check if it is possible to concatenate the two strings in a certain order so that the resulting string is good. A string S is considered good if and only if all the brackets in S are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchBraces(['()(', ')']) == 'Yes'\n  matchBraces([')', ')']) == 'No'\n  */\nconst matchCurly = (lst) => {\n  let result = 'No';\n  let openCurly = 0;\n  let closeCurly = 0;\n  let openCurlyCount = 0;\n  let closeCurlyCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '{') {\n      openCurlyCount++;\n    } else if (lst[i] === '}') {\n      closeCurlyCount++;\n    }\n    if (openCurlyCount === closeCurlyCount) {\n      if (openCurlyCount === 1) {\n        result += lst[i];\n      } else if (openCurlyCount === 2) {\n        result += lst[i] + lst[i + 1];\n      }\n    }\n  }\n  return result;\n};\n\n/* You get a list of two strings, both strings consisting only of open brackets' ('or closed brackets') '. Your task is to check if it is possible to concatenate the two strings in a certain order so that the resulting string is good. A string S is considered good if and only if all the brackets in S are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchCurly(['()(', ')']) == 'Yes'\n  matchCurly([')', ')']) == 'No'\n  */\nconst matchSquare = (lst) => {\n  let result = 'No';\n  let openSquare = 0;\n  let closeSquare = 0;\n  let openSquareCount = 0;\n  let closeSquareCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '[') {\n      openSquareCount++;\n    } else if (lst[i] === ']') {\n      closeSquareCount++;\n    }\n    if (openSquareCount === closeSquareCount) {\n      if (openSquareCount === 1) {\n        result += lst[i];\n      } else if (openSquareCount === 2) {\n        result += lst[i] + lst[i + 1];\n      }\n    }\n  }\n  return result;\n};\n\n/* You get a list of two strings, both strings consisting only of open brackets' ('or closed brackets') '. Your task is to check if it is possible to concatenate the two strings in a certain order so that the resulting string is good. A string S is considered good if and only if all the brackets in S are balanced. For example: the string '(())()' is good, while the string\n  '())' is not.\n  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n  Examples:\n  matchSquare(['()(', ')']) == 'Yes'\n  matchSquare([')', ')']) == 'No'\n  */\nconst matchAngle = (lst) => {\n  let result = 'No';\n  let openAngle = 0;\n  let closeAngle = 0;\n  let openAngleCount = 0;\n  let closeAngleCount = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === '<') {\n      openAngleCount++;\n    } else if (lst[i] === '>') {\n      closeAngleCount++;\n    }\n    if (openAngleCount === closeAngleCount) {\n      if (openAngleCount === 1) {\n        result += lst[i];\n      } else if (openAngleCount === 2) {\n        result += lst[i] + lst[i + 1];\n      }\n    }\n  }\n  return result;\n};\n\n/* You get a list of two strings, both strings consisting only of open brackets' ('or closed brackets') '. Your task is to check if it is possible to concatenate the two strings in a certain order so that the resulting string is good. A string ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/12", "prompt": "/* Returns the longest string from the list of strings. Returns the first one if there are multiple strings of the same length. Returns zero if the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n", "canonical_solution": "  if (!Array.isArray(strings) || strings.length == 0)\n    return null;\n  var maxlen = Math.max(...strings.map(x => x.length));\n  for (const s of strings) {\n    if (s.length == maxlen) {\n      return s;\n    }\n  }\n}\n\n", "test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['x', 'y', 'z']) === 'x')\n  console.assert(longest(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) === 'zzzz')\n}\n\ntestLongest()\n", "declaration": "\nconst longest = (strings) => {\n", "example_test": "const testLongest = () => {\n  console.assert(longest([]) === null)\n  console.assert(longest(['a', 'b', 'c']) === 'a')\n  console.assert(longest(['a', 'bb', 'ccc']) === 'ccc')\n}\ntestLongest()\n", "entry_point": "longest", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Returns the longest string from the list of strings. Returns the first one if there are multiple strings of the same length. Returns zero if the input list is empty.\n  >>> longest([])\n\n  >>> longest(['a', 'b', 'c'])\n  'a'\n  >>> longest(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst longest = (strings) => {\n  let longestString = '';\n  let longestLength = 0;\n\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].length > longestLength) {\n      longestString = strings[i];\n      longestLength = strings[i].length;\n    }\n  }\n\n  return longestString;\n};\n\n/**\n * Returns the first string from the list of strings. Returns the first one if there are multiple strings of the same length. Returns zero if the input list is empty.\n  >>> first([])\n\n  >>> first(['a', 'b', 'c'])\n  'a'\n  >>> first(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst first = (strings) => {\n  let firstString = '';\n  let firstLength = 0;\n\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].length < firstLength) {\n      firstString = strings[i];\n      firstLength = strings[i].length;\n    }\n  }\n\n  return firstString;\n};\n\n/**\n * Returns the last string from the list of strings. Returns the last one if there are multiple strings of the same length. Returns zero if the input list is empty.\n  >>> last([])\n\n  >>> last(['a', 'b', 'c'])\n  'c'\n  >>> last(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst last = (strings) => {\n  let lastString = '';\n  let lastLength = 0;\n\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].length > lastLength) {\n      lastString = strings[i];\n      lastLength = strings[i].length;\n    }\n  }\n\n  return lastString;\n};\n\n/**\n * Returns the middle string from the list of strings. Returns the middle one if there are multiple strings of the same length. Returns zero if the input list is empty.\n  >>> middle([])\n\n  >>> middle(['a', 'b', 'c'])\n  'b'\n  >>> middle(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst middle = (strings) => {\n  let middleString = '';\n  let middleLength = 0;\n\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].length < middleLength) {\n      middleString = strings[i];\n      middleLength = strings[i].length;\n    }\n  }\n\n  return middleString;\n};\n\n/**\n * Returns the middle string from the list of strings. Returns the middle one if there are multiple strings of the same length. Returns zero if the input list is empty.\n  >>> middle([])\n\n  >>> middle(['a', 'b', 'c'])\n  'b'\n  >>> middle(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst middle = (strings) => {\n  let middleString = '';\n  let middleLength = 0;\n\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].length < middleLength) {\n      middleString = strings[i];\n      middleLength = strings[i].length;\n    }\n  }\n\n  return middleString;\n};\n\n/**\n * Returns the middle string from the list of strings. Returns the middle one if there are multiple strings of the same length. Returns zero if the input list is empty.\n  >>> middle([])\n\n  >>> middle(['a', 'b', 'c'])\n  'b'\n  >>> middle(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst middle = (strings) => {\n  let middleString = '';\n  let middleLength = 0;\n\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].length < middleLength) {\n      middleString = strings[i];\n      middleLength = strings[i].length;\n    }\n  }\n\n  return middleString;\n};\n\n/**\n * Returns the middle string from the list of strings. Returns the middle one if there are multiple strings of the same length. Returns zero if the input list is empty.\n  >>> middle([])\n\n  >>> middle(['a', 'b', 'c'])\n  'b'\n  >>> middle(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst middle = (strings) => {\n  let middleString = '';\n  let middleLength = 0;\n\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].length < middleLength) {\n      middleString = strings[i];\n      middleLength = strings[i].length;\n    }\n  }\n\n  return middleString;\n};\n\n/**\n * Returns the middle string from the list of strings. Returns the middle one if there are multiple strings of the same length. Returns zero if the input list is empty.\n  >>> middle([])\n\n  >>> middle(['a', 'b', 'c'])\n  'b'\n  >>> middle(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst middle = (strings) => {\n  let middleString = '';\n  let middleLength = 0;\n\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].length < middleLength) {\n      middleString = strings[i];\n      middleLength = strings[i].length;\n    }\n  }\n\n  return middleString;\n};\n\n/**\n * Returns the middle string from the list of strings. Returns the middle one if there are multiple strings of the same length. Returns zero if the input list is empty.\n  >>> middle([])\n\n  >>> middle(['a', 'b', 'c'])\n  'b'\n  >>> middle(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst middle = (strings) => {\n  let middleString = '';\n  let middleLength = 0;\n\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].length < middleLength) {\n      middleString = strings[i];\n      middleLength = strings[i].length;\n    }\n  }\n\n  return middleString;\n};\n\n/**\n * Returns the middle string from the list of strings. Returns the middle one if there are multiple strings of the same length. Returns zero if the input list is empty.\n  >>> middle([])\n\n  >>> middle(['a', 'b', 'c'])\n  'b'\n  >>> middle(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst middle = (strings) => {\n  let middleString = '';\n  let middleLength = 0;\n\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].length < middleLength) {\n      middleString = strings[i];\n      middleLength = strings[i].length;\n    }\n  }\n\n  return middleString;\n};\n\n/**\n * Returns the middle string from the list of strings. Returns the middle one if there are multiple strings of the same length. Returns zero if the input list is empty.\n  >>> middle([])\n\n  >>> middle(['a', 'b', 'c'])\n  'b'\n  >>> middle(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst middle = (strings) => {\n  let middleString = '';\n  let middleLength = 0;\n\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].length < middleLength) {\n      middleString = strings[i];\n      middleLength = strings[i].length;\n    }\n  }\n\n  return middleString;\n};\n\n/**\n * Returns the middle string from the list of strings. Returns the middle one if there are multiple strings of the same length. Returns zero if the input list is empty.\n  >>> middle([])\n\n  >>> middle(['a', 'b', 'c'])\n  'b'\n  >>> middle(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst middle = (strings) => {\n  let middleString = '';\n  let middleLength = 0;\n\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].length < middleLength) {\n      middleString = strings[i];\n      middleLength = strings[i].length;\n    }\n  }\n\n  return middleString;\n};\n\n/**\n * Returns the middle string from the list of strings. Returns the middle one if there are multiple strings of the same length. Returns zero if the input list is empty.\n  >>> middle([])\n\n  >>> middle(['a', 'b', 'c'])\n  'b'\n  >>> middle(['a', 'bb', 'ccc'])\n  'ccc'\n  */\nconst middle = (strings) => {\n  let middleString = '';\n  let middleLength = 0;\n\n  for (let i = 0; i < strings.length; i++) {\n    if (strings[i].length < middleLength) {\n      middleString = strings[i];\n      middleLength = strings[i].length;\n    }\n  }\n\n  return middleString;\n};\n\n/**\n * Returns the middle string from the list of strings. Returns the middle one if there are multiple string", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/120", "prompt": "/*\n  If you specify an array of integers and a positive integer k, you return a sorted list of length k with the maximum k numbers in Arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n", "canonical_solution": "  let p = arr\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  if (k == 0) { return [] }\n  return p.slice(-k)\n}\n\n", "test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n  console.assert(\n    JSON.stringify(maximum([123, -123, 20, 0, 1, 2, -3], 3)) ===\n    JSON.stringify([2, 20, 123])\n  )\n  console.assert(\n    JSON.stringify(maximum([-123, 20, 0, 1, 2, -3], 4)) ===\n    JSON.stringify([0, 1, 2, 20])\n  )\n  console.assert(\n    JSON.stringify(maximum([5, 15, 0, 3, -13, -8, 0], 7)) ===\n    JSON.stringify([-13, -8, 0, 0, 3, 5, 15])\n  )\n  console.assert(\n    JSON.stringify(maximum([-1, 0, 2, 5, 3, -10], 2)) === JSON.stringify([3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 0, 5, -7], 1)) === JSON.stringify([5])\n  )\n  console.assert(JSON.stringify(maximum([4, -4], 2)) === JSON.stringify([-4, 4]))\n  console.assert(\n    JSON.stringify(maximum([-10, 10], 2)) === JSON.stringify([-10, 10])\n  )\n  console.assert(\n    JSON.stringify(maximum([1, 2, 3, -23, 243, -400, 0], 0)) ===\n    JSON.stringify([])\n  )\n}\n\ntestMaximum()\n", "declaration": "\nconst maximum = (arr, k) => {\n", "example_test": "const testMaximum = () => {\n  console.assert(\n    JSON.stringify(maximum([-3, -4, 5], 3)) === JSON.stringify([-4, -3, 5])\n  )\n  console.assert(\n    JSON.stringify(maximum([4, -4, 4], 2)) === JSON.stringify([4, 4])\n  )\n  console.assert(\n    JSON.stringify(maximum([-3, 2, 1, 2, -1, -2, 1], 1)) === JSON.stringify([2])\n  )\n}\ntestMaximum()\n", "entry_point": "maximum", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  If you specify an array of integers and a positive integer k, you return a sorted list of length k with the maximum k numbers in Arr.\n\n  Example 1:\n\n      Input: arr = [-3, -4, 5], k = 3\n      Output: [-4, -3, 5]\n\n  Example 2:\n\n      Input: arr = [4, -4, 4], k = 2\n      Output: [4, 4]\n\n  Example 3:\n\n      Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n      Output: [2]\n\n  Note:\n      1. The length of the array will be in the range of [1, 1000].\n      2. The elements in the array will be in the range of [-1000, 1000].\n      3. 0 <= k <= len(arr)\n  */\nconst maximum = (arr, k) => {\n  const len = arr.length;\n  if (len <= k) {\n    return arr;\n  }\n  const mid = Math.floor(len / 2);\n  const left = maximum([...arr.slice(0, mid),...arr.slice(mid + 1)], k - 1);\n  const right = maximum([...arr.slice(mid + 1),...arr.slice(0, mid)], k - 1);\n  return [...left,...right];\n};\n\n// https://leetcode.com/problems/find-the-maximum-subarray-sum/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-ii/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iii/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-iv/\n// https://leetcode.com/problems/find-the-maximum-subarray-sum-", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/121", "prompt": "/*GIf you create a non-empty list of integers, you return the sum of all odd elements in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 1) {\n      p += lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n  console.assert(solution([5, 9]) === 5)\n  console.assert(solution([2, 4, 8]) === 0)\n  console.assert(solution([30, 13, 23, 32]) === 23)\n  console.assert(solution([3, 13, 2, 9]) === 3)\n}\n\ntestSolution()\n", "declaration": "\nconst solution = (lst) => {\n", "example_test": "const testSolution = () => {\n  console.assert(solution([5, 8, 7, 1]) === 12)\n  console.assert(solution([3, 3, 3, 3, 3]) === 9)\n  console.assert(solution([30, 13, 24, 321]) === 0)\n}\ntestSolution()\n", "entry_point": "solution", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*GIf you create a non-empty list of integers, you return the sum of all odd elements in even positions.\n  \n\n  Examples\n  solution([5, 8, 7, 1]) ==> 12\n  solution([3, 3, 3, 3, 3]) ==> 9\n  solution([30, 13, 24, 321]) ==>0\n  */\nconst solution = (lst) => {\n  const odds = lst.filter((x) => x % 2 === 1);\n  return odds.length? odds.length : 0;\n};\n\nmodule.exports = solution;\n\n},{}],3:[function(require,module,exports){\n/*\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/122", "prompt": "/*\n  For a non-empty array of integers arr and an integer k, the sum of the elements with a maximum of two digits from the first k elements of arr is returned.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < k; i++) {\n    if (arr[i] < 100 && arr[i] > -100) { p += arr[i] }\n  }\n  return p\n}\n\n", "test": "const testAddElements = () => {\n  console.assert(addElements([1, -2, -3, 41, 57, 76, 87, 88, 99], 3) === -4)\n  console.assert(addElements([111, 121, 3, 4000, 5, 6], 2) === 0)\n  console.assert(addElements([11, 21, 3, 90, 5, 6, 7, 8, 9], 4) === 125)\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n  console.assert(addElements([1], 1) === 1)\n}\n\ntestAddElements()\n", "declaration": "\nconst addElements = (arr, k) => {\n", "example_test": "const testAddElements = () => {\n  console.assert(addElements([111, 21, 3, 4000, 5, 6, 7, 8, 9], 4) === 24)\n}\ntestAddElements()\n", "entry_point": "addElements", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  For a non-empty array of integers arr and an integer k, the sum of the elements with a maximum of two digits from the first k elements of arr is returned.\n\n  Example:\n\n      Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n      Output: 24 # sum of 21 + 3\n\n  Constraints:\n      1. 1 <= len(arr) <= 100\n      2. 1 <= k <= len(arr)\n  */\nconst addElements = (arr, k) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0 && arr[i] % 10 === 0) {\n      sum += arr[i];\n    }\n  }\n  return sum + addElements(arr.slice(k + 1), k);\n};\n\n// A recursive solution for finding the sum of all elements in a sorted array.\nconst sumOfSortedArray = (arr, k) => {\n  if (k === 0) return 0;\n  return addElements(arr, k) + sumOfSortedArray(arr.slice(k + 1), k - 1);\n};\n\n// A recursive solution for finding the sum of all elements in a sorted array.\nconst sumOfSortedArrayRecursive = (arr, k) => {\n  if (k === 0) return 0;\n  return addElements(arr, k) + sumOfSortedArrayRecursive(arr.slice(k + 1), k - 1);\n};\n\n// A recursive solution for finding the sum of all elements in a sorted array.\nconst sumOfSortedArrayRecursive2 = (a, k) => {\n  if (k === 0) return 0;\n  return addElements(a, k) + sumOfSortedArrayRecursive2(\n    a.slice(k + 1),\n    k - 1\n  );\n};\n\n// A recursive solution for finding the sum of all elements in a sorted array.\nconst sumOfSortedArrayRecursive3 = (arr, k) => {\n  if (k === 0) return 0;\n  return addElements(arr, k) + sumOfSortedArrayRecursive3(\n    arr.slice(k + 1),\n    k - 1\n  );\n};\n\n// A recursive solution for finding the sum of all elements in a sorted array.\nconst sumOfSortedArrayRecursive4 = (arr, k) => {\n  if (k === 0) return 0;\n  return addElements(arr, k) + sumOfSortedArrayRecursive4(\n    arr.slice(k + 1),\n    k - 1\n  );\n};\n\n// A recursive solution for finding the sum of all elements in a sorted array.\nconst sumOfSortedArrayRecursive5 = (arr, k) => {\n  if (k === 0) return 0;\n  return addElements(arr, k) + sumOfSortedArrayRecursive5(\n    arr.slice(k + 1),\n    k - 1\n  );\n};\n\n// A recursive solution for finding the sum of all elements in a sorted array.\nconst sumOfSortedArrayRecursive6 = (arr, k) => {\n  if (k === 0) return 0;\n  return addElements(arr, k) + sumOfSortedArrayRecursive6(\n    arr.slice(k + 1),\n    k - 1\n  );\n};\n\n// A recursive solution for finding the sum of all elements in a sorted array.\nconst sumOfSortedArrayRecursive7 = (arr, k) => {\n  if (k === 0) return 0;\n  return addElements(arr, k) + sumOfSortedArrayRecursive7(\n    arr.slice(k + 1),\n    k - 1\n  );\n};\n\n// A recursive solution for finding the sum of all elements in a sorted array.\nconst sumOfSortedArrayRecursive8 = (arr, k) => {\n  if (k === 0) return 0;\n  return addElements(arr, k) + sumOfSortedArrayRecursive8(\n    arr.slice(k + 1),\n    k - 1\n  );\n};\n\n// A recursive solution for finding the sum of all elements in a sorted array.\nconst sumOfSortedArrayRecursive9 = (arr, k) => {\n  if (k === 0) return 0;\n  return addElements(arr, k) + sumOfSortedArrayRecursive9(\n    arr.slice(k + 1),\n    k - 1\n  );\n};\n\n// A recursive solution for finding the sum of all elements in a sorted array.\nconst sumOfSortedArrayRecursive10 = (arr, k) => {\n  if (k === 0) return 0;\n  return addElements(arr, k) + sumOfSortedArrayRecursive10(\n    arr.slice(k + 1),\n    k - 1\n  );\n};\n\n// A recursive solution for finding the sum of all elements in a sorted array.\nconst sumOfSortedArrayRecursive11 = (arr, k) => {\n  if (k === 0) return 0;\n  return addElements(arr, k) + sumOfSortedArrayRecursive11(\n    arr.slice(k + 1),\n    k - 1\n  );\n};\n\n// A recursive solution for finding the sum of all elements in a sorted array.\nconst sumOfSortedArrayRecursive12 = (arr, k) => {\n  if (k === 0) return 0;\n  return addElements(arr, k) + sumOfSortedArrayRecursive12(\n    arr.slice(k + 1),\n    k - 1\n  );\n};\n\n// A recursive solution for finding the sum of all elements in a sorted array.\nconst sumOfSortedArrayRecursive13 = (arr, k) => {\n  if (k === 0) return 0;\n  return addElements(arr, k) + sumOfSortedArrayRecursive13(\n    arr.slice(k + 1),\n    k - 1\n  );\n};\n\n// A recursive solution for finding the sum of all elements in a sorted array.\nconst sumOfSortedArrayRecursive14 = (arr, k) => {\n  if (k === 0) return 0;\n  return addElements(arr, k) + sumOfSortedArrayRecursive14(\n    arr.slice(k + 1),\n    k - 1\n  );\n};\n\n// A recursive solution for finding the sum of all elements in a sorted array.\nconst sumOfSortedArrayRecursive15 = (arr, k) => {\n  if (k === 0) return 0;\n  return addElements(arr, k) + sumOfSortedArrayRecursive15(\n    arr.slice(k + 1),\n    k - 1\n  );\n};\n\n// A recursive solution for finding the sum of all elements in a sorted array.\nconst sumOfSortedArrayRecursive16 = (arr, k) => {\n  if (k === 0) return 0;\n  return addElements(arr, k) + sumOfSortedArrayRecursive16(\n    arr.slice(k + 1),\n    k - 1\n  );\n};\n\n// A recursive solution for finding the sum of all elements in a sorted array.\nconst sumOfSortedArrayRecursive17 = (arr, k) => {\n  if (k === 0) return 0;\n  return addElements(arr, k) + sumOfSortedArrayRecursive17(\n    arr.slice(k + 1),\n    k - 1\n  );\n};\n\n// A recursive solution for finding the sum of all elements in a sorted array.\nconst sumOfSortedArrayRecursive18 = (arr, k) => {\n  if (k === 0) return 0;\n  return addElements(arr, k) + sumOfSortedArrayRecursive18(\n    arr.slice(k + 1),\n    k - 1\n  );\n};\n\n// A recursive solution for finding the sum of all elements in a sorted array.\nconst sumOfSortedArrayRecursive19 = (arr, k) => {\n  if (k === 0) return 0;\n  return addElements(arr, k) + sumOfSortedArrayRecursive19(\n    arr.slice(k + 1),\n    k - 1\n  );\n};\n\n// A recursive solution for finding the sum of all elements in a sorted array.\nconst sumOfSortedArrayRecursive20 = (arr, k) => {\n  if (k === 0) return 0;\n  return addElements(arr, k) + sumOfSortedArrayRecursive20(\n    arr.slice(k + 1),\n    k - 1\n  );\n};\n\n// A recursive solution for finding the sum of all elements in a sorted array.\nconst sumOfSortedArrayRecursive21 = (arr, k) => {\n  if (k === 0) return 0;\n  return addElements(arr, k) + sumOfSortedArrayRecursive21(\n    arr.slice(k + 1),\n    k - 1\n  );\n};\n\n// A recursive solution for finding the sum of all elements in a sorted ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/123", "prompt": "/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n", "canonical_solution": "  let p = []\n  let t = n\n  while (1) {\n    let u = 0\n    for (let i = 0; i < p.length; i++) {\n      if (t == p[i]) {\n        u = 1\n        break;\n      }\n    }\n    if (u == 1) { break }\n    if (t % 2 == 1) { p.push(t); t = 3 * t + 1 }\n    else { t = t / 2 }\n  }\n  for (let j = 0; j < p.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < p.length; k++) {\n      if (p[k] < p[ind]) {\n        ind = k\n      }\n    }\n    if (ind > j) {\n      let tmp = p[j]\n      p[j] = p[ind]\n      p[ind] = tmp\n    }\n  }\n  return p\n}\n\n", "test": "const testGetOddCollatz = () => {\n  console.assert(\n    JSON.stringify(getOddCollatz(14)) === JSON.stringify([1, 5, 7, 11, 13, 17])\n  )\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n  console.assert(JSON.stringify(getOddCollatz(12)) === JSON.stringify([1, 3, 5]))\n  console.assert(JSON.stringify(getOddCollatz(1)) === JSON.stringify([1]))\n}\n\ntestGetOddCollatz()\n", "declaration": "\nconst getOddCollatz = (n) => {\n", "example_test": "const testGetOddCollatz = () => {\n  console.assert(JSON.stringify(getOddCollatz(5)) === JSON.stringify([1, 5]))\n}\ntestGetOddCollatz()\n", "entry_point": "getOddCollatz", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*\n  Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getOddCollatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n  */\nconst getOddCollatz = (n) => {\n  let collatz = [];\n  let prev = 1;\n  let next;\n\n  while (n > 0) {\n    next = prev * prev;\n    collatz.push(next);\n    prev = next;\n    n -= 1;\n  }\n\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the even numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getEvenCollatz(5) returns [1, 5, 16, 8, 4, 2] # The collatz sequence for 5 is [1, 5, 16, 8, 4, 2, 1], so the even numbers are only 1, 5, 16, and 8.\n  */\nconst getEvenCollatz = (n) => {\n  let collatz = [];\n  let prev = 1;\n  let next;\n\n  while (n > 0) {\n    next = prev * prev;\n    collatz.push(next);\n    prev = next;\n    n -= 1;\n  }\n\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the prime numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getPrimeCollatz(5) returns [1, 3, 5, 7, 9, 11] # The collatz sequence for 5 is [1, 3, 5, 7, 9, 11, 13, 17, 19], so primes are 1, 3, 5, 7, 9, 11, 13, 17, 19.\n  */\nconst getPrimeCollatz = (n) => {\n  let collatz = [];\n  let prev = 1;\n  let next;\n\n  while (n > 0) {\n    next = prev * prev;\n    collatz.push(next);\n    prev = next;\n    n -= 1;\n  }\n\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the natural numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getNaturalCollatz(5) returns [1, 3, 5, 7, 9, 11, 13, 17, 19] # The collatz sequence for 5 is [1, 3, 5, 7, 9, 11, 13, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97] # Natural numbers are 1, 3, 5, 7, 9, 11, 13, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97].\n  */\nconst getNaturalCollatz = (n) => {\n  let collatz = [];\n  let prev = 1;\n  let next;\n\n  while (n > 0) {\n    next = prev * prev;\n    collatz.push(next);\n    prev = next;\n    n -= 1;\n  }\n\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the triangular numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, the next term is 3 times the previous\n  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n  Note: \n      1. Collatz(1) is [1].\n      2. returned list sorted in increasing order.\n\n  For example:\n  getTriangularCollatz(5) returns [1, 3, 5, 7, 9, 11, 13, 17, 19] # The collatz sequence for 5 is [1, 3, 5, 7, 9, 11, 13, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97] # Triangular numbers are 1, 3, 5, 7, 9, 11, 13, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97].\n  */\nconst getTriangularCollatz = (n) => {\n  let collatz = [];\n  let prev = 1;\n  let next;\n\n  while (n > 0) {\n    next = prev * prev;\n    collatz.push(next);\n    prev = next;\n    n -= 1;\n  }\n\n  return collatz;\n};\n\n/*\n  Given a positive integer n, return a sorted list that has the factorial numbers in collatz sequence.\n\n  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n  as follows: start with any positive integer n. Then each term is obtained from the \n  previous term as follows: if the previous term is even, the next term is one half of \n  the previous term. If the previous term is odd, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/124", "prompt": "/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n", "canonical_solution": "  let t = date.split(/-/)\n  if (t.length != 3) { return false }\n  if (t[0] < 1 || t[0] > 12 || t[1] < 1) { return false }\n  if (t[0] == 2 && t[1] > 29) { return false }\n  if ((t[0] == 1 || t[0] == 3 || t[0] == 5 || t[0] == 7 || t[0] == 8 || t[0] == 10 || t[0] == 12) && t[1] > 31) { return false }\n  if ((t[0] == 4 || t[0] == 6 || t[0] == 9 || t[0] == 11) && t[1] > 30) { return false }\n  return true\n}\n\n", "test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('01-01-2007') === true)\n  console.assert(validDate('03-32-2011') === false)\n  console.assert(validDate('') === false)\n  console.assert(validDate('04-31-3000') === false)\n  console.assert(validDate('06-06-2005') === true)\n  console.assert(validDate('21-31-2000') === false)\n  console.assert(validDate('04-12-2003') === true)\n  console.assert(validDate('04122003') === false)\n  console.assert(validDate('20030412') === false)\n  console.assert(validDate('2003-04') === false)\n  console.assert(validDate('2003-04-12') === false)\n  console.assert(validDate('04-2003') === false)\n}\n\ntestValidDate()\n", "declaration": "\nconst validDate = (date) => {\n", "example_test": "const testValidDate = () => {\n  console.assert(validDate('03-11-2000') === true)\n  console.assert(validDate('15-01-2012') === false)\n  console.assert(validDate('04-0-2040') === false)\n  console.assert(validDate('06-04-2020') === true)\n  console.assert(validDate('06/04/2020') === false)\n}\ntestValidDate()\n", "entry_point": "validDate", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*You have to write a function which validates a given date string and\n  returns true if the date is valid otherwise false.\n  The date is valid if all of the following rules are satisfied:\n  1. The date string is not empty.\n  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n  3. The months should not be less than 1 or higher than 12.\n  4. The date should be in the format: mm-dd-yyyy\n\n  for example: \n  validDate('03-11-2000') => true\n\n  validDate('15-01-2012') => false\n\n  validDate('04-0-2040') => false\n\n  validDate('06-04-2020') => true\n\n  validDate('06/04/2020') => false\n  */\nconst validDate = (date) => {\n  const dateString = date.toString();\n  const dateParts = dateString.split('-');\n  const datePartCount = dateParts.length;\n  const datePartCount = datePartCount - 1;\n  const monthCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePartCount - 1;\n  const datePartCount = datePart", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/125", "prompt": "/* If you specify a word sequence, you return a list of words divided into spaces. If there are no spaces in the text, you should split them into commas. \"If there are no commas, you return the number of lowercase letters in odd order in the alphabet: ord (\" a \") = 0, ord (\" b \") = 1,... ord (\" z \") = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n", "canonical_solution": "  let t = txt.split(/\\s/)\n  if (t.length > 1) {\n    return t\n  } else {\n    t = txt.split(/,/)\n    if (t.length > 1) {\n      return t\n    } else {\n      let p = 0\n      for (let i = 0; i < txt.length; i++) {\n        let m = txt[i].charCodeAt()\n        if (m >= 97 && m <= 122 && m % 2 == 0) {\n          p++\n        }\n      }\n      return p\n    }\n  }\n}\n\n", "test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello world,!')) ===\n    JSON.stringify(['Hello', 'world,!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,Hello,world !')) ===\n    JSON.stringify(['Hello,Hello,world', '!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n  console.assert(JSON.stringify(splitWords('aaabb')) === JSON.stringify(2))\n  console.assert(JSON.stringify(splitWords('aaaBb')) === JSON.stringify(1))\n  console.assert(JSON.stringify(splitWords('')) === JSON.stringify(0))\n}\n\ntestSplitWords()\n", "declaration": "\nconst splitWords = (txt) => {\n", "example_test": "const testSplitWords = () => {\n  console.assert(\n    JSON.stringify(splitWords('Hello world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(\n    JSON.stringify(splitWords('Hello,world!')) ===\n    JSON.stringify(['Hello', 'world!'])\n  )\n  console.assert(JSON.stringify(splitWords('abcdef')) === JSON.stringify(3))\n}\ntestSplitWords()\n", "entry_point": "splitWords", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* If you specify a word sequence, you return a list of words divided into spaces. If there are no spaces in the text, you should split them into commas. \"If there are no commas, you return the number of lowercase letters in odd order in the alphabet: ord (\" a \") = 0, ord (\" b \") = 1,... ord (\" z \") = 25\n  Examples\n  splitWords(\"Hello world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"Hello,world!\")  [\"Hello\", \"world!\"]\n  splitWords(\"abcdef\") == 3\n  */\nconst splitWords = (txt) => {\n  let words = txt.split(' ')\n  let wordCount = 0\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''\n  let i = 0\n  let j = 0\n  let spaceCount = 0\n  let commaCount = 0\n  let space = ''\n  let comma = ''\n  let word = ''\n  let spaces = []\n  let commas = []\n  let words = []\n  let word = ''", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/126", "prompt": "/* If the list has more than one duplicate of the same number, return false. Suppose there are no negative numbers and only integers.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n", "canonical_solution": "  if (lst.length == 0) { return true }\n  let dup = 1\n  let pre = lst[0]\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < pre) { return false }\n    if (lst[i] == pre) {\n      dup += 1;\n      if (dup == 3) { return false }\n    } else {\n      pre = lst[i]\n      dup = 1\n    }\n  }\n  return true\n}\n\n", "test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([]) === true)\n  console.assert(isSorted([1]) === true)\n  console.assert(isSorted([3, 2, 1]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 3, 3, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n  console.assert(isSorted([1, 2, 3, 4]) === true)\n}\n\ntestIsSorted()\n", "declaration": "\nconst isSorted = (lst) => {\n", "example_test": "const testIsSorted = () => {\n  console.assert(isSorted([5]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5]) === false)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6]) === true)\n  console.assert(isSorted([1, 2, 3, 4, 5, 6, 7]) === true)\n  console.assert(isSorted([1, 3, 2, 4, 5, 6, 7]) === false)\n  console.assert(isSorted([1, 2, 2, 2, 3, 4]) === false)\n  console.assert(isSorted([1, 2, 2, 3, 3, 4]) === true)\n}\ntestIsSorted()\n", "entry_point": "isSorted", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* If the list has more than one duplicate of the same number, return false. Suppose there are no negative numbers and only integers.\n  Examples\n  isSorted([5])  true\n  isSorted([1, 2, 3, 4, 5])  true\n  isSorted([1, 3, 2, 4, 5])  false\n  isSorted([1, 2, 3, 4, 5, 6])  true\n  isSorted([1, 2, 3, 4, 5, 6, 7])  true\n  isSorted([1, 3, 2, 4, 5, 6, 7])  false\n  isSorted([1, 2, 2, 3, 3, 4])  true\n  isSorted([1, 2, 2, 2, 3, 4])  false\n  */\nconst isSorted = (lst) => {\n  const len = lst.length;\n  let i = len - 1;\n  let j = len - 1;\n  let k = 0;\n  while (i >= 0 && j >= 0) {\n    if (lst[i] < lst[j]) {\n      k++;\n      i--;\n      j--;\n    } else if (lst[i] > lst[j]) {\n      k++;\n      j--;\n    } else {\n      i--;\n      j--;\n    }\n  }\n  return k === 0;\n};\n\n/**\n * Given a sorted array, return the minimum element in the array.\n * If the array is empty, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the array has more than one minimum element, return undefined.\n * If the ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/127", "prompt": "/*You get two intervals, each interval being a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n", "canonical_solution": "  let lo = interval1[0]\n  if (interval2[0] > lo) { lo = interval2[0] }\n  let hi = interval1[1]\n  if (interval2[1] < hi) { hi = interval2[1] }\n  let len = 0\n  if (hi > lo) { len = hi - lo }\n  if (len == 1 || len == 0) { return 'NO' }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return 'NO' }\n  }\n  return 'YES'\n}\n\n", "test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n  console.assert(intersection([-2, 2], [-4, 0]) === 'YES')\n  console.assert(intersection([-11, 2], [-1, -1]) === 'NO')\n  console.assert(intersection([1, 2], [3, 5]) === 'NO')\n  console.assert(intersection([1, 2], [1, 2]) === 'NO')\n  console.assert(intersection([-2, -2], [-3, -2]) === 'NO')\n}\n\ntestIntersection()\n", "declaration": "\nconst intersection = (interval1, interval2) => {\n", "example_test": "const testIntersection = () => {\n  console.assert(intersection([1, 2], [2, 3]) === 'NO')\n  console.assert(intersection([-1, 1], [0, 4]) === 'NO')\n  console.assert(intersection([-3, -1], [-5, 5]) === 'YES')\n}\ntestIntersection()\n", "entry_point": "intersection", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*You get two intervals, each interval being a pair of integers. For example, interval = (start, end) = (1, 2).\n  The given intervals are closed which means that the interval (start, end)\n  includes both start and end.\n  For each given interval, it is assumed that its start is less or equal its end.\n  Your task is to determine whether the length of intersection of these two \n  intervals is a prime number.\n  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  which its length is 1, which not a prime number.\n  If the length of the intersection is a prime number, return \"YES\",\n  otherwise, return \"NO\".\n  If the two intervals don't intersect, return \"NO\".\n\n\n  [input/output] samples:\n  intersection((1, 2), (2, 3)) ==> \"NO\"\n  intersection((-1, 1), (0, 4)) ==> \"NO\"\n  intersection((-3, -1), (-5, 5)) ==> \"YES\"\n  */\nconst intersection = (interval1, interval2) => {\n  let start1 = interval1[0];\n  let end1 = interval1[1];\n  let start2 = interval2[0];\n  let end2 = interval2[1];\n  let result = [];\n  if (start1 < end1 && start2 < end2) {\n    if (start1 < end2) {\n      if (start2 < end1) {\n        result.push(start1);\n        result.push(end2);\n      }\n    }\n    if (start2 < end1) {\n      result.push(start2);\n      result.push(end1);\n    }\n  }\n  return result;\n};\n\n/*\n  [input] intervals: an array of intervals\n  [output] primes: an array of primes\n  [output] intervalsPrimes: an array of primes whose length is equal to the length of intervals\n*/\nconst intervalsPrimes = (intervals) => {\n  let primes = [];\n  let intervalsPrimes = [];\n  for (let i = 0; i < intervals.length; i++) {\n    let interval = intervals[i];\n    if (interval[0] < interval[1]) {\n      primes.push(interval[0]);\n      intervalsPrimes.push(interval);\n    }\n  }\n  return primes;\n};\n\n/*\n  [input] intervals: an array of intervals\n  [output] primes: an array of primes\n  [output] intervalsPrimes: an array of primes whose length is equal to the length of intervals\n*/\nconst intervalsPrimes2 = intervals => {\n  let primes = [];\n  let intervalsPrimes = [];\n  for (let i = 0; i < intervals.length; i++) {\n    let interval = intervals[i];\n    if (interval[0] < interval[1]) {\n      primes.push(interval[0]);\n      intervalsPrimes.push(interval[1]);\n    }\n  }\n  return primes;\n};\n\n/*\n  [input] intervals: an array of intervals\n  [output] primes: an array of primes\n  [output] intervalsPrimes: an array of primes whose length is equal to the length of intervals\n*/\nconst intervalsPrimes3 = intervals => {\n  let primes = [];\n  let intervalsPrimes = [];\n  for (let i = 0; i < intervals.length; i++) {\n    let interval = intervals[i];\n    if (interval[0] < interval[1]) {\n      primes.push(interval[0]);\n      intervalsPrimes.push(interval[1]);\n    }\n  }\n  return primes;\n};\n\n/*\n  [input] intervals: an array of intervals\n  [output] primes: an array of primes\n  [output] intervalsPrimes: an array of primes whose length is equal to the length of intervals\n*/\nconst intervalsPrimes4 = intervals => {\n  let primes = [];\n  let intervalsPrimes = [];\n  for (let i = 0; i < intervals.length; i++) {\n    let interval = intervals[i];\n    if (interval[0] < interval[1]) {\n      primes.push(interval[0]);\n      intervalsPrimes.push(interval[1]);\n    }\n  }\n  return primes;\n};\n\n/*\n  [input] intervals: an array of intervals\n  [output] primes: an array of primes\n  [output] intervalsPrimes: an array of primes whose length is equal to the length of intervals\n*/\nconst intervalsPrimes5 = intervals => {\n  let primes = [];\n  let intervalsPrimes = [];\n  for (let i = 0; i < intervals.length; i++) {\n    let interval = intervals[i];\n    if (interval[0] < interval[1]) {\n      primes.push(interval[0]);\n      intervalsPrimes.push(interval[1]);\n    }\n  }\n  return primes;\n};\n\n/*\n  [input] intervals: an array of intervals\n  [output] primes: an array of primes\n  [output] intervalsPrimes: an array of primes whose length is equal to the length of intervals\n*/\nconst intervalsPrimes6 = intervals => {\n  let primes = [];\n  let intervalsPrimes = [];\n  for (let i = 0; i < intervals.length; i++) {\n    let interval = intervals[i];\n    if (interval[0] < interval[1]) {\n      primes.push(interval[0]);\n      intervalsPrimes.push(interval[1]);\n    }\n  }\n  return primes;\n};\n\n/*\n  [input] intervals: an array of intervals\n  [output] primes: an array of primes\n  [output] intervalsPrimes: an array of primes whose length is equal to the length of intervals\n*/\nconst intervalsPrimes7 = intervals => {\n  let primes = [];\n  let intervalsPrimes = [];\n  for (let i = 0; i < intervals.length; i++) {\n    let interval = intervals[i];\n    if (interval[0] < interval[1]) {\n      primes.push(interval[0]);\n      intervalsPrimes.push(interval[1]);\n    }\n  }\n  return primes;\n};\n\n/*\n  [input] intervals: an array of intervals\n  [output] primes: an array of primes\n  [output] intervalsPrimes: an array of primes whose length is equal to the length of intervals\n*/\nconst intervalsPrimes8 = intervals => {\n  let primes = [];\n  let intervalsPrimes = [];\n  for (let i = 0; i < intervals.length; i++) {\n    let interval = intervals[i];\n    if (interval[0] < interval[1]) {\n      primes.push(interval[0]);\n      intervalsPrimes.push(interval[1]);\n    }\n  }\n  return primes;\n};\n\n/*\n  [input] intervals: an array of intervals\n  [output] primes: an array of primes\n  [output] intervalsPrimes: an array of primes whose length is equal to the length of intervals\n*/\nconst intervalsPrimes9 = intervals => {\n  let primes = [];\n  let intervalsPrimes = [];\n  for (let i = 0; i < intervals.length; i++) {\n    let interval = intervals[i];\n    if (interval[0] < interval[1]) {\n      primes.push(interval[0]);\n      intervalsPrimes.push(interval[1]);\n    }\n  }\n  return primes;\n};\n\n/*\n  [input] intervals: an array of intervals\n  [output] primes: an array of primes\n  [output] intervalsPrimes: an array of primes whose length is equal to the length of intervals\n*/\nconst intervalsPrimes10 = intervals => {\n  let primes = [];\n  let intervalsPrimes = [];\n  for (let i = 0; i < intervals.length; i++) {\n    let interval = intervals[i];\n    if (interval[0] < interval[1]) {\n      primes.push(interval[0]);\n      intervalsPrimes.push(interval[1]);\n    }\n  }\n  return primes;\n};\n\n/*\n  [input] intervals: an array of intervals\n  [output] primes: an array of primes\n  [output] intervalsPrimes: an array of primes whose length is equal to the length of intervals\n*/\nconst intervalsPrimes11 = intervals => {\n  let primes = [];\n  let intervalsPrimes = [];\n  for (let i = 0; i < intervals.length; i++) {\n    let interval = intervals[i];\n    if (interval[0] < interval[1]) {\n      primes.push(interval[0]);\n      intervalsPrimes.push(interval[1]);\n    }\n  }\n  return primes;\n};\n\n/*\n  [input] intervals: an array of intervals\n  [output] primes: an array of primes\n  [output] intervalsPrimes: an array of primes whose length is equal to the length of intervals\n*/\nconst intervalsPrimes12 = intervals => {\n  let primes = [];\n  let intervalsPrimes = [];\n  for (let i = 0; i < intervals.length; i++) {\n    let interval = intervals[i];\n    if (interval[0] < interval", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/128", "prompt": "/*\n  You get an array of integers, and you must return the sum of orders of magnitude multiplied by the product of all the characters of each number in the array, represented by 1, -1, or 0.\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return null }\n  let n = 1\n  let s = 0\n  for (let i = 0; i < arr.length; i++) {\n    s += arr[i]\n    if (arr[i] == 0) { return 0 }\n    if (arr[i] < 0) { n = -n; s -= 2 * arr[i] }\n  }\n  return s * n\n}\n\n", "test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([1, 1, 1, 2, 3, -1, 1]) === -10)\n  console.assert(prodSigns([]) === null)\n  console.assert(prodSigns([2, 4, 1, 2, -1, -1, 9]) === 20)\n  console.assert(prodSigns([-1, 1, -1, 1]) === 4)\n  console.assert(prodSigns([-1, 1, 1, 1]) === -4)\n  console.assert(prodSigns([-1, 1, 1, 0]) === 0)\n}\n\ntestProdSigns()\n", "declaration": "\nconst prodSigns = (arr) => {\n", "example_test": "const testProdSigns = () => {\n  console.assert(prodSigns([1, 2, 2, -4]) === -9)\n  console.assert(prodSigns([0, 1]) === 0)\n  console.assert(prodSigns([]) === null)\n}\ntestProdSigns()\n", "entry_point": "prodSigns", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You get an array of integers, and you must return the sum of orders of magnitude multiplied by the product of all the characters of each number in the array, represented by 1, -1, or 0.\n  >>> prodSigns([1, 2, 2, -4]) == -9\n  >>> prodSigns([0, 1]) == 0\n  >>> prodSigns([]) == null\n  */\nconst prodSigns = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i] * Math.pow(10, arr[i].toString().length - 1);\n  }\n  return sum;\n};\n\n/*\n  You get an array of integers, and you must return the product of all the numbers in the array, represented by 1, -1, or 0.\n  >>> prodNumbers([1, 2, 2, -4]) == 4\n  >>> prodNumbers([0, 1]) == 0\n  >>> prodNumbers([]) == null\n  */\nconst prodNumbers = (arr) => {\n  let product = 1;\n  for (let i = 0; i < arr.length; i++) {\n    product *= arr[i];\n  }\n  return product;\n};\n\n/*\n  You get an array of integers, and you must return the sum of all the numbers in the array, represented by 1, -1, or 0.\n  >>> sumNumbers([1, 2, 2, -4]) == 9\n  >>> sumNumbers([0, 1]) == 0\n  >>> sumNumbers([]) == null\n  */\nconst sumNumbers = (arr) => {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n};\n\n/*\n  You get an array of integers, and you must return the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the product of the ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/129", "prompt": "/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n", "canonical_solution": "  let m = 0\n  let n = 0\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid.length; j++) {\n      if (grid[i][j] == 1) {\n        m = i;\n        n = j;\n        break;\n      }\n    }\n  }\n  let min = grid.length * grid.length\n  if (m > 0 && grid[m - 1][n] < min) { min = grid[m - 1][n] }\n  if (n > 0 && grid[m][n - 1] < min) { min = grid[m][n - 1] }\n  if (m < grid.length - 1 && grid[m + 1][n] < min) { min = grid[m + 1][n] }\n  if (n < grid.length - 1 && grid[m][n + 1] < min) { min = grid[m][n + 1] }\n  let p = []\n  for (let i = 0; i < k; i++) {\n    if (i % 2 == 0) { p.push(1) }\n    else { p.push(min) }\n  }\n  return p\n}\n\n", "test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3, 4],\n          [5, 6, 7, 8],\n          [9, 10, 11, 12],\n          [13, 14, 15, 16],\n        ],\n        4\n      )\n    ) === JSON.stringify([1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 4, 13, 10],\n          [5, 7, 12, 1],\n          [3, 16, 11, 15],\n          [8, 14, 9, 2],\n        ],\n        7\n      )\n    ) === JSON.stringify([1, 10, 1, 10, 1, 10, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [8, 14, 9, 2],\n          [6, 4, 13, 15],\n          [5, 7, 1, 12],\n          [3, 10, 11, 16],\n        ],\n        5\n      )\n    ) === JSON.stringify([1, 7, 1, 7, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [11, 8, 7, 2],\n          [5, 16, 14, 4],\n          [9, 3, 15, 6],\n          [12, 13, 10, 1],\n        ],\n        9\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [12, 13, 10, 1],\n          [9, 3, 15, 6],\n          [5, 16, 14, 4],\n          [11, 8, 7, 2],\n        ],\n        12\n      )\n    ) === JSON.stringify([1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [2, 7, 4],\n          [3, 1, 5],\n          [6, 8, 9],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [6, 1, 5],\n          [3, 8, 9],\n          [2, 7, 4],\n        ],\n        8\n      )\n    ) === JSON.stringify([1, 5, 1, 5, 1, 5, 1, 5])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2],\n          [3, 4],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 2, 1, 2, 1, 2, 1, 2, 1, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 3],\n          [4, 2],\n        ],\n        10\n      )\n    ) === JSON.stringify([1, 3, 1, 3, 1, 3, 1, 3, 1, 3])\n  )\n}\n\ntestMinPath()\n", "declaration": "\nconst minPath = (grid, k) => {\n", "example_test": "const testMinPath = () => {\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9],\n        ],\n        3\n      )\n    ) === JSON.stringify([1, 2, 1])\n  )\n  console.assert(\n    JSON.stringify(\n      minPath(\n        [\n          [5, 9, 3],\n          [4, 1, 6],\n          [7, 8, 2],\n        ],\n        1\n      )\n    ) === JSON.stringify([1])\n  )\n}\ntestMinPath()\n", "entry_point": "minPath", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*\n  Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n  each cell of the grid contains a value. Every integer in the range [1, N * N]\n  inclusive appears exactly once on the cells of the grid.\n\n  You have to find the minimum path of length k in the grid. You can start\n  from any cell, and in each step you can move to any of the neighbor cells,\n  in other words, you can go to cells which share an edge with you current\n  cell.\n  Please note that a path of length k means visiting exactly k cells (not\n  necessarily distinct).\n  You CANNOT go off the grid.\n  A path A (of length k) is considered less than a path B (of length k) if\n  after making the ordered lists of the values on the cells that A and B go\n  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n  lst_A[j] = lst_B[j].\n  It is guaranteed that the answer is unique.\n  Return an ordered list of the values on the cells that the minimum path go through.\n\n  Examples:\n\n      Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n      Output: [1, 2, 1]\n\n      Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n      Output: [1]\n  */\nconst minPath = (grid, k) => {\n  const [rows, cols] = grid.length;\n  const [gridValues, gridIndices] = createGridValues(grid, k);\n  const [minPathValues, minPathIndices] = minPathValues(gridValues, gridIndices);\n  return minPathValues.map(v => gridValues[v]);\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-length-in-a-grid/\nconst findMinPathLength = (grid, k) => {\n  const [rows, cols] = grid.length;\n  const [gridValues, gridIndices] = createGridValues(grid, k);\n  const [minPathValues, minPathIndices] = minPathValues(gridValues, gridIndices);\n  return minPathIndices.map(i => gridIndices[i]);\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-length-in-a-grid/\nconst findMinPathLength2 = (grid, k) => {\n  const [rows, cols] = grid.length;\n  const [gridValues, gridIndices] = createGridValues(grid, k);\n  const [minPathValues, minPathIndices] = minPathValues(gridValues, gridIndices);\n  return minPathIndices.map(i => gridValues[i]);\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-length-in-a-grid/\nconst findMinPathLength3 = (grid, k) => {\n  const [rows, cols] = grid.length;\n  const [gridValues, gridIndices] = createGridValues(grid, k);\n  const [minPathValues, minPathIndices] = minPathValues(gridValues, gridIndices);\n  return minPathIndices.map(i => gridValues[gridIndices[i]]);\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-length-in-a-grid/\nconst findMinPathLength4 = (grid, k) => {\n  const [rows, cols] = grid.length;\n  const [gridValues, gridIndices] = createGridValues(grid, k);\n  const [minPathValues, minPathIndices] = minPathValues(gridValues, gridIndices);\n  return minPathIndices.map(i => gridValues[gridIndices[i]]);\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-length-in-a-grid/\nconst findMinPathLength5 = (grid, k) => {\n  const [rows, cols] = grid.length;\n  const [gridValues, gridIndices] = createGridValues(grid, k);\n  const [minPathValues, minPathIndices] = minPathValues(gridValues, gridIndices);\n  return minPathIndices.map(i => gridValues[gridIndices[i]]);\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-length-in-a-grid/\nconst findMinPathLength6 = (grid, k) => {\n  const [rows, cols] = grid.length;\n  const [gridValues, gridIndices] = createGridValues(grid, k);\n  const [minPathValues, minPathIndices] = minPathValues(gridValues, gridIndices);\n  return minPathIndices.map(i => gridValues[gridIndices[i]]);\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-length-in-a-grid/\nconst findMinPathLength7 = (grid, k) => {\n  const [rows, cols] = grid.length;\n  const [gridValues, gridIndices] = createGridValues(grid, k);\n  const [minPathValues, minPathIndices] = minPathValues(gridValues, gridIndices);\n  return minPathIndices.map(i => gridValues[gridIndices[i]]);\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-length-in-a-grid/\nconst findMinPathLength8 = (grid, k) => {\n  const [rows, cols] = grid.length;\n  const [gridValues, gridIndices] = createGridValues(grid, k);\n  const [minPathValues, minPathIndices] = minPathValues(gridValues, gridIndices);\n  return minPathIndices.map(i => gridValues[gridIndices[i]]);\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-length-in-a-grid/\nconst findMinPathLength9 = (grid, k) => {\n  const [rows, cols] = grid.length;\n  const [gridValues, gridIndices] = createGridValues(grid, k);\n  const [minPathValues, minPathIndices] = minPathValues(gridValues, gridIndices);\n  return minPathIndices.map(i => gridValues[gridIndices[i]]);\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-length-in-a-grid/\nconst findMinPathLength10 = (grid, k) => {\n  const [rows, cols] = grid.length;\n  const [gridValues, gridIndices] = createGridValues(grid, k);\n  const [minPathValues, minPathIndices] = minPathValues(gridValues, gridIndices);\n  return minPathIndices.map(i => gridValues[gridIndices[i]]);\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-length-in-a-grid/\nconst findMinPathLength11 = (grid, k) => {\n  const [rows, cols] = grid.length;\n  const [gridValues, gridIndices] = createGridValues(grid, k);\n  const [minPathValues, minPathIndices] = minPathValues(gridValues, gridIndices);\n  return minPathIndices.map(i => gridValues[gridIndices[i]]);\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-length-in-a-grid/\nconst findMinPathLength12 = (grid, k) => {\n  const [rows, cols] = grid.length;\n  const [gridValues, gridIndices] = createGridValues(grid, k);\n  const [minPathValues, minPathIndices] = minPathValues(gridValues, gridIndices);\n  return minPathIndices.map(i => gridValues[gridIndices[i]]);\n};\n\n// https://leetcode.com/problems/find-the-minimum-path-length-in-a-grid/\nconst findMinPathLength13 = (grid, k) => {\n  const ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/13", "prompt": "/* Returns the largest common divisor of two integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n", "canonical_solution": "  while (b != 0) {\n    let temp = a;\n    a = b;\n    b = temp % b;\n  }\n  return a;\n}\n\n", "test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 7) === 1)\n  console.assert(greatestCommonDivisor(10, 15) === 5)\n  console.assert(greatestCommonDivisor(49, 14) === 7)\n  console.assert(greatestCommonDivisor(144, 60) === 12)\n}\n\ntestGreatestCommonDivisor()\n", "declaration": "\nconst greatestCommonDivisor = (a, b) => {\n", "example_test": "const testGreatestCommonDivisor = () => {\n  console.assert(greatestCommonDivisor(3, 5) === 1)\n  console.assert(greatestCommonDivisor(25, 15) === 5)\n}\ntestGreatestCommonDivisor()\n", "entry_point": "greatestCommonDivisor", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Returns the largest common divisor of two integers a and b\n  >>> greatestCommonDivisor(3, 5)\n  1\n  >>> greatestCommonDivisor(25, 15)\n  5\n  */\nconst greatestCommonDivisor = (a, b) => {\n  if (a === 0 || b === 0) {\n    return 0;\n  }\n\n  const lcm = a % b;\n  return lcm === 0? a : lcm > b? b : lcm;\n};\n\n/**\n * Returns true if a is greater than b\n */\nconst isGreaterThan = (a, b) => {\n  return a > b;\n};\n\n/**\n * Returns true if a is less than b\n */\nconst isLessThan = (a, b) => {\n  return a < b;\n};\n\n/**\n * Returns true if a is equal to b\n */\nconst isEqual = (a, b) => {\n  return a === b;\n};\n\n/**\n * Returns true if a is divisible by b\n */\nconst isDivisibleBy = (n, k) => {\n  return n % k === 0;\n};\n\n/**\n * Returns true if a is divisible by n\n */\nconst isDivisibleByN = (n, k) => {\n  return isDivisibleBy(n, k) && n % k === 0;\n};\n\n/**\n * Returns true if a is divisible by n\n */\nconst isDivisibleByNAndN = (a, b) => {\n  return isDivisibleByN(a, a) && isDivisibleByN(a, b);\n};\n\n/**\n * Returns true if a is divisible by n\n */\nconst isDivisibleByNAndNAndN = (a, b) => {\n  return isDivisibleByNAndN(a, a) && isDivisibleByNAndN(a, b);\n};\n\n/**\n * Returns true if a is divisible by n\n */\nconst isDivisibleByNAndNAndN = (a, b) => {\n  return isDivisibleByNAndNAndN(a, a) && isDivisibleByNAndNAndN(a, b);\n};\n\n/**\n * Returns true if a is divisible by n\n */\nconst isDivisibleByNAndNAndNAndN = (a, b) => {\n  return isDivisibleByNAndNAndNAndN(a, a) && isDivisibleByNAndNAndNAndN(a, b);\n};\n\n/**\n * Returns true if a is divisible by n\n */\nconst isDivisibleByNAndNAndNAndN = (a, b) => {\n  return isDivisibleByNAndNAndNAndN(a, a) && isDivisibleByNAndNAndNAndN(a, b);\n};\n\n/**\n * Returns true if a is divisible by n\n */\nconst isDivisibleByNAndNAndNAndN = (a, b) => {\n  return isDivisibleByNAndNAndNAndN(a, a) && isDivisibleByNAndNAndNAndN(a, b);\n};\n\n/**\n * Returns true if a is divisible by n\n */\nconst isDivisibleByNAndNAndNAndN = (a, b) => {\n  return isDivisibleByNAndNAndNAndN(a, a) && isDivisibleByNAndNAndNAndN(a, b);\n};\n\n/**\n * Returns true if a is divisible by n\n */\nconst isDivisibleByNAndNAndNAndN = (a, b) => {\n  return isDivisibleByNAndNAndNAndN(a, a) && isDivisibleByNAndNAndNAndN(a, b);\n};\n\n/**\n * Returns true if a is divisible by n\n */\nconst isDivisibleByNAndNAndNAndN = (a, b) => {\n  return isDivisibleByNAndNAndNAndN(a, a) && isDivisibleByNAndNAndNAndN(a, b);\n};\n\n/**\n * Returns true if a is divisible by n\n */\nconst isDivisibleByNAndNAndNAndN = (a, b) => {\n  return isDivisibleByNAndNAndNAndN(a, a) && isDivisibleByNAndNAndNAndN(a, b);\n};\n\n/**\n * Returns true if a is divisible by n\n */\nconst isDivisibleByNAndNAndNAndN = (a, b) => {\n  return isDivisibleByNAndNAndNAndN(a, a) && isDivisibleByNAndNAndNAndN(a, b);\n};\n\n/**\n * Returns true if a is divisible by n\n */\nconst isDivisibleByNAndNAndNAndN = (a, b) => {\n  return isDivisibleByNAndNAndNAndN(a, a) && isDivisibleByNAndNAndNAndN(a, b);\n};\n\n/**\n * Returns true if a is divisible by n\n */\nconst isDivisibleByNAndNAndNAndN = (a, b) => {\n  return isDivisibleByNAndNAndNAndN(a, a) && isDivisibleByNAndNAndNAndN(a, b);\n};\n\n/**\n * Returns true if a is divisible by n\n */\nconst isDivisibleByNAndNAndNAndN = (a, b) => {\n  return isDivisibleByNAndNAndNAndN(a, a) && isDivisibleByNAndNAndNAndN(a, b);\n};\n\n/**\n * Returns true if a is divisible by n\n */\nconst isDivisibleByNAndNAndNAndN = (a, b) => {\n  return isDivisibleByNAndNAndNAndN(a, a) && isDivisibleByNAndNAndNAndN(a, b);\n};\n\n/**\n * Returns true if a is divisible by n\n */\nconst isDivisibleByNAndNAndNAndN = (a, b) => {\n  return isDivisibleByNAndNAndNAndN(a, a) && isDivisibleByNAndNAndNAndN(a, b);\n};\n\n/**\n * Returns true if a is divisible by n\n */\nconst isDivisibleByNAndNAndNAndN = (a, b) => {\n  return isDivisibleByNAndNAndNAndN(a, a) && isDivisibleByNAndNAndNAndN(a, b);\n};\n\n/**\n * Returns true if a is divisible by n\n */\nconst isDivisibleByNAndNAndNAndN = (a, b) => {\n  return isDivisibleByNAndNAndNAndN(a, a) && isDivisibleByNAndNAndNAndN(a, b);\n};\n\n/**\n * Returns true if a is divisible by n\n */\nconst isDivisibleByNAndNAndNAndN = (a, b) => {\n  return isDivisibleByNAndNAndNAndN(a, a) && isDivisibleByNAndNAndNAndN(a, b);\n};\n\n/**\n * Returns true if a is divisible by n\n */\nconst isDivisibleByNAndNAndNAndN = (a, b) => {\n  return isDivisibleByNAndNAndNAndN(a, a) && isDivisibleByNAndNAndNAndN(a, b);\n};\n\n/**\n * Returns true if a is divisible by n\n */\nconst isDivisibleByNAndNAndNAndN = (a, b) => {\n  return isDivisibleByNAndNAndNAndN(a, a) && isDivisibleByNAndNAndNAndN(a, b);\n};\n\n/**\n * Returns true if a is divisible by n\n */\nconst isDivisibleByN", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/130", "prompt": "/*EThe Fibonacci sequence is very well known, it has been thoroughly studied by mathematicians in recent centuries, but what people do not know is the Tribonacci sequence. The Tribonacci sequence is defined by repetition: tri (1) = 3 tri (n) = 1 + n / 2 if n is. tri (n) = tri (n - 1) + tri (n - 2) + tri (n + 1) if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n", "canonical_solution": "  if (n == 0) { return [1] }\n  if (n == 1) { return [1, 3] }\n  let p = [1, 3]\n  for (let i = 2; i <= n; i++) {\n    if (i % 2 == 0) {\n      p.push(1 + i / 2)\n    }\n    else {\n      p.push(p[i - 2] + p[i - 1] + 1 + (i + 1) / 2)\n    }\n  }\n  return p\n}\n\n", "test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n\n  console.assert(\n    JSON.stringify(tri(4)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0])\n  )\n  console.assert(\n    JSON.stringify(tri(5)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0])\n  )\n  console.assert(\n    JSON.stringify(tri(6)) === JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0])\n  )\n  console.assert(\n    JSON.stringify(tri(7)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0])\n  )\n  console.assert(\n    JSON.stringify(tri(8)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0])\n  )\n  console.assert(\n    JSON.stringify(tri(9)) ===\n    JSON.stringify([1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0])\n  )\n  console.assert(\n    JSON.stringify(tri(20)) ===\n    JSON.stringify([\n      1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0,\n      8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0,\n    ])\n  )\n  console.assert(JSON.stringify(tri(0)) === JSON.stringify([1]))\n  console.assert(JSON.stringify(tri(1)) === JSON.stringify([1, 3]))\n}\n\ntestTri()\n", "declaration": "\nconst tri = (n) => {\n", "example_test": "const testTri = () => {\n  console.assert(JSON.stringify(tri(3)) === JSON.stringify([1, 3, 2.0, 8.0]))\n}\ntestTri()\n", "entry_point": "tri", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*EThe Fibonacci sequence is very well known, it has been thoroughly studied by mathematicians in recent centuries, but what people do not know is the Tribonacci sequence. The Tribonacci sequence is defined by repetition: tri (1) = 3 tri (n) = 1 + n / 2 if n is. tri (n) = tri (n - 1) + tri (n - 2) + tri (n + 1) if n is odd.\n  For example:\n  tri(2) = 1 + (2 / 2) = 2\n  tri(4) = 3\n  tri(3) = tri(2) + tri(1) + tri(4)\n         = 2 + 3 + 3 = 8 \n  You are given a non-negative integer number n, you have to a return a list of the \n  first n + 1 numbers of the Tribonacci sequence.\n  Examples:\n  tri(3) = [1, 3, 2, 8]\n  */\nconst tri = (n) => {\n  let arr = [1, 2];\n  let i = 1;\n  let j = 1;\n  while (i <= n) {\n    arr[i] = arr[j];\n    i++;\n    j++;\n  }\n  return arr;\n};\n\n/*\n  Given a positive integer n, return a list of all the prime factors of n.\n  Examples:\n  factors(2) = [2, 1]\n  factors(3) = [2, 3, 5]\n  factors(4) = [2, 3, 5, 7]\n  factors(5) = [2, 3, 5, 7, 11]\n  factors(6) = [2, 3, 5, 7, 11, 13]\n  factors(7) = [2, 3, 5, 7, 11, 13, 17]\n  factors(8) = [2, 3, 5, 7, 11, 13, 17, 19]\n  factors(9) = [2, 3, 5, 7, 11, 13, 17, 19, 23]\n  factors(10) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n  factors(11) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\n  factors(12) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n  factors(13) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41]\n  factors(14) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n  factors(15) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51]\n  factors(16) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 57]\n  factors(17) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 57, 61]\n  factors(18) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 57, 61, 67]\n  factors(19) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 57, 61, 67, 71]\n  factors(20) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 57, 61, 67, 71, 73]\n  factors(21) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 57, 61, 67, 71, 73, 79]\n  factors(22) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 57, 61, 67, 71, 73, 79, 83]\n  factors(23) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 57, 61, 67, 71, 73, 79, 83, 89]\n  factors(24) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 57, 61, 67, 71, 73, 79, 83, 89, 97]\n  factors(25) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 57, 61, 67, 71, 73, 79, 83, 89, 97, 101]\n  factors(26) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 57, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103]\n  factors(27) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 57, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107]\n  factors(28) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 57, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 111]\n  factors(29) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 57, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 111, 113]\n  factors(30) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 57, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 111, 113, 127]\n  factors(31) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 57, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 111, 113, 127, 131]\n  factors(32) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 57, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 111, 113, 127, 131, 135]\n  factors(33) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 57, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 111, 113, 127, 131, 135, 139]\n  factors(34) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 57, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 111, 113, 127, 131, 135, 139, 149]\n  factors(35) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 57, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 111, 113, 127, 131, 135, 139, 149, 151]\n  factors(36) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 57, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 111, 113, 127, 131, 135, 139, 149, 151, 153]\n  factors(37) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 57, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 111, 113, 127, 131, 135, 139, 149, 151, 153, 157]\n  factors(38) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, 57, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 111, 113, 127, 131, 135, 139, 149, 151, 153, 157, 159]\n  factors(39) = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 51, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/131", "prompt": "/*GIf you return a positive integer n, you get the product of the odd digits. If you return 0, all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n", "canonical_solution": "  let p = 1\n  let k = 1\n  while (n > 0) {\n    let y = n % 10\n    if (y % 2 == 1) {\n      p *= y; k = 0;\n    }\n    n = (n - n % 10) / 10\n  }\n  if (k == 0) { return p }\n  return 0\n}\n\n", "test": "const testDigits = () => {\n  console.assert(digits(5) === 5)\n  console.assert(digits(54) === 5)\n  console.assert(digits(120) === 1)\n  console.assert(digits(5014) === 5)\n  console.assert(digits(98765) === 315)\n  console.assert(digits(5576543) === 2625)\n  console.assert(digits(2468) === 0)\n}\n\ntestDigits()\n", "declaration": "\nconst digits = (n) => {\n", "example_test": "const testDigits = () => {\n  console.assert(digits(1) === 1)\n  console.assert(digits(4) === 0)\n  console.assert(digits(235) === 15)\n}\ntestDigits()\n", "entry_point": "digits", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*GIf you return a positive integer n, you get the product of the odd digits. If you return 0, all digits are even.\n  For example:\n  digits(1)  == 1\n  digits(4)  == 0\n  digits(235) == 15\n  */\nconst digits = (n) => {\n  let digits = 0;\n  let remainder = 0;\n  let digit;\n  while (n) {\n    digit = n % 10;\n    digits = digits + digit * Math.pow(10, digits);\n    remainder = n % 10;\n    n = Math.floor(n / 10);\n  }\n  return digits;\n};\n\n/*\n  Given a number, return its decimal representation.\n  For example:\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == 123\n  decimal(456)  == 456\n  decimal(789)  == 789\n  decimal(123)  == ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/132", "prompt": "/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  false\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n", "canonical_solution": "  let opening_bracket_index = []\n  let closing_bracket_index1 = []\n  for (let i = 0; i < string.length; i++) {\n    if (string[i] == '[') {\n      opening_bracket_index.push(i)\n    }\n    else {\n      closing_bracket_index1.push(i)\n    }\n  }\n  let closing_bracket_index = []\n  for (let i = 0; i < closing_bracket_index1.length; i++) {\n    closing_bracket_index.push(closing_bracket_index1[closing_bracket_index1.length - i - 1])\n  }\n  let cnt = 0\n  let i = 0\n  let l = closing_bracket_index.length\n  for (let k = 0; k < opening_bracket_index.length; k++) {\n    if (i < l && opening_bracket_index[k] < closing_bracket_index[i]) {\n      cnt += 1;\n      i += 1;\n    }\n  }\n  return cnt >= 2\n}\n\n", "test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[[[]]]]') === true)\n  console.assert(isNested('[]]]]]]]]]]') === false)\n  console.assert(isNested('[][][[]]') === true)\n  console.assert(isNested('[[]') === false)\n  console.assert(isNested('[]]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n  console.assert(isNested('') === false)\n  console.assert(isNested('[[[[[[[[') === false)\n  console.assert(isNested(']]]]]]]]') === false)\n}\n\ntestIsNested()\n", "declaration": "\nconst isNested = (string) => {\n", "example_test": "const testIsNested = () => {\n  console.assert(isNested('[[]]') === true)\n  console.assert(isNested('[]]]]]]][[[[[]') === false)\n  console.assert(isNested('[][]') === false)\n  console.assert(isNested('[]') === false)\n  console.assert(isNested('[[]][[') === true)\n  console.assert(isNested('[[][]]') === true)\n}\ntestIsNested()\n", "entry_point": "isNested", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  false\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n  const stack = [string];\n  while (stack.length) {\n    const char = stack.pop();\n    if (char === '[') {\n      stack.push(char);\n    } else if (char === ']') {\n      if (stack.length) {\n        stack.push(char);\n      } else {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  false\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n  const stack = [string];\n  while (stack.length) {\n    const char = stack.pop();\n    if (char === '[') {\n      stack.push(char);\n    } else if (char === ']') {\n      if (stack.length) {\n        stack.push(char);\n      } else {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  false\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n  const stack = [string];\n  while (stack.length) {\n    const char = stack.pop();\n    if (char === '[') {\n      stack.push(char);\n    } else if (char === ']') {\n      if (stack.length) {\n        stack.push(char);\n      } else {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  false\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n  const stack = [string];\n  while (stack.length) {\n    const char = stack.pop();\n    if (char === '[') {\n      stack.push(char);\n    } else if (char === ']') {\n      if (stack.length) {\n        stack.push(char);\n      } else {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  false\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n  const stack = [string];\n  while (stack.length) {\n    const char = stack.pop();\n    if (char === '[') {\n      stack.push(char);\n    } else if (char === ']') {\n      if (stack.length) {\n        stack.push(char);\n      } else {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  false\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n  const stack = [string];\n  while (stack.length) {\n    const char = stack.pop();\n    if (char === '[') {\n      stack.push(char);\n    } else if (char === ']') {\n      if (stack.length) {\n        stack.push(char);\n      } else {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  false\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n  const stack = [string];\n  while (stack.length) {\n    const char = stack.pop();\n    if (char === '[') {\n      stack.push(char);\n    } else if (char === ']') {\n      if (stack.length) {\n        stack.push(char);\n      } else {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if there is a valid subsequence of brackets\n  where at least one bracket in the subsequence is nested.\n  isNested('[[]]')  true\n  isNested('[]]]]]]][[[[[]')  false\n  isNested('[][]')  false\n  isNested('[]')  false\n  isNested('[[][]]')  true\n  isNested('[[]][[')  true\n  */\nconst isNested = (string) => {\n  const stack = [string];\n  while (stack.length) {\n    const char = stack.pop();\n    if (char === '[') {\n      stack.push(char);\n    } else if (char === ']') {\n      if (stack.length) {\n        stack.push(char);\n      } else {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n  Create a function that takes a string as input which contains only square brackets.\n  The function should return true if and only if ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/133", "prompt": "/*YYou get a list of numbers. You have to return the sum of the square numbers in the given list and round each element in the list to the top int (ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    let y = lst[i]\n    if (y % 1 != 0) {\n      if (y > 0) { y = y - y % 1 + 1 }\n      else { y = -y; y = y - y % 1 }\n    }\n    p += y * y\n  }\n  return p\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1.0, 2, 3]) === 14)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n\n  console.assert(sumSquares([100, 1, 15, 2]) === 10230)\n  console.assert(sumSquares([10000, 10000]) === 200000000)\n  console.assert(sumSquares([-1.4, 4.6, 6.3]) === 75)\n  console.assert(sumSquares([-1.4, 17.9, 18.9, 19.9]) === 1086)\n\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1]) === 1)\n  console.assert(sumSquares([-1, 1, 0]) === 2)\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 14)\n  console.assert(sumSquares([1, 4, 9]) === 98)\n  console.assert(sumSquares([1, 3, 5, 7]) === 84)\n  console.assert(sumSquares([1.4, 4.2, 0]) === 29)\n  console.assert(sumSquares([-2.4, 1, 1]) === 6)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*YYou get a list of numbers. You have to return the sum of the square numbers in the given list and round each element in the list to the top int (ceiling) first.\n  Examples:\n  For lst = [1,2,3] the output should be 14\n  For lst = [1,4,9] the output should be 98\n  For lst = [1,3,5,7] the output should be 84\n  For lst = [1.4,4.2,0] the output should be 29\n  For lst = [-2.4,1,1] the output should be 6\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  lst.forEach((num) => {\n    sum += Math.pow(num, 2);\n  });\n  return Math.ceil(sum);\n};\n\n/*\n  Write a function that takes an array of numbers and returns an array of the sum of the squares of the numbers in the given array. \n  Examples:\n  sumSquares([1,2,3]) should return [4,9,16]\n  sumSquares([1,4,9]) should return [98,160,252]\n  sumSquares([1,3,5,7]) should return [84,252,416]\n  sumSquares([1.4,4.2,0]) should return [29,62,12]\n  sumSquares([-2.4,1,1]) should return [6,1,1]\n  */\nconst sumSquares = (arr) => {\n  let sumArr = [];\n  arr.forEach((num) => {\n    sumArr.push(Math.pow(num, 2));\n  });\n  return sumArr;\n};\n\n/*\n  Write a function that takes an array of numbers and returns an array of the sum of the squares of the numbers in the given array. \n  Examples:\n  sumSquares([1,2,3]) should return [4,9,16]\n  sumSquares([1,4,9]) should return [98,160,252]\n  sumSquares([1,3,5,7]) should return [84,252,416]\n  sumSquares([1.4,4.2,0]) should return [29,62,12]\n  sumSquares([-2.4,1,1]) should return [6,1,1]\n  */\nconst sumSquares = (arr) => {\n  let sumArr = [];\n  arr.forEach((num) => {\n    sumArr.push(Math.pow(num, 2));\n  });\n  return sumArr;\n};\n\n/*\n  Write a function that takes an array of numbers and returns an array of the sum of the squares of the numbers in the given array. \n  Examples:\n  sumSquares([1,2,3]) should return [4,9,16]\n  sumSquares([1,4,9]) should return [98,160,252]\n  sumSquares([1,3,5,7]) should return [84,252,416]\n  sumSquares([1.4,4.2,0]) should return [29,62,12]\n  sumSquares([-2.4,1,1]) should return [6,1,1]\n  */\nconst sumSquares = (arr) => {\n  let sumArr = [];\n  arr.forEach((num) => {\n    sumArr.push(Math.pow(num, 2));\n  });\n  return sumArr;\n};\n\n/*\n  Write a function that takes an array of numbers and returns an array of the sum of the squares of the numbers in the given array. \n  Examples:\n  sumSquares([1,2,3]) should return [4,9,16]\n  sumSquares([1,4,9]) should return [98,160,252]\n  sumSquares([1,3,5,7]) should return [84,252,416]\n  sumSquares([1.4,4.2,0]) should return [29,62,12]\n  sumSquares([-2.4,1,1]) should return [6,1,1]\n  */\nconst sumSquares = (arr) => {\n  let sumArr = [];\n  arr.forEach((num) => {\n    sumArr.push(Math.pow(num, 2));\n  });\n  return sumArr;\n};\n\n/*\n  Write a function that takes an array of numbers and returns an array of the sum of the squares of the numbers in the given array. \n  Examples:\n  sumSquares([1,2,3]) should return [4,9,16]\n  sumSquares([1,4,9]) should return [98,160,252]\n  sumSquares([1,3,5,7]) should return [84,252,416]\n  sumSquares([1.4,4.2,0]) should return [29,62,12]\n  sumSquares([-2.4,1,1]) should return [6,1,1]\n  */\nconst sumSquares = (arr) => {\n  let sumArr = [];\n  arr.forEach((num) => {\n    sumArr.push(Math.pow(num, 2));\n  });\n  return sumArr;\n};\n\n/*\n  Write a function that takes an array of numbers and returns an array of the sum of the squares of the numbers in the given array. \n  Examples:\n  sumSquares([1,2,3]) should return [4,9,16]\n  sumSquares([1,4,9]) should return [98,160,252]\n  sumSquares([1,3,5,7]) should return [84,252,416]\n  sumSquares([1.4,4.2,0]) should return [29,62,12]\n  sumSquares([-2.4,1,1]) should return [6,1,1]\n  */\nconst sumSquares = (arr) => {\n  let sumArr = [];\n  arr.forEach((num) => {\n    sumArr.push(Math.pow(num, 2));\n  });\n  return sumArr;\n};\n\n/*\n  Write a function that takes an array of numbers and returns an array of the sum of the squares of the numbers in the given array. \n  Examples:\n  sumSquares([1,2,3]) should return [4,9,16]\n  sumSquares([1,4,9]) should return [98,160,252]\n  sumSquares([1,3,5,7]) should return [84,252,416]\n  sumSquares([1.4,4.2,0]) should return [29,62,12]\n  sumSquares([-2.4,1,1]) should return [6,1,1]\n  */\nconst sumSquares = (arr) => {\n  let sumArr = [];\n  arr.forEach((num) => {\n    sumArr.push(Math.pow(num, 2));\n  });\n  return sumArr;\n};\n\n/*\n  Write a function that takes an array of numbers and returns an array of the sum of the squares of the numbers in the given array. \n  Examples:\n  sumSquares([1,2,3]) should return [4,9,16]\n  sumSquares([1,4,9]) should return [98,160,252]\n  sumSquares([1,3,5,7]) should return [84,252,416]\n  sumSquares([1.4,4.2,0]) should return [29,62,12]\n  sumSquares([-2.4,1,1]) should return [6,1,1]\n  */\nconst sumSquares = (arr) => {\n  let sumArr = [];\n  arr.forEach((num) => {\n    sumArr.push(Math.pow(num, 2));\n  });\n  return sumArr;\n};\n\n/*\n  Write a function that takes an array of numbers and returns an array of the sum of the squares of the numbers in the given array. \n  Examples:\n  sumSquares([1,2,3]) should return [4,9,16]\n  sumSquares([1,4,9]) should return [98,160,252]\n  sumSquares([1,3,5,7]) should return [84,252,416]\n  sumSquares([1.4,4.2,0]) should return [29,62,12]\n  sumSquares([-2.4,1,1]) should return [6,1,1]\n  */\nconst ", "passed": 1, "run_status": 0, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/134", "prompt": "/* Create a function that returns true if the last character in a given string is an alphabetic character and not part of a word, and otherwise incorrect. Note: \"Word\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n", "canonical_solution": "  let len = txt.length\n  if (len == 0) { return false }\n  let y = txt[len - 1].charCodeAt()\n  if (len == 1) {\n    if ((y >= 65 && y <= 90) || (y >= 97 && y <= 122)) { return true }\n    return false\n  }\n  if (txt[len - 2] == ' ' && ((y >= 65 && y <= 90) || (y >= 97 && y <= 122))) { return true }\n  return false\n}\n\n", "test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('eeeee') === false)\n  console.assert(checkIfLastCharIsALetter('A') === true)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie ') === false)\n  console.assert(checkIfLastCharIsALetter('Pumpkin pie 1') === false)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('eeeee e ') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\n\ntestCheckIfLastCharIsALetter()\n", "declaration": "\nconst checkIfLastCharIsALetter = (txt) => {\n", "example_test": "const testCheckIfLastCharIsALetter = () => {\n  console.assert(checkIfLastCharIsALetter('apple pi e') === true)\n  console.assert(checkIfLastCharIsALetter('') === false)\n  console.assert(checkIfLastCharIsALetter('apple pie') === false)\n  console.assert(checkIfLastCharIsALetter('apple pi e ') === false)\n}\ntestCheckIfLastCharIsALetter()\n", "entry_point": "checkIfLastCharIsALetter", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Create a function that returns true if the last character in a given string is an alphabetic character and not part of a word, and otherwise incorrect. Note: \"Word\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsALetter(\"apple pie\")  false\n  checkIfLastCharIsALetter(\"apple pi e\")  true\n  checkIfLastCharIsALetter(\"apple pi e \")  false\n  checkIfLastCharIsALetter(\"\")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!=='' && lastChar!== '.' && lastChar!== '?' && lastChar!== '!';\n};\n\n/* Create a function that returns true if the last character in a given string is a number, and otherwise incorrect. Note: \"Number\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsANumber(\"\")  false\n  checkIfLastCharIsANumber(\" \")  false\n  checkIfLastCharIsANumber(\" 1 \")  true\n  checkIfLastCharIsANumber(\" 1 2 \")  true\n  checkIfLastCharIsANumber(\" 1 2 3 \")  false\n  checkIfLastCharIsANumber(\" 1 2 3 4 \")  false\n  */\nconst checkIfLastCharIsANumber = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!=='' && lastChar!== '.' && lastChar!== '?' && lastChar!== '!' && lastChar!== '-' && lastChar!== '+';\n};\n\n/* Create a function that returns true if the last character in a given string is a letter, and otherwise incorrect. Note: \"Letter\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsALetter(\"a\")  false\n  checkIfLastCharIsALetter(\"a \")  false\n  checkIfLastCharIsALetter(\"a b\")  true\n  checkIfLastCharIsALetter(\"a b c\")  true\n  checkIfLastCharIsALetter(\"a b c \")  false\n  checkIfLastCharIsALetter(\"a b c d \")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!=='' && lastChar!== '.' && lastChar!== '?' && lastChar!== '!' && lastChar!== '-' && lastChar!== '+';\n};\n\n/* Create a function that returns true if the last character in a given string is a number, and otherwise incorrect. Note: \"Number\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsANumber(\" \")  false\n  checkIfLastCharIsANumber(\" 1 \")  true\n  checkIfLastCharIsANumber(\" 1 2 \")  true\n  checkIfLastCharIsANumber(\" 1 2 3 \")  false\n  checkIfLastCharIsANumber(\" 1 2 3 4 \")  false\n  */\nconst checkIfLastCharIsANumber = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!=='' && lastChar!== '.' && lastChar!== '?' && lastChar!== '!' && lastChar!== '-' && lastChar!== '+';\n};\n\n/* Create a function that returns true if the last character in a given string is a letter, and otherwise incorrect. Note: \"Letter\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsALetter(\"a\")  false\n  checkIfLastCharIsALetter(\"a \")  false\n  checkIfLastCharIsALetter(\"a b\")  true\n  checkIfLastCharIsALetter(\"a b c\")  true\n  checkIfLastCharIsALetter(\"a b c \")  false\n  checkIfLastCharIsALetter(\"a b c d \")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!=='' && lastChar!== '.' && lastChar!== '?' && lastChar!== '!' && lastChar!== '-' && lastChar!== '+';\n};\n\n/* Create a function that returns true if the last character in a given string is a number, and otherwise incorrect. Note: \"Number\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsANumber(\" \")  false\n  checkIfLastCharIsANumber(\" 1 \")  true\n  checkIfLastCharIsANumber(\" 1 2 \")  true\n  checkIfLastCharIsANumber(\" 1 2 3 \")  false\n  checkIfLastCharIsANumber(\" 1 2 3 4 \")  false\n  */\nconst checkIfLastCharIsANumber = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!=='' && lastChar!== '.' && lastChar!== '?' && lastChar!== '!' && lastChar!== '-' && lastChar!== '+';\n};\n\n/* Create a function that returns true if the last character in a given string is a letter, and otherwise incorrect. Note: \"Letter\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsALetter(\"a\")  false\n  checkIfLastCharIsALetter(\"a \")  false\n  checkIfLastCharIsALetter(\"a b\")  true\n  checkIfLastCharIsALetter(\"a b c\")  true\n  checkIfLastCharIsALetter(\"a b c \")  false\n  checkIfLastCharIsALetter(\"a b c d \")  false\n  */\nconst checkIfLastCharIsALetter = (txt) => {\n  const lastChar = txt.charAt(txt.length - 1);\n  return lastChar!=='' && lastChar!== '.' && lastChar!== '?' && lastChar!== '!' && lastChar!== '-' && lastChar!== '+';\n};\n\n/* Create a function that returns true if the last character in a given string is a number, and otherwise incorrect. Note: \"Number\" is a group of characters separated by spaces.\n  Examples:\n  checkIfLastCharIsANumber(\" \")  false\n  checkIfLastCharIsANumber(\" 1 \")  true\n  checkIfLastCharIsANumber(\" 1 2 \")  true\n  checkIfLastCharIsANumber(\" 1 2 3 \")  false\n  ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/135", "prompt": "/*CReturns the largest index of an element that is not larger or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) { return -1 }\n  for (let i = arr.length - 1; i > 0; i--) {\n    if (arr[i] < arr[i - 1]) { return i }\n  }\n  return -1\n}\n\n", "test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 4, 5]) === -1)\n  console.assert(canArrange([1, 4, 2, 5, 6, 7, 8, 9, 10]) === 2)\n  console.assert(canArrange([4, 8, 5, 7, 3]) === 4)\n  console.assert(canArrange([]) === -1)\n}\n\ntestCanArrange()\n", "declaration": "\nconst canArrange = (arr) => {\n", "example_test": "const testCanArrange = () => {\n  console.assert(canArrange([1, 2, 4, 3, 5]) === 3)\n  console.assert(canArrange([1, 2, 3]) === -1)\n}\ntestCanArrange()\n", "entry_point": "canArrange", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*CReturns the largest index of an element that is not larger or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrange = (arr) => {\n  let i = arr.length - 1;\n  let j = 0;\n  while (j >= 0 && arr[j] < arr[j + 1]) {\n    j--;\n  }\n  return j;\n};\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrangeBack = (arr) => {\n  let i = arr.length - 1;\n  let j = 0;\n  while (j >= 0 && arr[j] > arr[j + 1]) {\n    j--;\n  }\n  return j;\n};\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrangeFront = (arr) => {\n  let i = arr.length - 1;\n  let j = 0;\n  while (j >= 0 && arr[j] < arr[j - 1]) {\n    j--;\n  }\n  return j;\n};\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrangeBackFront = (arr) => {\n  let i = arr.length - 1;\n  let j = 0;\n  while (j >= 0 && arr[j] > arr[j + 1]) {\n    j--;\n  }\n  return j;\n};\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrangeFrontBack = (arr) => {\n  let i = arr.length - 1;\n  let j = 0;\n  while (j >= 0 && arr[j] < arr[j - 1]) {\n    j--;\n  }\n  return j;\n};\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrangeFrontBackFront = (arr) => {\n  let i = arr.length - 1;\n  let j = 0;\n  while (j >= 0 && arr[j] > arr[j + 1]) {\n    j--;\n  }\n  return j;\n};\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrangeFrontBackBack = (arr) => {\n  let i = arr.length - 1;\n  let j = 0;\n  while (j >= 0 && arr[j] < arr[j - 1]) {\n    j--;\n  }\n  return j;\n};\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrangeFrontBackBackFront = (arr) => {\n  let i = arr.length - 1;\n  let j = 0;\n  while (j >= 0 && arr[j] > arr[j + 1]) {\n    j--;\n  }\n  return j;\n};\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrangeFrontBackBackBackFront = (arr) => {\n  let i = arr.length - 1;\n  let j = 0;\n  while (j >= 0 && arr[j] < arr[j - 1]) {\n    j--;\n  }\n  return j;\n};\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrangeFrontBackBackBackBack = (arr) => {\n  let i = arr.length - 1;\n  let j = 0;\n  while (j >= 0 && arr[j] > arr[j + 1]) {\n    j--;\n  }\n  return j;\n};\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrangeFrontBackBackBackBackFront = (arr) => {\n  let i = arr.length - 1;\n  let j = 0;\n  while (j >= 0 && arr[j] < arr[j - 1]) {\n    j--;\n  }\n  return j;\n};\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrangeFrontBackBackBackBackBackBack = (arr) => {\n  let i = arr.length - 1;\n  let j = 0;\n  while (j >= 0 && arr[j] > arr[j + 1]) {\n    j--;\n  }\n  return j;\n};\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrangeFrontBackBackBackBackBackBackFront = (arr) => {\n  let i = arr.length - 1;\n  let j = 0;\n  while (j >= 0 && arr[j] < arr[j - 1]) {\n    j--;\n  }\n  return j;\n};\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrangeFrontBackBackBackBackBackBackBack = (arr) => {\n  let i = arr.length - 1;\n  let j = 0;\n  while (j >= 0 && arr[j] > arr[j + 1]) {\n    j--;\n  }\n  return j;\n};\n\n/*CReturns the smallest index of an element that is not smaller or equal to the element immediately in front of it. If no such element exists, it returns -1. The given array will not contain duplicate values.\n\n  Examples:\n  canArrange([1,2,4,3,5]) = 3\n  canArrange([1,2,3]) = -1\n  */\nconst canArrangeFrontBackBackBackBackBackBackBackFront = (arr) => {\n  let i = arr.length - 1;\n  let j = 0;\n  while (j >= 0 && arr", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/136", "prompt": "/* Create a function that returns a tuple (a, b), where \"a\" is the largest negative integer and \"b\" is the smallest positive integer in a list. If there are no negative or positive integers, return them as zero.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n", "canonical_solution": "  let a = Infinity\n  let b = -Infinity\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && lst[i] < a) { a = lst[i] }\n    if (lst[i] < 0 && lst[i] > b) { b = lst[i] }\n  }\n  if (a == Infinity) { a = null }\n  if (b == -Infinity) { b = null }\n  return (b, a)\n}\n\n", "test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7, 0])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([1, 3, 2, 4, 5, 6, -2])) ===\n    JSON.stringify((-2, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([4, 5, 3, 6, 2, 7, -7])) ===\n    JSON.stringify((-7, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([7, 3, 8, 4, 9, 2, 5, -9])) ===\n    JSON.stringify((-9, 2))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-1, -3, -5, -6, 0])) ===\n    JSON.stringify((-1, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([-6, -4, -4, -3, -100, 1])) ===\n    JSON.stringify((-3, 1))\n  )\n}\n\ntestLargestSmallestIntegers()\n", "declaration": "\nconst largestSmallestIntegers = (lst) => {\n", "example_test": "const testLargestSmallestIntegers = () => {\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([2, 4, 1, 3, 5, 7])) ===\n    JSON.stringify((null, 1))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([])) === JSON.stringify((null, null))\n  )\n  console.assert(\n    JSON.stringify(largestSmallestIntegers([0])) ===\n    JSON.stringify((null, null))\n  )\n}\ntestLargestSmallestIntegers()\n", "entry_point": "largestSmallestIntegers", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Create a function that returns a tuple (a, b), where \"a\" is the largest negative integer and \"b\" is the smallest positive integer in a list. If there are no negative or positive integers, return them as zero.\n  Examples:\n  largestSmallestIntegers([2, 4, 1, 3, 5, 7]) == (null, 1)\n  largestSmallestIntegers([]) == (null, null)\n  largestSmallestIntegers([0]) == (null, null)\n  */\nconst largestSmallestIntegers = (lst) => {\n  let largest = Number.MIN_SAFE_INTEGER;\n  let smallest = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < 0) {\n      smallest = Number.MIN_SAFE_INTEGER;\n      largest = Number.MIN_SAFE_INTEGER;\n    } else if (lst[i] > 0) {\n      smallest = Number.MAX_SAFE_INTEGER;\n      largest = Number.MAX_SAFE_INTEGER;\n    }\n  }\n  return [smallest, largest];\n};\n\n/**\n * Given a string, convert it to a list of integers. Each integer in the list will be a character in the string.\n * Examples:\n * convertToIntegers('abc') == [a, b, c]\n * convertToIntegers('ab') == [a, b, 0]\n * convertToIntegers('') == []\n * convertToIntegers('') == []\n */\nconst convertToIntegers = (str) => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    result.push(str[i]);\n  }\n  return result;\n};\n\n/**\n * Given a string, convert it to a list of integers. Each integer in the list will be a character in the string.\n * Examples:\n * convertToIntegers('abc') == [a, b, c]\n * convertToIntegers('ab') == [a, b, 0]\n * convertToIntegers('') == []\n * convertToIntegers('') == []\n */\nconst convertToIntegers = (str) => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    result.push(str[i]);\n  }\n  return result;\n};\n\n/**\n * Given a string, convert it to a list of integers. Each integer in the list will be a character in the string.\n * Examples:\n * convertToIntegers('abc') == [a, b, c]\n * convertToIntegers('ab') == [a, b, 0]\n * convertToIntegers('') == []\n * convertToIntegers('') == []\n */\nconst convertToIntegers = (str) => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    result.push(str[i]);\n  }\n  return result;\n};\n\n/**\n * Given a string, convert it to a list of integers. Each integer in the list will be a character in the string.\n * Examples:\n * convertToIntegers('abc') == [a, b, c]\n * convertToIntegers('ab') == [a, b, 0]\n * convertToIntegers('') == []\n * convertToIntegers('') == []\n */\nconst convertToIntegers = (str) => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    result.push(str[i]);\n  }\n  return result;\n};\n\n/**\n * Given a string, convert it to a list of integers. Each integer in the list will be a character in the string.\n * Examples:\n * convertToIntegers('abc') == [a, b, c]\n * convertToIntegers('ab') == [a, b, 0]\n * convertToIntegers('') == []\n * convertToIntegers('') == []\n */\nconst convertToIntegers = (str) => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    result.push(str[i]);\n  }\n  return result;\n};\n\n/**\n * Given a string, convert it to a list of integers. Each integer in the list will be a character in the string.\n * Examples:\n * convertToIntegers('abc') == [a, b, c]\n * convertToIntegers('ab') == [a, b, 0]\n * convertToIntegers('') == []\n * convertToIntegers('') == []\n */\nconst convertToIntegers = (str) => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    result.push(str[i]);\n  }\n  return result;\n};\n\n/**\n * Given a string, convert it to a list of integers. Each integer in the list will be a character in the string.\n * Examples:\n * convertToIntegers('abc') == [a, b, c]\n * convertToIntegers('ab') == [a, b, 0]\n * convertToIntegers('') == []\n * convertToIntegers('') == []\n */\nconst convertToIntegers = (str) => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    result.push(str[i]);\n  }\n  return result;\n};\n\n/**\n * Given a string, convert it to a list of integers. Each integer in the list will be a character in the string.\n * Examples:\n * convertToIntegers('abc') == [a, b, c]\n * convertToIntegers('ab') == [a, b, 0]\n * convertToIntegers('') == []\n * convertToIntegers('') == []\n */\nconst convertToIntegers = (str) => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    result.push(str[i]);\n  }\n  return result;\n};\n\n/**\n * Given a string, convert it to a list of integers. Each integer in the list will be a character in the string.\n * Examples:\n * convertToIntegers('abc') == [a, b, c]\n * convertToIntegers('ab') == [a, b, 0]\n * convertToIntegers('') == []\n * convertToIntegers('') == []\n */\nconst convertToIntegers = (str) => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    result.push(str[i]);\n  }\n  return result;\n};\n\n/**\n * Given a string, convert it to a list of integers. Each integer in the list will be a character in the string.\n * Examples:\n * convertToIntegers('abc') == [a, b, c]\n * convertToIntegers('ab') == [a, b, 0]\n * convertToIntegers('') == []\n * convertToIntegers('') == []\n */\nconst convertToIntegers = (str) => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    result.push(str[i]);\n  }\n  return result;\n};\n\n/**\n * Given a string, convert it to a list of integers. Each integer in the list will be a character in the string.\n * Examples:\n * convertToIntegers('abc') == [a, b, c]\n * convertToIntegers('ab') == [a, b, 0]\n * convertToIntegers('') == []\n * convertToIntegers('') == []\n */\nconst convertToIntegers = (str) => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    result.push(str[i]);\n  }\n  return result;\n};\n\n/**\n * Given a string, convert it to a list of integers. Each integer in the list will be a character in the string.\n * Examples:\n * convertToIntegers('abc') == [a, b, c]\n * convertToIntegers('ab') == [a, b, 0]\n * convertToIntegers('') == []\n * convertToIntegers('') == []\n */\nconst convertToIntegers = (str) => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    result.push(str[i]);\n  }\n  return result;\n};\n\n/**\n * Given a string, convert it to a list of integers. Each integer in the list will be a character in the string.\n * Examples:\n * convertToIntegers('abc') == [a, b, c]\n * convertToIntegers('ab') == [a, b, 0]\n * convertToIntegers('') == []\n * convertToIntegers('') == []\n */\nconst convertToIntegers = (str) => {\n  let result = [];\n  for (let i = 0; i < str.length; i++) {\n    result.push(str[i]);\n  }\n  return result;\n};\n\n/**\n * Given a string, convert it to a list of integers. Each integer in the list will be a character in the string.\n * Examples:\n * convertToIntegers('abc') == [a, b, c]\n * convertToIntegers('ab') == [a, b, 0]\n * convertToIntegers('') == []\n * convertToIntegers('') == []\n */\nconst convertToIntegers = (str) => {\n  let result = [];\n  for (", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/137", "prompt": "/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be . or ,\n\n  compareOne(1, 2.5)  2.5\n  compareOne(1, \"2,3\")  \"2,3\"\n  compareOne(\"5,1\", \"6\")  \"6\"\n  compareOne(\"1\", 1)  null\n  */\nconst compareOne = (a, b) => {\n", "canonical_solution": "  let aa = Number(a)\n  if (typeof a == 'string') { aa = Number(a.replace(',', '.')) }\n  let bb = Number(b)\n  if (typeof b == 'string') { bb = Number(b.replace(',', '.')) }\n  if (aa > bb) { return a }\n  if (aa < bb) { return b }\n  return null\n}\n\n", "test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2) === 2)\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(2, 3) === 3)\n  console.assert(compareOne(5, 6) === 6)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', '2') === '2')\n  console.assert(compareOne('1', 1) === null)\n}\n\ntestCompareOne()\n", "declaration": "\nconst compareOne = (a, b) => {\n", "example_test": "const testCompareOne = () => {\n  console.assert(compareOne(1, 2.5) === 2.5)\n  console.assert(compareOne(1, '2,3') === '2,3')\n  console.assert(compareOne('5,1', '6') === '6')\n  console.assert(compareOne('1', 1) === null)\n}\ntestCompareOne()\n", "entry_point": "compareOne", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*\n  Create a function that takes integers, floats, or strings representing\n  real numbers, and returns the larger variable in its given variable type.\n  Return null if the values are equal.\n  Note: If a real number is represented as a string, the floating point might be. or,\n\n  compareOne(1, 2.5)  2.5\n  compareOne(1, \"2,3\")  \"2,3\"\n  compareOne(\"5,1\", \"6\")  \"6\"\n  compareOne(\"1\", 1)  null\n  */\nconst compareOne = (a, b) => {\n  if (a === null || b === null) {\n    return null\n  }\n  if (a === \"\" || b === \"\") {\n    return null\n  }\n  if (isNaN(a) && isNaN(b)) {\n    return null\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n    return a\n  }\n  if (a === \"\") {\n    return b\n  }\n  if (b === \"\") {\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/138", "prompt": "/*Eevaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n", "canonical_solution": "  return (n >= 8 && n % 2 == 0)\n}\n\n", "test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n  console.assert(isEqualToSumEven(10) === true)\n  console.assert(isEqualToSumEven(11) === false)\n  console.assert(isEqualToSumEven(12) === true)\n  console.assert(isEqualToSumEven(13) === false)\n  console.assert(isEqualToSumEven(16) === true)\n}\n\ntestIsEqualToSumEven()\n", "declaration": "\nconst isEqualToSumEven = (n) => {\n", "example_test": "const testIsEqualToSumEven = () => {\n  console.assert(isEqualToSumEven(4) === false)\n  console.assert(isEqualToSumEven(6) === false)\n  console.assert(isEqualToSumEven(8) === true)\n}\ntestIsEqualToSumEven()\n", "entry_point": "isEqualToSumEven", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Eevaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n  Example\n  isEqualToSumEven(4) == false\n  isEqualToSumEven(6) == false\n  isEqualToSumEven(8) == true\n  */\nconst isEqualToSumEven = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      sum += i;\n    }\n  }\n  return sum === 4;\n};\n\n/*\n  Given a number n, return true if it is possible to divide it into two smaller numbers, such that each of them is even.\n  Example\n  isDivisibleByTwo(2) == true\n  isDivisibleByTwo(5) == false\n  isDivisibleByTwo(7) == true\n  */\nconst isDivisibleByTwo = (n) => {\n  let divisor = 1;\n  while (divisor < n) {\n    if (n % divisor === 0) {\n      return false;\n    }\n    divisor += 2;\n  }\n  return true;\n};\n\n/*\n  Given a number n, return true if it is possible to divide it into two smaller numbers, such that each of them is odd.\n  Example\n  isDivisibleByOdd(2) == false\n  isDivisibleByOdd(5) == true\n  isDivisibleByOdd(7) == false\n  */\nconst isDivisibleByOdd = (n) => {\n  let divisor = 1;\n  while (divisor < n) {\n    if (n % divisor === 0) {\n      return true;\n    }\n    divisor += 2;\n  }\n  return false;\n};\n\n/*\n  Given a number n, return true if it is possible to divide it into two smaller numbers, such that each of them is divisible by both numbers.\n  Example\n  isDivisibleByBoth(2) == true\n  isDivisibleByBoth(5) == false\n  isDivisibleByBoth(7) == true\n  */\nconst isDivisibleByBoth = (n) => {\n  let divisor = 1;\n  while (divisor < n) {\n    if (n % divisor === 0) {\n      return false;\n    }\n    divisor += 2;\n  }\n  return true;\n};\n\n/*\n  Given a number n, return true if it is possible to divide it into two smaller numbers, such that each of them is divisible by exactly two numbers.\n  Example\n  isDivisibleByExactly(2) == true\n  isDivisibleByExactly(5) == false\n  isDivisibleByExactly(7) == false\n  */\nconst isDivisibleByExactly = (n) => {\n  let divisor = 1;\n  while (divisor < n) {\n    if (n % divisor === 0) {\n      return true;\n    }\n    divisor += 2;\n  }\n  return false;\n};\n\n/*\n  Given a number n, return true if it is possible to divide it into two smaller numbers, such that each of them is divisible by exactly three numbers.\n  Example\n  isDivisibleByExactlyThree(2) == true\n  isDivisibleByExactlyThree(5) == false\n  isDivisibleByExactlyThree(7) == false\n  */\nconst isDivisibleByExactlyThree = (n) => {\n  let divisor = 1;\n  while (divisor < n) {\n    if (n % divisor === 0) {\n      return false;\n    }\n    divisor += 2;\n  }\n  return true;\n};\n\n/*\n  Given a number n, return true if it is possible to divide it into two smaller numbers, such that each of them is divisible by exactly four numbers.\n  Example\n  isDivisibleByExactlyFour(2) == true\n  isDivisibleByExactlyFour(5) == false\n  isDivisibleByExactlyFour(7) == false\n  */\nconst isDivisibleByExactlyFour = (n) => {\n  let divisor = 1;\n  while (divisor < n) {\n    if (n % divisor === 0) {\n      return true;\n    }\n    divisor += 2;\n  }\n  return false;\n};\n\n/*\n  Given a number n, return true if it is possible to divide it into two smaller numbers, such that each of them is divisible by exactly five numbers.\n  Example\n  isDivisibleByExactlyFive(2) == true\n  isDivisibleByExactlyFive(5) == false\n  isDivisibleByExactlyFive(7) == false\n  */\nconst isDivisibleByExactlyFive = (n) => {\n  let divisor = 1;\n  while (divisor < n) {\n    if (n % divisor === 0) {\n      return false;\n    }\n    divisor += 2;\n  }\n  return true;\n};\n\n/*\n  Given a number n, return true if it is possible to divide it into two smaller numbers, such that each of them is divisible by exactly six numbers.\n  Example\n  isDivisibleByExactlySix(2) == true\n  isDivisibleByExactlySix(5) == false\n  isDivisibleByExactlySix(7) == false\n  */\nconst isDivisibleByExactlySix = (n) => {\n  let divisor = 1;\n  while (divisor < n) {\n    if (n % divisor === 0) {\n      return true;\n    }\n    divisor += 2;\n  }\n  return false;\n};\n\n/*\n  Given a number n, return true if it is possible to divide it into two smaller numbers, such that each of them is divisible by exactly seven numbers.\n  Example\n  isDivisibleByExactlySeven(2) == true\n  isDivisibleByExactlySeven(5) == false\n  isDivisibleByExactlySeven(7) == true\n  */\nconst isDivisibleByExactlySeven = (n) => {\n  let divisor = 1;\n  while (divisor < n) {\n    if (n % divisor === 0) {\n      return false;\n    }\n    divisor += 2;\n  }\n  return true;\n};\n\n/*\n  Given a number n, return true if it is possible to divide it into two smaller numbers, such that each of them is divisible by exactly eight numbers.\n  Example\n  isDivisibleByExactlyEight(2) == true\n  isDivisibleByExactlyEight(5) == false\n  isDivisibleByExactlyEight(7) == false\n  */\nconst isDivisibleByExactlyEight = (n) => {\n  let divisor = 1;\n  while (divisor < n) {\n    if (n % divisor === 0) {\n      return true;\n    }\n    divisor += 2;\n  }\n  return false;\n};\n\n/*\n  Given a number n, return true if it is possible to divide it into two smaller numbers, such that each of them is divisible by exactly nine numbers.\n  Example\n  isDivisibleByExactlyNine(2) == true\n  isDivisibleByExactlyNine(5) == false\n  isDivisibleByExactlyNine(7) == false\n  */\nconst isDivisibleByExactlyNine = (n) => {\n  let divisor = 1;\n  while (divisor < n) {\n    if (n % divisor === 0) {\n      return false;\n    }\n    divisor += 2;\n  }\n  return true;\n};\n\n/*\n  Given a number n, return true if it is possible to divide it into two smaller numbers, such that each of them is divisible by exactly ten numbers.\n  Example\n  isDivisibleByExactlyTen(2) == true\n  isDivisibleByExactlyTen(5) == false\n  isDivisibleByExactlyTen(7) == false\n  */\nconst isDivisibleByExactlyTen = (n) => {\n  let divisor = 1;\n  while (divisor < n) {\n    if (n % divisor === 0) {\n      return true;\n    }\n    divisor += 2;\n  }\n  return false;\n};\n\n/*\n  Given a number n, return true if it is possible to divide it into two smaller numbers, such that each of them is divisible by exactly eleven numbers.\n  Example\n  isDivisibleByExactlyEleven(2) == true\n  isDivisibleByExactlyEleven(5) == false\n  is", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/139", "prompt": "/*The Brazilian faculty is defined as: brazilian _ factorial (n) = n! * (n-1)! * (n-2)! *... * 1! where n > 0 for example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n", "canonical_solution": "  let p = 1;\n  let t = 1;\n  while (n > 1) {\n    let y = p;\n    while (y > 0) {\n      y--;\n      t *= n;\n    }\n    p++;\n    n--;\n  }\n  return t\n}\n\n", "test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n  console.assert(specialFactorial(5) === 34560)\n  console.assert(specialFactorial(7) === 125411328000)\n  console.assert(specialFactorial(1) === 1)\n}\n\ntestSpecialFactorial()\n", "declaration": "\nconst specialFactorial = (n) => {\n", "example_test": "const testSpecialFactorial = () => {\n  console.assert(specialFactorial(4) === 288)\n}\ntestSpecialFactorial()\n", "entry_point": "specialFactorial", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*The Brazilian faculty is defined as: brazilian _ factorial (n) = n! * (n-1)! * (n-2)! *... * 1! where n > 0 for example:\n  >>> specialFactorial(4)\n  288\n\n  The function will receive an integer as input and should return the special\n  factorial of this integer.\n  */\nconst specialFactorial = (n) => {\n  if (n <= 0) return 1;\n  if (n <= 1) return n;\n  return n * specialFactorial(n - 1);\n};\n\n/*\n  Returns the factorial of n raised to the power of e.\n  >>> factorial(4)\n  120\n  >>> factorial(5)\n  720\n  >>> factorial(6)\n  5040\n  >>> factorial(7)\n  40320\n  >>> factorial(8)\n  362880\n  >>> factorial(9)\n  3628800\n  >>> factorial(10)\n  3628800\n  >>> factorial(11)\n  3628800\n  >>> factorial(12)\n  3628800\n  >>> factorial(13)\n  3628800\n  >>> factorial(14)\n  3628800\n  >>> factorial(15)\n  3628800\n  >>> factorial(16)\n  3628800\n  >>> factorial(17)\n  3628800\n  >>> factorial(18)\n  3628800\n  >>> factorial(19)\n  3628800\n  >>> factorial(20)\n  3628800\n  >>> factorial(21)\n  3628800\n  >>> factorial(22)\n  3628800\n  >>> factorial(23)\n  3628800\n  >>> factorial(24)\n  3628800\n  >>> factorial(25)\n  3628800\n  >>> factorial(26)\n  3628800\n  >>> factorial(27)\n  3628800\n  >>> factorial(28)\n  3628800\n  >>> factorial(29)\n  3628800\n  >>> factorial(30)\n  3628800\n  >>> factorial(31)\n  3628800\n  >>> factorial(32)\n  3628800\n  >>> factorial(33)\n  3628800\n  >>> factorial(34)\n  3628800\n  >>> factorial(35)\n  3628800\n  >>> factorial(36)\n  3628800\n  >>> factorial(37)\n  3628800\n  >>> factorial(38)\n  3628800\n  >>> factorial(39)\n  3628800\n  >>> factorial(40)\n  3628800\n  >>> factorial(41)\n  3628800\n  >>> factorial(42)\n  3628800\n  >>> factorial(43)\n  3628800\n  >>> factorial(44)\n  3628800\n  >>> factorial(45)\n  3628800\n  >>> factorial(46)\n  3628800\n  >>> factorial(47)\n  3628800\n  >>> factorial(48)\n  3628800\n  >>> factorial(49)\n  3628800\n  >>> factorial(50)\n  3628800\n  >>> factorial(51)\n  3628800\n  >>> factorial(52)\n  3628800\n  >>> factorial(53)\n  3628800\n  >>> factorial(54)\n  3628800\n  >>> factorial(55)\n  3628800\n  >>> factorial(56)\n  3628800\n  >>> factorial(57)\n  3628800\n  >>> factorial(58)\n  3628800\n  >>> factorial(59)\n  3628800\n  >>> factorial(60)\n  3628800\n  >>> factorial(61)\n  3628800\n  >>> factorial(62)\n  3628800\n  >>> factorial(63)\n  3628800\n  >>> factorial(64)\n  3628800\n  >>> factorial(65)\n  3628800\n  >>> factorial(66)\n  3628800\n  >>> factorial(67)\n  3628800\n  >>> factorial(68)\n  3628800\n  >>> factorial(69)\n  3628800\n  >>> factorial(70)\n  3628800\n  >>> factorial(71)\n  3628800\n  >>> factorial(72)\n  3628800\n  >>> factorial(73)\n  3628800\n  >>> factorial(74)\n  3628800\n  >>> factorial(75)\n  3628800\n  >>> factorial(76)\n  3628800\n  >>> factorial(77)\n  3628800\n  >>> factorial(78)\n  3628800\n  >>> factorial(79)\n  3628800\n  >>> factorial(80)\n  3628800\n  >>> factorial(81)\n  3628800\n  >>> factorial(82)\n  3628800\n  >>> factorial(83)\n  3628800\n  >>> factorial(84)\n  3628800\n  >>> factorial(85)\n  3628800\n  >>> factorial(86)\n  3628800\n  >>> factorial(87)\n  3628800\n  >>> factorial(88)\n  3628800\n  >>> factorial(89)\n  3628800\n  >>> factorial(90)\n  3628800\n  >>> factorial(91)\n  3628800\n  >>> factorial(92)\n  3628800\n  >>> factorial(93)\n  3628800\n  >>> factorial(94)\n  3628800\n  >>> factorial(95)\n  3628800\n  >>> factorial(96)\n  3628800\n  >>> factorial(97)\n  3628800\n  >>> factorial(98)\n  3628800\n  >>> factorial(99)\n  3628800\n  >>> factorial(100)\n  3628800\n  >>> factorial(101)\n  3628800\n  >>> factorial(102)\n  3628800\n  >>> factorial(103)\n  3628800\n  >>> factorial(104)\n  3628800\n  >>> factorial(105)\n  3628800\n  >>> factorial(106)\n  3628800\n  >>> factorial(107)\n  3628800\n  >>> factorial(108)\n  3628800\n  >>> factorial(109)\n  3628800\n  >>> factorial(110)\n  3628800\n  >>> factorial(111)\n  3628800\n  >>> factorial(112)\n  3628800\n  >>> factorial(113)\n  3628800\n  >>> factorial(114)\n  3628800\n  >>> factorial(115)\n  3628800\n  >>> factorial(116)\n  3628800\n  >>> factorial(117)\n  3628800\n  >>> factorial(118)\n  3628800\n  >>> factorial(119)\n  3628800\n  >>> factorial(120)\n  3628800\n  >>> factorial(121)\n  3628800\n  >>> factorial(122)\n  3628800\n  >>> factorial(123)\n  3628800\n  >>> factorial(124)\n  3628800\n  >>> factori", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/14", "prompt": "/* Returns a list of all prefixes from the shortest to the longest of the input strings\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n", "canonical_solution": "  var result = [];\n  for (let i = 0; i < string.length; i++) {\n    result.push(string.slice(0, i+1));\n  }\n  return result;\n}\n\n", "test": "const testAllPrefixes = () => {\n  console.assert(JSON.stringify(allPrefixes('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      allPrefixes('asdfgh')) ===\n        JSON.stringify(['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'])\n  )\n  console.assert(\n    JSON.stringify(allPrefixes('WWW')) === JSON.stringify(['W', 'WW', 'WWW'])\n  )\n}\n\ntestAllPrefixes()\n", "declaration": "\nconst allPrefixes = (string) => {\n", "example_test": "const testAllPrefixes = () => {\n  console.assert(\n    JSON.stringify(\n      allPrefixes('abc')) ===\n        JSON.stringify(['a', 'ab', 'abc'])\n  )\n}\ntestAllPrefixes()\n", "entry_point": "allPrefixes", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Returns a list of all prefixes from the shortest to the longest of the input strings\n  >>> allPrefixes('abc')\n  ['a', 'ab', 'abc']\n  */\nconst allPrefixes = (string) => {\n  let prefixes = [];\n  let currentPrefix = string;\n  while (currentPrefix.length > 0) {\n    prefixes.push(currentPrefix);\n    currentPrefix = currentPrefix.substring(0, currentPrefix.length - 1);\n  }\n  return prefixes;\n};\n\n/**\n * Returns a list of all suffixes from the shortest to the longest of the input strings\n  >>> allSuffixes('abc')\n  ['c', 'ba', 'cab']\n  */\nconst allSuffixes = (string) => {\n  let suffixes = [];\n  let currentSuffix = string;\n  while (currentSuffix.length > 0) {\n    suffixes.push(currentSuffix);\n    currentSuffix = currentSuffix.substring(0, currentSuffix.length - 1);\n  }\n  return suffixes;\n};\n\n/**\n * Returns a list of all substrings from the shortest to the longest of the input strings\n  >>> allSubstrings('abc')\n  ['abc', 'ab', 'ba', 'cab']\n  */\nconst allSubstrings = (string) => {\n  let substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substring(0, currentSubstring.length - 1);\n  }\n  return substrings;\n};\n\n/**\n * Returns a list of all substrings from the shortest to the longest of the input strings\n  >>> allSubstrings('abc')\n  ['abc', 'ab', 'ba', 'cab']\n  */\nconst allSubstringsInOrder = (string) => {\n  let substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substring(0, currentSubstring.length - 1);\n  }\n  return substrings.sort();\n};\n\n/**\n * Returns a list of all substrings from the shortest to the longest of the input strings\n  >>> allSubstringsInOrder('abc')\n  ['abc', 'ab', 'ba', 'cab']\n  */\nconst allSubstringsInOrderReverse = (string) => {\n  let substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substring(0, currentSubstring.length - 1);\n  }\n  return substrings.reverse();\n};\n\n/**\n * Returns a list of all substrings from the shortest to the longest of the input strings\n  >>> allSubstringsInOrderReverse('abc')\n  ['cab', 'cab', 'cab', 'cab']\n  */\nconst allSubstringsInOrderReverseInOrder = (string) => {\n  let substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substring(0, currentSubstring.length - 1);\n  }\n  return substrings.sort().reverse();\n};\n\n/**\n * Returns a list of all substrings from the shortest to the longest of the input strings\n  >>> allSubstringsInOrderReverseInOrder('abc')\n  ['cab', 'cab', 'cab', 'cab']\n  */\nconst allSubstringsInOrderReverseInOrderReverse = (string) => {\n  let substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substring(0, currentSubstring.length - 1);\n  }\n  return substrings.sort().reverse().reverse();\n};\n\n/**\n * Returns a list of all substrings from the shortest to the longest of the input strings\n  >>> allSubstringsInOrderReverseInOrderReverse('abc')\n  ['cab', 'cab', 'cab', 'cab']\n  */\nconst allSubstringsInOrderReverseInOrderReverseInOrder = (string) => {\n  let substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substring(0, currentSubstring.length - 1);\n  }\n  return substrings.sort().reverse().reverse().reverse();\n};\n\n/**\n * Returns a list of all substrings from the shortest to the longest of the input strings\n  >>> allSubstringsInOrderReverseInOrderReverseInOrder('abc')\n  ['cab', 'cab', 'cab', 'cab']\n  */\nconst allSubstringsInOrderReverseInOrderReverseInOrderReverse = (string) => {\n  let substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substring(0, currentSubstring.length - 1);\n  }\n  return substrings.sort().reverse().reverse().reverse().reverse();\n};\n\n/**\n * Returns a list of all substrings from the shortest to the longest of the input strings\n  >>> allSubstringsInOrderReverseInOrderReverseInOrderReverse('abc')\n  ['cab', 'cab', 'cab', 'cab']\n  */\nconst allSubstringsInOrderReverseInOrderReverseInOrderReverseInOrder = (string) => {\n  let substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substring(0, currentSubstring.length - 1);\n  }\n  return substrings.sort().reverse().reverse().reverse().reverse().reverse();\n};\n\n/**\n * Returns a list of all substrings from the shortest to the longest of the input strings\n  >>> allSubstringsInOrderReverseInOrderReverseInOrderReverseInOrder('abc')\n  ['cab', 'cab', 'cab', 'cab']\n  */\nconst allSubstringsInOrderReverseInOrderReverseInOrderReverseInOrderReverse = (string) => {\n  let substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substring(0, currentSubstring.length - 1);\n  }\n  return substrings.sort().reverse().reverse().reverse().reverse().reverse().reverse();\n};\n\n/**\n * Returns a list of all substrings from the shortest to the longest of the input strings\n  >>> allSubstringsInOrderReverseInOrderReverseInOrderReverseInOrderReverse('abc')\n  ['cab', 'cab', 'cab', 'cab']\n  */\nconst allSubstringsInOrderReverseInOrderReverseInOrderReverseInOrderReverseInOrder = (string) => {\n  let substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substring(0, currentSubstring.length - 1);\n  }\n  return substrings.sort().reverse().reverse().reverse().reverse().reverse().reverse().reverse();\n};\n\n/**\n * Returns a list of all substrings from the shortest to the longest of the input strings\n  >>> allSubstringsInOrderReverseInOrderReverseInOrderReverseInOrderReverseInOrder('abc')\n  ['cab', 'cab', 'cab', 'cab']\n  */\nconst allSubstringsInOrderReverseInOrderReverseInOrderReverseInOrderReverseInOrderReverse = (string) => {\n  let substrings = [];\n  let currentSubstring = string;\n  while (currentSubstring.length > 0) {\n    substrings.push(currentSubstring);\n    currentSubstring = currentSubstring.substring(0, currentSubstring.length - 1);\n  }\n  return substrings.sort().reverse().reverse().reverse().reverse().reverse().reverse().reverse().reverse();\n};\n\n/**\n * Returns a list of all substrings from the shortest to the longest of the input strings\n  >>> allSubstringsInOrderReverseInOrderReverseInOrderReverseInOrderReverseInOrder('abc')\n  ['cab', 'cab', 'cab', 'cab']\n  */\nconst allSubstringsInOrderReverseInOrderReverseInOrderReverseInOrderReverseInOrderReverseInOrder = (string) => {\n  let substrings = [];\n  let ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/140", "prompt": "/*\n  For a string text, replace all spaces in it with underscores, and if a string has more than 2 consecutive spaces, replace all consecutive spaces with - fixSpaces (\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n", "canonical_solution": "  let t = ''\n  let c = 0\n  for (let i = 0; i < text.length; i++) {\n    if (text[i] == ' ') { c++ }\n    else if (c > 0) {\n      if (c == 1) { t += '_' }\n      if (c == 2) { t += '__' }\n      if (c > 2) { t += '-' }\n      t += text[i]\n      c = 0;\n    } else {\n      t += text[i]\n    }\n  }\n  if (c == 1) { t += '_' }\n  if (c == 2) { t += '__' }\n  if (c > 2) { t += '-' }\n  return t\n}\n\n", "test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Mudasir Hanif ') === 'Mudasir_Hanif_')\n  console.assert(\n    fixSpaces('Yellow Yellow  Dirty  Fellow') === 'Yellow_Yellow__Dirty__Fellow'\n  )\n  console.assert(fixSpaces('Exa   mple') === 'Exa-mple')\n  console.assert(fixSpaces('   Exa 1 2 2 mple') === '-Exa_1_2_2_mple')\n}\n\ntestFixSpaces()\n", "declaration": "\nconst fixSpaces = (text) => {\n", "example_test": "const testFixSpaces = () => {\n  console.assert(fixSpaces('Example') === 'Example')\n  console.assert(fixSpaces('Example 1') === 'Example_1')\n  console.assert(\n    fixSpaces(' Example 2') === '_Example_2'\n  )\n  console.assert(fixSpaces(' Example   3') === '_Example-3')\n}\ntestFixSpaces()\n", "entry_point": "fixSpaces", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  For a string text, replace all spaces in it with underscores, and if a string has more than 2 consecutive spaces, replace all consecutive spaces with - fixSpaces (\"Example\") == \"Example\"\n  fixSpaces(\"Example 1\") == \"Example_1\"\n  fixSpaces(\" Example 2\") == \"_Example_2\"\n  fixSpaces(\" Example   3\") == \"_Example-3\"\n  */\nconst fixSpaces = (text) => {\n  let newText = text;\n  let spaces = text.split(' ');\n  for (let i = 0; i < spaces.length; i++) {\n    if (spaces[i].length > 1) {\n      newText = newText.replace(spaces[i], \"-\");\n    } else if (spaces[i].length === 1) {\n      newText = newText.replace(spaces[i], \"_\");\n    }\n  }\n  return newText;\n};\n\nconst getRandomInt = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nconst getRandomIntFromInterval = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nconst getRandomIntFromRange = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nconst getRandomIntFromArray = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nconst getRandomIntFromArrayFromInterval = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nconst getRandomIntFromArrayFromRange = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nconst getRandomIntFromArrayFromRangeFromInterval = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nconst getRandomIntFromArrayFromRangeFromIntervalFromInterval = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nconst getRandomIntFromArrayFromRangeFromIntervalFromIntervalFromInterval = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nconst getRandomIntFromArrayFromRangeFromIntervalFromIntervalFromIntervalFromInterval = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nconst getRandomIntFromArrayFromRangeFromIntervalFromIntervalFromIntervalFromIntervalFromInterval = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nconst getRandomIntFromArrayFromRangeFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromIntervalFromInterval", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/141", "prompt": "/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n", "canonical_solution": "  let t = file_name.split(/\\./)\n  if (t.length != 2) { return 'No' }\n  if (t[1] != 'txt' && t[1] != 'dll' && t[1] != 'exe') { return 'No' }\n  if (t[0] == '') { return 'No' }\n  let a = t[0][0].charCodeAt()\n  if (!((a >= 65 && a <= 90) || (a >= 97 && a <= 122))) { return 'No' }\n  let y = 0\n  for (let i = 1; i < t[0].length; i++) {\n    if (t[0][i].charCodeAt() >= 48 && t[0][i].charCodeAt() <= 57) { y++ }\n    if (y > 3) { return 'No' }\n  }\n  return 'Yes'\n}\n\n", "test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n  console.assert(fileNameCheck('s1sdf3.asd') === 'No')\n  console.assert(fileNameCheck('K.dll') === 'Yes')\n  console.assert(fileNameCheck('MY16FILE3.exe') === 'Yes')\n  console.assert(fileNameCheck('His12FILE94.exe') === 'No')\n  console.assert(fileNameCheck('_Y.txt') === 'No')\n  console.assert(fileNameCheck('?aREYA.exe') === 'No')\n  console.assert(fileNameCheck('/this_is_valid.dll') === 'No')\n  console.assert(fileNameCheck('this_is_valid.wow') === 'No')\n  console.assert(fileNameCheck('this_is_valid.txt') === 'Yes')\n  console.assert(fileNameCheck('this_is_valid.txtexe') === 'No')\n  console.assert(fileNameCheck('#this2_i4s_5valid.ten') === 'No')\n  console.assert(fileNameCheck('@this1_is6_valid.exe') === 'No')\n  console.assert(fileNameCheck('this_is_12valid.6exe4.txt') === 'No')\n  console.assert(fileNameCheck('all.exe.txt') === 'No')\n  console.assert(fileNameCheck('I563_No.exe') === 'Yes')\n  console.assert(fileNameCheck('Is3youfault.txt') === 'Yes')\n  console.assert(fileNameCheck('no_one#knows.dll') === 'Yes')\n  console.assert(fileNameCheck('1I563_Yes3.exe') === 'No')\n  console.assert(fileNameCheck('I563_Yes3.txtt') === 'No')\n  console.assert(fileNameCheck('final..txt') === 'No')\n  console.assert(fileNameCheck('final132') === 'No')\n  console.assert(fileNameCheck('_f4indsartal132.') === 'No')\n  console.assert(fileNameCheck('.txt') === 'No')\n  console.assert(fileNameCheck('s.') === 'No')\n}\n\ntestFileNameCheck()\n", "declaration": "\nconst fileNameCheck = (file_name) => {\n", "example_test": "const testFileNameCheck = () => {\n  console.assert(fileNameCheck('example.txt') === 'Yes')\n  console.assert(fileNameCheck('1example.dll') === 'No')\n}\ntestFileNameCheck()\n", "entry_point": "fileNameCheck", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.?[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*\n  Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.?[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*\n  Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.?[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*\n  Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.?[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*\n  Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.?[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*\n  Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.?[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*\n  Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n  Examples:\n  fileNameCheck(\"example.txt\") # => 'Yes'\n  fileNameCheck(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n  */\nconst fileNameCheck = (file_name) => {\n  const re = /^[0-9]{3}\\.?[a-zA-Z]{2,}$/;\n  return re.test(file_name);\n};\n\n/*\n  Create a function which takes a string representing a file's name, and returns\n  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n  A file's name is considered to be valid if and only if all the following conditions \n  are met:\n  - There should not be more than three digits ('0'-'9') in the file's name.\n  - The file's name contains exactly one dot '.'\n  - The substring before the dot should not be empty, and it starts with a letter from \n  the latin alphapet ('a'-'z' and 'A'-'Z').\n  - The substring after the dot should be one of these: ['", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/142", "prompt": "/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n", "canonical_solution": "  let y = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 == 0) { y += lst[i] * lst[i] }\n    else if (i % 4 == 0) { y += lst[i] * lst[i] * lst[i] }\n    else { y += lst[i] }\n  }\n  return y\n}\n\n", "test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([1, 4, 9]) === 14)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([1, 1, 1, 1, 1, 1, 1, 1, 1]) === 9)\n  console.assert(sumSquares([-1, -1, -1, -1, -1, -1, -1, -1, -1]) === -3)\n  console.assert(sumSquares([0]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n  console.assert(sumSquares([-56, -99, 1, 0, -2]) === 3030)\n  console.assert(sumSquares([-1, 0, 0, 0, 0, 0, 0, 0, -1]) === 0)\n  console.assert(\n    sumSquares([\n      -16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37,\n    ]) === -14196\n  )\n  console.assert(\n    sumSquares([\n      -1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16,\n      4, 10,\n    ]) === -1448\n  )\n}\n\ntestSumSquares()\n", "declaration": "\nconst sumSquares = (lst) => {\n", "example_test": "const testSumSquares = () => {\n  console.assert(sumSquares([1, 2, 3]) === 6)\n  console.assert(sumSquares([]) === 0)\n  console.assert(sumSquares([-1, -5, 2, -1, -5]) === -126)\n}\ntestSumSquares()\n", "entry_point": "sumSquares", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*\"\n  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n  \n  Examples:\n  For lst = [1,2,3] the output should be 6\n  For lst = []  the output should be 0\n  For lst = [-1,-5,2,-1,-5]  the output should be -126\n  */\nconst sumSquares = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 3!== 0) {\n      sum += lst[i] * lst[i];\n    } else if (i % 4!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/*\n  Given a list with integers, return a new list with integers squared and cubed such that each integer in the new list is a multiple of \n  the original list's index. \n  \n  Examples:\n  Given lst = [1,2,3], the output should be [4,9,16]\n  Given lst = [], the output should be []\n  Given lst = [-1,-5,2,-1,-5]  the output should be [-1,-5,2,-1,-5]\n  */\nconst squareAndCube = (lst) => {\n  let newLst = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      newLst.push(lst[i] * lst[i]);\n    } else if (i % 3!== 0) {\n      newLst.push(lst[i] * lst[i]);\n    } else if (i % 4!== 0) {\n      newLst.push(lst[i] * lst[i]);\n    }\n  }\n  return newLst;\n};\n\n/*\n  Given a list with integers, return a new list with integers squared and cubed such that each integer in the new list is a multiple of \n  the original list's index. \n  \n  Examples:\n  Given lst = [1,2,3], the output should be [4,9,16]\n  Given lst = [], the output should be []\n  Given lst = [-1,-5,2,-1,-5]  the output should be [-1,-5,2,-1,-5]\n  */\nconst squareAndCubeAndSum = (lst) => {\n  let newLst = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      newLst.push(lst[i] * lst[i]);\n    } else if (i % 3!== 0) {\n      newLst.push(lst[i] * lst[i]);\n    } else if (i % 4!== 0) {\n      newLst.push(lst[i] * lst[i]);\n    }\n  }\n  return squareAndCube(newLst);\n};\n\n/*\n  Given a list with integers, return a new list with integers squared and cubed such that each integer in the new list is a multiple of \n  the original list's index. \n  \n  Examples:\n  Given lst = [1,2,3], the output should be [4,9,16]\n  Given lst = [], the output should be []\n  Given lst = [-1,-5,2,-1,-5]  the output should be [-1,-5,2,-1,-5]\n  */\nconst squareAndCubeAndSumAndSum = (lst) => {\n  let newLst = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      newLst.push(lst[i] * lst[i]);\n    } else if (i % 3!== 0) {\n      newLst.push(lst[i] * lst[i]);\n    } else if (i % 4!== 0) {\n      newLst.push(lst[i] * lst[i]);\n    }\n  }\n  return squareAndCubeAndSum(newLst);\n};\n\n/*\n  Given a list with integers, return a new list with integers squared and cubed such that each integer in the new list is a multiple of \n  the original list's index. \n  \n  Examples:\n  Given lst = [1,2,3], the output should be [4,9,16]\n  Given lst = [], the output should be []\n  Given lst = [-1,-5,2,-1,-5]  the output should be [-1,-5,2,-1,-5]\n  */\nconst squareAndCubeAndSumAndSumAndSum = (lst) => {\n  let newLst = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      newLst.push(lst[i] * lst[i]);\n    } else if (i % 3!== 0) {\n      newLst.push(lst[i] * lst[i]);\n    } else if (i % 4!== 0) {\n      newLst.push(lst[i] * lst[i]);\n    }\n  }\n  return squareAndCubeAndSumAndSumAndSum(newLst);\n};\n\n/*\n  Given a list with integers, return a new list with integers squared and cubed such that each integer in the new list is a multiple of \n  the original list's index. \n  \n  Examples:\n  Given lst = [1,2,3], the output should be [4,9,16]\n  Given lst = [], the output should be []\n  Given lst = [-1,-5,2,-1,-5]  the output should be [-1,-5,2,-1,-5]\n  */\nconst squareAndCubeAndSumAndSumAndSumAndSum = (lst) => {\n  let newLst = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      newLst.push(lst[i] * lst[i]);\n    } else if (i % 3!== 0) {\n      newLst.push(lst[i] * lst[i]);\n    } else if (i % 4!== 0) {\n      newLst.push(lst[i] * lst[i]);\n    }\n  }\n  return squareAndCubeAndSumAndSumAndSumAndSum(newLst);\n};\n\n/*\n  Given a list with integers, return a new list with integers squared and cubed such that each integer in the new list is a multiple of \n  the original list's index. \n  \n  Examples:\n  Given lst = [1,2,3], the output should be [4,9,16]\n  Given lst = [], the output should be []\n  Given lst = [-1,-5,2,-1,-5]  the output should be [-1,-5,2,-1,-5]\n  */\nconst squareAndCubeAndSumAndSumAndSumAndSumAndSum = (lst) => {\n  let newLst = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      newLst.push(lst[i] * lst[i]);\n    } else if (i % 3!== 0) {\n      newLst.push(lst[i] * lst[i]);\n    } else if (i % 4!== 0) {\n      newLst.push(lst[i] * lst[i]);\n    }\n  }\n  return squareAndCubeAndSumAndSumAndSumAndSumAndSumAndSum(newLst);\n};\n\n/*\n  Given a list with integers, return a new list with integers squared and cubed such that each integer in the new list is a multiple of \n  the original list's index. \n  \n  Examples:\n  Given lst = [1,2,3], the output should be [4,9,16]\n  Given lst = [], the output should be []\n  Given lst = [-1,-5,2,-1,-5]  the output should be [-1,-5,2,-1,-5]\n  */\nconst squareAndCubeAndSumAndSumAndSumAndSumAndSumAndSumAndSum = (lst) => {\n  let newLst = [];\n  for (let i = 0; i < lst.length; i++) {\n    if (i % 3 === 0 && i % 4!== 0) {\n      newLst.push(lst[i] * lst[i]);\n    } else if (i % 3!== 0) {\n      newLst.push(lst[i] * lst[i]);\n    } else if (i % 4!== 0) {\n      newLst.push(lst[i] * lst[i]);\n    }\n  }\n  return squareAndCubeAndSumAndSumAndSumAndSumAndSumAndSumAndSumAndSum(newLst);\n};\n\n/*\n  Given a list with integers, return a new list with integers squared and cubed ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/143", "prompt": "/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n", "canonical_solution": "  let t = sentence.split(/\\s/)\n  let p = ''\n  for (let j = 0; j < t.length; j++) {\n    let len = t[j].length;\n    let u = 1\n    if (len == 1 || len == 0) { continue }\n    for (let i = 2; i * i <= len; i++) {\n      if (len % i == 0) { u = 0 }\n    }\n    if (u == 0) { continue }\n    if (p == '') { p += t[j] }\n    else { p = p + ' ' + t[j] }\n  }\n  return p\n}\n\n", "test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n  console.assert(\n    wordsInSentence('there is no place available here') === 'there is no place'\n  )\n  console.assert(wordsInSentence('Hi I am Hussein') === 'Hi am Hussein')\n  console.assert(wordsInSentence('go for it') === 'go for it')\n  console.assert(wordsInSentence('here') === '')\n  console.assert(wordsInSentence('here is') === 'is')\n}\n\ntestWordsInSentence()\n", "declaration": "\nconst wordsInSentence = (sentence) => {\n", "example_test": "const testWordsInSentence = () => {\n  console.assert(wordsInSentence('This is a test') === 'is')\n  console.assert(wordsInSentence('lets go for swimming') === 'go for')\n}\ntestWordsInSentence()\n", "entry_point": "wordsInSentence", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let words = sentence.split(\" \");\n  let length = words.length;\n  let primes = [];\n  for (let i = 0; i < length; i++) {\n    if (primes.includes(words[i])) {\n      continue;\n    }\n    primes.push(words[i]);\n  }\n  return primes.join(\" \");\n};\n\n/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let words = sentence.split(\" \");\n  let length = words.length;\n  let primes = [];\n  for (let i = 0; i < length; i++) {\n    if (primes.includes(words[i])) {\n      continue;\n    }\n    primes.push(words[i]);\n  }\n  return primes.join(\" \");\n};\n\n/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let words = sentence.split(\" \");\n  let length = words.length;\n  let primes = [];\n  for (let i = 0; i < length; i++) {\n    if (primes.includes(words[i])) {\n      continue;\n    }\n    primes.push(words[i]);\n  }\n  return primes.join(\" \");\n};\n\n/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let words = sentence.split(\" \");\n  let length = words.length;\n  let primes = [];\n  for (let i = 0; i < length; i++) {\n    if (primes.includes(words[i])) {\n      continue;\n    }\n    primes.push(words[i]);\n  }\n  return primes.join(\" \");\n};\n\n/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let words = sentence.split(\" \");\n  let length = words.length;\n  let primes = [];\n  for (let i = 0; i < length; i++) {\n    if (primes.includes(words[i])) {\n      continue;\n    }\n    primes.push(words[i]);\n  }\n  return primes.join(\" \");\n};\n\n/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let words = sentence.split(\" \");\n  let length = words.length;\n  let primes = [];\n  for (let i = 0; i < length; i++) {\n    if (primes.includes(words[i])) {\n      continue;\n    }\n    primes.push(words[i]);\n  }\n  return primes.join(\" \");\n};\n\n/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let words = sentence.split(\" \");\n  let length = words.length;\n  let primes = [];\n  for (let i = 0; i < length; i++) {\n    if (primes.includes(words[i])) {\n      continue;\n    }\n    primes.push(words[i]);\n  }\n  return primes.join(\" \");\n};\n\n/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let words = sentence.split(\" \");\n  let length = words.length;\n  let primes = [];\n  for (let i = 0; i < length; i++) {\n    if (primes.includes(words[i])) {\n      continue;\n    }\n    primes.push(words[i]);\n  }\n  return primes.join(\" \");\n};\n\n/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the order of the words in the new string should be the same as the original.\n\n  Example 1:\n      Input: sentence = \"This is a test\"\n      Output: \"is\"\n\n  Example 2:\n      Input: sentence = \"lets go for swimming\"\n      Output: \"go for\"\n\n  Constraints:\n      * 1 <= len(sentence) <= 100\n      * sentence contains only letters\n  */\nconst wordsInSentence = (sentence) => {\n  let words = sentence.split(\" \");\n  let length = words.length;\n  let primes = [];\n  for (let i = 0; i < length; i++) {\n    if (primes.includes(words[i])) {\n      continue;\n    }\n    primes.push(words[i]);\n  }\n  return primes.join(\" \");\n};\n\n/*\n  You get a string that represents a sentence, the sentence contains some words separated by a space, and you have to return a string that contains the words of the original sentence, the length of which is primes, the ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/144", "prompt": "/*Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n", "canonical_solution": "  let a = x.split(/\\//)\n  let b = n.split(/\\//)\n  let m = Number(a[0]) * Number(b[0])\n  let r = Number(a[1]) * Number(b[1])\n  return m % r == 0\n}\n\n", "test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('5/1', '3/1') === true)\n  console.assert(simplify('7/10', '10/2') === false)\n  console.assert(simplify('2/10', '50/10') === true)\n  console.assert(simplify('7/2', '4/2') === true)\n  console.assert(simplify('11/6', '6/1') === true)\n  console.assert(simplify('2/3', '5/2') === false)\n  console.assert(simplify('5/2', '3/5') === false)\n  console.assert(simplify('2/4', '8/4') === true)\n  console.assert(simplify('2/4', '4/2') === true)\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/5', '1/5') === false)\n}\n\ntestSimplify()\n", "declaration": "\nconst simplify = (x, n) => {\n", "example_test": "const testSimplify = () => {\n  console.assert(simplify('1/5', '5/1') === true)\n  console.assert(simplify('1/6', '2/1') === false)\n  console.assert(simplify('7/10', '10/2') === false)\n}\ntestSimplify()\n", "entry_point": "simplify", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n};\n\n/*\n  Your task is to implement a function that will simplify the expression\n  x * n. The function returns true if x * n evaluates to a whole number and false\n  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n\n  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n\n  simplify(\"1/5\", \"5/1\") = true\n  simplify(\"1/6\", \"2/1\") = false\n  simplify(\"7/10\", \"10/2\") = false\n  */\nconst simplify = (x, n) => {\n  // Your code here\n};\n\n/*\n  Your task is to implement a function that will simplify the expression", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/145", "prompt": "/*\n  Write a function that sorts the specified list of integers in ascending order according to the sum of their digits. Note: If there are several elements with a similar sum of their digits, order them by their index in the original list. Example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n", "canonical_solution": "  let p = nums\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let m = 0\n      let n = 0\n      let h = p[k]\n      let d = p[k + 1]\n      let y = 1\n      let u = 1\n      if (h < 0) { y = -1; h = -h; }\n      if (d < 0) { u = -1; d = -d; }\n      while (h >= 10) {\n        m += h % 10;\n        h = (h - h % 10) / 10;\n      }\n      m += y * h\n      while (d >= 10) {\n        n += d % 10;\n        d = (d - d % 10) / 10;\n      }\n      n += u * d\n      if (m > n) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(\n    JSON.stringify(\n      orderByPoints([\n        1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46,\n      ])\n    ) ===\n    JSON.stringify([\n      0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457,\n    ])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(orderByPoints([1, -11, -32, 43, 54, -98, 2, -3])) ===\n    JSON.stringify([-3, -32, -98, -11, 1, 2, 43, 54])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])) ===\n    JSON.stringify([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])\n  )\n  console.assert(\n    JSON.stringify(orderByPoints([0, 6, 6, -76, -21, 23, 4])) ===\n    JSON.stringify([-76, -21, 0, 4, 23, 6, 6])\n  )\n}\n\ntestOrderByPoints()\n", "declaration": "\nconst orderByPoints = (nums) => {\n", "example_test": "const testOrderByPoints = () => {\n  console.assert(\n    JSON.stringify(orderByPoints([1, 11, -1, -11, -12])) ===\n    JSON.stringify([-1, -11, 1, -12, 11])\n  )\n  console.assert(JSON.stringify(orderByPoints([])) === JSON.stringify([]))\n}\ntestOrderByPoints()\n", "entry_point": "orderByPoints", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that sorts the specified list of integers in ascending order according to the sum of their digits. Note: If there are several elements with a similar sum of their digits, order them by their index in the original list. Example:\n  >>> orderByPoints([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n  >>> orderByPoints([]) == []\n  */\nconst orderByPoints = (nums) => {\n  const sums = nums.reduce((acc, num) => acc + num, 0);\n  return nums.sort((a, b) => a - b).map(num => num * Math.pow(10, sums / 10));\n};\n\n/*\n  Write a function that returns the sum of the digits of a specified string. Note: If the string contains only digits, return 0. If the string contains letters, return 0. If the string contains more than one character, return 0. If the string contains no characters, return 0.\n  >>> sumOfDigits(\"123\") == 3\n  >>> sumOfDigits(\"abc\") == 3\n  >>> sumOfDigits(\"ab\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n  >>> sumOfDigits(\"a\") == 3\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/146", "prompt": "/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] < 10) { continue }\n    let y = nums[i].toString()\n    if (Number(y[0]) % 2 == 1 && Number(y[y.length - 1]) % 2 == 1) {\n      p++\n    }\n  }\n  return p\n}\n\n", "test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([5, -2, 1, -5]) === 0)\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n  console.assert(specialFilter([43, -12, 93, 125, 121, 109]) === 4)\n  console.assert(specialFilter([71, -2, -33, 75, 21, 19]) === 3)\n  console.assert(specialFilter([1]) === 0)\n  console.assert(specialFilter([]) === 0)\n}\n\ntestSpecialFilter()\n", "declaration": "\nconst specialFilter = (nums) => {\n", "example_test": "const testSpecialFilter = () => {\n  console.assert(specialFilter([15, -73, 14, -15]) === 1)\n  console.assert(specialFilter([33, -2, -3, 45, 21, 109]) === 2)\n}\ntestSpecialFilter()\n", "entry_point": "specialFilter", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let lastDigit = 0;\n  let firstDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1) {\n      if (nums[i] >= 10) {\n        if (nums[i] % 2 === 1) {\n          firstDigit = nums[i];\n        }\n        lastDigit = nums[i];\n      }\n    }\n  }\n  return count + firstDigit + lastDigit;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number even (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let lastDigit = 0;\n  let firstDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1) {\n      if (nums[i] >= 10) {\n        if (nums[i] % 2 === 1) {\n          firstDigit = nums[i];\n        }\n        lastDigit = nums[i];\n      }\n    }\n  }\n  return count + firstDigit + lastDigit;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let lastDigit = 0;\n  let firstDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1) {\n      if (nums[i] >= 10) {\n        if (nums[i] % 2 === 1) {\n          firstDigit = nums[i];\n        }\n        lastDigit = nums[i];\n      }\n    }\n  }\n  return count + firstDigit + lastDigit;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number even (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let lastDigit = 0;\n  let firstDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1) {\n      if (nums[i] >= 10) {\n        if (nums[i] % 2 === 1) {\n          firstDigit = nums[i];\n        }\n        lastDigit = nums[i];\n      }\n    }\n  }\n  return count + firstDigit + lastDigit;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let lastDigit = 0;\n  let firstDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1) {\n      if (nums[i] >= 10) {\n        if (nums[i] % 2 === 1) {\n          firstDigit = nums[i];\n        }\n        lastDigit = nums[i];\n      }\n    }\n  }\n  return count + firstDigit + lastDigit;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number even (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let lastDigit = 0;\n  let firstDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1) {\n      if (nums[i] >= 10) {\n        if (nums[i] % 2 === 1) {\n          firstDigit = nums[i];\n        }\n        lastDigit = nums[i];\n      }\n    }\n  }\n  return count + firstDigit + lastDigit;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let lastDigit = 0;\n  let firstDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1) {\n      if (nums[i] >= 10) {\n        if (nums[i] % 2 === 1) {\n          firstDigit = nums[i];\n        }\n        lastDigit = nums[i];\n      }\n    }\n  }\n  return count + firstDigit + lastDigit;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number even (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let lastDigit = 0;\n  let firstDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1) {\n      if (nums[i] >= 10) {\n        if (nums[i] % 2 === 1) {\n          firstDigit = nums[i];\n        }\n        lastDigit = nums[i];\n      }\n    }\n  }\n  return count + firstDigit + lastDigit;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number odd (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let lastDigit = 0;\n  let firstDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1) {\n      if (nums[i] >= 10) {\n        if (nums[i] % 2 === 1) {\n          firstDigit = nums[i];\n        }\n        lastDigit = nums[i];\n      }\n    }\n  }\n  return count + firstDigit + lastDigit;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a number even (1, 3, 5, 7, 9).\n  For example:\n  specialFilter([15, -73, 14, -15]) => 1 \n  specialFilter([33, -2, -3, 45, 21, 109]) => 2\n  */\nconst specialFilter = (nums) => {\n  let count = 0;\n  let lastDigit = 0;\n  let firstDigit = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] % 2 === 1) {\n      if (nums[i] >= 10) {\n        if (nums[i] % 2 === 1) {\n          firstDigit = nums[i];\n        }\n        lastDigit = nums[i];\n      }\n    }\n  }\n  return count + firstDigit + lastDigit;\n};\n\n/*Write is a function that takes a number array as input and returns the number of elements in the array that are greater than 10 and are both the first and last digits of a ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/147", "prompt": "/*\n  For each i (1  i  n) the value of a [i] = i * i - i + 1 is given. You give the number of triples (a [i], a [j], a [k]) from a where i < j < k and a [i] + a [j] + a [k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n", "canonical_solution": "  let y = []\n  for (let i = 1; i <= n; i++) {\n    y.push(i * i - i + 1)\n  }\n  let u = 0\n  for (let i = 0; i < n - 2; i++) {\n    for (let j = i + 1; j < n - 1; j++) {\n      for (let k = j + 1; k < n; k++) {\n        if ((y[i] + y[j] + y[k]) % 3 == 0) { u++ }\n      }\n    }\n  }\n  return u\n}\n\n", "test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n  console.assert(getMaxTriples(6) === 4)\n  console.assert(getMaxTriples(10) === 36)\n  console.assert(getMaxTriples(100) === 53361)\n}\n\ntestGetMaxTriples()\n", "declaration": "\nconst getMaxTriples = (n) => {\n", "example_test": "const testGetMaxTriples = () => {\n  console.assert(getMaxTriples(5) === 1)\n}\ntestGetMaxTriples()\n", "entry_point": "getMaxTriples", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  For each i (1  i  n) the value of a [i] = i * i - i + 1 is given. You give the number of triples (a [i], a [j], a [k]) from a where i < j < k and a [i] + a [j] + a [k] is a multiple of 3.\n\n  Example :\n      Input: n = 5\n      Output: 1\n      Explanation: \n      a = [1, 3, 7, 13, 21]\n      The only valid triple is (1, 7, 13).\n  */\nconst getMaxTriples = (n) => {\n  const triples = [];\n  let max = 0;\n  for (let i = 1; i <= n; i++) {\n    for (let j = i; j <= n; j++) {\n      for (let k = j; k <= n; k++) {\n        if (triples.includes([i, j, k])) {\n          triples.splice(triples.indexOf([i, j, k]), 1);\n        } else {\n          triples.push([i, j, k]);\n        }\n      }\n    }\n  }\n  return triples.reduce((a, b) => Math.max(a, b), max);\n};\n\n/*\n  Given an array of integers nums, return true if and only if all elements are unique.\n\n  Example :\n      Input: nums = [1, 2, 3, 1]\n      Output: true\n      Explanation: \n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      nums = [1, 2, 3, 1]\n      ", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/148", "prompt": "/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n", "canonical_solution": "  let y = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune']\n  let u = []\n  let lo = -1\n  let hi = -1\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet1) { lo = i }\n  }\n  for (let i = 0; i < 8; i++) {\n    if (y[i] == planet2) { hi = i }\n  }\n  if (lo == -1 || hi == -1 || lo == hi) { return [] }\n  if (lo > hi) {\n    let tmp = lo;\n    lo = hi;\n    hi = tmp;\n  }\n  for (let i = lo + 1; i < hi; i++) {\n    u.push(y[i])\n  }\n  return u\n}\n\n", "test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n  console.assert(\n    JSON.stringify(bf('Neptune', 'Venus')) ===\n    JSON.stringify(['Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'])\n  )\n  console.assert(JSON.stringify(bf('Earth', 'Earth')) === JSON.stringify([]))\n  console.assert(JSON.stringify(bf('Mars', 'Earth')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Makemake')) === JSON.stringify([])\n  )\n}\n\ntestBf()\n", "declaration": "\nconst bf = (planet1, planet2) => {\n", "example_test": "const testBf = () => {\n  console.assert(\n    JSON.stringify(bf('Jupiter', 'Neptune')) ===\n    JSON.stringify(['Saturn', 'Uranus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Earth', 'Mercury')) === JSON.stringify(['Venus'])\n  )\n  console.assert(\n    JSON.stringify(bf('Mercury', 'Uranus')) ===\n    JSON.stringify(['Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'])\n  )\n}\ntestBf()\n", "entry_point": "bf", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/* There are eight planets in our solar system: the closerst to the Sun\n  is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\n  Uranus, Neptune.\n  Write a function that takes two planet names as strings planet1 and planet2.\n  The function should return a tuple containing all planets whose orbits are\n  located between the orbit of planet1 and the orbit of planet2, sorted by\n  the proximity to the sun.\n  The function should return an empty tuple if planet1 or planet2\n  are not correct planet names.\n  Examples\n  bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n  bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n  bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n  */\nconst bf = (planet1, planet2) => {\n  let orbit1 = planet1.toUpperCase();\n  let orbit2 = planet2.toUpperCase();\n  let orbit1Orbit = orbit1.toUpperCase();\n  let orbit2Orbit = orbit2.toUpperCase();\n  let orbit1Orbit1 = orbit1Orbit.split(\"\");\n  let orbit2Orbit1 = orbit2Orbit.split(\"\");\n  let orbit1Orbit2 = orbit1Orbit1.concat(orbit2Orbit1);\n  let orbit2Orbit2 = orbit2Orbit1.concat(orbit1Orbit2);\n  let orbit1Orbit3 = orbit1Orbit2.concat(orbit2Orbit2);\n  let orbit2Orbit3 = orbit2Orbit2.concat(orbit1Orbit3);\n  let orbit1Orbit4 = orbit1Orbit3.concat(orbit2Orbit3);\n  let orbit2Orbit4 = orbit2Orbit3.concat(orbit1Orbit4);\n  let orbit1Orbit5 = orbit1Orbit4.concat(orbit2Orbit4);\n  let orbit2Orbit5 = orbit2Orbit4.concat(orbit1Orbit5);\n  let orbit1Orbit6 = orbit1Orbit5.concat(orbit2Orbit5);\n  let orbit2Orbit6 = orbit2Orbit5.concat(orbit1Orbit6);\n  let orbit1Orbit7 = orbit1Orbit6.concat(orbit2Orbit6);\n  let orbit2Orbit7 = orbit2Orbit6.concat(orbit1Orbit7);\n  let orbit1Orbit8 = orbit1Orbit7.concat(orbit2Orbit7);\n  let orbit2Orbit8 = orbit2Orbit7.concat(orbit1Orbit8);\n  let orbit1Orbit9 = orbit1Orbit8.concat(orbit2Orbit8);\n  let orbit2Orbit9 = orbit2Orbit8.concat(orbit1Orbit9);\n  let orbit1Orbit10 = orbit1Orbit9.concat(orbit2Orbit9);\n  let orbit2Orbit10 = orbit2Orbit9.concat(orbit1Orbit10);\n  let orbit1Orbit11 = orbit1Orbit10.concat(orbit2Orbit10);\n  let orbit2Orbit11 = orbit2Orbit10.concat(orbit1Orbit11);\n  let orbit1Orbit12 = orbit1Orbit11.concat(orbit2Orbit11);\n  let orbit2Orbit12 = orbit2Orbit11.concat(orbit1Orbit12);\n  let orbit1Orbit13 = orbit1Orbit12.concat(orbit2Orbit12);\n  let orbit2Orbit13 = orbit2Orbit12.concat(orbit1Orbit13);\n  let orbit1Orbit14 = orbit1Orbit13.concat(orbit2Orbit13);\n  let orbit2Orbit14 = orbit2Orbit13.concat(orbit1Orbit14);\n  let orbit1Orbit15 = orbit1Orbit14.concat(orbit2Orbit14);\n  let orbit2Orbit15 = orbit2Orbit14.concat(orbit1Orbit15);\n  let orbit1Orbit16 = orbit1Orbit15.concat(orbit2Orbit15);\n  let orbit2Orbit16 = orbit2Orbit15.concat(orbit1Orbit16);\n  let orbit1Orbit17 = orbit1Orbit16.concat(orbit2Orbit16);\n  let orbit2Orbit17 = orbit2Orbit16.concat(orbit1Orbit17);\n  let orbit1Orbit18 = orbit1Orbit17.concat(orbit2Orbit17);\n  let orbit2Orbit18 = orbit2Orbit17.concat(orbit1Orbit18);\n  let orbit1Orbit19 = orbit1Orbit18.concat(orbit2Orbit18);\n  let orbit2Orbit19 = orbit2Orbit18.concat(orbit1Orbit19);\n  let orbit1Orbit20 = orbit1Orbit19.concat(orbit2Orbit19);\n  let orbit2Orbit20 = orbit2Orbit19.concat(orbit1Orbit20);\n  let orbit1Orbit21 = orbit1Orbit20.concat(orbit2Orbit20);\n  let orbit2Orbit21 = orbit2Orbit20.concat(orbit1Orbit21);\n  let orbit1Orbit22 = orbit1Orbit21.concat(orbit2Orbit21);\n  let orbit2Orbit22 = orbit2Orbit21.concat(orbit1Orbit22);\n  let orbit1Orbit23 = orbit1Orbit22.concat(orbit2Orbit22);\n  let orbit2Orbit23 = orbit2Orbit22.concat(orbit1Orbit23);\n  let orbit1Orbit24 = orbit1Orbit23.concat(orbit2Orbit23);\n  let orbit2Orbit24 = orbit2Orbit23.concat(orbit1Orbit24);\n  let orbit1Orbit25 = orbit1Orbit24.concat(orbit2Orbit24);\n  let orbit2Orbit25 = orbit2Orbit24.concat(orbit1Orbit25);\n  let orbit1Orbit26 = orbit1Orbit25.concat(orbit2Orbit25);\n  let orbit2Orbit26 = orbit2Orbit25.concat(orbit1Orbit26);\n  let orbit1Orbit27 = orbit1Orbit26.concat(orbit2Orbit26);\n  let orbit2Orbit27 = orbit2Orbit26.concat(orbit1Orbit27);\n  let orbit1Orbit28 = orbit1Orbit27.concat(orbit2Orbit27);\n  let orbit2Orbit28 = orbit2Orbit27.concat(orbit1Orbit28);\n  let orbit1Orbit29 = orbit1Orbit28.concat(orbit2Orbit28);\n  let orbit2Orbit29 = orbit2Orbit28.concat(orbit1Orbit29);\n  let orbit1Orbit30 = orbit1Orbit29.concat(orbit2Orbit29);\n  let orbit2Orbit30 = orbit2Orbit29.concat(orbit1Orbit30);\n  let orbit1Orbit31 = orbit1Orbit30.concat(orbit2Orbit30);\n  let orbit2Orbit31 = orbit2Orbit30.concat(orbit1Orbit31);\n  let orbit1Orbit32 = orbit1Orbit31.concat(orbit2Orbit31);\n  let orbit2Orbit32 = orbit2Orbit31.concat(orbit1Orbit32);\n  let orbit1Orbit33 = orbit1Orbit32.concat(orbit2Orbit32);\n  let orbit2Orbit33 = orbit2Orbit32.concat(orbit1Orbit33);\n  let orbit1Orbit34 = orbit1Orbit33.concat(orbit2Orbit33);\n  let orbit2Orbit34 = orbit2Or", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/149", "prompt": "/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n", "canonical_solution": "  let p = []\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 == 0) {\n      p.push(lst[i])\n    }\n  }\n  for (let j = p.length - 2; j >= 0; j--) {\n    for (let k = 0; k <= j; k++) {\n      let f = 0\n      if (p[k].length > p[k + 1].length) { f = 1 }\n      if (p[k].length == p[k + 1].length) {\n        let r = p[k].length\n        for (let l = 0; l < r; l++) {\n          if (p[k][l].charCodeAt() > p[k + 1][l].charCodeAt()) {\n            f = 1;\n            break;\n          }\n          if (p[k][l].charCodeAt() < p[k + 1][l].charCodeAt()) {\n            break;\n          }\n        }\n      }\n      if (f == 1) {\n        let tmp = p[k]\n        p[k] = p[k + 1]\n        p[k + 1] = tmp\n      }\n    }\n  }\n  return p\n}\n\n", "test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['school', 'AI', 'asdf', 'b'])) ===\n    JSON.stringify(['AI', 'asdf', 'school'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'b', 'c', 'a'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['d', 'dcba', 'abcd', 'a'])) ===\n    JSON.stringify(['abcd', 'dcba'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['AI', 'ai', 'au'])) ===\n    JSON.stringify(['AI', 'ai', 'au'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['a', 'b', 'b', 'c', 'c', 'a'])) ===\n    JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['aaaa', 'bbbb', 'dd', 'cc'])) ===\n    JSON.stringify(['cc', 'dd', 'aaaa', 'bbbb'])\n  )\n}\n\ntestSortedListSum()\n", "declaration": "\nconst sortedListSum = (lst) => {\n", "example_test": "const testSortedListSum = () => {\n  console.assert(\n    JSON.stringify(sortedListSum(['aa', 'a', 'aaa'])) === JSON.stringify(['aa'])\n  )\n  console.assert(\n    JSON.stringify(sortedListSum(['ab', 'a', 'aaa', 'cd'])) ===\n    JSON.stringify(['ab', 'cd'])\n  )\n}\ntestSortedListSum()\n", "entry_point": "sortedListSum", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Write a function that accepts a list of strings as a parameter,\n  deletes the strings that have odd lengths from it,\n  and returns the resulted list with a sorted order,\n  The list is always a list of strings and never an array of numbers,\n  and it may contain duplicates.\n  The order of the list should be ascending by length of each word, and you\n  should return the list sorted by that rule.\n  If two words have the same length, sort the list alphabetically.\n  The function should return a list of strings in sorted order.\n  You may assume that all words will have the same length.\n  For example:\n  assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n  assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n  */\nconst sortedListSum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i].length % 2 === 1) {\n      sum += lst[i].length;\n    } else {\n      sum += lst[i].length;\n    }\n  }\n  return lst.sort((a, b) => a - b).filter(\n    x => x % 2 === 1 && x < sum\n  );\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the number of characters in that string.\n  You may assume that the string will contain only lowercase letters.\n  For example:\n  assert count_chars(\"ab\") == 2\n  assert count_chars(\"abc\") == 1\n  assert count_chars(\"a\") == 1\n  assert count_chars(\"a\") == 0\n*/\nconst count_chars = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] >= 'a' && str[i] <= 'z') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the number of uppercase letters in that string.\n  You may assume that the string will contain only uppercase letters.\n  For example:\n  assert count_uppers(\"AB\") == 2\n  assert count_uppers(\"ABC\") == 1\n  assert count_uppers(\"a\") == 1\n  assert count_uppers(\"a\") == 0\n*/\nconst count_uppers = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] >= 'A' && str[i] <= 'Z') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the number of lowercase letters in that string.\n  You may assume that the string will contain only lowercase letters.\n  For example:\n  assert count_lowers(\"a\") == 1\n  assert count_lowers(\"A\") == 0\n  assert count_lowers(\"a\") == 0\n*/\nconst count_lowers = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] >= 'a' && str[i] <= 'z') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the number of digits in that string.\n  You may assume that the string will contain only digits.\n  For example:\n  assert count_digits(\"123\") == 1\n  assert count_digits(\"12a\") == 1\n  assert count_digits(\"a\") == 1\n  assert count_digits(\"a\") == 0\n*/\nconst count_digits = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] >= '0' && str[i] <= '9') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the number of spaces in that string.\n  You may assume that the string will contain only spaces.\n  For example:\n  assert count_spaces(\" abc \") == 2\n  assert count_spaces(\" abc \") == 1\n  assert count_spaces(\"  \") == 1\n  assert count_spaces(\"  \") == 0\n*/\nconst count_spaces = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the number of words in that string.\n  You may assume that the string will contain only words.\n  For example:\n  assert count_words(\"a b c d e f\") == 3\n  assert count_words(\"a b c d e f\") == 2\n  assert count_words(\"a b c d e f\") == 1\n  assert count_words(\"a b c d e f\") == 0\n*/\nconst count_words = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='' || str[i] === '\\t') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the number of lines in that string.\n  You may assume that the string will contain only lines.\n  For example:\n  assert count_lines(\"a b c d e f\") == 3\n  assert count_lines(\"a b c d e f\") == 2\n  assert count_lines(\"a b c d e f\") == 1\n  assert count_lines(\"a b c d e f\") == 0\n*/\nconst count_lines = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '\\n') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the number of spaces and words in that string.\n  You may assume that the string will contain only spaces and words.\n  For example:\n  assert count_spaces_and_words(\" abc \") == 2\n  assert count_spaces_and_words(\" abc \") == 1\n  assert count_spaces_and_words(\"  \") == 1\n  assert count_spaces_and_words(\"  \") == 0\n*/\nconst count_spaces_and_words = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] ==='' || str[i] === '\\t') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the number of spaces and lines in that string.\n  You may assume that the string will contain only spaces and lines.\n  For example:\n  assert count_spaces_and_lines(\" abc \") == 2\n  assert count_spaces_and_lines(\" abc \") == 1\n  assert count_spaces_and_lines(\"  \") == 1\n  assert count_spaces_and_lines(\"  \") == 0\n*/\nconst count_spaces_and_lines = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '\\n') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the number of characters in that string.\n  You may assume that the string will contain only lowercase letters.\n  For example:\n  assert count_chars_and_uppers(\"ab\") == 2\n  assert count_chars_and_uppers(\"abc\") == 1\n  assert count_chars_and_uppers(\"a\") == 1\n  assert count_chars_and_uppers(\"a\") == 0\n*/\nconst count_chars_and_uppers = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] >= 'a' && str[i] <= 'z') {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  Write a function that accepts a string as a parameter,\n  and returns the number of uppercase letters in that string.\n  You may assume that the string will contain only uppercase letters.\n  For example:\n  assert count_chars_and_uppers(\"AB\") == 2\n  assert count_chars_and_uppers(\"ABC\") == 1\n  assert count_chars_and_uppers(\"a\") == 1\n  assert count_chars_and_uppers(\"a\") == 0\n*/\nconst count_chars_and_lowers = (str) => {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] >= 'A", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/15", "prompt": "/* Returns a string containing spaces from 0 to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n", "canonical_solution": "  return [...Array(n).keys(), n].join(' ')\n}\n\n", "test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(3) === '0 1 2 3')\n  console.assert(stringSequence(10) === '0 1 2 3 4 5 6 7 8 9 10')\n}\n\ntestStringSequence()\n", "declaration": "\nconst stringSequence = (n) => {\n", "example_test": "const testStringSequence = () => {\n  console.assert(stringSequence(0) === '0')\n  console.assert(stringSequence(5) === '0 1 2 3 4 5')\n}\ntestStringSequence()\n", "entry_point": "stringSequence", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Returns a string containing spaces from 0 to n inclusive.\n  >>> stringSequence(0)\n  '0'\n  >>> stringSequence(5)\n  '0 1 2 3 4 5'\n  */\nconst stringSequence = (n) => {\n  let s = '';\n  for (let i = 0; i < n; i++) {\n    s +='';\n  }\n  return s;\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n * If n is 0, returns an empty string.\n * If n is greater than the length of the string, returns an empty string.\n * If n is less than 0, returns an empty string.\n */\nconst stringSequenceFrom = (n, start) => {\n  if (n === 0) {\n    return '';\n  }\n  if (n >= 0 && n <= stringLength(start)) {\n    return stringSequence(n);\n  }\n  return '';\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n * If n is 0, returns an empty string.\n * If n is greater than the length of the string, returns an empty string.\n * If n is less than 0, returns an empty string.\n */\nconst stringSequenceFromEnd = (start, n) => {\n  if (n === 0) {\n    return '';\n  }\n  if (n >= 0 && n <= stringLength(start)) {\n    return stringSequence(n);\n  }\n  return '';\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n * If n is 0, returns an empty string.\n * If n is greater than the length of the string, returns an empty string.\n * If n is less than 0, returns an empty string.\n */\nconst stringSequenceFromStart = (n, start) => {\n  if (n === 0) {\n    return '';\n  }\n  if (n >= 0 && n <= stringLength(start)) {\n    return stringSequence(n);\n  }\n  return '';\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n * If n is 0, returns an empty string.\n * If n is greater than the length of the string, returns an empty string.\n * If n is less than 0, returns an empty string.\n */\nconst stringSequenceFromStartEnd = (start, n, end) => {\n  if (n === 0) {\n    return '';\n  }\n  if (n >= 0 && n <= stringLength(start)) {\n    return stringSequence(n);\n  }\n  return '';\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n * If n is 0, returns an empty string.\n * If n is greater than the length of the string, returns an empty string.\n * If n is less than 0, returns an empty string.\n */\nconst stringSequenceFromStartEndEnd = (start, n, end, endEnd) => {\n  if (n === 0) {\n    return '';\n  }\n  if (n >= 0 && n <= stringLength(start)) {\n    return stringSequence(n);\n  }\n  return '';\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n * If n is 0, returns an empty string.\n * If n is greater than the length of the string, returns an empty string.\n * If n is less than 0, returns an empty string.\n */\nconst stringSequenceFromStartEndEndEnd = (start, n, end, endEnd, endEndEnd) => {\n  if (n === 0) {\n    return '';\n  }\n  if (n >= 0 && n <= stringLength(start)) {\n    return stringSequence(n);\n  }\n  return '';\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n * If n is 0, returns an empty string.\n * If n is greater than the length of the string, returns an empty string.\n * If n is less than 0, returns an empty string.\n */\nconst stringSequenceFromStartEndEndEndEnd = (start, n, end, endEnd, endEndEnd, endEndEndEndEnd) => {\n  if (n === 0) {\n    return '';\n  }\n  if (n >= 0 && n <= stringLength(start)) {\n    return stringSequence(n);\n  }\n  return '';\n};\n\n/**\n * Returns a string containing spaces from 0 to n inclusive.\n * If n is 0, returns an empty string.\n * If n is greater than the length of the string, returns an empty string.\n * If n is less than 0, returns an empty string.\n */\nconst stringSequenceFromStartEndEndEndEndEnd = (start, n, end, endEnd, endEndEnd, endEndEndEndEnd, endEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/150", "prompt": "/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n", "canonical_solution": "  let len = n\n  if (len == 1 || len == 0) { return y }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return y }\n  }\n  return x\n}\n\n", "test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n  console.assert(xOrY(3, 33, 5212) === 33)\n  console.assert(xOrY(1259, 3, 52) === 3)\n  console.assert(xOrY(7919, -1, 12) === -1)\n  console.assert(xOrY(3609, 1245, 583) === 583)\n  console.assert(xOrY(91, 56, 129) === 129)\n  console.assert(xOrY(6, 34, 1234) === 1234)\n  console.assert(xOrY(1, 2, 0) === 0)\n  console.assert(xOrY(2, 2, 0) === 2)\n}\n\ntestXOrY()\n", "declaration": "\nconst xOrY = (n, x, y) => {\n", "example_test": "const testXOrY = () => {\n  console.assert(xOrY(7, 34, 12) === 34)\n  console.assert(xOrY(15, 8, 5) === 5)\n}\ntestXOrY()\n", "entry_point": "xOrY", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*A simple program that should return the value of x if n is a prime and should return the value of y otherwise.\n\n  Examples:\n  for xOrY(7, 34, 12) == 34\n  for xOrY(15, 8, 5) == 5\n  \n  */\nconst xOrY = (n, x, y) => {\n  if (n < 1 || n > 100) {\n    throw new Error('n must be between 1 and 100');\n  }\n  if (x === 0 || y === 0) {\n    throw new Error('x and y must be non-zero');\n  }\n  if (n % 2 === 0) {\n    throw new Error('n must be odd');\n  }\n  if (n % 3 === 0) {\n    throw new Error('n must be even');\n  }\n  if (n % 5 === 0) {\n    throw new Error('n must be divisible by 5');\n  }\n  if (n % 7 === 0) {\n    throw new Error('n must be divisible by 7');\n  }\n  if (n % 11 === 0) {\n    throw new Error('n must be divisible by 11');\n  }\n  if (n % 13 === 0) {\n    throw new Error('n must be divisible by 13');\n  }\n  if (n % 17 === 0) {\n    throw new Error('n must be divisible by 17');\n  }\n  if (n % 19 === 0) {\n    throw new Error('n must be divisible by 19');\n  }\n  if (n % 23 === 0) {\n    throw new Error('n must be divisible by 23');\n  }\n  if (n % 29 === 0) {\n    throw new Error('n must be divisible by 29');\n  }\n  if (n % 31 === 0) {\n    throw new Error('n must be divisible by 31');\n  }\n  if (n % 37 === 0) {\n    throw new Error('n must be divisible by 37');\n  }\n  if (n % 41 === 0) {\n    throw new Error('n must be divisible by 41');\n  }\n  if (n % 43 === 0) {\n    throw new Error('n must be divisible by 43');\n  }\n  if (n % 47 === 0) {\n    throw new Error('n must be divisible by 47');\n  }\n  if (n % 51 === 0) {\n    throw new Error('n must be divisible by 51');\n  }\n  if (n % 57 === 0) {\n    throw new Error('n must be divisible by 57');\n  }\n  if (n % 59 === 0) {\n    throw new Error('n must be divisible by 59');\n  }\n  if (n % 61 === 0) {\n    throw new Error('n must be divisible by 61');\n  }\n  if (n % 67 === 0) {\n    throw new Error('n must be divisible by 67');\n  }\n  if (n % 71 === 0) {\n    throw new Error('n must be divisible by 71');\n  }\n  if (n % 73 === 0) {\n    throw new Error('n must be divisible by 73');\n  }\n  if (n % 79 === 0) {\n    throw new Error('n must be divisible by 79');\n  }\n  if (n % 81 === 0) {\n    throw new Error('n must be divisible by 81');\n  }\n  if (n % 87 === 0) {\n    throw new Error('n must be divisible by 87');\n  }\n  if (n % 91 === 0) {\n    throw new Error('n must be divisible by 91');\n  }\n  if (n % 93 === 0) {\n    throw new Error('n must be divisible by 93');\n  }\n  if (n % 97 === 0) {\n    throw new Error('n must be divisible by 97');\n  }\n  if (n % 99 === 0) {\n    throw new Error('n must be divisible by 99');\n  }\n  if (n % 101 === 0) {\n    throw new Error('n must be divisible by 101');\n  }\n  if (n % 103 === 0) {\n    throw new Error('n must be divisible by 103');\n  }\n  if (n % 107 === 0) {\n    throw new Error('n must be divisible by 107');\n  }\n  if (n % 109 === 0) {\n    throw new Error('n must be divisible by 109');\n  }\n  if (n % 111 === 0) {\n    throw new Error('n must be divisible by 111');\n  }\n  if (n % 113 === 0) {\n    throw new Error('n must be divisible by 113');\n  }\n  if (n % 115 === 0) {\n    throw new Error('n must be divisible by 115');\n  }\n  if (n % 121 === 0) {\n    throw new Error('n must be divisible by 121');\n  }\n  if (n % 123 === 0) {\n    throw new Error('n must be divisible by 123');\n  }\n  if (n % 125 === 0) {\n    throw new Error('n must be divisible by 125');\n  }\n  if (n % 129 === 0) {\n    throw new Error('n must be divisible by 129');\n  }\n  if (n % 131 === 0) {\n    throw new Error('n must be divisible by 131');\n  }\n  if (n % 133 === 0) {\n    throw new Error('n must be divisible by 133');\n  }\n  if (n % 135 === 0) {\n    throw new Error('n must be divisible by 135');\n  }\n  if (n % 137 === 0) {\n    throw new Error('n must be divisible by 137');\n  }\n  if (n % 139 === 0) {\n    throw new Error('n must be divisible by 139');\n  }\n  if (n % 141 === 0) {\n    throw new Error('n must be divisible by 141');\n  }\n  if (n % 143 === 0) {\n    throw new Error('n must be divisible by 143');\n  }\n  if (n % 145 === 0) {\n    throw new Error('n must be divisible by 145');\n  }\n  if (n % 147 === 0) {\n    throw new Error('n must be divisible by 147');\n  }\n  if (n % 149 === 0) {\n    throw new Error('n must be divisible by 149');\n  }\n  if (n % 151 === 0) {\n    throw new Error('n must be divisible by 151');\n  }\n  if (n % 153 === 0) {\n    throw new Error('n must be divisible by 153');\n  }\n  if (n % 155 === 0) {\n    throw new Error('n must be divisible by 155');\n  }\n  if (n % 157 === 0) {\n    throw new Error('n must be divisible by 157');\n  }\n  if (n % 159 === 0) {\n    throw new Error('n must be divisible by 159');\n  }\n  if (n % 161 === 0) {\n    throw new Error('n must be divisible by 161');\n  }\n  if (n % 163 === 0) {\n    throw new Error('n must be divisible by 163');\n  }\n  if (n % 165 === 0) {\n    throw new Error('n must be divisible by 165');\n  }\n  if (n % 167 === 0) {\n    throw new Error('n must be divisible by 167');\n  }\n  if (n % 169 === 0) {\n    throw new Error('n must be divisible by 169');\n  }\n  if (n % 171 === 0) {\n    throw new Error('n must be divisible by 171');\n  }\n  if (n % 173 === 0) {\n    throw new Error('n must be divisible by 173');\n  }\n  if (n % 175 === 0) {\n    throw new Error('n must be divisible by 175');\n  }\n  if (n % 177 === 0) {\n    throw new Error('n must be divisible by 177');\n  }\n  if (n % 179 === 0) {\n    throw new Error('n must be divisible by 179');\n  }\n  if (n % 181 === 0) {\n    throw new Error('n must be divisible by 181');\n  }\n  if (n % 183 === 0) {\n    throw new Error('n must be divisible by 183');\n  }\n  if (n % 185 === 0) {\n    throw new Error('n must be divisible by 185');\n  }\n  if (n % 187 === 0) {\n    throw new Error('n must be divisible by 187');\n  }\n  if (n % 189 === 0) {\n    throw new Error('n must be divisible by 189');\n  }\n  if (n % 191 === 0) {\n    throw new Error('n must be divisible by 191');\n  }\n  if (n % 193 === 0) {\n    throw new Error('n must be divisible by 193');\n  }\n  if (n % 195 === 0) {\n    throw new Error('n must be divisible by 195');\n  }\n  if (n % 197 === 0) {\n    throw new Error('n must be divisible by 197');\n  }\n  if (n % 199 === 0) {\n    throw new Error('n must be divisible by 199');\n  }\n  if (n % 201 === 0) {\n    throw new Error('n must be divisible by 201');\n  }\n  if (n % 203 === 0) {\n    throw new Error('n must be divisible by 203');\n  }\n  if (n % 205 === 0) {\n    throw new Error('n must be divisible by 205');\n  }\n  if (n % 207 === 0) {\n    throw new Error('n must be divisible by 207');\n  }\n  if (n % 209 === 0) {\n    throw new Error('n must be divisible by 209');\n  }\n  if (n % 211 === 0) {\n    throw new Error('n must be divisible by 211');\n  }\n  if (n % 213 === 0) {\n    throw new Error('n must be divisible by 213');\n  }\n  if (n % 215 === 0) {\n    throw new Error('n must be divisible by 215');\n  }\n  if (n % ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/151", "prompt": "/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 == 1 && lst[i] > 0) {\n      p += lst[i] * lst[i]\n    }\n  }\n  return p\n}\n\n", "test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([]) === 0)\n  console.assert(doubleTheDifference([5, 4]) === 25)\n  console.assert(doubleTheDifference([0.1, 0.2, 0.3]) === 0)\n  console.assert(doubleTheDifference([-10, -20, -30]) === 0)\n  console.assert(doubleTheDifference([-1, -2, 8]) === 0)\n  console.assert(doubleTheDifference([0.2, 3, 5]) === 34)\n  let lst = []\n  let odd_sum = 0\n  for (let i = -99; i < 100; i += 2) {\n    if (i % 2 != 0 && i > 0) { odd_sum += i * i }\n    lst.push(i)\n  }\n  console.assert(doubleTheDifference(lst) === odd_sum)\n}\n", "declaration": "\nconst doubleTheDifference = (lst) => {\n", "example_test": "const testDoubleTheDifference = () => {\n  console.assert(doubleTheDifference([1,3,2,0]) === 10)\n  console.assert(doubleTheDifference([-1,-2,0]) === 0)\n  console.assert(doubleTheDifference([9,-2]) === 81)\n  console.assert(doubleTheDifference([0]) === 0)\n}\ntestDoubleTheDifference()\n", "entry_point": "doubleTheDifference", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are odd. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == 0\n  doubleTheDifference([9, -2]) == 81\n  doubleTheDifference([0]) == 0\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2!== 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are even. Ignore numbers that are negative or not integers.\n  doubleTheDifference([1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == -1\n  doubleTheDifference([9, -2]) == 9\n  doubleTheDifference([0]) == 10\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by both 2 and 3. doubleTheDifference(\n  [1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == -1\n  doubleTheDifference([9, -2]) == 9\n  doubleTheDifference([0]) == 10\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by both 2 and 3. doubleTheDifference(\n  [1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == -1\n  doubleTheDifference([9, -2]) == 9\n  doubleTheDifference([0]) == 10\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by both 2 and 3. doubleTheDifference(\n  [1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == -1\n  doubleTheDifference([9, -2]) == 9\n  doubleTheDifference([0]) == 10\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by both 2 and 3. doubleTheDifference(\n  [1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == -1\n  doubleTheDifference([9, -2]) == 9\n  doubleTheDifference([0]) == 10\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by both 2 and 3. doubleTheDifference(\n  [1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == -1\n  doubleTheDifference([9, -2]) == 9\n  doubleTheDifference([0]) == 10\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by both 2 and 3. doubleTheDifference(\n  [1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == -1\n  doubleTheDifference([9, -2]) == 9\n  doubleTheDifference([0]) == 10\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by both 2 and 3. doubleTheDifference(\n  [1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == -1\n  doubleTheDifference([9, -2]) == 9\n  doubleTheDifference([0]) == 10\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by both 2 and 3. doubleTheDifference(\n  [1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == -1\n  doubleTheDifference([9, -2]) == 9\n  doubleTheDifference([0]) == 10\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by both 2 and 3. doubleTheDifference(\n  [1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == -1\n  doubleTheDifference([9, -2]) == 9\n  doubleTheDifference([0]) == 10\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by both 2 and 3. doubleTheDifference(\n  [1, 3, 2, 0]) == 1 + 0 + 0 + 0 = 10\n  doubleTheDifference([-1, -2, 0]) == -1\n  doubleTheDifference([9, -2]) == 9\n  doubleTheDifference([0]) == 10\n  If the input list is empty, return 0.\n  */\nconst doubleTheDifference = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] % 2 === 0 && lst[i] % 3 === 0) {\n      sum += lst[i] * lst[i];\n    }\n  }\n  return sum;\n};\n\n/* Given a list of numbers, return the sum of squares of the numbers\n  in the list that are divisible by both 2 and 3. doubleTheDifference(\n  [1, 3, 2, 0]) == 1 + ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/152", "prompt": "/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n", "canonical_solution": "  for (let i = 0; i < guess.length; i++) {\n    game[i] -= guess[i]\n if (game[i]<0)\n game[i]=-game[i];  }\n  return game\n}\n\n", "test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0])) ===\n    JSON.stringify([0, 0, 0, 0, 0, 0])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3], [-1, -2, -3])) ===\n    JSON.stringify([2, 4, 6])\n  )\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 5], [-1, 2, 3, 4])) ===\n    JSON.stringify([2, 0, 0, 1])\n  )\n}\n\ntestCompare()\n", "declaration": "\nconst compare = (game, guess) => {\n", "example_test": "const testCompare = () => {\n  console.assert(\n    JSON.stringify(compare([1, 2, 3, 4, 5, 1], [1, 2, 3, 4, 2, -2])) ===\n    JSON.stringify([0, 0, 0, 0, 3, 3])\n  )\n  console.assert(\n    JSON.stringify(compare([0,5,0,0,0,4],[4,1,1,0,0,-2])) ===\n    JSON.stringify([4,4,1,0,0,6])\n  )\n}\ntestCompare()\n", "entry_point": "compare", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*I think we all remember that feeling when the result of some long-awaited\n  event is finally known. The feelings and thoughts you have at that moment are\n  definitely worth noting down and comparing.\n  Your task is to determine if a person correctly guessed the results of a number of matches.\n  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n  \n  \n  example:\n\n  compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n  compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n  */\nconst compare = (game, guess) => {\n  const scores = new Array(game.length).fill(0);\n  \n  for(let i = 0; i < game.length; i++) {\n    scores[i] = game[i];\n  }\n  \n  for(let i = 0; i < game.length; i++) {\n    for(let j = 0; j < game.length; j++) {\n      if(game[i] === guess[j]) {\n        scores[i] += 1;\n      }\n    }\n  }\n  \n  return scores.map((score) => Math.abs(score));\n};\n\n/*\n  Given an array of scores, a number of guesses, and a number of matches, return the number of guesses \n  that were correctly guessed and how many were incorrect.\n  \n  \n  example:\n\n  correct([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [2,2]\n  correct([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [2,2]\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/153", "prompt": "/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n", "canonical_solution": "  let u = 0\n  let s = -Infinity\n  for (let i = extensions.length - 1; i >= 0; i--) {\n    let y = 0\n    for (let j = 0; j < extensions[i].length; j++) {\n      let k = extensions[i][j].charCodeAt()\n      if (k >= 65 && k <= 90) { y += 1 }\n      if (k >= 97 && k <= 122) { y -= 1 }\n    }\n    if (y >= s) {\n      s = y;\n      u = i;\n    }\n  }\n  return class_name + '.' + extensions[u]\n}\n\n", "test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) ===\n    'Watashi.eIGHt8OKe'\n  )\n  console.assert(\n    strongestExtension('Boku123', [\n      'nani',\n      'NazeDa',\n      'YEs.WeCaNe',\n      '32145tggg',\n    ]) === 'Boku123.YEs.WeCaNe'\n  )\n  console.assert(\n    strongestExtension('__YESIMHERE', [\n      't',\n      'eMptY',\n      'nothing',\n      'zeR00',\n      'NuLl__',\n      '123NoooneB321',\n    ]) === '__YESIMHERE.NuLl__'\n  )\n  console.assert(\n    strongestExtension('K', ['Ta', 'TAR', 't234An', 'cosSo']) === 'K.TAR'\n  )\n  console.assert(\n    strongestExtension('__HAHA', ['Tab', '123', '781345', '-_-']) ===\n    '__HAHA.123'\n  )\n  console.assert(\n    strongestExtension('YameRore', [\n      'HhAas',\n      'okIWILL123',\n      'WorkOut',\n      'Fails',\n      '-_-',\n    ]) === 'YameRore.okIWILL123'\n  )\n  console.assert(\n    strongestExtension('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) ===\n    'finNNalLLly.WoW'\n  )\n  console.assert(strongestExtension('_', ['Bb', '91245']) === '_.Bb')\n  console.assert(strongestExtension('Sp', ['671235', 'Bb']) === 'Sp.671235')\n}\n\ntestStrongestExtension()\n", "declaration": "\nconst strongestExtension = (class_name, extensions) => {\n", "example_test": "const testStrongestExtension = () => {\n  console.assert(\n    strongestExtension('my_class', ['AA', 'Be', 'CC']) ===\n    'my_class.AA'\n  )\n}\ntestStrongestExtension()\n", "entry_point": "strongestExtension", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*You will be given the name of a class (a string) and a list of extensions.\n  The extensions are to be used to load additional classes to the class. The\n  strength of the extension is as follows: Let CAP be the number of the uppercase\n  letters in the extension's name, and let SM be the number of lowercase letters\n  in the extension's name, the strength is given by the fraction CAP - SM.\n  You should find the strongest extension and return a string in this\n  format: ClassName.StrongestExtensionName.\n  If there are two or more extensions with the same strength, you should\n  choose the one that comes first in the list.\n  For example, if you are given \"Slices\" as the class and a list of the\n  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\n  (its strength is -1).\n  Example:\n  for strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n  */\nconst strongestExtension = (class_name, extensions) => {\n  const extension_strengths = extensions.map(extension => extension.match(/[A-Z]/)? -1 : extension.match(/[a-z]/)? 1 : 0);\n  const sorted_extensions = extensions.sort((a, b) => extension_strengths[b] - extension_strengths[a]);\n  return sorted_extensions[sorted_extensions.length - 1];\n};\n\n/*\n  Given a class name and a list of extensions, return the class name that is\n  the strongest extension of the class name.\n  Example:\n  strongestExtension('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst strongestExtensionName = (class_name, extensions) => {\n  return strongestExtension(class_name, extensions);\n};\n\n/*\n  Given a class name and a list of extensions, return the class name that is\n  the strongest extension of the class name.\n  Example:\n  strongestExtensionName('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst strongestExtensionNames = (class_name, extensions) => {\n  return strongestExtensionName(class_name, extensions).split('.');\n};\n\n/*\n  Given a class name and a list of extensions, return the class name that is\n  the strongest extension of the class name.\n  Example:\n  strongestExtensionNames('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst strongestExtensionNamesArray = (class_name, extensions) => {\n  return strongestExtensionNames(class_name, extensions).map(name => name.split('.')[0]);\n};\n\n/*\n  Given a class name and a list of extensions, return the class name that is\n  the strongest extension of the class name.\n  Example:\n  strongestExtensionNamesArray('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst strongestExtensionNamesArrays = (class_name, extensions) => {\n  return strongestExtensionNamesArray(class_name, extensions).map(name => name.split('.')[0]);\n};\n\n/*\n  Given a class name and a list of extensions, return the class name that is\n  the strongest extension of the class name.\n  Example:\n  strongestExtensionNamesArrays('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst strongestExtensionNamesArraysArray = (class_name, extensions) => {\n  return strongestExtensionNamesArrays(class_name, extensions).map(name => name.split('.')[0]);\n};\n\n/*\n  Given a class name and a list of extensions, return the class name that is\n  the strongest extension of the class name.\n  Example:\n  strongestExtensionNamesArraysArray('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst strongestExtensionNamesArraysArrays = (class_name, extensions) => {\n  return strongestExtensionNamesArraysArray(class_name, extensions).map(name => name.split('.')[0]);\n};\n\n/*\n  Given a class name and a list of extensions, return the class name that is\n  the strongest extension of the class name.\n  Example:\n  strongestExtensionNamesArraysArrays('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst strongestExtensionNamesArraysArraysArray = (class_name, extensions) => {\n  return strongestExtensionNamesArraysArrays(class_name, extensions).map(name => name.split('.')[0]);\n};\n\n/*\n  Given a class name and a list of extensions, return the class name that is\n  the strongest extension of the class name.\n  Example:\n  strongestExtensionNamesArraysArraysArray('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst strongestExtensionNamesArraysArraysArrays = (class_name, extensions) => {\n  return strongestExtensionNamesArraysArraysArray(class_name, extensions).map(name => name.split('.')[0]);\n};\n\n/*\n  Given a class name and a list of extensions, return the class name that is\n  the strongest extension of the class name.\n  Example:\n  strongestExtensionNamesArraysArraysArrays('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst strongestExtensionNamesArraysArraysArraysArray = (class_name, extensions) => {\n  return strongestExtensionNamesArraysArraysArraysArray(class_name, extensions).map(name => name.split('.')[0]);\n};\n\n/*\n  Given a class name and a list of extensions, return the class name that is\n  the strongest extension of the class name.\n  Example:\n  strongestExtensionNamesArraysArraysArraysArrays('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst strongestExtensionNamesArraysArraysArraysArraysArray = (class_name, extensions) => {\n  return strongestExtensionNamesArraysArraysArraysArraysArray(class_name, extensions).map(name => name.split('.')[0]);\n};\n\n/*\n  Given a class name and a list of extensions, return the class name that is\n  the strongest extension of the class name.\n  Example:\n  strongestExtensionNamesArraysArraysArraysArraysArrays('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst strongestExtensionNamesArraysArraysArraysArraysArraysArraysArray = (class_name, extensions) => {\n  return strongestExtensionNamesArraysArraysArraysArraysArraysArraysArray(class_name, extensions).map(name => name.split('.')[0]);\n};\n\n/*\n  Given a class name and a list of extensions, return the class name that is\n  the strongest extension of the class name.\n  Example:\n  strongestExtensionNamesArraysArraysArraysArraysArraysArraysArrays('my_class', ['AA', 'Be', 'CC']) =='my_class.AA'\n*/\nconst strongestExtensionNamesArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArraysArrays", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/154", "prompt": "/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n", "canonical_solution": "  let l = b.length\n  let pat = b + b\n  for (let i = 0; i < a.length - l + 1; i++) {\n    for (let j = 0; j < l + 1; j++) {\n      let y = 1\n      for (let k = 0; k < l; k++) {\n        if (a[i + k] != pat[j + k]) { y = 0 }\n      }\n      if (y == 1) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\n", "test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('xyzw', 'xyw') === false)\n  console.assert(cycpatternCheck('yello', 'ell') === true)\n  console.assert(cycpatternCheck('whattup', 'ptut') === false)\n  console.assert(cycpatternCheck('efef', 'fee') === true)\n  console.assert(cycpatternCheck('abab', 'aabb') === false)\n  console.assert(cycpatternCheck('winemtt', 'tinem') === true)\n}\n\ntestCycpatternCheck()\n", "declaration": "\nconst cycpatternCheck = (a, b) => {\n", "example_test": "const testCycpatternCheck = () => {\n  console.assert(cycpatternCheck('abcd', 'abd') === false)\n  console.assert(cycpatternCheck('hello', 'ell') === true)\n  console.assert(cycpatternCheck('whassup', 'psus') === false)\n  console.assert(cycpatternCheck('abab', 'baa') === true)\n  console.assert(cycpatternCheck('efef', 'eeff') === false)\n  console.assert(cycpatternCheck('himenss', 'simen') === true)\n}\ntestCycpatternCheck()\n", "entry_point": "cycpatternCheck", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  let rotatedA = a.split('')\n  let rotatedB = b.split('')\n  let rotatedAIndex = rotatedA.indexOf(b[0])\n  let rotatedBIndex = rotatedB.indexOf(b[1])\n  if (rotatedAIndex === -1 || rotatedBIndex === -1) {\n    return false\n  }\n  if (rotatedAIndex === rotatedBIndex) {\n    return true\n  }\n  if (rotatedAIndex > rotatedBIndex) {\n    return cycpatternCheck(rotatedA.slice(0, rotatedAIndex), rotatedB.slice(0, rotatedBIndex))\n  }\n  return cycpatternCheck(rotatedA.slice(rotatedAIndex), rotatedB.slice(rotatedBIndex))\n}\n\n/*\n  You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  let rotatedA = a.split('')\n  let rotatedB = b.split('')\n  let rotatedAIndex = rotatedA.indexOf(b[0])\n  let rotatedBIndex = rotatedB.indexOf(b[1])\n  if (rotatedAIndex === -1 || rotatedBIndex === -1) {\n    return false\n  }\n  if (rotatedAIndex === rotatedBIndex) {\n    return true\n  }\n  if (rotatedAIndex > rotatedBIndex) {\n    return cycpatternCheck(rotatedA.slice(0, rotatedAIndex), rotatedB.slice(0, rotatedBIndex))\n  }\n  return cycpatternCheck(rotatedA.slice(rotatedAIndex), rotatedB.slice(rotatedBIndex))\n}\n\n/*\n  You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  let rotatedA = a.split('')\n  let rotatedB = b.split('')\n  let rotatedAIndex = rotatedA.indexOf(b[0])\n  let rotatedBIndex = rotatedB.indexOf(b[1])\n  if (rotatedAIndex === -1 || rotatedBIndex === -1) {\n    return false\n  }\n  if (rotatedAIndex === rotatedBIndex) {\n    return true\n  }\n  if (rotatedAIndex > rotatedBIndex) {\n    return cycpatternCheck(rotatedA.slice(0, rotatedAIndex), rotatedB.slice(0, rotatedBIndex))\n  }\n  return cycpatternCheck(rotatedA.slice(rotatedAIndex), rotatedB.slice(rotatedBIndex))\n}\n\n/*\n  You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  let rotatedA = a.split('')\n  let rotatedB = b.split('')\n  let rotatedAIndex = rotatedA.indexOf(b[0])\n  let rotatedBIndex = rotatedB.indexOf(b[1])\n  if (rotatedAIndex === -1 || rotatedBIndex === -1) {\n    return false\n  }\n  if (rotatedAIndex === rotatedBIndex) {\n    return true\n  }\n  if (rotatedAIndex > rotatedBIndex) {\n    return cycpatternCheck(rotatedA.slice(0, rotatedAIndex), rotatedB.slice(0, rotatedBIndex))\n  }\n  return cycpatternCheck(rotatedA.slice(rotatedAIndex), rotatedB.slice(rotatedBIndex))\n}\n\n/*\n  You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  let rotatedA = a.split('')\n  let rotatedB = b.split('')\n  let rotatedAIndex = rotatedA.indexOf(b[0])\n  let rotatedBIndex = rotatedB.indexOf(b[1])\n  if (rotatedAIndex === -1 || rotatedBIndex === -1) {\n    return false\n  }\n  if (rotatedAIndex === rotatedBIndex) {\n    return true\n  }\n  if (rotatedAIndex > rotatedBIndex) {\n    return cycpatternCheck(rotatedA.slice(0, rotatedAIndex), rotatedB.slice(0, rotatedBIndex))\n  }\n  return cycpatternCheck(rotatedA.slice(rotatedAIndex), rotatedB.slice(rotatedBIndex))\n}\n\n/*\n  You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n  cycpatternCheck(\"abcd\",\"abd\") => false\n  cycpatternCheck(\"hello\",\"ell\") => true\n  cycpatternCheck(\"whassup\",\"psus\") => false\n  cycpatternCheck(\"abab\",\"baa\") => true\n  cycpatternCheck(\"efef\",\"eeff\") => false\n  cycpatternCheck(\"himenss\",\"simen\") => true\n  */\nconst cycpatternCheck = (a, b) => {\n  let rotatedA = a.split('')\n  let rotatedB = b.split('')\n  let rotatedAIndex = rotatedA.indexOf(b[0])\n  let rotatedBIndex = rotatedB.indexOf(b[1])\n  if (rotatedAIndex === -1 || rotatedBIndex === -1) {\n    return false\n  }\n  if (rotatedAIndex === rotated", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/155", "prompt": "/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n", "canonical_solution": "  let o = 0\n  let e = 0\n  if (num < 0) { num = -num }\n  while (num > 0) {\n    if (num % 2 == 0) { e++ }\n    else { o++ }\n    num = (num - num % 10) / 10\n  }\n  return (e, o)\n}\n\n", "test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(7)) === JSON.stringify((0, 1)))\n  console.assert(JSON.stringify(evenOddCount(-78)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(3452)) === JSON.stringify((2, 2)))\n  console.assert(\n    JSON.stringify(evenOddCount(346211)) === JSON.stringify((3, 3))\n  )\n  console.assert(\n    JSON.stringify(evenOddCount(-345821)) === JSON.stringify((3, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(-2)) === JSON.stringify((1, 0)))\n  console.assert(\n    JSON.stringify(evenOddCount(-45347)) === JSON.stringify((2, 3))\n  )\n  console.assert(JSON.stringify(evenOddCount(0)) === JSON.stringify((1, 0)))\n}\n\ntestEvenOddCount()\n", "declaration": "\nconst evenOddCount = (num) => {\n", "example_test": "const testEvenOddCount = () => {\n  console.assert(JSON.stringify(evenOddCount(-12)) === JSON.stringify((1, 1)))\n  console.assert(JSON.stringify(evenOddCount(123)) === JSON.stringify((1, 2)))\n}\ntestEvenOddCount()\n", "entry_point": "evenOddCount", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount = (num) => {\n  let result = 0;\n  let digit;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n\n  do {\n    digit = num % 10;\n    num = Math.floor(num / 10);\n    result++;\n  } while (digit % 2 === 0);\n\n  i = 1;\n  j = 1;\n  k = 1;\n  l = 1;\n  m = 1;\n  n = 1;\n  p = 1;\n  q = 1;\n  r = 0;\n  s = 0;\n  t = 0;\n  u = 0;\n  v = 0;\n  w = 0;\n  x = 0;\n  y = 0;\n  z = 0;\n\n  while (num > 0) {\n    digit = num % 10;\n    num = Math.floor(num / 10);\n    result++;\n\n    if (digit % 2 === 0) {\n      i++;\n    }\n\n    if (digit % 2 === 1) {\n      j++;\n    }\n\n    if (digit % 2 === 0) {\n      k++;\n    }\n\n    if (digit % 2 === 1) {\n      l++;\n    }\n\n    if (digit % 2 === 0) {\n      m++;\n    }\n\n    if (digit % 2 === 1) {\n      n++;\n    }\n\n    if (digit % 2 === 0) {\n      p++;\n    }\n\n    if (digit % 2 === 1) {\n      q++;\n    }\n\n    if (digit % 2 === 0) {\n      r++;\n    }\n\n    if (digit % 2 === 1) {\n      s++;\n    }\n\n    if (digit % 2 === 0) {\n      t++;\n    }\n\n    if (digit % 2 === 1) {\n      u++;\n    }\n\n    if (digit % 2 === 0) {\n      v++;\n    }\n\n    if (digit % 2 === 1) {\n      w++;\n    }\n\n    if (digit % 2 === 0) {\n      x++;\n    }\n\n    if (digit % 2 === 1) {\n      y++;\n    }\n\n    if (digit % 2 === 0) {\n      z++;\n    }\n  }\n\n  return [result, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z];\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount2 = (num) => {\n  let result = 0;\n  let digit;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n\n  do {\n    digit = num % 10;\n    num = Math.floor(num / 10);\n    result++;\n  } while (digit % 2 === 0);\n\n  i = 1;\n  j = 1;\n  k = 1;\n  l = 1;\n  m = 1;\n  n = 1;\n  p = 1;\n  q = 1;\n  r = 0;\n  s = 0;\n  t = 0;\n  u = 0;\n  v = 0;\n  w = 0;\n  x = 0;\n  y = 0;\n  z = 0;\n\n  while (num > 0) {\n    digit = num % 10;\n    num = Math.floor(num / 10);\n    result++;\n\n    if (digit % 2 === 0) {\n      i++;\n    }\n\n    if (digit % 2 === 1) {\n      j++;\n    }\n\n    if (digit % 2 === 0) {\n      k++;\n    }\n\n    if (digit % 2 === 1) {\n      l++;\n    }\n\n    if (digit % 2 === 0) {\n      m++;\n    }\n\n    if (digit % 2 === 1) {\n      n++;\n    }\n\n    if (digit % 2 === 0) {\n      p++;\n    }\n\n    if (digit % 2 === 1) {\n      q++;\n    }\n\n    if (digit % 2 === 0) {\n      r++;\n    }\n\n    if (digit % 2 === 1) {\n      s++;\n    }\n\n    if (digit % 2 === 0) {\n      t++;\n    }\n\n    if (digit % 2 === 1) {\n      u++;\n    }\n\n    if (digit % 2 === 0) {\n      v++;\n    }\n\n    if (digit % 2 === 1) {\n      w++;\n    }\n\n    if (digit % 2 === 0) {\n      x++;\n    }\n\n    if (digit % 2 === 1) {\n      y++;\n    }\n\n    if (digit % 2 === 0) {\n      z++;\n    }\n  }\n\n  return [result, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z];\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount3 = (num) => {\n  let result = 0;\n  let digit;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n\n  do {\n    digit = num % 10;\n    num = Math.floor(num / 10);\n    result++;\n  } while (digit % 2 === 0);\n\n  i = 1;\n  j = 1;\n  k = 1;\n  l = 1;\n  m = 1;\n  n = 1;\n  p = 1;\n  q = 1;\n  r = 0;\n  s = 0;\n  t = 0;\n  u = 0;\n  v = 0;\n  w = 0;\n  x = 0;\n  y = 0;\n  z = 0;\n\n  while (num > 0) {\n    digit = num % 10;\n    num = Math.floor(num / 10);\n    result++;\n\n    if (digit % 2 === 0) {\n      i++;\n    }\n\n    if (digit % 2 === 1) {\n      j++;\n    }\n\n    if (digit % 2 === 0) {\n      k++;\n    }\n\n    if (digit % 2 === 1) {\n      l++;\n    }\n\n    if (digit % 2 === 0) {\n      m++;\n    }\n\n    if (digit % 2 === 1) {\n      n++;\n    }\n\n    if (digit % 2 === 0) {\n      p++;\n    }\n\n    if (digit % 2 === 1) {\n      q++;\n    }\n\n    if (digit % 2 === 0) {\n      r++;\n    }\n\n    if (digit % 2 === 1) {\n      s++;\n    }\n\n    if (digit % 2 === 0) {\n      t++;\n    }\n\n    if (digit % 2 === 1) {\n      u++;\n    }\n\n    if (digit % 2 === 0) {\n      v++;\n    }\n\n    if (digit % 2 === 1) {\n      w++;\n    }\n\n    if (digit % 2 === 0) {\n      x++;\n    }\n\n    if (digit % 2 === 1) {\n      y++;\n    }\n\n    if (digit % 2 === 0) {\n      z++;\n    }\n  }\n\n  return [result, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z];\n};\n\n/*GReturns a tuple with even or odd digits.\n\n   Example:\n      evenOddCount(-12) ==> (1, 1)\n      evenOddCount(123) ==> (1, 2)\n  */\nconst evenOddCount4 = (num) => {\n  let result = 0;\n  let digit;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n  let p;\n  let q;\n  let r;\n  let s;\n  let t;\n  let u;\n  let v;\n  let w;\n  let x;\n  let y;\n  let z;\n\n  do {\n    digit = num % 10;\n    num = Math.floor(num / 10);\n    result++;\n  } while (digit % 2 === 0);\n\n  i = 1;\n  j = 1;\n  k = 1;\n", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 3, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/156", "prompt": "/*\n  With a positive integer, you get your Roman number equivalent as a string and return it in lowercase letters. Limitations: 1 < = number < = 1000 Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n", "canonical_solution": "  let num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000]\n  let sym = ['i', 'iv', 'v', 'ix', 'x', 'xl', 'l', 'xc', 'c', 'cd', 'd', 'cm', 'm']\n  let i = 12\n  let res = ''\n  while (number) {\n    let div = (number - number % num[i]) / num[i]\n    number = number % num[i]\n    while (div) {\n      res += sym[i]\n      div -= 1\n    }\n    i -= 1\n  }\n  return res\n}\n\n", "test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(251) === 'ccli')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n  console.assert(intToMiniRoman(500) === 'd')\n  console.assert(intToMiniRoman(1) === 'i')\n  console.assert(intToMiniRoman(4) === 'iv')\n  console.assert(intToMiniRoman(43) === 'xliii')\n  console.assert(intToMiniRoman(90) === 'xc')\n  console.assert(intToMiniRoman(94) === 'xciv')\n  console.assert(intToMiniRoman(532) === 'dxxxii')\n  console.assert(intToMiniRoman(900) === 'cm')\n  console.assert(intToMiniRoman(994) === 'cmxciv')\n  console.assert(intToMiniRoman(1000) === 'm')\n}\n\ntestIntToMiniRoman()\n", "declaration": "\nconst intToMiniRoman = (number) => {\n", "example_test": "const testIntToMiniRoman = () => {\n  console.assert(intToMiniRoman(19) === 'xix')\n  console.assert(intToMiniRoman(152) === 'clii')\n  console.assert(intToMiniRoman(426) === 'cdxxvi')\n}\ntestIntToMiniRoman()\n", "entry_point": "intToMiniRoman", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  With a positive integer, you get your Roman number equivalent as a string and return it in lowercase letters. Limitations: 1 < = number < = 1000 Examples:\n  >>> intToMiniRoman(19) == 'xix'\n  >>> intToMiniRoman(152) == 'clii'\n  >>> intToMiniRoman(426) == 'cdxxvi'\n  */\nconst intToMiniRoman = (number) => {\n  let roman = '';\n  let num = (number + '').toString();\n  let numLength = num.length;\n  let numDigits = numLength;\n  let numLetters = numLength - numDigits;\n  let numRoman = '';\n  let numRomanLength = (numLength - numLetters);\n  let numRomanDigits = numRomanLength;\n  let numRomanLetters = numRomanLength - numRomanDigits;\n  let numRomanRoman = '';\n  let numRomanRomanLength = (numRomanLength - numRomanLetters);\n  let numRomanRomanDigits = numRomanRomanLength;\n  let numRomanRomanLetters = numRomanRomanLength - numRomanRomanDigits;\n  let numRomanRomanRoman = '';\n  let numRomanRomanRomanLength = (numRomanRomanLength - numRomanRomanLetters);\n  let numRomanRomanRomanDigits = numRomanRomanRomanLength;\n  let numRomanRomanRomanLetters = numRomanRomanRomanLength - numRomanRomanRomanDigits;\n  let numRomanRomanRomanRoman = '';\n  let numRomanRomanRomanRomanLength = (numRomanRomanRomanLength - numRomanRomanRomanLetters);\n  let numRomanRomanRomanRomanDigits = numRomanRomanRomanRomanLength;\n  let numRomanRomanRomanRomanLetters = numRomanRomanRomanRomanLength - numRomanRomanRomanRomanDigits;\n  let numRomanRomanRomanRomanRoman = '';\n  let numRomanRomanRomanRomanRomanLength = (numRomanRomanRomanRomanLength - numRomanRomanRomanRomanLetters);\n  let numRomanRomanRomanRomanRomanDigits = numRomanRomanRomanRomanRomanLength;\n  let numRomanRomanRomanRomanLetters = numRomanRomanRomanRomanRomanLength - numRomanRomanRomanRomanDigits;\n  let numRomanRomanRomanRomanRoman = '';\n  let numRomanRomanRomanRomanRomanLength = (numRomanRomanRomanRomanLength - numRomanRomanRomanRomanLetters);\n  let numRomanRomanRomanRomanRomanDigits = numRomanRomanRomanRomanRomanLength;\n  let numRomanRomanRomanRomanRomanLetters = numRomanRomanRomanRomanRomanLength - numRomanRomanRomanRomanDigits;\n  let numRomanRomanRomanRomanRomanRoman = '';\n  let numRomanRomanRomanRomanRomanRomanLength = (numRomanRomanRomanRomanRomanLength - numRomanRomanRomanRomanRomanLetters);\n  let numRomanRomanRomanRomanRomanRomanDigits = numRomanRomanRomanRomanRomanRomanLength;\n  let numRomanRomanRomanRomanRomanLetters = numRomanRomanRomanRomanRomanRomanLength - numRomanRomanRomanRomanRomanDigits;\n  let numRomanRomanRomanRomanRomanRoman = '';\n  let numRomanRomanRomanRomanRomanRomanLength = (numRomanRomanRomanRomanRomanLength - numRomanRomanRomanRomanRomanLetters);\n  let numRomanRomanRomanRomanRomanRomanDigits = numRomanRomanRomanRomanRomanRomanLength;\n  let numRomanRomanRomanRomanRomanLetters = numRomanRomanRomanRomanRomanLength - numRomanRomanRomanRomanRomanDigits;\n  let numRomanRomanRomanRomanRomanRoman = '';\n  let numRomanRomanRomanRomanRomanRomanLength = (numRomanRomanRomanRomanRomanRomanLength - numRomanRomanRomanRomanRomanRomanLetters);\n  let numRomanRomanRomanRomanRomanRomanDigits = numRomanRomanRomanRomanRomanRomanLength;\n  let numRomanRomanRomanRomanRomanRoman = '';\n  let numRomanRomanRomanRomanRomanRomanLength = (numRomanRomanRomanRomanRomanLength - numRomanRomanRomanRomanRomanRomanLetters);\n  let numRomanRomanRomanRomanRomanRomanDigits = numRomanRomanRomanRomanRomanRomanRomanLength;\n  let numRomanRomanRomanRomanRomanRomanLetters = numRomanRomanRomanRomanRomanRomanRomanLength - numRomanRomanRomanRomanRomanRomanDigits;\n  let numRomanRomanRomanRomanRomanRoman = '';\n  let numRomanRomanRomanRomanRomanRomanLength = (numRomanRomanRomanRomanRomanRomanLength - numRomanRomanRomanRomanRomanRomanLetters);\n  let numRomanRomanRomanRomanRomanRomanRomanDigits = numRomanRomanRomanRomanRomanRomanRomanLength;\n  let numRomanRomanRomanRomanRomanRomanRoman = '';\n  let numRomanRomanRomanRomanRomanRomanRomanLength = (numRomanRomanRomanRomanRomanRomanRomanLength - numRomanRomanRomanRomanRomanRomanRomanLetters);\n  let numRomanRomanRomanRomanRomanRomanRomanDigits = numRomanRomanRomanRomanRomanRomanRomanRomanLength;\n  let numRomanRomanRomanRomanRomanRomanRoman = '';\n  let numRomanRomanRomanRomanRomanRomanRomanLength = (numRomanRomanRomanRomanRomanRomanRomanLength - numRomanRomanRomanRomanRomanRomanRomanLetters);\n  let numRomanRomanRomanRomanRomanRomanRomanDigits = numRomanRomanRomanRomanRomanRomanRomanLength;\n  let numRomanRomanRomanRomanRomanRoman = '';\n  let numRomanRomanRomanRomanRomanRomanRomanLength = (numRomanRomanRomanRomanRomanRomanLength - numRomanRoman", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/157", "prompt": "/*\n Given the length of the three sides of a triangle. Returns true if the three sides form a right-angled triangle, otherwise wrong. A right-angled triangle is a triangle in which an angle is right-angled or 90 degrees.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n", "canonical_solution": "  return (a * a + b * b == c * c || a * a == b * b + c * c || b * b == a * a + c * c)\n}\n\n", "test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n  console.assert(rightAngleTriangle(10, 6, 8) === true)\n  console.assert(rightAngleTriangle(2, 2, 2) === false)\n  console.assert(rightAngleTriangle(7, 24, 25) === true)\n  console.assert(rightAngleTriangle(10, 5, 7) === false)\n  console.assert(rightAngleTriangle(5, 12, 13) === true)\n  console.assert(rightAngleTriangle(15, 8, 17) === true)\n  console.assert(rightAngleTriangle(48, 55, 73) === true)\n  console.assert(rightAngleTriangle(1, 1, 1) === false)\n  console.assert(rightAngleTriangle(2, 2, 10) === false)\n}\n\ntestRightAngleTriangle()\n", "declaration": "\nconst rightAngleTriangle = (a, b, c) => {\n", "example_test": "const testRightAngleTriangle = () => {\n  console.assert(rightAngleTriangle(3, 4, 5) === true)\n  console.assert(rightAngleTriangle(1, 2, 3) === false)\n}\ntestRightAngleTriangle()\n", "entry_point": "rightAngleTriangle", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n Given the length of the three sides of a triangle. Returns true if the three sides form a right-angled triangle, otherwise wrong. A right-angled triangle is a triangle in which an angle is right-angled or 90 degrees.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  */\nconst rightAngleTriangle = (a, b, c) => {\n  return a === b - c && b === c - a && c === a + b;\n};\n\n/*\n Given the length of the three sides of a triangle. Returns true if the three sides form a left-angled triangle, otherwise wrong. A left-angled triangle is a triangle in which an angle is left-angled or -90 degrees.\n  Example:\n  leftAngleTriangle(3, 4, 5) == true\n  leftAngleTriangle(1, 2, 3) == false\n  */\nconst leftAngleTriangle = (a, b, c) => {\n  return a === b + c && b === c + a && c === a - b;\n};\n\n/*\n Given the length of the three sides of a triangle. Returns true if the three sides form a counter-clockwise triangle, otherwise wrong. A counter-clockwise triangle is a triangle in which an angle is counter-clockwise or -90 degrees.\n  Example:\n  counterClockwiseTriangle(3, 4, 5) == true\n  counterClockwiseTriangle(1, 2, 3) == false\n  */\nconst counterClockwiseTriangle = (a, b, c) => {\n  return a === b - c && b === c + a && c === a + b;\n};\n\n/*\n Given the length of the three sides of a triangle. Returns true if the three sides form a clockwise triangle, otherwise wrong. A clockwise triangle is a triangle in which an angle is clockwise or 90 degrees.\n  Example:\n  clockwiseTriangle(3, 4, 5) == true\n  clockwiseTriangle(1, 2, 3) == false\n  */\nconst clockwiseTriangle = (a, b, c) => {\n  return a === b + c && b === c + a && c === a - b;\n};\n\n/*\n Given the length of the three sides of a triangle. Returns true if the three sides form a right-angled triangle or counter-clockwise triangle, otherwise wrong. A right-angled triangle is a triangle in which an angle is right-angled or 90 degrees.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  counterClockwiseTriangle(3, 4, 5) == true\n  counterClockwiseTriangle(1, 2, 3) == false\n  clockwiseTriangle(3, 4, 5) == true\n  clockwiseTriangle(1, 2, 3) == false\n  */\nconst sideTriangle = (a, b, c) => {\n  return a === b - c && b === c + a && c === a + b;\n};\n\n/*\n Given the length of the three sides of a triangle. Returns true if the three sides form a left-angled triangle or counter-clockwise triangle, otherwise wrong. A left-angled triangle is a triangle in which an angle is left-angled or -90 degrees.\n  Example:\n  leftAngleTriangle(3, 4, 5) == true\n  leftAngleTriangle(1, 2, 3) == false\n  counterClockwiseTriangle(3, 4, 5) == true\n  counterClockwiseTriangle(1, 2, 3) == false\n  clockwiseTriangle(3, 4, 5) == true\n  clockwiseTriangle(1, 2, 3) == false\n  */\nconst sideTriangleCounter = (a, b, c) => {\n  return a === b + c && b === c + a && c === a - b;\n};\n\n/*\n Given the length of the three sides of a triangle. Returns true if the three sides form a clockwise triangle or counter-clockwise triangle, otherwise wrong. A clockwise triangle is a triangle in which an angle is clockwise or 90 degrees.\n  Example:\n  clockwiseTriangle(3, 4, 5) == true\n  clockwiseTriangle(1, 2, 3) == false\n  counterClockwiseTriangle(3, 4, 5) == true\n  counterClockwiseTriangle(1, 2, 3) == false\n  sideTriangle(3, 4, 5) == true\n  sideTriangle(1, 2, 3) == false\n  sideTriangleCounter(1, 2, 3) == false\n  */\nconst sideTriangleClock = (a, b, c) => {\n  return a === b - c && b === c + a && c === a + b;\n};\n\n/*\n Given the length of the three sides of a triangle. Returns true if the three sides form a right-angled triangle or counter-clockwise triangle, otherwise wrong. A right-angled triangle is a triangle in which an angle is right-angled or 90 degrees.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  counterClockwiseTriangle(3, 4, 5) == true\n  counterClockwiseTriangle(1, 2, 3) == false\n  clockwiseTriangle(3, 4, 5) == true\n  clockwiseTriangle(1, 2, 3) == false\n  */\nconst sideTriangleCounterClock = (a, b, c) => {\n  return a === b + c && b === c + a && c === a - b;\n};\n\n/*\n Given the length of the three sides of a triangle. Returns true if the three sides form a clockwise triangle or counter-clockwise triangle, otherwise wrong. A clockwise triangle is a triangle in which an angle is clockwise or 90 degrees.\n  Example:\n  clockwiseTriangle(3, 4, 5) == true\n  clockwiseTriangle(1, 2, 3) == false\n  counterClockwiseTriangle(3, 4, 5) == true\n  counterClockwiseTriangle(1, 2, 3) == false\n  sideTriangle(3, 4, 5) == true\n  sideTriangle(1, 2, 3) == false\n  sideTriangleCounter(1, 2, 3) == false\n  */\nconst sideTriangleClockCounter = (a, b, c) => {\n  return a === b - c && b === c + a && c === a + b;\n};\n\n/*\n Given the length of the three sides of a triangle. Returns true if the three sides form a right-angled triangle or counter-clockwise triangle, otherwise wrong. A right-angled triangle is a triangle in which an angle is right-angled or -90 degrees.\n  Example:\n  rightAngleTriangle(3, 4, 5) == true\n  rightAngleTriangle(1, 2, 3) == false\n  counterClockwiseTriangle(3, 4, 5) == true\n  counterClockwiseTriangle(1, 2, 3) == false\n  clockwiseTriangle(3, 4, 5) == true\n  clockwiseTriangle(1, 2, 3) == false\n  */\nconst sideTriangleCounterClockClock = (a, b, c) => {\n  return a === b + c && b === c + a && c === a - b;\n};\n\n/*\n Given the length of the three sides of a triangle. Returns true if the three sides form a clockwise triangle or counter-clockwise triangle, otherwise wrong. A clockwise triangle is a triangle in which an angle is clockwise or 90 degrees.\n  Example:\n  clockwiseTriangle(3, 4, 5) == true\n  clockwiseTriangle(1, 2, 3) == false\n  counterClockwiseTriangle(3, 4, 5) == true\n  counterClockwiseTriangle(1, 2, 3) == false\n  sideTriangle(3, 4, 5) == true\n  sideTriangle(1, 2, 3) == false\n  sideTriangleCounter(1, 2, 3) == false\n  */\nconst sideTriangleClockCounter = (a, b, c) => {\n  return a === b - c && b === c + a && c === a + b;\n};\n\n/*\n Given the length of the three sides of a triangle. Returns true if the three sides form a right-angled triangle or counter-clockwise triangle", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/158", "prompt": "/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\" ,\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n", "canonical_solution": "  let s = -1\n  let u = -1\n  if (words.length == 0) { return '' }\n  for (let i = 0; i < words.length; i++) {\n    let p = 0\n    for (let j = 0; j < words[i].length; j++) {\n      let y = 1\n      for (let k = 0; k < j; k++) {\n        if (words[i][j] == words[i][k]) { y = 0 }\n      }\n      if (y == 1) { p++ }\n    }\n    if (p > s || (p == s && words[i] < words[u])) {\n      u = i;\n      s = p;\n    }\n  }\n  return words[u]\n}\n\n", "test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n  console.assert(findMax(['abc', 'cba']) === 'abc')\n  console.assert(\n    findMax(['play', 'this', 'game', 'of', 'footbott']) === 'footbott'\n  )\n  console.assert(findMax(['we', 'are', 'gonna', 'rock']) === 'gonna')\n  console.assert(findMax(['we', 'are', 'a', 'mad', 'nation']) === 'nation')\n  console.assert(findMax(['this', 'is', 'a', 'prrk']) === 'this')\n  console.assert(findMax(['b']) === 'b')\n  console.assert(findMax(['play', 'play', 'play']) === 'play')\n}\n\ntestFindMax()\n", "declaration": "\nconst findMax = (words) => {\n", "example_test": "const testFindMax = () => {\n  console.assert(findMax(['name', 'of', 'string']) === 'string')\n  console.assert(findMax(['name', 'enam', 'game']) === 'enam')\n  console.assert(findMax(['aaaaaaa', 'bb', 'cc']) === 'aaaaaaa')\n}\ntestFindMax()\n", "entry_point": "findMax", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Write a function that accepts a list of strings.\n  The list contains different words. Return the word with maximum number\n  of unique characters. If multiple strings have maximum number of unique\n  characters, return the one which comes first in lexicographical order.\n\n  findMax([\"name\", \"of\", \"string\"]) === \"string\"\n  findMax([\"name\", \"enam\", \"game\"]) === \"enam\"\n  findMax([\"aaaaaaa\", \"bb\",\"cc\"]) === \"\"aaaaaaa\"\n  */\nconst findMax = (words) => {\n  let maxLength = 0;\n  let maxWord = \"\";\n  let maxChar = 0;\n  let maxCharCount = 0;\n  let maxCharCount2 = 0;\n  let maxCharCount3 = 0;\n  let maxCharCount4 = 0;\n  let maxCharCount5 = 0;\n  let maxCharCount6 = 0;\n  let maxCharCount7 = 0;\n  let maxCharCount8 = 0;\n  let maxCharCount9 = 0;\n  let maxCharCount10 = 0;\n  let maxCharCount11 = 0;\n  let maxCharCount12 = 0;\n  let maxCharCount13 = 0;\n  let maxCharCount14 = 0;\n  let maxCharCount15 = 0;\n  let maxCharCount16 = 0;\n  let maxCharCount17 = 0;\n  let maxCharCount18 = 0;\n  let maxCharCount19 = 0;\n  let maxCharCount20 = 0;\n  let maxCharCount21 = 0;\n  let maxCharCount22 = 0;\n  let maxCharCount23 = 0;\n  let maxCharCount24 = 0;\n  let maxCharCount25 = 0;\n  let maxCharCount26 = 0;\n  let maxCharCount27 = 0;\n  let maxCharCount28 = 0;\n  let maxCharCount29 = 0;\n  let maxCharCount30 = 0;\n  let maxCharCount31 = 0;\n  let maxCharCount32 = 0;\n  let maxCharCount33 = 0;\n  let maxCharCount34 = 0;\n  let maxCharCount35 = 0;\n  let maxCharCount36 = 0;\n  let maxCharCount37 = 0;\n  let maxCharCount38 = 0;\n  let maxCharCount39 = 0;\n  let maxCharCount40 = 0;\n  let maxCharCount41 = 0;\n  let maxCharCount42 = 0;\n  let maxCharCount43 = 0;\n  let maxCharCount44 = 0;\n  let maxCharCount45 = 0;\n  let maxCharCount46 = 0;\n  let maxCharCount47 = 0;\n  let maxCharCount48 = 0;\n  let maxCharCount49 = 0;\n  let maxCharCount50 = 0;\n  let maxCharCount51 = 0;\n  let maxCharCount52 = 0;\n  let maxCharCount53 = 0;\n  let maxCharCount54 = 0;\n  let maxCharCount55 = 0;\n  let maxCharCount56 = 0;\n  let maxCharCount57 = 0;\n  let maxCharCount58 = 0;\n  let maxCharCount59 = 0;\n  let maxCharCount60 = 0;\n  let maxCharCount61 = 0;\n  let maxCharCount62 = 0;\n  let maxCharCount63 = 0;\n  let maxCharCount64 = 0;\n  let maxCharCount65 = 0;\n  let maxCharCount66 = 0;\n  let maxCharCount67 = 0;\n  let maxCharCount68 = 0;\n  let maxCharCount69 = 0;\n  let maxCharCount70 = 0;\n  let maxCharCount71 = 0;\n  let maxCharCount72 = 0;\n  let maxCharCount73 = 0;\n  let maxCharCount74 = 0;\n  let maxCharCount75 = 0;\n  let maxCharCount76 = 0;\n  let maxCharCount77 = 0;\n  let maxCharCount78 = 0;\n  let maxCharCount79 = 0;\n  let maxCharCount80 = 0;\n  let maxCharCount81 = 0;\n  let maxCharCount82 = 0;\n  let maxCharCount83 = 0;\n  let maxCharCount84 = 0;\n  let maxCharCount85 = 0;\n  let maxCharCount86 = 0;\n  let maxCharCount87 = 0;\n  let maxCharCount88 = 0;\n  let maxCharCount89 = 0;\n  let maxCharCount90 = 0;\n  let maxCharCount91 = 0;\n  let maxCharCount92 = 0;\n  let maxCharCount93 = 0;\n  let maxCharCount94 = 0;\n  let maxCharCount95 = 0;\n  let maxCharCount96 = 0;\n  let maxCharCount97 = 0;\n  let maxCharCount98 = 0;\n  let maxCharCount99 = 0;\n  let maxCharCount100 = 0;\n  let maxCharCount101 = 0;\n  let maxCharCount102 = 0;\n  let maxCharCount103 = 0;\n  let maxCharCount104 = 0;\n  let maxCharCount105 = 0;\n  let maxCharCount106 = 0;\n  let maxCharCount107 = 0;\n  let maxCharCount108 = 0;\n  let maxCharCount109 = 0;\n  let maxCharCount110 = 0;\n  let maxCharCount111 = 0;\n  let maxCharCount112 = 0;\n  let maxCharCount113 = 0;\n  let maxCharCount114 = 0;\n  let maxCharCount115 = 0;\n  let maxCharCount116 = 0;\n  let maxCharCount117 = 0;\n  let maxCharCount118 = 0;\n  let maxCharCount119 = 0;\n  let maxCharCount120 = 0;\n  let maxCharCount121 = 0;\n  let maxCharCount122 = 0;\n  let maxCharCount123 = 0;\n  let maxCharCount124 = 0;\n  let maxCharCount125 = 0;\n  let maxCharCount126 = 0;\n  let maxCharCount127 = 0;\n  let maxCharCount128 = 0;\n  let maxCharCount129 = 0;\n  let maxCharCount130 = 0;\n  let maxCharCount131 = 0;\n  let maxCharCount132 = 0;\n  let maxCharCount133 = 0;\n  let maxCharCount134 = 0;\n  let maxCharCount135 = 0;\n  let maxCharCount136 = 0;\n  let maxCharCount137 = 0;\n  let maxCharCount138 = 0;\n  let maxCharCount139 = 0;\n  let maxCharCount140 = 0;\n  let maxCharCount141 = 0;\n  let maxCharCount142 = 0;\n  let maxCharCount143 = 0;\n  let maxCharCount144 = 0;\n  let maxCharCount145 = 0;\n  let maxCharCount146 = 0;\n  let maxCharCount147 = 0;\n  let maxCharCount148 = 0;\n  let maxCharCount149 = 0;\n  let maxCharCount150 = 0;\n  let maxCharCount151 = 0;\n  let maxCharCount152 = 0;\n  let maxCharCount153 = 0;\n  let maxCharCount154 = 0;\n  let maxCharCount155 = 0;\n  let maxCharCount156 = 0;\n  let maxCharCount157 = 0;\n  let maxCharCount158 = 0;\n  let maxCharCount159 = 0;\n  let maxCharCount160 = 0;\n  let maxCharCount161 = 0;\n  let maxCharCount162 = 0;\n  let maxCharCount163 = 0;\n  let maxCharCount164 = 0;\n  let maxCharCount165 = 0;\n  let maxCharCount166 = 0;\n  let maxCharCount167 = 0;\n  let maxCharCount168 = 0;\n  let maxCharCount169 = 0;\n  let maxCharCount170 = 0;\n  let maxCharCount171 = 0;\n  let maxCharCount172 = 0;\n  let maxCharCount173 = 0;\n  let maxCharCount174 = 0;\n  let maxCharCount175 = 0;\n  let maxCharCount176 = 0;\n  let maxCharCount177 = 0;\n  let maxCharCount178 = 0;\n  let maxCharCount179 = 0;\n  let maxCharCount180 = 0;\n  let maxCharCount181 = 0;\n  let maxCharCount182 = 0;\n  let maxCharCount183 = 0;\n  let maxCharCount184 = 0;\n  let maxCharCount185 = 0;\n  let maxCharCount186 = 0;\n  let maxCharCount187 = 0;\n  let maxCharCount188 = 0;\n  let maxCharCount189 = 0;\n  let maxCharCount190 = 0;\n  let maxCharCount191 = 0;\n  let maxCharCount192 = 0;\n  let maxCharCount193 = 0;\n  let maxCharCount194 = 0;\n  let maxCharCount195 = 0;\n  let maxCharCount196 = 0;\n  let maxCharCount197 = 0;\n  let maxCharCount198 = 0;\n  let maxCharCount199 = 0;\n  let maxCharCount200 = 0;\n  let maxCharCount201 = 0;\n  let maxCharCount202 = 0;\n  let maxCharCount203 = 0;", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/159", "prompt": "/*\n  You're a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n", "canonical_solution": "  if (need <= remaining) {\n    return [need + number, remaining - need]\n  }\n  return [remaining + number, 0]\n}\n\n", "test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n  console.assert(JSON.stringify(eat(4, 5, 7)) === JSON.stringify([9, 2]))\n  console.assert(JSON.stringify(eat(4, 5, 1)) === JSON.stringify([5, 0]))\n}\n\ntestEat()\n", "declaration": "\nconst eat = (number, need, remaining) => {\n", "example_test": "const testEat = () => {\n  console.assert(JSON.stringify(eat(5, 6, 10)) === JSON.stringify([11, 4]))\n  console.assert(JSON.stringify(eat(4, 8, 9)) === JSON.stringify([12, 1]))\n  console.assert(JSON.stringify(eat(1, 10, 10)) === JSON.stringify([11, 0]))\n  console.assert(JSON.stringify(eat(2, 11, 5)) === JSON.stringify([7, 0]))\n}\ntestEat()\n", "entry_point": "eat", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*\n  You're a hungry rabbit, and you already have eaten a certain number of carrots,\n  but now you need to eat more carrots to complete the day's meals.\n  you should return an array of [ total number of eaten carrots after your meals,\n                                  the number of carrots left after your meals ]\n  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n  \n  Example:\n  * eat(5, 6, 10) -> [11, 4]\n  * eat(4, 8, 9) -> [12, 1]\n  * eat(1, 10, 10) -> [11, 0]\n  * eat(2, 11, 5) -> [7, 0]\n  \n  Variables:\n  @number : integer\n      the number of carrots that you have eaten.\n  @need : integer\n      the number of carrots that you need to eat.\n  @remaining : integer\n      the number of remaining carrots thet exist in stock\n  \n  Constrain:\n  * 0 <= number <= 1000\n  * 0 <= need <= 1000\n  * 0 <= remaining <= 1000\n\n  Have fun :)\n  */\nconst eat = (number, need, remaining) => {\n  const carrots = Math.ceil(number * Math.ceil(need / 100));\n  const remaining = Math.ceil(remaining / 100);\n  const carrotLeft = carrots - remaining;\n  const carrotEaten = carrots - remaining;\n  const carrotRemaining = carrots - remaining;\n  const carrotRemainingEaten = carrotRemaining - carrotEaten;\n  const carrotRemainingEatenRemaining = carrotRemainingEaten - carrotRemaining;\n  const carrotRemainingEatenRemainingEaten = carrotRemainingEatenRemaining - carrotRemainingEatenRemaining;\n  const carrotRemainingEatenRemainingEatenRemaining = carrotRemainingEatenRemainingEaten - carrotRemainingEatenRemaining;\n  const carrotRemainingEatenRemainingEatenRemainingEaten = carrotRemainingEatenRemainingEatenRemaining - carrotRemainingEatenRemainingEaten;\n  const carrotRemainingEatenRemainingEatenRemainingEatenRemaining = carrotRemainingEatenRemainingEatenRemainingEaten - carrotRemainingEatenRemainingEatenRemaining;\n  const carrotRemainingEatenRemainingEatenRemainingEatenRemainingEaten = carrotRemainingEatenRemainingEatenRemainingEatenRemaining - carrotRemainingEatenRemainingEatenRemainingEatenRemaining;\n  const carrotRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEaten = carrotRemainingEatenRemainingEatenRemainingEatenRemainingEaten - carrotRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEaten;\n  const carrotRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEaten = carrotRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemainingEatenRemaining", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/16", "prompt": "/* Find out how many different characters a string consists of (regardless of the case).\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n", "canonical_solution": "  return (new Set(string.toLowerCase())).size;\n\n}\n\n", "test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('') === 0)\n  console.assert(countDistinctCharacters('abcde') === 5)\n  console.assert(countDistinctCharacters('abcde' + 'cade' + 'CADE') === 5)\n  console.assert(countDistinctCharacters('aaaaAAAAaaaa') === 1)\n  console.assert(countDistinctCharacters('Jerry jERRY JeRRRY') === 5)\n}\n\ntestCountDistinctCharacters()\n", "declaration": "\nconst countDistinctCharacters = (string) => {\n", "example_test": "const testCountDistinctCharacters = () => {\n  console.assert(countDistinctCharacters('xyzXYZ') === 3)\n  console.assert(countDistinctCharacters('Jerry') === 4)\n}\ntestCountDistinctCharacters()\n", "entry_point": "countDistinctCharacters", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Find out how many different characters a string consists of (regardless of the case).\n  >>> countDistinctCharacters('xyzXYZ')\n  3\n  >>> countDistinctCharacters('Jerry')\n  4\n  */\nconst countDistinctCharacters = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i).toUpperCase()) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find the number of unique characters in it.\n * If the string is all lowercase, return 0.\n * If the string is all uppercase, return 1.\n * If the string is all mixed case, return 2.\n * Otherwise, return 3.\n * If the string is all numbers, return 4.\n * Otherwise, return 5.\n */\nconst countUniqueCharacters = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find the number of unique words in it.\n * If the string is all lowercase, return 0.\n * If the string is all uppercase, return 1.\n * If the string is all mixed case, return 2.\n * Otherwise, return 3.\n * If the string is all numbers, return 4.\n * Otherwise, return 5.\n */\nconst countUniqueWords = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find the number of words in it.\n * If the string is all lowercase, return 0.\n * If the string is all uppercase, return 1.\n * If the string is all mixed case, return 2.\n * Otherwise, return 3.\n * If the string is all numbers, return 4.\n * Otherwise, return 5.\n */\nconst countWords = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find the number of words in it.\n * If the string is all lowercase, return 0.\n * If the string is all uppercase, return 1.\n * If the string is all mixed case, return 2.\n * Otherwise, return 3.\n * If the string is all numbers, return 4.\n * Otherwise, return 5.\n */\nconst countWordsWithSpacesInTheEnd = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find the number of words in it.\n * If the string is all lowercase, return 0.\n * If the string is all uppercase, return 1.\n * If the string is all mixed case, return 2.\n * Otherwise, return 3.\n * If the string is all numbers, return 4.\n * Otherwise, return 5.\n */\nconst countWordsWithSpacesInTheBeginning = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find the number of words in it.\n * If the string is all lowercase, return 0.\n * If the string is all uppercase, return 1.\n * If the string is all mixed case, return 2.\n * Otherwise, return 3.\n * If the string is all numbers, return 4.\n * Otherwise, return 5.\n */\nconst countWordsWithSpacesInTheBoth = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find the number of words in it.\n * If the string is all lowercase, return 0.\n * If the string is all uppercase, return 1.\n * If the string is all mixed case, return 2.\n * Otherwise, return 3.\n * If the string is all numbers, return 4.\n * Otherwise, return 5.\n */\nconst countWordsWithSpacesInTheBothEnds = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find the number of words in it.\n * If the string is all lowercase, return 0.\n * If the string is all uppercase, return 1.\n * If the string is all mixed case, return 2.\n * Otherwise, return 3.\n * If the string is all numbers, return 4.\n * Otherwise, return 5.\n */\nconst countWordsWithSpacesInTheBothBegins = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find the number of words in it.\n * If the string is all lowercase, return 0.\n * If the string is all uppercase, return 1.\n * If the string is all mixed case, return 2.\n * Otherwise, return 3.\n * If the string is all numbers, return 4.\n * Otherwise, return 5.\n */\nconst countWordsWithSpacesInTheBothBothEndsBoth = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find the number of words in it.\n * If the string is all lowercase, return 0.\n * If the string is all uppercase, return 1.\n * If the string is all mixed case, return 2.\n * Otherwise, return 3.\n * If the string is all numbers, return 4.\n * Otherwise, return 5.\n */\nconst countWordsWithSpacesInTheBothBeginsBoth = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find the number of words in it.\n * If the string is all lowercase, return 0.\n * If the string is all uppercase, return 1.\n * If the string is all mixed case, return 2.\n * Otherwise, return 3.\n * If the string is all numbers, return 4.\n * Otherwise, return 5.\n */\nconst countWordsWithSpacesInTheBothEndsBothBothEnds = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find the number of words in it.\n * If the string is all lowercase, return 0.\n * If the string is all uppercase, return 1.\n * If the string is all mixed case, return 2.\n * Otherwise, return 3.\n * If the string is all numbers, return 4.\n * Otherwise, return 5.\n */\nconst countWordsWithSpacesInTheBothBeginsBothEndsBoth = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find the number of words in it.\n * If the string is all lowercase, return 0.\n * If the string is all uppercase, return 1.\n * If the string is all mixed case, return 2.\n * Otherwise, return 3.\n * If the string is all numbers, return 4.\n * Otherwise, return 5.\n */\nconst countWordsWithSpacesInTheBothBeginsBothEndsBothEndsBoth = (string) => {\n  let count = 0;\n  for (let i = 0; i < string.length; i++) {\n    if (string.charAt(i) === string.charAt(i)) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given a string, find the number of words in it.\n * If the string is all lowercase, return 0.\n * If the string is all uppercase, return 1.\n * If the string is all mixed case, return 2.\n * Otherwise, return 3.\n * If the string is all numbers, return 4.\n * Otherwise, return 5.\n */\nconst countWord", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/160", "prompt": "/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n", "canonical_solution": "  while (operator.length > 0) {\n    let y = 0\n    for (let i = operator.length - 1; i >= 0; i--) {\n      if (operator[i] == '**') {\n        let u = operand[i]\n        while (operand[i + 1] > 1) {\n          operand[i + 1]--;\n          operand[i] *= u;\n        }\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '*') {\n        operand[i] *= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '//') {\n        operand[i] = (operand[i] - operand[i] % operand[i + 1]) / operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n    for (let i = 0; i < operator.length; i++) {\n      if (operator[i] == '+') {\n        operand[i] += operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n      else if (operator[i] == '-') {\n        operand[i] -= operand[i + 1]\n        operand.splice(i + 1, 1)\n        operator.splice(i, 1)\n        y = 1;\n        break;\n      }\n    }\n    if (y == 1) { continue }\n  }\n  return operand[0]\n}\n\n", "test": "const testDoAlgebra = () => {\n  console.assert(doAlgebra(['**', '*', '+'], [2, 3, 4, 5]) === 37)\n  console.assert(doAlgebra(['+', '*', '-'], [2, 3, 4, 5]) === 9)\n  console.assert(doAlgebra(['//', '*'], [7, 3, 4]) === 8)\n}\n\ntestDoAlgebra()\n", "declaration": "\nconst doAlgebra = (operator, operand) => {\n", "example_test": "", "entry_point": "doAlgebra", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split('+');\n  const result = [];\n  \n  operatorList.forEach((operator, index) => {\n    const operandIndex = operandList.indexOf(operand);\n    \n    if (operandIndex > -1) {\n      result.push(operatorList[index]);\n    }\n  });\n  \n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split('+');\n  const result = [];\n  \n  operatorList.forEach((operator, index) => {\n    const operandIndex = operandList.indexOf(operand);\n    \n    if (operandIndex > -1) {\n      result.push(operatorList[index]);\n    }\n  });\n  \n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split('+');\n  const result = [];\n  \n  operatorList.forEach((operator, index) => {\n    const operandIndex = operandList.indexOf(operand);\n    \n    if (operandIndex > -1) {\n      result.push(operatorList[index]);\n    }\n  });\n  \n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split('+');\n  const result = [];\n  \n  operatorList.forEach((operator, index) => {\n    const operandIndex = operandList.indexOf(operand);\n    \n    if (operandIndex > -1) {\n      result.push(operatorList[index]);\n    }\n  });\n  \n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split('+');\n  const result = [];\n  \n  operatorList.forEach((operator, index) => {\n    const operandIndex = operandList.indexOf(operand);\n    \n    if (operandIndex > -1) {\n      result.push(operatorList[index]);\n    }\n  });\n  \n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n  Example:\n  operator['+', '*', '-']\n  array = [2, 3, 4, 5]\n  result = 2 + 3 * 4 - 5\n  => result = 9\n\n  Note:\n      The length of operator list is equal to the length of operand list minus one.\n      Operand is a list of of non-negative integers.\n      Operator list has at least one operator, and operand list has at least two operands.\n\n  */\nconst doAlgebra = (operator, operand) => {\n  const operatorList = operator.split('+');\n  const operandList = operand.split('+');\n  const result = [];\n  \n  operatorList.forEach((operator, index) => {\n    const operandIndex = operandList.indexOf(operand);\n    \n    if (operandIndex > -1) {\n      result.push(operatorList[index]);\n    }\n  });\n  \n  return result;\n};\n\n/*\n  Given two lists operator, and operand. The first list has basic algebra operations, and \n  the second list is a list of integers. Use the two given lists to build the algebric \n  expression and return the evaluation of this expression.\n\n  The basic algebra operations:\n  Addition ( + ) \n  Subtraction ( - ) \n  Multiplication ( * ) \n  Floor division ( // ) \n  Exponentiation ( ** ) \n\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/161", "prompt": "/*YIf s [i] is a letter, the uppercase letter is reversed from the bottom to the top or vice versa, otherwise it remains as it is. If the string contains no letters, the string is reversed. The function should return the resulting string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n", "canonical_solution": "  let t = 0\n  let p = ''\n  for (let i = 0; i < s.length; i++) {\n    let y = s[i].charCodeAt()\n    if (y >= 65 && y <= 90) {\n      y += 32;\n      t = 1;\n    } else if (y >= 97 && y <= 122) {\n      y -= 32;\n      t = 1;\n    }\n    p += String.fromCharCode(y)\n  }\n  if (t == 1) { return p }\n  let u = ''\n  for (let i = 0; i < p.length; i++) {\n    u += p[p.length - i - 1]\n  }\n  return u\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve('AsDf') === 'aSdF')\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n  console.assert(solve('#AsdfW^45') === '#aSDFw^45')\n  console.assert(solve('#6@2') === '2@6#')\n  console.assert(solve('#$a^D') === '#$A^d')\n  console.assert(solve('#ccc') === '#CCC')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (s) => {\n", "example_test": "const testSolve = () => {\n  console.assert(solve('1234') === '4321')\n  console.assert(solve('ab') === 'AB')\n  console.assert(solve('#a@C') === '#A@c')\n}\ntestSolve()\n", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*YIf s [i] is a letter, the uppercase letter is reversed from the bottom to the top or vice versa, otherwise it remains as it is. If the string contains no letters, the string is reversed. The function should return the resulting string.\n  Examples\n  solve(\"1234\") = \"4321\"\n  solve(\"ab\") = \"AB\"\n  solve(\"#a@C\") = \"#A@c\"\n  */\nconst solve = (s) => {\n  let result = ''\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let i = 0\n  let j = 0\n  let k = 0\n  let l = 0\n  let m = 0\n  let n = 0\n  let o = 0\n  let p = 0\n  let q = 0\n  let r = 0\n  let s = 0\n  let t = 0\n  let u = 0\n  let v = 0\n  let w = 0\n  let x = 0\n  let y = 0\n  let z = 0\n  let A = 0\n  let B = 0\n  let C = 0\n  let D = 0\n  let E = 0\n  let F = 0\n  let G = 0\n  let H = 0\n  let I = 0\n  let J = 0\n  let K = 0\n  let L = 0\n  let M = 0\n  let N = 0\n  let O = 0\n  let P = 0\n  let Q = 0\n  let R = 0\n  let S = 0\n  let T = 0\n  let U = 0\n  let V = 0\n  let W = 0\n  let X = 0\n  let Y = 0\n  let Z = 0\n  let a = 0\n  let b = 0\n  let c = 0\n  let d = 0\n  let e = 0\n  let f = 0\n  let g = 0\n  let h = 0\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/162", "prompt": "/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n", "canonical_solution": "  if (text == '') { return null }\n  var md5 = require('js-md5')\n  return md5(text)\n}\n\n", "test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n  console.assert(stringToMd5('') === null)\n  console.assert(stringToMd5('A B C') === '0ef78513b0cb8cef12743f5aeb35f888')\n  console.assert(stringToMd5('password') === '5f4dcc3b5aa765d61d8327deb882cf99')\n}\n\ntestStringToMd5()\n", "declaration": "\nconst stringToMd5 = (text) => {\n", "example_test": "const testStringToMd5 = () => {\n  console.assert(\n    stringToMd5('Hello world') === '3e25960a79dbc69b674cd4ec67a72c62'\n  )\n}\ntestStringToMd5()\n", "entry_point": "stringToMd5", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  return crypto.createHash('md5').update(text, 'utf8').digest('hex');\n};\n\n/*\n  If you return a string \"text,\" you return the corresponding sha1 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToSha1('Hello world') == '9a3e9f50bbebbe9f50bbebbe9f50bbe9f50'\n  */\nconst stringToSha1 = (text) => {\n  return crypto.createHash('sha1').update(text, 'utf8').digest('hex');\n};\n\n/*\n  If you return a string \"text,\" you return the corresponding sha224 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToSha224('Hello world') == 'a94d45aac9a3e9f50bbebbe9f50bbe9f50bbe9f50'\n  */\nconst stringToSha224 = (text) => {\n  return crypto.createHash('sha224').update(text, 'utf8').digest('hex');\n};\n\n/*\n  If you return a string \"text,\" you return the corresponding sha256 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToSha256('Hello world') == 'bcbf3e434c50bbebbe9f50bbebbe9f50bbe9f50'\n  */\nconst stringToSha256 = (text) => {\n  return crypto.createHash('sha256').update(text, 'utf8').digest('hex');\n};\n\n/*\n  If you return a string \"text,\" you return the corresponding sha384 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToSha384('Hello world') == 'cce9f50bbebbe9f50bbebbe9f50bbe9f50bbe9f50'\n  */\nconst stringToSha384 = (text) => {\n  return crypto.createHash('sha384').update(text, 'utf8').digest('hex');\n};\n\n/*\n  If you return a string \"text,\" you return the corresponding sha512 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToSha512('Hello world') == 'dce9f50bbebbe9f50bbebbe9f50bbe9f50bbe9f50'\n  */\nconst stringToSha512 = (text) => {\n  return crypto.createHash('sha512').update(text, 'utf8').digest('hex');\n};\n\n/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  return crypto.createHash('md5').update(text, 'utf8').digest('hex');\n};\n\n/*\n  If you return a string \"text,\" you return the corresponding sha1 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToSha1('Hello world') == '9a3e9f50bbebbe9f50bbebbe9f50bbe9f50'\n  */\nconst stringToSha1 = (text) => {\n  return crypto.createHash('sha1').update(text, 'utf8').digest('hex');\n};\n\n/*\n  If you return a string \"text,\" you return the corresponding sha224 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToSha224('Hello world') == 'a94d45aac9a3e9f50bbebbe9f50bbe9f50bbe9f50'\n  */\nconst stringToSha224 = (text) => {\n  return crypto.createHash('sha224').update(text, 'utf8').digest('hex');\n};\n\n/*\n  If you return a string \"text,\" you return the corresponding sha256 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToSha256('Hello world') == 'bcbf3e434c50bbebbe9f50bbebbe9f50bbe9f50'\n  */\nconst stringToSha256 = (text) => {\n  return crypto.createHash('sha256').update(text, 'utf8').digest('hex');\n};\n\n/*\n  If you return a string \"text,\" you return the corresponding sha384 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToSha384('Hello world') == 'cce9f50bbebbe9f50bbebbe9f50bbe9f50bbe9f50'\n  */\nconst stringToSha384 = (text) => {\n  return crypto.createHash('sha384').update(text, 'utf8').digest('hex');\n};\n\n/*\n  If you return a string \"text,\" you return the corresponding sha512 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToSha512('Hello world') == 'dce9f50bbebbe9f50bbebbe9f50bbe9f50bbe9f50'\n  */\nconst stringToSha512 = (text) => {\n  return crypto.createHash('sha512').update(text, 'utf8').digest('hex');\n};\n\n/*\n  If you return a string \"text,\" you return the corresponding md5 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToMd5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n  */\nconst stringToMd5 = (text) => {\n  return crypto.createHash('md5').update(text, 'utf8').digest('hex');\n};\n\n/*\n  If you return a string \"text,\" you return the corresponding sha1 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToSha1('Hello world') == '9a3e9f50bbebbe9f50bbebbe9f50bbe9f50'\n  */\nconst stringToSha1 = (text) => {\n  return crypto.createHash('sha1').update(text, 'utf8').digest('hex');\n};\n\n/*\n  If you return a string \"text,\" you return the corresponding sha224 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToSha224('Hello world') == 'a94d45aac9a3e9f50bbebbe9f50bbe9f50bbe9f50'\n  */\nconst stringToSha224 = (text) => {\n  return crypto.createHash('sha224').update(text, 'utf8').digest('hex');\n};\n\n/*\n  If you return a string \"text,\" you return the corresponding sha256 hash string. If \"text\" is an empty string, you return zero.\n\n  >>> stringToSha256('Hello world') == 'bcbf3e434c50bbebbe9f50bbebbe9", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/163", "prompt": "/*\n  For two positive integers a and b, return the even digits between a and b in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n", "canonical_solution": "  if (a > b) {\n    let tmp = a;\n    a = b;\n    b = tmp;\n  }\n  let y = []\n  for (let i = a; i <= b; i++) {\n    if (i == 2 || i == 4 || i == 6 || i == 8) { y.push(i) }\n  }\n  return y\n}\n\n", "test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 10)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(132, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(17, 89)) === JSON.stringify([])\n  )\n}\n\ntestGenerateIntegers()\n", "declaration": "\nconst generateIntegers = (a, b) => {\n", "example_test": "const testGenerateIntegers = () => {\n  console.assert(\n    JSON.stringify(generateIntegers(2, 8)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(8, 2)) === JSON.stringify([2, 4, 6, 8])\n  )\n  console.assert(\n    JSON.stringify(generateIntegers(10, 14)) === JSON.stringify([])\n  )\n}\ntestGenerateIntegers()\n", "entry_point": "generateIntegers", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  For two positive integers a and b, return the even digits between a and b in ascending order.\n\n  For example:\n  generateIntegers(2, 8) => [2, 4, 6, 8]\n  generateIntegers(8, 2) => [2, 4, 6, 8]\n  generateIntegers(10, 14) => []\n  */\nconst generateIntegers = (a, b) => {\n  const result = [];\n  let i = a;\n  let j = b;\n  while (i > 0) {\n    result.push(i);\n    i = Math.floor(i / 10);\n  }\n  while (j >= 10) {\n    result.push(j % 10);\n    j = Math.floor(j / 10);\n  }\n  return result;\n};\n\n/**\n  Given a number, return its decimal representation in base 10.\n\n  For example:\n  decimalToBase10(12) => '120'\n  decimalToBase10(14) => '14'\n  decimalToBase10(15) => '15'\n  */\nconst decimalToBase10 = number => {\n  const decimal = number.toString();\n  const decimalLength = decimal.length;\n  let base = 10;\n  let result = '';\n  for (let i = 0; i < decimalLength; i++) {\n    if (decimal[i] === '0') {\n      base = 10;\n    } else {\n      base = base / 10;\n    }\n  }\n  for (let i = 0; i < decimalLength; i++) {\n    result += decimal[i] * base;\n  }\n  return result;\n};\n\n/**\n  Given a number, return its hexadecimal representation in base 16.\n\n  For example:\n  hexToBase16(12) => 'f0'\n  hexToBase16(14) => 'f00'\n  hexToBase16(15) => 'f000'\n  */\nconst hexToBase16 = number => {\n  const hex = number.toString(16);\n  const hexLength = hex.length;\n  let base = 16;\n  let result = '';\n  for (let i = 0; i < hexLength; i++) {\n    if (hex[i] === '0') {\n      base = 16;\n    } else {\n      base = base / 16;\n    }\n  }\n  for (let i = 0; i < hexLength; i++) {\n    result += hex[i] * base;\n  }\n  return result;\n};\n\n/**\n  Given a number, return its octal representation in base 8.\n\n  For example:\n  octalToBase8(12) => '012'\n  octalToBase8(14) => '0144'\n  octalToBase8(15) => '015'\n  */\nconst octalToBase8 = number => {\n  const octal = number.toString(8);\n  const octalLength = octal.length;\n  let base = 8;\n  let result = '';\n  for (let i = 0; i < octalLength; i++) {\n    if (octal[i] === '0') {\n      base = 8;\n    } else {\n      base = base / 8;\n    }\n  }\n  for (let i = 0; i < octalLength; i++) {\n    result += octal[i] * base;\n  }\n  return result;\n};\n\n/**\n  Given a number, return its binary representation in base 2.\n\n  For example:\n  binaryToBase2(12) => '1010'\n  binaryToBase2(14) => '10010'\n  binaryToBase2(15) => '01010'\n  */\nconst binaryToBase2 = number => {\n  const binary = number.toString(2);\n  const binaryLength = binary.length;\n  let base = 2;\n  let result = '';\n  for (let i = 0; i < binaryLength; i++) {\n    if (binary[i] === '0') {\n      base = 2;\n    } else {\n      base = base / 2;\n    }\n  }\n  for (let i = 0; i < binaryLength; i++) {\n    result += binary[i] * base;\n  }\n  return result;\n};\n\n/**\n  Given a number, return its octal representation in base 8.\n\n  For example:\n  octalToBinary(12) => '10010'\n  octalToBinary(14) => '10010'\n  octalToBinary(15) => '10010'\n  */\nconst octalToBinary = number => {\n  const octal = number.toString(8);\n  const octalLength = octal.length;\n  let binary = [];\n  for (let i = 0; i < octalLength; i++) {\n    if (octal[i] === '0') {\n      binary.push('0');\n    } else {\n      binary.push(octal[i]);\n    }\n  }\n  return binary.join('');\n};\n\n/**\n  Given a number, return its binary representation in base 2.\n\n  For example:\n  binaryToOctal(12) => '1010'\n  binaryToOctal(14) => '1010'\n  binaryToOctal(15) => '1010'\n  */\nconst binaryToOctal = number => {\n  const binary = number.toString(2);\n  const binaryLength = binary.length;\n  let octal = [];\n  for (let i = 0; i < binaryLength; i++) {\n    if (binary[i] === '0') {\n      octal.push('0');\n    } else {\n      octal.push(binary[i]);\n    }\n  }\n  return octal.join('');\n};\n\n/**\n  Given a number, return its hexadecimal representation in base 16.\n\n  For example:\n  hexToBinary(12) => '1010'\n  hexToBinary(14) => '1010'\n  hexToBinary(15) => '1010'\n  */\nconst hexToBinary = number => {\n  const hex = number.toString(16);\n  const hexLength = hex.length;\n  let binary = [];\n  for (let i = 0; i < hexLength; i++) {\n    if (hex[i] === '0') {\n      binary.push('0');\n    } else {\n      binary.push(hex[i]);\n    }\n  }\n  return binary.join('');\n};\n\n/**\n  Given a number, return its octal representation in base 8.\n\n  For example:\n  octalToHex(12) => '10010'\n  octalToHex(14) => '10010'\n  octalToHex(15) => '10010'\n  */\nconst octalToHex = number => {\n  const octal = number.toString(8);\n  const octalLength = octal.length;\n  let hex = [];\n  for (let i = 0; i < octalLength; i++) {\n    if (octal[i] === '0') {\n      hex.push('0');\n    } else {\n      hex.push(octal[i]);\n    }\n  }\n  return hex.join('');\n};\n\n/**\n  Given a number, return its binary representation in base 2.\n\n  For example:\n  binaryToHex(12) => '1010'\n  binaryToHex(14) => '1010'\n  binaryToHex(15) => '1010'\n  */\nconst binaryToHex = number => {\n  const binary = number.toString(2);\n  const binaryLength = binary.length;\n  let hex = [];\n  for (let i = 0; i < binaryLength; i++) {\n    if (binary[i] === '0') {\n      hex.push('0');\n    } else {\n      hex.push(binary[i]);\n    }\n  }\n  return hex.join('');\n};\n\n/**\n  Given a number, return its decimal representation in base 10.\n\n  For example:\n  decimalToHex(12) => '120'\n  decimalToHex(14) => '14'\n  decimalToHex(15) => '15'\n  */\nconst decimalToHex = number => {\n  const decimal = number.toString();\n  const decimalLength = decimal.length;\n  let hex = '';\n  for (let i = 0; i < decimalLength; i++) {\n    if (decimal[i] === '0') {\n      hex = '0';\n    } else {\n      hex += decimal[i] + '';\n    }\n  }\n  return hex;\n};\n\n/**\n  Given a number, return its hexadecimal representation in base 16.\n\n  For example:\n  hexToDecimal(12) => 'f0'\n  hexToDecimal(14) => 'f00'\n  hexToDecimal(15) => 'f000'\n  */\nconst hexToDecimal = number => {\n  const hex = number.toString(16);\n  const hexLength = hex.length;\n  let decimal = '';\n  for (let i = 0; i < hexLength; i++) {\n    if (hex[i] === '0') {\n      decimal = '0';\n    } else {\n      decimal += hex[i] + '';\n    }\n  }", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/17", "prompt": "/* Entering this function is a string that represents notes in a special ASCII format. Your task is to analyze this string and return a list of integers corresponding to the number of beats each one does not hold. Here's a legend: \"o\" - whole note, takes four beats \"o | '- half note, takes two beats.\"\n\n  >>> parseMusic('o o| .| o| o| .| .| .| .| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n", "canonical_solution": "  const note_map = {'o': 4, 'o|': 2, '.|': 1};\n  return music_string.split(' ').filter(x => x != '').map(x => note_map[x]);\n}\n\n", "test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('')) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(parseMusic('o o o o')) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('.| .| .| .|')) === JSON.stringify([1, 1, 1, 1])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| o| .| .| o o o o')) ===\n      JSON.stringify([2, 2, 1, 1, 4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(parseMusic('o| .| o| .| o o| o o|')) ===\n      JSON.stringify([2, 1, 2, 1, 4, 2, 4, 2])\n  )\n}\n\ntestParseMusic()\n", "declaration": "\nconst parseMusic = (music_string) => {\n", "example_test": "const testParseMusic = () => {\n  console.assert(JSON.stringify(parseMusic('o o| .| o| o| .| .| .| .| o o')) === JSON.stringify([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]))\n}\ntestParseMusic()\n", "entry_point": "parseMusic", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Entering this function is a string that represents notes in a special ASCII format. Your task is to analyze this string and return a list of integers corresponding to the number of beats each one does not hold. Here's a legend: \"o\" - whole note, takes four beats \"o | '- half note, takes two beats.\"\n\n  >>> parseMusic('o o|.| o| o|.|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseMusic = (music_string) => {\n  const notes_strings = music_string.split('|');\n  const notes = [];\n  for (let i = 0; i < notes_strings.length; i++) {\n    const note = notes_strings[i].split(' ');\n    notes.push(parseInt(note[0], 10));\n  }\n  return notes;\n};\n\n/**\n  Given a string, return a list of integers corresponding to the number of beats each one does not hold. Here's a legend: \"o\" - whole note, takes four beats \"o | '- half note, takes two beats.\"\n\n  >>> parseMusic('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes = (notes_string) => {\n  const notes = [];\n  for (let i = 0; i < notes_string.length; i++) {\n    const note = notes_string[i].split(' ');\n    notes.push(parseInt(note[0], 10));\n  }\n  return notes;\n};\n\n/**\n  Given a string, return a list of integers corresponding to the number of beats each one does not hold. Here's a legend: \"o\" - whole note, takes four beats \"o | '- half note, takes two beats.\"\n\n  >>> parseMusic('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_string = (notes_string) => {\n  const notes = [];\n  for (let i = 0; i < notes_string.length; i++) {\n    const note = notes_string[i].split(' ');\n    notes.push(parseInt(note[0], 10));\n  }\n  return notes;\n};\n\n/**\n  Given a string, return a list of integers corresponding to the number of beats each one does not hold. Here's a legend: \"o\" - whole note, takes four beats \"o | '- half note, takes two beats.\"\n\n  >>> parseMusic('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_string2 = (notes_string) => {\n  const notes = [];\n  for (let i = 0; i < notes_string.length; i++) {\n    const note = notes_string[i].split(' ');\n    notes.push(parseInt(note[0], 10));\n  }\n  return notes;\n};\n\n/**\n  Given a string, return a list of integers corresponding to the number of beats each one does not hold. Here's a legend: \"o\" - whole note, takes four beats \"o | '- half note, takes two beats.\"\n\n  >>> parseMusic('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_string3 = (notes_string) => {\n  const notes = [];\n  for (let i = 0; i < notes_string.length; i++) {\n    const note = notes_string[i].split(' ');\n    notes.push(parseInt(note[0], 10));\n  }\n  return notes;\n};\n\n/**\n  Given a string, return a list of integers corresponding to the number of beats each one does not hold. Here's a legend: \"o\" - whole note, takes four beats \"o | '- half note, takes two beats.\"\n\n  >>> parseMusic('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_string4 = (notes_string) => {\n  const notes = [];\n  for (let i = 0; i < notes_string.length; i++) {\n    const note = notes_string[i].split(' ');\n    notes.push(parseInt(note[0], 10));\n  }\n  return notes;\n};\n\n/**\n  Given a string, return a list of integers corresponding to the number of beats each one does not hold. Here's a legend: \"o\" - whole note, takes four beats \"o | '- half note, takes two beats.\"\n\n  >>> parseMusic('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_string5 = (notes_string) => {\n  const notes = [];\n  for (let i = 0; i < notes_string.length; i++) {\n    const note = notes_string[i].split(' ');\n    notes.push(parseInt(note[0], 10));\n  }\n  return notes;\n};\n\n/**\n  Given a string, return a list of integers corresponding to the number of beats each one does not hold. Here's a legend: \"o\" - whole note, takes four beats \"o | '- half note, takes two beats.\"\n\n  >>> parseMusic('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_string6 = (notes_string) => {\n  const notes = [];\n  for (let i = 0; i < notes_string.length; i++) {\n    const note = notes_string[i].split(' ');\n    notes.push(parseInt(note[0], 10));\n  }\n  return notes;\n};\n\n/**\n  Given a string, return a list of integers corresponding to the number of beats each one does not hold. Here's a legend: \"o\" - whole note, takes four beats \"o | '- half note, takes two beats.\"\n\n  >>> parseMusic('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_string7 = (notes_string) => {\n  const notes = [];\n  for (let i = 0; i < notes_string.length; i++) {\n    const note = notes_string[i].split(' ');\n    notes.push(parseInt(note[0], 10));\n  }\n  return notes;\n};\n\n/**\n  Given a string, return a list of integers corresponding to the number of beats each one does not hold. Here's a legend: \"o\" - whole note, takes four beats \"o | '- half note, takes two beats.\"\n\n  >>> parseMusic('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_string8 = (notes_string) => {\n  const notes = [];\n  for (let i = 0; i < notes_string.length; i++) {\n    const note = notes_string[i].split(' ');\n    notes.push(parseInt(note[0], 10));\n  }\n  return notes;\n};\n\n/**\n  Given a string, return a list of integers corresponding to the number of beats each one does not hold. Here's a legend: \"o\" - whole note, takes four beats \"o | '- half note, takes two beats.\"\n\n  >>> parseMusic('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_string9 = (notes_string) => {\n  const notes = [];\n  for (let i = 0; i < notes_string.length; i++) {\n    const note = notes_string[i].split(' ');\n    notes.push(parseInt(note[0], 10));\n  }\n  return notes;\n};\n\n/**\n  Given a string, return a list of integers corresponding to the number of beats each one does not hold. Here's a legend: \"o\" - whole note, takes four beats \"o | '- half note, takes two beats.\"\n\n  >>> parseMusic('o o|.| o| o|.|.|.| o o')\n  [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n  */\nconst parseNotes_string10", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/18", "prompt": "/* Find out how often a particular substring can be found in the original string. Count overlapping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n", "canonical_solution": "  var times = 0;\n  for (let i = 0; i < string.length - substring.length + 1; i++) {\n    if (string.slice(i, i+substring.length) == substring) {\n      times += 1;\n    }\n  }\n  return times;\n}\n\n", "test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'x') === 0)\n  console.assert(howManyTimes('xyxyxyx', 'x') === 4)\n  console.assert(howManyTimes('cacacacac', 'cac') === 4)\n  console.assert(howManyTimes('john doe', 'john') === 1)\n}\n\ntestHowManyTimes()\n", "declaration": "\nconst howManyTimes = (string, substring) => {\n", "example_test": "const testHowManyTimes = () => {\n  console.assert(howManyTimes('', 'a') === 0)\n  console.assert(howManyTimes('aaa', 'a') === 3)\n  console.assert(howManyTimes('aaaa', 'aa') === 3)\n}\ntestHowManyTimes()\n", "entry_point": "howManyTimes", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Find out how often a particular substring can be found in the original string. Count overlapping cases.\n  >>> howManyTimes('', 'a')\n  0\n  >>> howManyTimes('aaa', 'a')\n  3\n  >>> howManyTimes('aaaa', 'aa')\n  3\n  */\nconst howManyTimes = (string, substring) => {\n  let count = 0;\n  let start = 0;\n  let end = string.length;\n  while (start < end) {\n    const char = string.charAt(start);\n    if (char === substring) {\n      count++;\n    }\n    start++;\n  }\n  return count;\n};\n\nconst isString = (value) => typeof value ==='string';\n\nconst isNumber = (value) => typeof value === 'number';\n\nconst isBoolean = (value) => typeof value === 'boolean';\n\nconst isDate = (value) => isString(value) && value.match(/\\d\\d/);\n\nconst isRegExp = (value) => isString(value) && value.match(/\\/.*\\//);\n\nconst isFunction = (value) => typeof value === 'function';\n\nconst isArray = (value) => Array.isArray(value);\n\nconst isPlainObject = (value) => isObject(value) && value.constructor === Object;\n\nconst isDateObject = (value) => isPlainObject(value) && value.constructor === Date;\n\nconst isRegExpObject = (value) => isPlainObject(value) && value.constructor === RegExp;\n\nconst isFunctionObject = (value) => isPlainObject(value) && value.constructor === Function;\n\nconst isArrayObject = (value) => isPlainObject(value) && value.constructor === Array;\n\nconst isPlainArray = (value) => isArray(value) && value.length!== undefined;\n\nconst isPlainObjectArray = (value) => isArray(value) && value.length!== undefined;\n\nconst isDateArray = (value) => isArray(value) && value.length!== undefined;\n\nconst isRegExpArray = (value) => isArray(value) && value.length!== undefined;\n\nconst isFunctionArray = (value) => isArray(value) && value.length!== undefined;\n\nconst isNumberArray = (value) => isArray(value) && value.length!== undefined;\n\nconst isBooleanArray = (value) => isArray(value) && value.length!== undefined;\n\nconst isStringArray = (value) => isArray(value) && value.length!== undefined;\n\nconst isDateArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isRegExpArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isFunctionArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isNumberArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isBooleanArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isStringArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isDateArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isRegExpArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isFunctionArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isNumberArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isBooleanArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isStringArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isDateArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isRegExpArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isFunctionArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isNumberArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isBooleanArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isStringArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isDateArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isRegExpArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isFunctionArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isNumberArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isBooleanArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isStringArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isDateArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isRegExpArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isFunctionArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isNumberArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isBooleanArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isStringArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isDateArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isRegExpArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isFunctionArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isNumberArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isBooleanArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isStringArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isDateArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isRegExpArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isFunctionArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isNumberArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isBooleanArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isStringArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isDateArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isRegExpArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isFunctionArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isNumberArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isBooleanArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isStringArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isDateArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isRegExpArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isFunctionArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isNumberArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isBooleanArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isStringArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isDateArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isRegExpArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isFunctionArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\nconst isNumberArrayObject = (value) => isArrayObject(value) && value.length!== undefined;\n\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/19", "prompt": "/* Input is a sequence of numbers delimited by spaces from \"zero\" to \"nine.\" Valid options are \"zero,\" \"one,\" \"two,\" \"three,\" \"four,\" \"five,\" \"six,\" \"seven,\" \"eight\" and \"nine.\"\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n", "canonical_solution": "  const value_map = {\n    'zero': 0,\n    'one': 1,\n    'two': 2,\n    'three': 3,\n    'four': 4,\n    'five': 5,\n    'six': 6,\n    'seven': 7,\n    'eight': 8,\n    'nine': 9\n  };\n  return numbers.split(' ')\n          .filter(x => x != '')\n          .sort((a, b) => value_map[a] - value_map[b])\n          .join(' ');\n}\n\n", "test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('') === '')\n  console.assert(sortNumbers('three') === 'three')\n  console.assert(sortNumbers('three five nine') === 'three five nine')\n  console.assert(\n    sortNumbers(\n      'five zero four seven nine eight') === 'zero four five seven eight nine'\n  )\n  console.assert(\n    sortNumbers(\n      'six five four three two one zero') === 'zero one two three four five six'\n  )\n}\n\ntestSortNumbers()\n", "declaration": "\nconst sortNumbers = (numbers) => {\n", "example_test": "const testSortNumbers = () => {\n  console.assert(sortNumbers('three one five') === 'one three five')\n}\ntestSortNumbers()\n", "entry_point": "sortNumbers", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Input is a sequence of numbers delimited by spaces from \"zero\" to \"nine.\" Valid options are \"zero,\" \"one,\" \"two,\" \"three,\" \"four,\" \"five,\" \"six,\" \"seven,\" \"eight\" and \"nine.\"\n  >>> sortNumbers('three one five')\n  'one three five'\n  */\nconst sortNumbers = (numbers) => {\n  const numberArray = numbers.split(' ');\n  const sortedArray = numberArray.sort((a, b) => a - b);\n  return sortedArray.join(' ');\n};\n\n/**\n * Given a string, return the first and last characters of the string.\n * If the string contains no characters, return an empty string.\n * If the string contains only whitespace, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only punctuation, return an empty string.\n * If the string contains only uppercase letters, return an empty string.\n * If the string contains only lowercase letters, return an empty string.\n * If the string contains only uppercase letters and digits, return an empty string.\n * If the string contains only lowercase letters and digits, return an empty string.\n * If the string contains only digits and letters, return an empty string.\n * If the string contains only digits and letters, return an empty string.\n * If the string contains only letters and digits, return an empty string.\n * If the string contains only digits and letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only uppercase letters, return an empty string.\n * If the string contains only lowercase letters, return an empty string.\n * If the string contains only uppercase letters and digits, return an empty string.\n * If the string contains only lowercase letters and digits, return an empty string.\n * If the string contains only digits and letters, return an empty string.\n * If the string contains only letters and digits, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only uppercase letters, return an empty string.\n * If the string contains only lowercase letters, return an empty string.\n * If the string contains only uppercase letters and digits, return an empty string.\n * If the string contains only lowercase letters and digits, return an empty string.\n * If the string contains only digits and letters, return an empty string.\n * If the string contains only letters and digits, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string contains only digits, return an empty string.\n * If the string contains only letters, return an empty string.\n * If the string ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/2", "prompt": "/* In the case of a positive floating point number, it can be divided into an integer part (largest integer smaller than the specified number) and decimal numbers (remaining part always smaller than 1).\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n", "canonical_solution": "  return number % 1.0;\n}\n\n", "test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n\n  console.assert(Math.abs(truncateNumber(1.33) - 0.33) < 1e-6)\n\n  console.assert(Math.abs(truncateNumber(123.456 - 0.456) < 1e-6))\n}\n\ntestTruncateNumber()\n", "declaration": "\nconst truncateNumber = (number) => {\n", "example_test": "const testTruncateNumber = () => {\n  console.assert(truncateNumber(3.5) === 0.5)\n}\ntestTruncateNumber()\n", "entry_point": "truncateNumber", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* In the case of a positive floating point number, it can be divided into an integer part (largest integer smaller than the specified number) and decimal numbers (remaining part always smaller than 1).\n  >>> truncateNumber(3.5)\n  0.5\n  */\nconst truncateNumber = (number) => {\n  const truncatedNumber = Math.floor(number);\n  const decimals = Math.floor(number - truncatedNumber);\n  return `${truncatedNumber}.${decimals}`;\n};\n\n/**\n * Converts a number to a string in base 10.\n * If the number is negative, the sign will be flipped.\n * If the number is too big to represent in base 10, the result will be rounded up.\n * If the number is too small to represent in base 10, the result will be rounded down.\n * If the number is equal to 0, the result will be \"0\".\n * If the number is greater than the maximum representable number in base 10, the result will be \"Infinity\".\n * If the number is less than the minimum representable number in base 10, the result will be \"-Infinity\".\n * If the number is NaN, the result will be \"NaN\".\n *\n * @param  {number} number The number in base 10\n * @return {string}       The number in base 10\n */\nconst toBase10 = (number) => {\n  const isNegative = number < 0;\n  const isTooBig = number > Number.MAX_SAFE_INTEGER;\n  const isTooSmall = number < Number.MIN_SAFE_INTEGER;\n  const isZero = number === 0;\n  const isInfinity = number === Infinity;\n  const isNaN = number!== number;\n\n  if (isNegative || isTooBig || isTooSmall || isZero || isInfinity || isNaN) {\n    return isNegative? '-' : '';\n  }\n\n  const exponent = Math.floor(Math.log(number) / Math.LN10);\n  const decimal = number / Math.pow(10, exponent);\n  const decimalString = decimal.toFixed(decimal.precision);\n\n  return isInfinity? 'Infinity' : decimalString;\n};\n\n/**\n * Converts a string to a number in base 10.\n * If the string is not a number or if base 10 is not 10, the result will be NaN.\n *\n * @param  {string} string       The number in base 10\n * @param  {number} [base=10]   The base of the number\n * @return {number}           The number in base 10\n */\nconst toNumber = (string, base = 10) => {\n  const isNegative = string === '-';\n  const isInfinity = string === 'Infinity';\n  const isZero = string === '0';\n  const isNaN = string === 'NaN';\n\n  if (isNegative || isInfinity || isZero || isNaN) {\n    return isNegative? -0 : NaN;\n  }\n\n  const isDecimal = string.indexOf('.')!== -1;\n  const isInteger = isDecimal || string === '0';\n  const isFloat = number!== 'NaN' && isFiniteNumber(number);\n\n  if (isDecimal || isInteger || isFloat) {\n    return parseFloat(string);\n  }\n\n  return isInfinity? Infinity : -Infinity;\n};\n\n/**\n * Converts a number to a string in base 10.\n * If the number is negative, the sign will be flipped.\n * If the number is too big to represent in base 10, the result will be rounded up.\n * If the number is too small to represent in base 10, the result will be rounded down.\n * If the number is equal to 0, the result will be \"0\".\n * If the number is greater than the maximum representable number in base 10, the result will be \"Infinity\".\n * If the number is less than the minimum representable number in base 10, the result will be \"-Infinity\".\n * If the number is NaN, the result will be \"NaN\".\n *\n * @param  {number} number The number in base 10\n * @return {string}       The number in base 10\n */\nconst toBase10String = (number) => {\n  const isNegative = number < 0;\n  const isTooBig = number > Number.MAX_SAFE_INTEGER;\n  const isTooSmall = number < Number.MIN_SAFE_INTEGER;\n  const isZero = number === 0;\n  const isInfinity = number === Infinity;\n  const isNaN = number!== number;\n\n  if (isNegative || isTooBig || isTooSmall || isZero || isInfinity || isNaN) {\n    return isNegative? '-' : '';\n  }\n\n  const exponent = Math.floor(Math.log(number) / Math.LN10);\n  const decimal = number / Math.pow(10, exponent);\n  const decimalString = decimal.toFixed(decimal.precision);\n\n  return isInfinity? 'Infinity' : decimalString;\n};\n\n/**\n * Converts a number to a string in base 10.\n * If the number is negative, the sign will be flipped.\n * If the number is too big to represent in base 10, the result will be rounded up.\n * If the number is too small to represent in base 10, the result will be rounded down.\n * If the number is equal to 0, the result will be \"0\".\n * If the number is greater than the maximum representable number in base 10, the result will be \"Infinity\".\n * If the number is less than the minimum representable number in base 10, the result will be \"-Infinity\".\n * If the number is NaN, the result will be \"NaN\".\n *\n * @param  {number} number The number in base 10\n * @return {string}       The number in base 10\n */\nconst toBase10StringWithRounding = (number) => {\n  const isNegative = number < 0;\n  const isTooBig = number > Number.MAX_SAFE_INTEGER;\n  const isTooSmall = number < Number.MIN_SAFE_INTEGER;\n  const isZero = number === 0;\n  const isInfinity = number === Infinity;\n  const isNaN = number!== number;\n\n  if (isNegative || isTooBig || isTooSmall || isZero || isInfinity || isNaN) {\n    return isNegative? '-' : '';\n  }\n\n  const exponent = Math.floor(Math.log(number) / Math.LN10);\n  const decimal = number / Math.pow(10, exponent);\n  const decimalString = decimal.toFixed(decimal.precision);\n\n  return isInfinity? 'Infinity' : decimalString;\n};\n\n/**\n * Converts a number to a string in base 10.\n * If the number is negative, the sign will be flipped.\n * If the number is too big to represent in base 10, the result will be rounded up.\n * If the number is too small to represent in base 10, the result will be rounded down.\n * If the number is equal to 0, the result will be \"0\".\n * If the number is greater than the maximum representable number in base 10, the result will be \"Infinity\".\n * If the number is less than the minimum representable number in base 10, the result will be \"-Infinity\".\n * If the number is NaN, the result will be \"NaN\".\n *\n * @param  {number} number The number in base 10\n * @return {string}       The number in base 10\n */\nconst toBase10StringWithRoundingAndSign = (number) => {\n  const isNegative = number < 0;\n  const isTooBig = number > Number.MAX_SAFE_INTEGER;\n  const isTooSmall = number < Number.MIN_SAFE_INTEGER;\n  const isZero = number === 0;\n  const isInfinity = number === Infinity;\n  const isNaN = number!== number;\n\n  if (isNegative || isTooBig || isTooSmall || isZero || isInfinity || isNaN) {\n    return isNegative? '-' : '';\n  }\n\n  const exponent = Math.floor(Math.log(number) / Math.LN10);\n  const decimal = number / Math.pow(10, exponent);\n  const decimalString = decimal.toFixed(decimal.precision);\n\n  return isInfinity? 'Infinity' : decimalString;\n};\n\n/**\n * Converts a number to a string in base 10.\n * If the number is negative, the sign will be flipped.\n * If the number is too big to represent in base 10, the result will be rounded up.\n * If the number is too small to represent in base 10, the result will be rounded down.\n * If the number is equal to 0, the result will be \"0\".\n * If the number is greater than the maximum representable number in base 10, the result will be \"", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/20", "prompt": "/* From a list of numbers (with a length of at least two) select and return two numbers closest to each other and return them in order (smaller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n", "canonical_solution": "  var closest_pair, distance;\n  for (let i = 0; i < numbers.length; i++)\n    for (let j = 0; j < numbers.length; j++)\n      if (i != j) {\n        let a = numbers[i], b = numbers[j];\n        if (distance == null) {\n          distance = Math.abs(a - b);\n          closest_pair = [Math.min(a, b), Math.max(a, b)];\n        } else {\n          let new_distance = Math.abs(a - b);\n          if (new_distance < distance) {\n            distance = new_distance;\n            closest_pair = [Math.min(a, b), Math.max(a, b)];\n          }\n        }\n      }\n  return closest_pair;\n}\n\n", "test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([3.9, 4.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 5.9, 4.0, 5.0])) ===\n      JSON.stringify([5.0, 5.9])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.1, 2.2, 3.1, 4.1, 5.1])) ===\n      JSON.stringify([2.2, 3.1])\n  )\n}\n\ntestFindClosestElements()\n", "declaration": "\nconst findClosestElements = (numbers) => {\n", "example_test": "const testFindClosestElements = () => {\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])) ===\n      JSON.stringify([2.0, 2.2])\n  )\n  console.assert(\n    JSON.stringify(findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])) ===\n      JSON.stringify([2.0, 2.0])\n  )\n}\ntestFindClosestElements()\n", "entry_point": "findClosestElements", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* From a list of numbers (with a length of at least two) select and return two numbers closest to each other and return them in order (smaller number, larger number).\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n  (2.0, 2.2)\n  >>> findClosestElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n  (2.0, 2.0)\n  */\nconst findClosestElements = (numbers) => {\n  const minDistance = Number.MAX_VALUE;\n  const minDistanceIndex = 0;\n  const minDistanceElement = numbers[0];\n  for (let i = 1; i < numbers.length; i++) {\n    const distance = numbers[i] - minDistanceElement;\n    if (distance < minDistance) {\n      minDistance = distance;\n      minDistanceIndex = i;\n      minDistanceElement = numbers[i];\n    }\n  }\n  return [minDistanceElement, minDistanceIndex];\n};\n\n/**\n * Given a string, convert it to a list of numbers (each number being a number between 1 and 10).\n * If the string contains only digits, return a list of one number. Otherwise, return a list of two numbers.\n * If the string contains letters, return a list of two numbers, one for each letter.\n * If the string contains both letters and digits, return a list of two numbers, one for each letter and digit.\n * Otherwise, return a list of two numbers, one for each letter.\n */\nconst convertToNumbers = (str) => {\n  const numbers = [];\n  for (let i = 0; i < str.length; i++) {\n    const digit = str.charAt(i);\n    if (digit >= '0' && digit <= '9') {\n      numbers.push(parseInt(digit, 10));\n    } else {\n      numbers.push(parseInt(digit, 10));\n    }\n  }\n  return numbers;\n};\n\n/**\n * Given a string, convert it to a list of numbers (each number being a number between 1 and 10).\n * If the string contains only digits, return a list of one number. Otherwise, return a list of two numbers.\n * If the string contains letters, return a list of two numbers, one for each letter.\n * If the string contains both letters and digits, return a list of two numbers, one for each letter and digit.\n * Otherwise, return a list of two numbers, one for each letter.\n */\nconst convertToNumbersArray = (str) => {\n  const numbers = [];\n  for (let i = 0; i < str.length; i++) {\n    const digit = str.charAt(i);\n    if (digit >= '0' && digit <= '9') {\n      numbers.push(parseInt(digit, 10));\n    } else {\n      numbers.push(parseInt(digit, 10));\n    }\n  }\n  return numbers;\n};\n\n/**\n * Given a string, convert it to a list of numbers (each number being a number between 1 and 10).\n * If the string contains only digits, return a list of one number. Otherwise, return a list of two numbers.\n * If the string contains letters, return a list of two numbers, one for each letter.\n * If the string contains both letters and digits, return a list of two numbers, one for each letter and digit.\n * Otherwise, return a list of two numbers, one for each letter.\n */\nconst convertToNumbersArrayWithLetters = (str) => {\n  const numbers = [];\n  for (let i = 0; i < str.length; i++) {\n    const digit = str.charAt(i);\n    if (digit >= 'a' && digit <= 'z') {\n      numbers.push(parseInt(digit, 10));\n    } else {\n      numbers.push(parseInt(digit, 10));\n    }\n  }\n  return numbers;\n};\n\n/**\n * Given a string, convert it to a list of numbers (each number being a number between 1 and 10).\n * If the string contains only digits, return a list of one number. Otherwise, return a list of two numbers.\n * If the string contains letters, return a list of two numbers, one for each letter.\n * If the string contains both letters and digits, return a list of two numbers, one for each letter and digit.\n * Otherwise, return a list of two numbers, one for each letter.\n */\nconst convertToNumbersArrayWithLettersAndDigits = (str) => {\n  const numbers = [];\n  for (let i = 0; i < str.length; i++) {\n    const digit = str.charAt(i);\n    if (digit >= 'a' && digit <= 'z') {\n      numbers.push(parseInt(digit, 10));\n    } else {\n      numbers.push(parseInt(digit, 10));\n    }\n  }\n  return numbers;\n};\n\n/**\n * Given a string, convert it to a list of numbers (each number being a number between 1 and 10).\n * If the string contains only digits, return a list of one number. Otherwise, return a list of two numbers.\n * If the string contains letters, return a list of two numbers, one for each letter.\n * If the string contains both letters and digits, return a list of two numbers, one for each letter and digit.\n * Otherwise, return a list of two numbers, one for each letter.\n */\nconst convertToNumbersArrayWithLettersAndDigitsAndLetters = (str) => {\n  const numbers = [];\n  for (let i = 0; i < str.length; i++) {\n    const digit = str.charAt(i);\n    if (digit >= 'a' && digit <= 'z') {\n      numbers.push(parseInt(digit, 10));\n    } else {\n      numbers.push(parseInt(digit, 10));\n    }\n  }\n  return numbers;\n};\n\n/**\n * Given a string, convert it to a list of numbers (each number being a number between 1 and 10).\n * If the string contains only digits, return a list of one number. Otherwise, return a list of two numbers.\n * If the string contains letters, return a list of two numbers, one for each letter.\n * If the string contains both letters and digits, return a list of two numbers, one for each letter and digit.\n * Otherwise, return a list of two numbers, one for each letter.\n */\nconst convertToNumbersArrayWithLettersAndDigitsAndLettersAndDigits = (str) => {\n  const numbers = [];\n  for (let i = 0; i < str.length; i++) {\n    const digit = str.charAt(i);\n    if (digit >= 'a' && digit <= 'z') {\n      numbers.push(parseInt(digit, 10));\n    } else {\n      numbers.push(parseInt(digit, 10));\n    }\n  }\n  return numbers;\n};\n\n/**\n * Given a string, convert it to a list of numbers (each number being a number between 1 and 10).\n * If the string contains only digits, return a list of one number. Otherwise, return a list of two numbers.\n * If the string contains letters, return a list of two numbers, one for each letter.\n * If the string contains both letters and digits, return a list of two numbers, one for each letter and digit.\n * Otherwise, return a list of two numbers, one for each letter.\n */\nconst convertToNumbersArrayWithLettersAndDigitsAndLettersAndDigitsAndLetters = (str) => {\n  const numbers = [];\n  for (let i = 0; i < str.length; i++) {\n    const digit = str.charAt(i);\n    if (digit >= 'a' && digit <= 'z') {\n      numbers.push(parseInt(digit, 10));\n    } else {\n      numbers.push(parseInt(digit, 10));\n    }\n  }\n  return numbers;\n};\n\n/**\n * Given a string, convert it to a list of numbers (each number being a number between 1 and 10).\n * If the string contains only digits, return a list of one number. Otherwise, return a list of two numbers.\n * If the string contains letters, return a list of two numbers, one for each letter.\n * If the string contains both letters and digits, return a list of two numbers, one for each letter and digit.\n * Otherwise, return a list of two numbers, one for each letter.\n */\nconst convertToNumbersArrayWithLettersAndDigitsAndLettersAndDigitsAndLettersAndDigits = (str) => {\n  const numbers = [];\n  for (let i = 0; i < str.length; i++) {\n    const digit = str.charAt(i);\n    if (digit >= 'a' && digit <= 'z') {\n      numbers.push(parseInt(digit, 10));\n    } else {\n      numbers.push(parseInt(digit, 10));\n    }\n  }\n  return numbers;\n};\n\n/**\n * Given a string, convert it to a list of numbers (each number being a number between 1 and 10).\n * If the string contains only digits, return a list of one number. Otherwise, return a list of two numbers.\n * If the string contains letters, return a list of two ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/21", "prompt": "/* Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n", "canonical_solution": "  var min_number = Math.min(...numbers);\n  var max_number = Math.max(...numbers);\n  return numbers.map(x => (x - min_number) / (max_number - min_number));\n}\n\n", "test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 49.9])) === JSON.stringify([0.0, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([100.0, 49.9])) === JSON.stringify([1.0, 0.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([2.0, 1.0, 5.0, 3.0, 4.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n  console.assert(\n    JSON.stringify(rescaleToUnit([12.0, 11.0, 15.0, 13.0, 14.0])) ===\n      JSON.stringify([0.25, 0.0, 1.0, 0.5, 0.75])\n  )\n}\n\ntestRescaleToUnit()\n", "declaration": "\nconst rescaleToUnit = (numbers) => {\n", "example_test": "const testRescaleToUnit = () => {\n  console.assert(\n    JSON.stringify(rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])) ===\n      JSON.stringify([0.0, 0.25, 0.5, 0.75, 1.0])\n  )\n}\ntestRescaleToUnit()\n", "entry_point": "rescaleToUnit", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n  >>> rescaleToUnit([1.0, 2.0, 3.0, 4.0, 5.0])\n  [0.0, 0.25, 0.5, 0.75, 1.0]\n  */\nconst rescaleToUnit = (numbers) => {\n  const [min, max] = numbers.reduce((acc, n) => [Math.min(acc, n), Math.max(acc, n)], [0, Number.MAX_VALUE]);\n  return numbers.map((n) => n * max / min);\n};\n\n/**\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * Given a list of numbers (consisting of at least two elements), apply a linear transformation to this list so that the smallest number becomes 0 and the largest becomes 1.\n * ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/22", "prompt": "/* Filters the specified list of arbitrary Python values for integers only\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n", "canonical_solution": "  return values.filter(x => Number.isInteger(x));\n}\n\n", "test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(filterIntegers([4, {}, [], 23.2, 9, 'adasd'])) ===\n      JSON.stringify([4, 9])\n  )\n  console.assert(\n    JSON.stringify(filterIntegers([3, 'c', 3, 3, 'a', 'b'])) ===\n      JSON.stringify([3, 3, 3])\n  )\n}\n\ntestFilterIntegers()\n", "declaration": "\nconst filterIntegers = (values) => {\n", "example_test": "const testFilterIntegers = () => {\n  console.assert(JSON.stringify(filterIntegers(['a', 3.14, 5])) === JSON.stringify([5]))\n  console.assert(\n    JSON.stringify(filterIntegers([1, 2, 3, 'abc', {}, []])) ===\n      JSON.stringify([1,2,3])\n  )\n}\ntestFilterIntegers()\n", "entry_point": "filterIntegers", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Filters the specified list of arbitrary Python values for integers only\n  >>> filterIntegers(['a', 3.14, 5])\n  [5]\n  >>> filterIntegers([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterIntegers = (values) => {\n  return values.filter(value => typeof value === 'number');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for floats only\n * >>> filterFloats(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterFloats([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterFloats = (values) => {\n  return values.filter(value => typeof value === 'number');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for booleans only\n * >>> filterBooleans(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterBooleans([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterBooleans = (values) => {\n  return values.filter(value => typeof value === 'boolean');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for strings only\n * >>> filterStrings(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterStrings([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterStrings = (values) => {\n  return values.filter(value => typeof value ==='string');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for tuples only\n * >>> filterTuples(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterTuples([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterTuples = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for dictionaries only\n * >>> filterDicts(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterDicts([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterDicts = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for lists only\n * >>> filterLists(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterLists([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterLists = (values) => {\n  return values.filter(value => Array.isArray(value));\n};\n\n/**\n * Filters the specified list of arbitrary Python values for sets and frozensets only\n * >>> filterSets(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterSets([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterSets = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for frozensets only\n * >>> filterFrozenSets(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterFrozenSets([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterFrozenSets = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for sets only\n * >>> filterSets(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterSets([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterSets = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for frozensets only\n * >>> filterFrozenSets(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterFrozenSets([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterFrozenSets = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for sets only\n * >>> filterSets(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterSets([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterSets = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for frozensets only\n * >>> filterFrozenSets(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterFrozenSets([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterFrozenSets = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for sets only\n * >>> filterSets(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterSets([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterSets = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for frozensets only\n * >>> filterFrozenSets(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterFrozenSets([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterFrozenSets = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for sets only\n * >>> filterSets(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterSets([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterSets = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for frozensets only\n * >>> filterFrozenSets(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterFrozenSets([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterFrozenSets = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for sets only\n * >>> filterSets(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterSets([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterSets = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for frozensets only\n * >>> filterFrozenSets(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterFrozenSets([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterFrozenSets = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for sets only\n * >>> filterSets(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterSets([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterSets = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for frozensets only\n * >>> filterFrozenSets(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterFrozenSets([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterFrozenSets = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for sets only\n * >>> filterSets(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterSets([1, 2, 3, 'abc', {}, []])\n  [1, 2, 3]\n  */\nconst filterSets = (values) => {\n  return values.filter(value => typeof value === 'object');\n};\n\n/**\n * Filters the specified list of arbitrary Python values for frozensets only\n * >>> filterFrozenSets(['a', 3.14, 5])\n  [3.14, 5]\n  >>> filterFrozenSets([1, 2, 3, 'abc', {}, []])\n  [", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/23", "prompt": "/* Returns the length of the given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n", "canonical_solution": "  return string.length;\n}\n\n", "test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('x') === 1)\n  console.assert(strlen('asdasnakj') === 9)\n}\n\ntestStrlen()\n", "declaration": "\nconst strlen = (string) => {\n", "example_test": "const testStrlen = () => {\n  console.assert(strlen('') === 0)\n  console.assert(strlen('abc') === 3)\n}\ntestStrlen()\n", "entry_point": "strlen", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Returns the length of the given string\n  >>> strlen('')\n  0\n  >>> strlen('abc')\n  3\n  */\nconst strlen = (string) => {\n  return string.length\n}\n\n/**\n * Returns the number of bytes the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytes = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of characters the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenChars = (string) => {\n  return string.length\n}\n\n/**\n * Returns the number of bytes the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of characters the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenCharsBytes = (string) => {\n  return string.length\n}\n\n/**\n * Returns the number of bytes the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of characters the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenCharsBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of bytes the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of characters the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of bytes the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of characters the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of bytes the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of characters the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of bytes the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of characters the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of bytes the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of characters the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of bytes the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of characters the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of bytes the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of characters the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of bytes the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of characters the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of bytes the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of characters the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of bytes the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of characters the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of bytes the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of characters the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of bytes the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of characters the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of bytes the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of characters the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of bytes the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of characters the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2\n}\n\n/**\n * Returns the number of bytes the given string takes\n * >>> strlen('abc')\n  3\n  */\nconst strlenBytesBytesChars = (string) => {\n  return string.length * 2", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/24", "prompt": "/* Find for a given number n the largest number dividing n equally, less than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n", "canonical_solution": "  for (let i = n - 1; i >= 0; i--)\n    if (n % i == 0)\n      return i;\n}\n\n", "test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(3) === 1)\n  console.assert(largestDivisor(7) === 1)\n  console.assert(largestDivisor(10) === 5)\n  console.assert(largestDivisor(100) === 50)\n  console.assert(largestDivisor(49) === 7)\n}\n\ntestLargestDivisor()\n", "declaration": "\nconst largestDivisor = (n) => {\n", "example_test": "const testLargestDivisor = () => {\n  console.assert(largestDivisor(15) === 5)\n}\ntestLargestDivisor()\n", "entry_point": "largestDivisor", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Find for a given number n the largest number dividing n equally, less than n\n  >>> largestDivisor(15)\n  5\n  */\nconst largestDivisor = (n) => {\n  let divisor = 1;\n  while (divisor <= n) {\n    divisor *= 10;\n  }\n  return divisor;\n};\n\n/**\n * Given a number n, return the largest number dividing n equally, less than n\n * >>> largestDivisor(15)\n * 15\n */\nconst largestFactor = (n) => {\n  let factor = 1;\n  while (factor <= n) {\n    factor *= 10;\n  }\n  return factor;\n};\n\n/**\n * Given a number n, return the largest number dividing n equally, less than n\n * >>> largestFactor(15)\n * 15\n */\nconst largestPowerOf10 = (n) => {\n  let powerOf10 = 1;\n  while (powerOf10 <= n) {\n    powerOf10 *= 10;\n  }\n  return powerOf10;\n};\n\n/**\n * Given a number n, return the largest number dividing n equally, less than n\n * >>> largestPowerOf10(15)\n * 15\n */\nconst largestPowerOf2N = (n) => {\n  let powerOf2N = 1;\n  while (powerOf2N <= n) {\n    powerOf2N *= 2;\n  }\n  return powerOf2N;\n};\n\n/**\n * Given a number n, return the largest number dividing n equally, less than n\n * >>> largestPowerOf2N(15)\n * 15\n */\nconst largestPowerOf3N = (n) => {\n  let powerOf3N = 1;\n  while (powerOf3N <= n) {\n    powerOf3N *= 3;\n  }\n  return powerOf3N;\n};\n\n/**\n * Given a number n, return the largest number dividing n equally, less than n\n * >>> largestPowerOf3N(15)\n * 15\n */\nconst largestPowerOf4N = (n) => {\n  let powerOf4N = 1;\n  while (powerOf4N <= n) {\n    powerOf4N *= 4;\n  }\n  return powerOf4N;\n};\n\n/**\n * Given a number n, return the largest number dividing n equally, less than n\n * >>> largestPowerOf4N(15)\n * 15\n */\nconst largestPowerOf5N = (n) => {\n  let powerOf5N = 1;\n  while (powerOf5N <= n) {\n    powerOf5N *= 5;\n  }\n  return powerOf5N;\n};\n\n/**\n * Given a number n, return the largest number dividing n equally, less than n\n * >>> largestPowerOf5N(15)\n * 15\n */\nconst largestPowerOf6N = (n) => {\n  let powerOf6N = 1;\n  while (powerOf6N <= n) {\n    powerOf6N *= 6;\n  }\n  return powerOf6N;\n};\n\n/**\n * Given a number n, return the largest number dividing n equally, less than n\n * >>> largestPowerOf6N(15)\n * 15\n */\nconst largestPowerOf7N = (n) => {\n  let powerOf7N = 1;\n  while (powerOf7N <= n) {\n    powerOf7N *= 7;\n  }\n  return powerOf7N;\n};\n\n/**\n * Given a number n, return the largest number dividing n equally, less than n\n * >>> largestPowerOf7N(15)\n * 15\n */\nconst largestPowerOf8N = (n) => {\n  let powerOf8N = 1;\n  while (powerOf8N <= n) {\n    powerOf8N *= 8;\n  }\n  return powerOf8N;\n};\n\n/**\n * Given a number n, return the largest number dividing n equally, less than n\n * >>> largestPowerOf8N(15)\n * 15\n */\nconst largestPowerOf9N = (n) => {\n  let powerOf9N = 1;\n  while (powerOf9N <= n) {\n    powerOf9N *= 9;\n  }\n  return powerOf9N;\n};\n\n/**\n * Given a number n, return the largest number dividing n equally, less than n\n * >>> largestPowerOf9N(15)\n * 15\n */\nconst largestPowerOf10N = (n) => {\n  let powerOf10N = 1;\n  while (powerOf10N <= n) {\n    powerOf10N *= 10;\n  }\n  return powerOf10N;\n};\n\n/**\n * Given a number n, return the largest number dividing n equally, less than n\n * >>> largestPowerOf10N(15)\n * 15\n */\nconst largestPowerOf11N = (n) => {\n  let powerOf11N = 1;\n  while (powerOf11N <= n) {\n    powerOf11N *= 11;\n  }\n  return powerOf11N;\n};\n\n/**\n * Given a number n, return the largest number dividing n equally, less than n\n * >>> largestPowerOf11N(15)\n * 15\n */\nconst largestPowerOf12N = (n) => {\n  let powerOf12N = 1;\n  while (powerOf12N <= n) {\n    powerOf12N *= 12;\n  }\n  return powerOf12N;\n};\n\n/**\n * Given a number n, return the largest number dividing n equally, less than n\n * >>> largestPowerOf12N(15)\n * 15\n */\nconst largestPowerOf13N = (n) => {\n  let powerOf13N = 1;\n  while (powerOf13N <= n) {\n    powerOf13N *= 13;\n  }\n  return powerOf13N;\n};\n\n/**\n * Given a number n, return the largest number dividing n equally, less than n\n * >>> largestPowerOf13N(15)\n * 15\n */\nconst largestPowerOf14N = (n) => {\n  let powerOf14N = 1;\n  while (powerOf14N <= n) {\n    powerOf14N *= 14;\n  }\n  return powerOf14N;\n};\n\n/**\n * Given a number n, return the largest number dividing n equally, less than n\n * >>> largestPowerOf14N(15)\n * 15\n */\nconst largestPowerOf15N = (n) => {\n  let powerOf15N = 1;\n  while (powerOf15N <= n) {\n    powerOf15N *= 15;\n  }\n  return powerOf15N;\n};\n\n/**\n * Given a number n, return the largest number dividing n equally, less than n\n * >>> largestPowerOf15N(15)\n * 15\n */\nconst largestPowerOf16N = (n) => {\n  let powerOf16N = 1;\n  while (powerOf16N <= n) {\n    powerOf16N *= 16;\n  }\n  return powerOf16N;\n};\n\n/**\n * Given a number n, return the largest number dividing n equally, less than n\n * >>> largestPowerOf16N(15)\n * 15\n */\nconst largestPowerOf17N = (n) => {\n  let powerOf17N = 1;\n  while (powerOf17N <= n) {\n    powerOf17N *= 17;\n  }\n  return powerOf17N;\n};\n\n/**\n * Given a number n, return the largest number dividing n equally, less than n\n * >>> largestPowerOf17N(15)\n * 15\n */\nconst largestPowerOf18N = (n) => {\n  let powerOf18N = 1;\n  while (powerOf18N <= n) {\n    powerOf18N *= 18;\n  }\n  return powerOf18N;\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/25", "prompt": "/* Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n", "canonical_solution": "  var fact = [], i = 2;\n  while (i <= Math.sqrt(n) + 1) {\n    if (n % i == 0) {\n      fact.push(i);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n\n  if (n > 1)\n    fact.push(n);\n  return fact;\n}\n\n", "test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(2)) === JSON.stringify([2]))\n  console.assert(JSON.stringify(factorize(4)) === JSON.stringify([2, 2]))\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(3 * 19)) === JSON.stringify([3, 19]))\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 3 * 19 * 3 * 19)) ===\n      JSON.stringify([3, 3, 3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 19 * 19 * 19)) ===\n      JSON.stringify([3, 19, 19, 19])\n  )\n  console.assert(\n    JSON.stringify(factorize(3 * 2 * 3)) === JSON.stringify([2, 3, 3])\n  )\n}\n\ntestFactorize()\n", "declaration": "\nconst factorize = (n) => {\n", "example_test": "const testFactorize = () => {\n  console.assert(JSON.stringify(factorize(8)) === JSON.stringify([2, 2, 2]))\n  console.assert(JSON.stringify(factorize(25)) === JSON.stringify([5,5]))\n  console.assert(\n    JSON.stringify(factorize(70)) ===\n      JSON.stringify([2,5,7])\n  )\n}\ntestFactorize()\n", "entry_point": "factorize", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n  >>> factorize(8)\n  [2, 2, 2]\n  >>> factorize(25)\n  [5, 5]\n  >>> factorize(70)\n  [2, 5, 7]\n  */\nconst factorize = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 1;\n  while (i <= n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n      factor = 1;\n    }\n    i++;\n  }\n  return factors;\n};\n\n/**\n * Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n * >>> factorize(8)\n * [2, 2]\n * >>> factorize(25)\n * [5, 5]\n * >>> factorize(70)\n * [2, 5, 7]\n */\nconst factorize2 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 1;\n  while (i <= n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n      factor = 1;\n    }\n    i++;\n  }\n  return factors;\n};\n\n/**\n * Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n * >>> factorize(8)\n * [2, 2]\n * >>> factorize(25)\n * [5, 5]\n * >>> factorize(70)\n * [2, 5, 7]\n */\nconst factorize3 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 1;\n  while (i <= n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n      factor = 1;\n    }\n    i++;\n  }\n  return factors;\n};\n\n/**\n * Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n * >>> factorize(8)\n * [2, 2]\n * >>> factorize(25)\n * [5, 5]\n * >>> factorize(70)\n * [2, 5, 7]\n */\nconst factorize4 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 1;\n  while (i <= n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n      factor = 1;\n    }\n    i++;\n  }\n  return factors;\n};\n\n/**\n * Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n * >>> factorize(8)\n * [2, 2]\n * >>> factorize(25)\n * [5, 5]\n * >>> factorize(70)\n * [2, 5, 7]\n */\nconst factorize5 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 1;\n  while (i <= n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n      factor = 1;\n    }\n    i++;\n  }\n  return factors;\n};\n\n/**\n * Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n * >>> factorize(8)\n * [2, 2]\n * >>> factorize(25)\n * [5, 5]\n * >>> factorize(70)\n * [2, 5, 7]\n */\nconst factorize6 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 1;\n  while (i <= n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n      factor = 1;\n    }\n    i++;\n  }\n  return factors;\n};\n\n/**\n * Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n * >>> factorize(8)\n * [2, 2]\n * >>> factorize(25)\n * [5, 5]\n * >>> factorize(70)\n * [2, 5, 7]\n */\nconst factorize7 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 1;\n  while (i <= n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n      factor = 1;\n    }\n    i++;\n  }\n  return factors;\n};\n\n/**\n * Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n * >>> factorize(8)\n * [2, 2]\n * >>> factorize(25)\n * [5, 5]\n * >>> factorize(70)\n * [2, 5, 7]\n */\nconst factorize8 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 1;\n  while (i <= n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n      factor = 1;\n    }\n    i++;\n  }\n  return factors;\n};\n\n/**\n * Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n * >>> factorize(8)\n * [2, 2]\n * >>> factorize(25)\n * [5, 5]\n * >>> factorize(70)\n * [2, 5, 7]\n */\nconst factorize9 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 1;\n  while (i <= n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n      factor = 1;\n    }\n    i++;\n  }\n  return factors;\n};\n\n/**\n * Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n * >>> factorize(8)\n * [2, 2]\n * >>> factorize(25)\n * [5, 5]\n * >>> factorize(70)\n * [2, 5, 7]\n */\nconst factorize10 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 1;\n  while (i <= n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n      factor = 1;\n    }\n    i++;\n  }\n  return factors;\n};\n\n/**\n * Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n * >>> factorize(8)\n * [2, 2]\n * >>> factorize(25)\n * [5, 5]\n * >>> factorize(70)\n * [2, 5, 7]\n */\nconst factorize11 = (n) => {\n  let factors = [];\n  let factor = 1;\n  let i = 1;\n  while (i <= n) {\n    factor *= i;\n    if (n % factor === 0) {\n      factors.push(factor);\n      factor = 1;\n    }\n    i++;\n  }\n  return factors;\n};\n\n/**\n * Returns the prime factors of a given integer in order from the smallest to the largest. Each of these factors should be listed as often as it occurs in the factorization. Input number should correspond to the product of all factors.\n * >>> factorize(8)\n * [2, 2]\n * >>> factorize(25)\n * [5, 5]\n * >>> factorize(70)\n * [2, 5, 7]\n */\nconst factorize12 = (n) => {\n  let factors = [];\n  let factor", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/26", "prompt": "/* Remove from a list of integers all elements that occur more than once, and leave the order of the elements the same as when you entered them.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n", "canonical_solution": "  var dict = new Object();\n  for (const num of numbers) {\n    if (num in dict) {\n      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  return numbers.filter(x => dict[x] <= 1);\n}\n\n", "test": "const testRemoveDuplicates = () => {\n  console.assert(JSON.stringify(removeDuplicates([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 4])) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2, 4, 3, 5])) ===\n      JSON.stringify([1, 4, 5])\n  )\n}\n\ntestRemoveDuplicates()\n", "declaration": "\nconst removeDuplicates = (numbers) => {\n", "example_test": "const testRemoveDuplicates = () => {\n  console.assert(\n    JSON.stringify(removeDuplicates([1, 2, 3, 2,4])) ===\n      JSON.stringify([1,3, 4])\n  )\n}\ntestRemoveDuplicates()\n", "entry_point": "removeDuplicates", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Remove from a list of integers all elements that occur more than once, and leave the order of the elements the same as when you entered them.\n  >>> removeDuplicates([1, 2, 3, 2, 4])\n  [1, 3, 4]\n  */\nconst removeDuplicates = (numbers) => {\n  let seen = {};\n  let result = [];\n  for (let i = 0; i < numbers.length; i++) {\n    if (!seen[numbers[i]]) {\n      result.push(numbers[i]);\n      seen[numbers[i]] = true;\n    }\n  }\n  return result;\n};\n\n/**\n * A function that takes an array of numbers and returns a new array with the unique elements. \n * \n * Note: This function is only available on browsers that support the ES6 spread syntax.\n * \n * Example:\n * \n * const uniqueNumbers = unique([1, 2, 3, 2, 4])\n * uniqueNumbers // => [1, 2, 3, 4]\n * \n * const uniqueNumbers2 = unique([1, 2, 3, 2, 4], true)\n * uniqueNumbers2 // => [1, 2, 3, 4]\n * \n * const uniqueNumbers3 = unique([1, 2, 3, 2, 4], false)\n * uniqueNumbers3 // => [1, 2, 3]\n * \n * const uniqueNumbers4 = unique([1, 2, 3, 2, 4], null, 2)\n * uniqueNumbers4 // => [1, 2, 3]\n * \n * const uniqueNumbers5 = unique([1, 2, 3, 2, 4], null, true)\n * uniqueNumbers5 // => [1, 2, 3]\n * \n * const uniqueNumbers6 = unique([1, 2, 3, 2, 4], null, false)\n * uniqueNumbers6 // => [1, 2, 3]\n * \n * const uniqueNumbers7 = unique([1, 2, 3, 2, 4], null, null, 2)\n * uniqueNumbers7 // => [1, 2, 3]\n * \n * const uniqueNumbers8 = unique([1, 2, 3, 2, 4], null, null, true)\n * uniqueNumbers8 // => [1, 2, 3]\n * \n * const uniqueNumbers9 = unique([1, 2, 3, 2, 4], null, null, false)\n * uniqueNumbers9 // => [1, 2, 3]\n * \n * const uniqueNumbers10 = unique([1, 2, 3, 2, 4], null, null, null, 2)\n * uniqueNumbers10 // => [1, 2, 3]\n * \n * const uniqueNumbers11 = unique([1, 2, 3, 2, 4], null, null, null, true)\n * uniqueNumbers11 // => [1, 2, 3]\n * \n * const uniqueNumbers12 = unique([1, 2, 3, 2, 4], null, null, null, false)\n * uniqueNumbers12 // => [1, 2, 3]\n * \n * const uniqueNumbers13 = unique([1, 2, 3, 2, 4], null, null, null, null, 2)\n * uniqueNumbers13 // => [1, 2, 3]\n * \n * const uniqueNumbers14 = unique([1, 2, 3, 2, 4], null, null, null, null, true)\n * uniqueNumbers14 // => [1, 2, 3]\n * \n * const uniqueNumbers15 = unique([1, 2, 3, 2, 4], null, null, null, null, false)\n * uniqueNumbers15 // => [1, 2, 3]\n * \n * const uniqueNumbers16 = unique([1, 2, 3, 2, 4], null, null, null, null, null, 2)\n * uniqueNumbers16 // => [1, 2, 3]\n * \n * const uniqueNumbers17 = unique([1, 2, 3, 2, 4], null, null, null, null, null, true)\n * uniqueNumbers17 // => [1, 2, 3]\n * \n * const uniqueNumbers18 = unique([1, 2, 3, 2, 4], null, null, null, null, null, false)\n * uniqueNumbers18 // => [1, 2, 3]\n * \n * const uniqueNumbers19 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, 2)\n * uniqueNumbers19 // => [1, 2, 3]\n * \n * const uniqueNumbers20 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, true)\n * uniqueNumbers20 // => [1, 2, 3]\n * \n * const uniqueNumbers21 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, false)\n * uniqueNumbers21 // => [1, 2, 3]\n * \n * const uniqueNumbers22 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, null, 2)\n * uniqueNumbers22 // => [1, 2, 3]\n * \n * const uniqueNumbers23 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, null, true)\n * uniqueNumbers23 // => [1, 2, 3]\n * \n * const uniqueNumbers24 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, null, false)\n * uniqueNumbers24 // => [1, 2, 3]\n * \n * const uniqueNumbers25 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, null, null, 2)\n * uniqueNumbers25 // => [1, 2, 3]\n * \n * const uniqueNumbers26 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, null, null, true)\n * uniqueNumbers26 // => [1, 2, 3]\n * \n * const uniqueNumbers27 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, null, null, false)\n * uniqueNumbers27 // => [1, 2, 3]\n * \n * const uniqueNumbers28 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, null, null, null, 2)\n * uniqueNumbers28 // => [1, 2, 3]\n * \n * const uniqueNumbers29 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, null, null, null, true)\n * uniqueNumbers29 // => [1, 2, 3]\n * \n * const uniqueNumbers30 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, null, null, null, false)\n * uniqueNumbers30 // => [1, 2, 3]\n * \n * const uniqueNumbers31 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, null, null, null, 2)\n * uniqueNumbers31 // => [1, 2, 3]\n * \n * const uniqueNumbers32 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, null, null, null, true)\n * uniqueNumbers32 // => [1, 2, 3]\n * \n * const uniqueNumbers33 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, null, null, null, false)\n * uniqueNumbers33 // => [1, 2, 3]\n * \n * const uniqueNumbers34 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, null, null, null, 2)\n * uniqueNumbers34 // => [1, 2, 3]\n * \n * const uniqueNumbers35 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, null, null, null, true)\n * uniqueNumbers35 // => [1, 2, 3]\n * \n * const uniqueNumbers36 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, null, null, null, false)\n * uniqueNumbers36 // => [1, 2, 3]\n * \n * const uniqueNumbers37 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, null, null, null, null, 2)\n * uniqueNumbers37 // => [1, 2, 3]\n * \n * const uniqueNumbers38 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, null, null, null, null, true)\n * uniqueNumbers38 // => [1, 2, 3]\n * \n * const uniqueNumbers39 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, null, null, null, null, false)\n * uniqueNumbers39 // => [1, 2, 3]\n * \n * const uniqueNumbers40 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, null, null, null, null, 2)\n * uniqueNumbers40 // => [1, 2, 3]\n * \n * const uniqueNumbers41 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, null, null, null, null, true)\n * uniqueNumbers41 // => [1, 2, 3]\n * \n * const uniqueNumbers42 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, null, null, null, false)\n * uniqueNumbers42 // => [1, 2, 3]\n * \n * const uniqueNumbers43 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, null, null, null, null, 2)\n * uniqueNumbers43 // => [1, 2, 3]\n * \n * const uniqueNumbers44 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, null, null, null, null, null, true)\n * uniqueNumbers44 // => [1, 2, 3]\n * \n * const uniqueNumbers45 = unique([1, 2, 3, 2, 4], null, null, null, null, null, null, null, null, null, null, null, false)\n * uniqueNumbers45 // => [1, 2, 3]\n * \n * const uniqueNumbers46 = unique([1, 2, 3, 2, 4], null, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/27", "prompt": "/* Flip lowercase letters to uppercase letters and uppercase letters to lowercase letters.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n", "canonical_solution": "  return string.split('')\n          .map(x => (x.toUpperCase() == x ? x.toLowerCase() : x.toUpperCase()))\n          .join('');\n}\n\n", "test": "const testFlipCase = () => {\n  console.assert(flipCase('') === '')\n  console.assert(flipCase('Hello!') === 'hELLO!')\n  console.assert(\n    flipCase(\n      'These violent delights have violent ends') ===\n        'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n  )\n}\n\ntestFlipCase()\n", "declaration": "\nconst flipCase = (string) => {\n", "example_test": "const testFlipCase = () => {\n  console.assert(flipCase('Hello') === 'hELLO')\n}\ntestFlipCase()\n", "entry_point": "flipCase", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Flip lowercase letters to uppercase letters and uppercase letters to lowercase letters.\n  >>> flipCase('Hello')\n  'hELLO'\n  */\nconst flipCase = (string) => {\n  return string.toLowerCase().split('')\n   .map((letter) => letter.split('').reverse().join(''))\n   .join('');\n};\n\n/**\n * Converts lowercase letters to uppercase letters and uppercase letters to lowercase letters.\n * If no lowercase letters are present, returns an empty string.\n * If a string contains only lowercase letters, returns an empty string.\n * If a string contains only uppercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase letters and lowercase letters and uppercase letters and lowercase letters, returns an empty string.\n * If a string contains only lowercase letters and uppercase ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/28", "prompt": "/* Merge List of Strings into a Single String\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n", "canonical_solution": "  return strings.join('');\n}\n\n", "test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['x', 'y', 'z']) === 'xyz')\n  console.assert(concatenate(['x', 'y', 'z', 'w', 'k']) === 'xyzwk')\n}\n\ntestConcatenate()\n", "declaration": "\nconst concatenate = (strings) => {\n", "example_test": "const testConcatenate = () => {\n  console.assert(concatenate([]) === '')\n  console.assert(concatenate(['a', 'b', 'c']) === 'abc')\n}\ntestConcatenate()\n", "entry_point": "concatenate", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Merge List of Strings into a Single String\n  >>> concatenate([])\n  ''\n  >>> concatenate(['a', 'b', 'c'])\n  'abc'\n  */\nconst concatenate = (strings) => {\n  return strings.reduce((acc, cur) => {\n    return acc + (cur? '' + cur : '');\n  }, '');\n};\n\n/* Convert Object to JSON\n  >>> toJSON({a: 1, b: 2})\n  '{\"a\":1,\"b\":2}'\n  */\nconst toJSON = (obj) => {\n  return JSON.stringify(obj, null, 2);\n};\n\n/* Convert JSON to Object\n  >>> fromJSON('{\"a\":1,\"b\":2}')\n  {a: 1, b: 2}\n  */\nconst fromJSON = (json) => {\n  return JSON.parse(json);\n};\n\n/* Convert Object to URL\n  >>> toURL({a: 1, b: 2})\n  '/a%3D1%26b%3D2'\n  */\nconst toURL = (obj) => {\n  return encodeURIComponent(toJSON(obj));\n};\n\n/* Convert URL to Object\n  >>> fromURL('/a%3D1%26b%3D2')\n  {a: 1, b: 2}\n  */\nconst fromURL = (url) => {\n  return decodeURIComponent(fromJSON(url));\n};\n\n/* Convert Object to QueryString\n  >>> toQueryString({a: 1, b: 2})\n  'a=1&b=2'\n  */\nconst toQueryString = (obj) => {\n  return Object.keys(obj).map(key => key + '=' + encodeURIComponent(obj[key])).join('&');\n};\n\n/* Convert QueryString to Object\n  >>> fromQueryString('a=1&b=2')\n  {a: 1, b: 2}\n  */\nconst fromQueryString = (queryString) => {\n  return queryString.split('&').map(param => param.split('=').map(decodeURIComponent).join('='));\n};\n\n/* Convert Object to FormData\n  >>> toFormData({a: 1, b: 2})\n  FormData([\n    FormDataEntry('a', '1'),\n    FormDataEntry('b', '2'),\n  ])\n  */\nconst toFormData = (obj) => {\n  const entries = Object.keys(obj).map(key => [key, obj[key]]);\n  return new FormData(entries);\n};\n\n/* Convert FormData to Object\n  >>> fromFormData([\n    FormDataEntry('a', '1'),\n    FormDataEntry('b', '2'),\n  ])\n  {a: 1, b: 2}\n  */\nconst fromFormData = (formData) => {\n  const entries = formData.entries();\n  return entries.reduce((acc, cur) => {\n    const [key, value] = cur;\n    acc[key] = value;\n    return acc;\n  }, {});\n};\n\n/* Convert Object to Blob\n  >>> toBlob({a: 1, b: 2})\n  Blob([\n    ArrayBufferView([\n      0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF, 0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF, 0x100, 0x101, 0x102, 0x103, 0x104, 0x105, 0x106, 0x107, 0x108, 0x109, 0x10A, 0x10B, 0x10C, 0x10D, 0x10E, 0x10F, 0x110, 0x111, 0x112, 0x113, 0x114, 0x115, 0x116, 0x117, 0x118, 0x119, 0x11A, 0x11B, 0x11C, 0x11D, 0x11E, 0x11F, 0x120, 0x121, 0x122, 0x123, 0x124, 0x125, 0x126, 0x127, 0x128, 0x129, 0x12A, 0x12B, 0x12C, 0x12D, 0x12E, 0x12F, 0x130, 0x131, 0x132, 0x133, 0x134, 0x135, 0x136, 0x137, 0x138, 0x139, 0x13A, 0x13B, 0x13C, 0x13D, 0x13E, 0x13F, 0x140, 0x141, 0x142, 0x143, 0x144, 0x145, 0x146, 0x147, 0x148, 0x149, 0x14A, 0x14B, 0x14C, 0x14D, 0x14E, 0x14F, 0x150, 0x151, 0x152, 0x153, 0x154, 0x155, 0x156, 0x157, 0x158, 0x159, 0x15A, 0x15B, 0x15C, 0x15D, 0x15E, 0x15F, 0x160, 0x161, 0x162, 0x163, 0x164, 0x165, 0x166, 0x167, 0x168, 0x169, 0x16A, 0x16B, 0x16C, 0x16D, 0x16E, 0x16F, 0x170, 0x171, 0x172, 0x173, 0x174, 0x175, 0x176, 0x177, 0x178, 0x179, 0x17A, 0x17B, 0x17C, 0x17D, 0x17E, 0x17F, 0x180, 0x181, 0x182, 0x183, 0x184, 0x185, 0x186, 0x187, 0x188, 0x189, 0x18A, 0x18B, 0x18C, 0x18D, 0x18E, 0x18F, 0x190, 0x191, 0x192, 0x193, 0x194, 0x195, 0x196, 0x197, 0x198, 0x199, 0x19A, 0x19B, 0x19C, 0x19D, 0x19E, 0x19F, 0x1A0, 0x1A1, 0x1A2, 0x1A3, 0x1A4, 0x1A5, 0x1A6, 0x1A7, 0x1A8, 0x1A9, 0x1AA, 0x1AB, 0x1AC, 0x1AD, 0x1AE, 0x1AF, 0x1B0, 0x1B1, 0x1B2, 0x1B3, 0x1B4, 0x1B5, 0x1B6, 0x1B7, 0x1B8, 0x1B9, 0x1BA, 0x1BD, 0x1BE, 0x1BF, 0x1C0, 0x1C1, 0x1C2, 0x1C3, 0x1C4, 0x1C5, 0x1C6, 0x1C7, 0x1C8, 0x1C9, 0x1CA, 0x1CB, 0x1CC, 0x1CD, 0x1CE, 0x1CF, 0x1D0, 0x1D1, 0x1D2, 0x1D3, 0x1D4, 0x1D5, 0x1D6, 0x1D7, 0x1D8, 0x1D9, 0x1DA, 0x1DB, 0x1DC, 0x1DE", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/29", "prompt": "/* Filter an input list of strings only for strings starting with a certain prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n", "canonical_solution": "  return strings.filter(x => x.startsWith(prefix));\n}\n\n", "test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx')\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n}\n\ntestFilterByPrefix()\n", "declaration": "\nconst filterByPrefix = (strings, prefix) => {\n", "example_test": "const testFilterByPrefix = () => {\n  console.assert(\n    JSON.stringify(filterByPrefix([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ) === JSON.stringify(['abc', 'array'])\n  )\n}\ntestFilterByPrefix()\n", "entry_point": "filterByPrefix", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Filter an input list of strings only for strings starting with a certain prefix.\n  >>> filterByPrefix([], 'a')\n  []\n  >>> filterByPrefix(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc', 'array']\n  */\nconst filterByPrefix = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix));\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a certain prefix.\n  >>> filterFirst([], 'a')\n  []\n  >>> filterFirst(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['abc']\n  */\nconst filterFirst = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix));\n};\n\n/**\n * Filter an input list of strings only for the last occurrence of a certain prefix.\n  >>> filterLast([], 'a')\n  []\n  >>> filterLast(['abc', 'bcd', 'cde', 'array'], 'a')\n  ['array', 'cde']\n  */\nconst filterLast = (strings, prefix) => {\n  return strings.filter(string => string.startsWith(prefix));\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a certain suffix.\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'b')\n  ['b', 'c']\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'c')\n  []\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'd')\n  []\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'e')\n  []\n  */\nconst filterFirstSuffix = (strings, suffix) => {\n  return strings.filter(string => string.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for the last occurrence of a certain suffix.\n  >>> filterLastSuffix(['a', 'b', 'c'], 'b')\n  ['c']\n  >>> filterLastSuffix(['a', 'b', 'c'], 'c')\n  []\n  >>> filterLastSuffix(['a', 'b', 'c'], 'd')\n  []\n  >>> filterLastSuffix(['a', 'b', 'c'], 'e')\n  []\n  */\nconst filterLastSuffix = (strings, suffix) => {\n  return strings.filter(string => string.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a certain suffix.\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'b')\n  ['b', 'c']\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'c')\n  []\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'd')\n  []\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'e')\n  []\n  */\nconst filterFirstSuffix = (strings, suffix) => {\n  return strings.filter(string => string.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for the last occurrence of a certain suffix.\n  >>> filterLastSuffix(['a', 'b', 'c'], 'b')\n  ['c']\n  >>> filterLastSuffix(['a', 'b', 'c'], 'c')\n  []\n  >>> filterLastSuffix(['a', 'b', 'c'], 'd')\n  []\n  >>> filterLastSuffix(['a', 'b', 'c'], 'e')\n  []\n  */\nconst filterLastSuffix = (strings, suffix) => {\n  return strings.filter(string => string.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a certain suffix.\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'b')\n  ['b', 'c']\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'c')\n  []\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'd')\n  []\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'e')\n  []\n  */\nconst filterFirstSuffix = (strings, suffix) => {\n  return strings.filter(string => string.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for the last occurrence of a certain suffix.\n  >>> filterLastSuffix(['a', 'b', 'c'], 'b')\n  ['c']\n  >>> filterLastSuffix(['a', 'b', 'c'], 'c')\n  []\n  >>> filterLastSuffix(['a', 'b', 'c'], 'd')\n  []\n  >>> filterLastSuffix(['a', 'b', 'c'], 'e')\n  []\n  */\nconst filterLastSuffix = (strings, suffix) => {\n  return strings.filter(string => string.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a certain suffix.\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'b')\n  ['b', 'c']\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'c')\n  []\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'd')\n  []\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'e')\n  []\n  */\nconst filterFirstSuffix = (strings, suffix) => {\n  return strings.filter(string => string.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for the last occurrence of a certain suffix.\n  >>> filterLastSuffix(['a', 'b', 'c'], 'b')\n  ['c']\n  >>> filterLastSuffix(['a', 'b', 'c'], 'c')\n  []\n  >>> filterLastSuffix(['a', 'b', 'c'], 'd')\n  []\n  >>> filterLastSuffix(['a', 'b', 'c'], 'e')\n  []\n  */\nconst filterLastSuffix = (strings, suffix) => {\n  return strings.filter(string => string.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a certain suffix.\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'b')\n  ['b', 'c']\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'c')\n  []\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'd')\n  []\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'e')\n  []\n  */\nconst filterFirstSuffix = (strings, suffix) => {\n  return strings.filter(string => string.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for the last occurrence of a certain suffix.\n  >>> filterLastSuffix(['a', 'b', 'c'], 'b')\n  ['c']\n  >>> filterLastSuffix(['a', 'b', 'c'], 'c')\n  []\n  >>> filterLastSuffix(['a', 'b', 'c'], 'd')\n  []\n  >>> filterLastSuffix(['a', 'b', 'c'], 'e')\n  []\n  */\nconst filterLastSuffix = (strings, suffix) => {\n  return strings.filter(string => string.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a certain suffix.\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'b')\n  ['b', 'c']\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'c')\n  []\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'd')\n  []\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'e')\n  []\n  */\nconst filterFirstSuffix = (strings, suffix) => {\n  return strings.filter(string => string.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for the last occurrence of a certain suffix.\n  >>> filterLastSuffix(['a', 'b', 'c'], 'b')\n  ['c']\n  >>> filterLastSuffix(['a', 'b', 'c'], 'c')\n  []\n  >>> filterLastSuffix(['a', 'b', 'c'], 'd')\n  []\n  >>> filterLastSuffix(['a', 'b', 'c'], 'e')\n  []\n  */\nconst filterLastSuffix = (strings, suffix) => {\n  return strings.filter(string => string.endsWith(suffix));\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a certain suffix.\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'b')\n  ['b', 'c']\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'c')\n  []\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'd')\n  []\n  >>> filterFirstSuffix(['a', 'b', 'c'], 'e')\n  []\n  */\nconst filterFirstSuffix = (strings, suffix) => {\n  return strings.filter(string => string.endsWith(suffix));\n};\n\n/**\n", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/3", "prompt": "/* You will be given a list of deposits and withdrawals into a bank account, starting with an account balance of zero. Your task is to determine if the account balance drops below zero at any point, and at that point the function should be correct again, otherwise it should be incorrect.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n", "canonical_solution": "  var balance = 0;\n  for (const op of operations) {\n    balance += op;\n    if (balance < 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n", "test": "const testBelowZero = () => {\n  console.assert(belowZero([]) === false)\n  console.assert(belowZero([1, 2, -3, 1, 2, -3]) === false)\n  console.assert(belowZero([1, 2, -4, 5, 6]) === true)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -4]) === false)\n  console.assert(belowZero([1, -1, 2, -2, 5, -5, 4, -5]) === true)\n  console.assert(belowZero([1, -2, 2, -2, 5, -5, 4, -4]) === true)\n}\n\ntestBelowZero()\n", "declaration": "\nconst belowZero = (operations) => {\n", "example_test": "const testBelowZero = () => {\n  console.assert(belowZero([1, 2, 3]) === false)\n  console.assert(belowZero([1, 2, -4, 5]) === true)\n}\ntestBelowZero()\n", "entry_point": "belowZero", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* You will be given a list of deposits and withdrawals into a bank account, starting with an account balance of zero. Your task is to determine if the account balance drops below zero at any point, and at that point the function should be correct again, otherwise it should be incorrect.\n  >>> belowZero([1, 2, 3])\n  false\n  >>> belowZero([1, 2, -4, 5])\n  true\n  */\nconst belowZero = (operations) => {\n  const accountBalance = operations.reduce((acc, operation) => acc + operation, 0);\n  return accountBalance > 0;\n};\n\nmodule.exports = belowZero;\n\n},{}],6:[function(require,module,exports){\n/**\n * A simple JavaScript implementation of the Mersenne Twister random number generator.\n * Version 2.1.\n * Author: Paul Johnston <removed@example.com>\n * Web: http://pauljohnston.com/\n *\n * Copyright 2011, Paul Johnston\n * Released under the MIT license\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n * A simple JavaScript implementation of the Mersenne Twister random number generator.\n * Version 2.1.\n * Author: Paul Johnston <removed@example.com>\n * Web: http://pauljohnston.com/\n *\n * Copyright 2011, Paul Johnston\n * Released under the MIT license\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n * A simple JavaScript implementation of the Mersenne Twister random number generator.\n * Version 2.1.\n * Author: Paul Johnston <removed@example.com>\n * Web: http://pauljohnston.com/\n *\n * Copyright 2011, Paul Johnston\n * Released under the MIT license\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n * A simple JavaScript implementation of the Mersenne Twister random number generator.\n * Version 2.1.\n * Author: Paul Johnston <removed@example.com>\n * Web: http://pauljohnston.com/\n *\n * Copyright 2011, Paul Johnston\n * Released under the MIT license\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n * A simple JavaScript implementation of the Mersenne Twister random number generator.\n * Version 2.1.\n * Author: Paul Johnston <removed@example.com>\n * Web: http://pauljohnston.com/\n *\n * Copyright 2011, Paul Johnston\n * Released under the MIT license\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n * A simple JavaScript implementation of the Mersenne Twister random number generator.\n * Version 2.1.\n * Author: Paul Johnston <removed@example.com>\n * Web: http://pauljohnston.com/\n *\n * Copyright 2011, Paul Johnston\n * Released under the MIT license\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n * A simple JavaScript implementation of the Mersenne Twister random number generator.\n * Version 2.1.\n * Author: Paul Johnston <removed@example.com>\n * Web: http://pauljohnston.com/\n *\n * Copyright 2011, Paul Johnston\n * Released under the MIT license\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n * A simple JavaScript implementation of the Mersenne Twister random number generator.\n * Version 2.1.\n * Author: Paul Johnston <removed@example.com>\n * Web: http://pauljohnston.com/\n *\n * Copyright 2011, Paul Johnston\n * Released under the MIT license\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n * A simple JavaScript implementation of the Mersenne Twister random number generator.\n * Version 2.1.\n * Author: Paul Johnston <removed@example.com>\n * Web: http://pauljohnston.com/\n *\n * Copyright 2011, Paul Johnston\n * Released under the MIT license\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n * A simple JavaScript implementation of the Mersenne Twister random number generator.\n * Version 2.1.\n * Author: Paul Johnston <removed@example.com>\n * Web: http://pauljohnston.com/\n *\n * Copyright 2011, Paul Johnston\n * Released under the MIT license\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n * A simple JavaScript implementation of the Mersenne Twister random number generator.\n * Version 2.1.\n * Author: Paul Johnston <removed@example.com>\n * Web: http://pauljohnston.com/\n *\n * Copyright 2011, Paul Johnston\n * Released under the MIT license\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n * A simple JavaScript implementation of the Mersenne Twister random number generator.\n * Version 2.1.\n * Author: Paul Johnston <removed@example.com>\n * Web: http://pauljohnston.com/\n *\n * Copyright 2011, Paul Johnston\n * Released under the MIT license\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n * A simple JavaScript implementation of the Mersenne Twister random number generator.\n * Version 2.1.\n * Author: Paul Johnston <removed@example.com>\n * Web: http://pauljohnston.com/\n *\n * Copyright 2011, Paul Johnston\n * Released under the MIT license\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n * A simple JavaScript implementation of the Mersenne Twister random number generator.\n * Version 2.1.\n * Author: Paul Johnston <removed@example.com>\n * Web: http://pauljohnston.com/\n *\n * Copyright 2011, Paul Johnston\n * Released under the MIT license\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n * A simple JavaScript implementation of the Mersenne Twister random number generator.\n * Version 2.1.\n * Author: Paul Johnston <removed@example.com>\n * Web: http://pauljohnston.com/\n *\n * Copyright 2011, Paul Johnston\n * Released under the MIT license\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n * A simple JavaScript implementation of the Mersenne Twister random number generator.\n * Version 2.1.\n * Author: Paul Johnston <removed@example.com>\n * Web: http://pauljohnston.com/\n *\n * Copyright 2011, Paul Johnston\n * Released under the MIT license\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n * A simple JavaScript implementation of the Mersenne Twister random number generator.\n * Version 2.1.\n * Author: Paul Johnston <removed@example.com>\n * Web: http://pauljohnston.com/\n *\n * Copyright 2011, Paul Johnston\n * Released under the MIT license\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n * A simple JavaScript implementation of the Mersenne Twister random number generator.\n * Version 2.1.\n * Author: Paul Johnston <removed@example.com>\n * Web: http://pauljohnston.com/\n *\n * Copyright 2011, Paul Johnston\n * Released under the MIT license\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n * A simple JavaScript implementation of the Mersenne Twister random number generator.\n * Version 2.1.\n * Author: Paul Johnston <removed@example.com>\n * Web: http://pauljohnston.com/\n *\n * Copyright 2011, Paul Johnston\n * Released under the MIT license\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n * A simple JavaScript implementation of the Mersenne Twister random number generator.\n * Version 2.1.\n * Author: Paul Johnston <removed@example.com>\n * Web: http://pauljohnston.com/\n *\n * Copyright 2011, Paul Johnston\n * Released under the MIT license\n * http://opensource.org/licenses/mit-license\n */\n\n/**\n * A ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/30", "prompt": "/*RThe list contains only positive numbers.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n", "canonical_solution": "  return l.filter(e => e > 0);\n}\n\n", "test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, -2, 4, 5, 6])) === JSON.stringify([4, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 3, 9, 123, 1])\n  )\n  console.assert(JSON.stringify(getPositive([-1, -2])) === JSON.stringify([]))\n  console.assert(JSON.stringify(getPositive([])) === JSON.stringify([]))\n}\n\ntestGetPositive()\n", "declaration": "\nconst getPositive = (l) => {\n", "example_test": "const testGetPositive = () => {\n  console.assert(\n    JSON.stringify(getPositive([-1, 2, -4, 5, 6])) === JSON.stringify([2, 5, 6])\n  )\n  console.assert(\n    JSON.stringify(getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n      JSON.stringify([5, 3, 2, 3, 9, 123, 1])\n  )\n}\ntestGetPositive()\n", "entry_point": "getPositive", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*RThe list contains only positive numbers.\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, 3, 2, 3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, -3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/*\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, -3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/*\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, -3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, -3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/*\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, -3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, -3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/*\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, -3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, -3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/*\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, -3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, -3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/*\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, -3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, -3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/*\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, -3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, -3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/*\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, -3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, -3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/*\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, -3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, -3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/*\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, -3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, -3, 9, 123, 1]\n  */\nconst getNegative = (l) => {\n  return l.filter(n => n < 0)\n}\n\n/*\n  >>> getPositive([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getPositive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, -3, 9, 123, 1]\n  */\nconst getPositive = (l) => {\n  return l.filter(n => n > 0)\n}\n\n/*\n  >>> getNegative([-1, 2, -4, 5, 6])\n  [2, -4, 5, 6]\n  >>> getNegative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  [5, -3, -3, -3, 9, 123, 1]\n  */\nconst getNegative = (l) => {", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/31", "prompt": "/*Return true if a given number is a prime number and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n", "canonical_solution": "  if (n < 2)\n    return false;\n  for (let k = 2; k < n - 1; k++)\n    if (n % k == 0)\n      return false;\n  return true;\n}\n\n", "test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n  console.assert(isPrime(5) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(17) === true)\n  console.assert(isPrime(5 * 17) === false)\n  console.assert(isPrime(11 * 7) === false)\n  console.assert(isPrime(13441 * 19) === false)\n}\n\ntestIsPrime()\n", "declaration": "\nconst isPrime = (n) => {\n", "example_test": "const testIsPrime = () => {\n  console.assert(isPrime(6) === false)\n  console.assert(isPrime(101) === true)\n  console.assert(isPrime(11) === true)\n  console.assert(isPrime(13441) === true)\n  console.assert(isPrime(61) === true)\n  console.assert(isPrime(4) === false)\n  console.assert(isPrime(1) === false)\n}\ntestIsPrime()\n", "entry_point": "isPrime", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Return true if a given number is a prime number and false otherwise.\n  >>> isPrime(6)\n  false\n  >>> isPrime(101)\n  true\n  >>> isPrime(11)\n  true\n  >>> isPrime(13441)\n  true\n  >>> isPrime(61)\n  true\n  >>> isPrime(4)\n  false\n  >>> isPrime(1)\n  false\n  */\nconst isPrime = (n) => {\n  if (n < 2) {\n    return false;\n  }\n  if (n % 2 === 0) {\n    return false;\n  }\n  for (let i = 2; i < Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns the number of ways to split an integer into two halves.\n * This is an O(n) algorithm.\n * >>> splitInto(2, 3)\n * [3, 1]\n * >>> splitInto(2, 4)\n * [4, 2]\n * >>> splitInto(2, 5)\n * [5, 2]\n * >>> splitInto(2, 6)\n * [6, 2]\n * >>> splitInto(2, 7)\n * [7, 2]\n * >>> splitInto(2, 8)\n * [8, 2]\n * >>> splitInto(2, 9)\n * [9, 2]\n * >>> splitInto(2, 10)\n * [10, 2]\n * >>> splitInto(2, 11)\n * [11, 2]\n * >>> splitInto(2, 12)\n * [12, 2]\n * >>> splitInto(2, 13)\n * [13, 2]\n * >>> splitInto(2, 14)\n * [14, 2]\n * >>> splitInto(2, 15)\n * [15, 2]\n * >>> splitInto(2, 16)\n * [16, 2]\n * >>> splitInto(2, 17)\n * [17, 2]\n * >>> splitInto(2, 18)\n * [18, 2]\n * >>> splitInto(2, 19)\n * [19, 2]\n * >>> splitInto(2, 20)\n * [20, 2]\n * >>> splitInto(2, 21)\n * [21, 2]\n * >>> splitInto(2, 22)\n * [22, 2]\n * >>> splitInto(2, 23)\n * [23, 2]\n * >>> splitInto(2, 24)\n * [24, 2]\n * >>> splitInto(2, 25)\n * [25, 2]\n * >>> splitInto(2, 26)\n * [26, 2]\n * >>> splitInto(2, 27)\n * [27, 2]\n * >>> splitInto(2, 28)\n * [28, 2]\n * >>> splitInto(2, 29)\n * [29, 2]\n * >>> splitInto(2, 30)\n * [30, 2]\n * >>> splitInto(2, 31)\n * [31, 2]\n * >>> splitInto(2, 32)\n * [32, 2]\n * >>> splitInto(2, 33)\n * [33, 2]\n * >>> splitInto(2, 34)\n * [34, 2]\n * >>> splitInto(2, 35)\n * [35, 2]\n * >>> splitInto(2, 36)\n * [36, 2]\n * >>> splitInto(2, 37)\n * [37, 2]\n * >>> splitInto(2, 38)\n * [38, 2]\n * >>> splitInto(2, 39)\n * [39, 2]\n * >>> splitInto(2, 40)\n * [40, 2]\n * >>> splitInto(2, 41)\n * [41, 2]\n * >>> splitInto(2, 42)\n * [42, 2]\n * >>> splitInto(2, 43)\n * [43, 2]\n * >>> splitInto(2, 44)\n * [44, 2]\n * >>> splitInto(2, 45)\n * [45, 2]\n * >>> splitInto(2, 46)\n * [46, 2]\n * >>> splitInto(2, 47)\n * [47, 2]\n * >>> splitInto(2, 48)\n * [48, 2]\n * >>> splitInto(2, 49)\n * [49, 2]\n * >>> splitInto(2, 50)\n * [50, 2]\n * >>> splitInto(2, 51)\n * [51, 2]\n * >>> splitInto(2, 52)\n * [52, 2]\n * >>> splitInto(2, 53)\n * [53, 2]\n * >>> splitInto(2, 54)\n * [54, 2]\n * >>> splitInto(2, 55)\n * [55, 2]\n * >>> splitInto(2, 56)\n * [56, 2]\n * >>> splitInto(2, 57)\n * [57, 2]\n * >>> splitInto(2, 58)\n * [58, 2]\n * >>> splitInto(2, 59)\n * [59, 2]\n * >>> splitInto(2, 60)\n * [60, 2]\n * >>> splitInto(2, 61)\n * [61, 2]\n * >>> splitInto(2, 62)\n * [62, 2]\n * >>> splitInto(2, 63)\n * [63, 2]\n * >>> splitInto(2, 64)\n * [64, 2]\n * >>> splitInto(2, 65)\n * [65, 2]\n * >>> splitInto(2, 66)\n * [66, 2]\n * >>> splitInto(2, 67)\n * [67, 2]\n * >>> splitInto(2, 68)\n * [68, 2]\n * >>> splitInto(2, 69)\n * [69, 2]\n * >>> splitInto(2, 70)\n * [70, 2]\n * >>> splitInto(2, 71)\n * [71, 2]\n * >>> splitInto(2, 72)\n * [72, 2]\n * >>> splitInto(2, 73)\n * [73, 2]\n * >>> splitInto(2, 74)\n * [74, 2]\n * >>> splitInto(2, 75)\n * [75, 2]\n * >>> splitInto(2, 76)\n * [76, 2]\n * >>> splitInto(2, 77)\n * [77, 2]\n * >>> splitInto(2, 78)\n * [78, 2]\n * >>> splitInto(2, 79)\n * [79, 2]\n * >>> splitInto(2, 80)\n * [80, 0]\n * >>> splitInto(2, 81)\n * [81, 2]\n * >>> splitInto(2, 82)\n * [82, 2]\n * >>> splitInto(2, 83)\n * [83, 2]\n * >>> splitInto(2, 84)\n * [84, 2]\n * >>> splitInto(2, 85)\n * [85, 2]\n * >>> splitInto(2, 86)\n * [86, 2]\n * >>> splitInto(2, 87)\n * [87, 2]\n * >>> splitInto(2, 88)\n * [88, 2]\n * >>> splitInto(2, 89)\n * [89, 2]\n * >>> splitInto(2, 90)\n * [90, 0]\n * >>> splitInto(2, 91)\n * [91, 2]\n * >>> splitInto(2, 92)\n * [92, 2]\n * >>> splitInto(2, 93)\n * [93, 2]\n * >>> splitInto(2, 94)\n * [94, 2]\n * >>> splitInto(2, 95)\n * [95, 2]\n * >>> splitInto(2, 96)\n * [96, 2]\n * >>> splitInto(2, 97)\n * [97, 2]\n * >>> splitInto(2, 98)\n * [98, 2]\n * >>> splitInto(2, 99)\n * [99, 2]\n * >>> splitInto(2, 100)\n * [100, 2]\n * >>> splitInto(2, 101)\n * [101, 2]\n * >>> splitInto(2, 102)\n * [102, 2]\n * >>> splitInto(2, 103)\n * [103, 2]\n * >>> splitInto(2, 104)\n * [104, 2]\n * >>> splitInto(2, 105)\n * [105, 2]\n * >>> splitInto(2, 106)\n * [106, 2]\n * >>> splitInto(2, 107)\n * [107, 2]\n * >>> splitInto(2, 108)\n * [108, 2]\n * >>> splitInto(2, 109)\n * ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/32", "prompt": "/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n", "canonical_solution": "  var begin = -1.0, end = 1.0;\n  while (poly(xs, begin) * poly(xs, end) > 0) {\n    begin *= 2.0;\n    end *= 2.0;\n  }\n  while (end - begin > 1e-10) {\n    let center = (begin + end) / 2.0;\n    if (poly(xs, center) * poly(xs, begin) > 0)\n      begin = center;\n    else\n      end = center;\n  }\n  return begin;\n}\n\n", "test": "const testfindZero = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n  for (let i = 0; i < 100; i++) {\n    let ncoeff = 2 * getRandomIntInclusive(1, 4);\n    let coeffs = [];\n    for (let j = 0; j < ncoeff; j++) {\n      let coeff = getRandomIntInclusive(-10, 10);\n      if (coeff === 0)\n        coeff = 1;\n      coeffs.push(coeff);\n    }\n    let solution = findZero(coeffs);\n    console.assert(Math.abs(poly(coeffs, solution)) < 1e-4);\n  }\n}\n", "declaration": "\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\nconst findZero = (xs) => {\n", "example_test": "const testPoly = () => {\n  console.assert(Math.abs(findZero([1,2])+0.5 < 1e-4));\n  console.assert(Math.abs(findZero([-6,11,-6,1])-1 < 1e-4));\n}\ntestPoly()\n", "entry_point": "poly", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly = (xs, x) => {\n  return xs.reduce((prev, item, index) => {\n    return prev + item * Math.pow(x, index);\n  }, 0);\n}\n\n/*\n  xs are coefficients of a polynomial.\n  findZero find x such that poly(x) = 0.\n  findZero returns only only zero point, even if there are many.\n  Moreover, findZero only takes list xs having even number of coefficients\n  and largest non zero coefficient as it guarantees\n  a solution.\n  >>> round(findZero([1, 2]), 2) # f(x) = 1 + 2x\n  -0.5\n  >>> round(findZero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n  1.0\n  */\nconst findZero = (xs) => {\n  let x = xs[0];\n  let zero = 0;\n  let i;\n  for (i = 1; i < xs.length; i++) {\n    if (Math.abs(x - xs[i]) < 1e-10) {\n      zero = i;\n      break;\n    }\n  }\n  return zero;\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly2 = (xs, x) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < xs.length; i++) {\n    sum += xs[i] * Math.pow(x, i);\n  }\n  return sum;\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly3 = (xs, x) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < xs.length; i++) {\n    sum += xs[i] * Math.pow(x, i) * Math.pow(x, i + 1);\n  }\n  return sum;\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly4 = (xs, x) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < xs.length; i++) {\n    sum += xs[i] * Math.pow(x, i) * Math.pow(x, i + 1) * Math.pow(x, i + 2);\n  }\n  return sum;\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly5 = (xs, x) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < xs.length; i++) {\n    sum += xs[i] * Math.pow(x, i) * Math.pow(x, i + 1) * Math.pow(x, i + 2) * Math.pow(x, i + 3);\n  }\n  return sum;\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly6 = (xs, x) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < xs.length; i++) {\n    sum += xs[i] * Math.pow(x, i) * Math.pow(x, i + 1) * Math.pow(x, i + 2) * Math.pow(x, i + 3) * Math.pow(x, i + 4);\n  }\n  return sum;\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly7 = (xs, x) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < xs.length; i++) {\n    sum += xs[i] * Math.pow(x, i) * Math.pow(x, i + 1) * Math.pow(x, i + 2) * Math.pow(x, i + 3) * Math.pow(x, i + 4) * Math.pow(x, i + 5);\n  }\n  return sum;\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly8 = (xs, x) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < xs.length; i++) {\n    sum += xs[i] * Math.pow(x, i) * Math.pow(x, i + 1) * Math.pow(x, i + 2) * Math.pow(x, i + 3) * Math.pow(x, i + 4) * Math.pow(x, i + 5) * Math.pow(x, i + 6);\n  }\n  return sum;\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly9 = (xs, x) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < xs.length; i++) {\n    sum += xs[i] * Math.pow(x, i) * Math.pow(x, i + 1) * Math.pow(x, i + 2) * Math.pow(x, i + 3) * Math.pow(x, i + 4) * Math.pow(x, i + 5) * Math.pow(x, i + 6) * Math.pow(x, i + 7);\n  }\n  return sum;\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly10 = (xs, x) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < xs.length; i++) {\n    sum += xs[i] * Math.pow(x, i) * Math.pow(x, i + 1) * Math.pow(x, i + 2) * Math.pow(x, i + 3) * Math.pow(x, i + 4) * Math.pow(x, i + 5) * Math.pow(x, i + 6) * Math.pow(x, i + 7) * Math.pow(x, i + 8);\n  }\n  return sum;\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly11 = (xs, x) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < xs.length; i++) {\n    sum += xs[i] * Math.pow(x, i) * Math.pow(x, i + 1) * Math.pow(x, i + 2) * Math.pow(x, i + 3) * Math.pow(x, i + 4) * Math.pow(x, i + 5) * Math.pow(x, i + 6) * Math.pow(x, i + 7) * Math.pow(x, i + 8) * Math.pow(x, i + 9) * Math.pow(x, i + 10);\n  }\n  return sum;\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly12 = (xs, x) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < xs.length; i++) {\n    sum += xs[i] * Math.pow(x, i) * Math.pow(x, i + 1) * Math.pow(x, i + 2) * Math.pow(x, i + 3) * Math.pow(x, i + 4) * Math.pow(x, i + 5) * Math.pow(x, i + 6) * Math.pow(x, i + 7) * Math.pow(x, i + 8) * Math.pow(x, i + 9) * Math.pow(x, i + 10) * Math.pow(x, i + 11);\n  }\n  return sum;\n}\n\n/*\n  Evaluates polynomial with coefficients xs at point x.\n  return xs[0] + xs[1] * x + xs[1] * x^2 +.... xs[n] * x^n\n  */\nconst poly13 = (xs, x) => {\n  let sum = 0;\n  let i;\n  for (i = 0; i < xs.length; i++) {\n    sum += xs[i] * Math.pow(x, i) * Math.pow(x, i + 1) * Math.pow(x, i + 2) * Math.pow(x, i + 3) * Math.pow(x, i + 4) * Math.pow(x, i + 5) * Math.pow(x, i + 6) * Math.pow(x, ", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/33", "prompt": "/*Tits function takes a list l and returns a list l'so that l' is identical to l in indices that are not divisible by three, while its values for indices divisible by three correspond to the values of the corresponding indices of l but are sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n", "canonical_solution": "  var three = l.filter((item, index) => index % 3 == 0);\n  three.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 3 == 0 ? three[index / 3] : item));\n}\n\n", "test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ==\n      JSON.stringify([1, 3, -5, 2, -3, 3, 5, 0, 123, 9, -10])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ==\n      JSON.stringify([-10, 8, -12, 3, 23, 2, 4, 11, 12, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 8, 3, 4, 6, 9, 2])) ==\n      JSON.stringify([2, 8, 3, 4, 6, 9, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 9, 4, 8, 3, 2])) ==\n      JSON.stringify([2, 6, 9, 4, 8, 3, 5])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2, 1])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5, 1])\n  )\n}\n\ntestSortThird()\n", "declaration": "\nconst sortThird = (l) => {\n", "example_test": "const testSortThird = () => {\n  console.assert(\n    JSON.stringify(sortThird([1, 2, 3])) == JSON.stringify([1, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(sortThird([5, 6, 3, 4, 8, 9, 2])) ==\n      JSON.stringify([2, 6, 3, 4, 8, 9, 5])\n  )\n}\ntestSortThird()\n", "entry_point": "sortThird", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Tits function takes a list l and returns a list l'so that l' is identical to l in indices that are not divisible by three, while its values for indices divisible by three correspond to the values of the corresponding indices of l but are sorted.\n  >>> sortThird([1, 2, 3])\n  [1, 2, 3]\n  >>> sortThird([5, 6, 3, 4, 8, 9, 2])\n  [2, 6, 3, 4, 8, 9, 5]\n  */\nconst sortThird = (l) => {\n  const thirds = [...Array(3)].map((_, i) => i);\n  const thirdsIndexes = [...Array(3)].map((_, i) => i);\n  const thirdsValues = [...Array(3)].map((_, i) => i);\n  const thirdsValueIndexes = [...Array(3)].map((_, i) => i);\n  const thirdsValueIndexesValues = [...Array(3)].map((_, i) => i);\n  const thirdsValueIndexesValueIndexes = [...Array(3)].map((_, i) => i);\n  const thirdsValueIndexesValueIndexesValues = [...Array(3)].map((_, i) => i);\n  const thirdsValueIndexesValueIndexesValueIndexesValues = [...Array(3)].map((_, i) => i);\n  const thirdsValueIndexesValueIndexesValueIndexesValueIndexesValues = [...Array(3)].map((_, i) => i);\n  const thirdsValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValues = [...Array(3)].map((_, i) => i);\n  const thirdsValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValues = [...Array(3)].map((_, i) => i);\n  const thirdsValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValues = [...Array(3)].map((_, i) => i);\n  const thirdsValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValues = [...Array(3)].map((_, i) => i);\n  const thirdsValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValues = [...Array(3)].map((_, i) => i);\n  const thirdsValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValues = [...Array(3)].map((_, i) => i);\n  const thirdsValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValues = [...Array(3)].map((_, i) => i);\n  const thirdsValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValues = [...Array(3)].map((_, i) => i);\n  const thirdsValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValues = [...Array(3)].map((_, i) => i);\n  const thirdsValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValues = [...Array(3)].map((_, i) => i);\n  const thirdsValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValues = [...Array(3)].map((_, i) => i);\n  const thirdsValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndexesValueIndex", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/34", "prompt": "/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n", "canonical_solution": "  return Array.from(new Set(l)).sort((a, b) => (a - b));\n}\n\n", "test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\n\ntestUnique()\n", "declaration": "\nconst unique = (l) => {\n", "example_test": "const testUnique = () => {\n  console.assert(\n    JSON.stringify(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([0, 2, 3, 5, 9, 123])\n  )\n}\ntestUnique()\n", "entry_point": "unique", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(item)) {\n      return false\n    }\n    seen[item] = true\n    return true\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str.lower)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str.lower)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str.lower)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str.lower)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str.lower)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str.lower)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str.lower)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str.lower)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str.lower)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str.lower)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str.lower)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str.lower)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str.lower)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str.lower)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str.lower)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str.lower)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str.lower)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str.lower)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n  })\n}\n\n/*Return sorted unique items in a list\n  >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], key=str.lower)\n  [0, 2, 3, 5, 9, 123]\n  */\nconst unique = (l, key) => {\n  let seen = {}\n  return l.filter((item, pos, arr) => {\n    if (seen.hasOwnProperty(key)) {\n      return false\n    }\n    seen[key] = true\n    return true\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/35", "prompt": "/*Rreturns the maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n", "canonical_solution": "  return Math.max(...l);\n}\n\n", "test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) === 124)\n}\n\ntestMaxElement()\n", "declaration": "\nconst maxElement = (l) => {\n", "example_test": "const testMaxElement = () => {\n  console.assert(maxElement([1, 2, 3]) === 3)\n  console.assert(maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) === 123)\n}\ntestMaxElement()\n", "entry_point": "maxElement", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Rreturns the maximum element in the list.\n  >>> maxElement([1, 2, 3])\n  3\n  >>> maxElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  123\n  */\nconst maxElement = (l) => {\n  return l.length? Math.max(...l) : undefined;\n};\n\n/**\n * Returns the minimum element in the list.\n * >>> minElement([1, 2, 3])\n  1\n  >>> minElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  -5\n  */\nconst minElement = (l) => {\n  return l.length? Math.min(...l) : undefined;\n};\n\n/**\n * Returns the sum of all the elements in the list.\n * >>> sumElement([1, 2, 3])\n  6\n  >>> sumElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  15\n  */\nconst sumElement = (l) => {\n  return l.length? l.reduce((acc, curr) => acc + curr, 0) : undefined;\n};\n\n/**\n * Returns the average of the elements in the list.\n * >>> averageElement([1, 2, 3])\n  1.5\n  >>> averageElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3.3333333333333335\n  */\nconst averageElement = (l) => {\n  return l.length? l.reduce((acc, curr) => acc + curr, 0) / l.length : undefined;\n};\n\n/**\n * Returns the standard deviation of the elements in the list.\n * >>> standardDeviationElement([1, 2, 3])\n  1.4142135623730951\n  >>> standardDeviationElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  1.4142135623730951\n  */\nconst standardDeviationElement = (l) => {\n  return l.length? Math.sqrt(l.reduce((acc, curr) => acc + Math.pow(curr, 2), 0)) : undefined;\n};\n\n/**\n * Returns the median of the elements in the list.\n * >>> medianElement([1, 2, 3])\n  3\n  >>> medianElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  2\n  */\nconst medianElement = (l) => {\n  return l.length? l.sort((a, b) => b - a).pop() : undefined;\n};\n\n/**\n * Returns the mode of the elements in the list.\n * >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElement = (l) => {\n  return l.length? l.sort((a, b) => b - a).slice(0, 1).reduce((acc, curr) => acc + curr, 0) : undefined;\n};\n\n/**\n * Returns the mode of the elements in the list.\n * >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElements = (l) => {\n  return l.length? l.sort((a, b) => b - a).slice(0, 1).reduce((acc, curr) => acc + curr, 0) : undefined;\n};\n\n/**\n * Returns the mode of the elements in the list.\n * >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsNoDuplicates = (l) => {\n  return l.length? l.sort((a, b) => b - a).slice(0, 1).reduce((acc, curr) => acc + curr, 0) : undefined;\n};\n\n/**\n * Returns the mode of the elements in the list.\n * >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsNoDuplicatesNoDuplicates = (l) => {\n  return l.length? l.sort((a, b) => b - a).slice(0, 1).reduce((acc, curr) => acc + curr, 0) : undefined;\n};\n\n/**\n * Returns the mode of the elements in the list.\n * >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsNoDuplicatesNoDuplicatesNoDuplicates = (l) => {\n  return l.length? l.sort((a, b) => b - a).slice(0, 1).reduce((acc, curr) => acc + curr, 0) : undefined;\n};\n\n/**\n * Returns the mode of the elements in the list.\n * >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsNoDuplicatesNoDuplicatesNoDuplicatesNoDuplicates = (l) => {\n  return l.length? l.sort((a, b) => b - a).slice(0, 1).reduce((acc, curr) => acc + curr, 0) : undefined;\n};\n\n/**\n * Returns the mode of the elements in the list.\n * >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsNoDuplicatesNoDuplicatesNoDuplicatesNoDuplicatesNoDuplicates = (l) => {\n  return l.length? l.sort((a, b) => b - a).slice(0, 1).reduce((acc, curr) => acc + curr, 0) : undefined;\n};\n\n/**\n * Returns the mode of the elements in the list.\n * >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsNoDuplicatesNoDuplicatesNoDuplicatesNoDuplicatesNoDuplicatesNoDuplicates = (\n  l\n) => {\n  return l.length? l.sort((a, b) => b - a).slice(0, 1).reduce((acc, curr) => acc + curr, 0) : undefined;\n};\n\n/**\n * Returns the mode of the elements in the list.\n * >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsNoDuplicatesNoDuplicatesNoDuplicatesNoDuplicatesNoDuplicatesNoDuplicatesNoDuplicates = (\n  l\n) => {\n  return l.length? l.sort((a, b) => b - a).slice(0, 1).reduce((acc, curr) => acc + curr, 0) : undefined;\n};\n\n/**\n * Returns the mode of the elements in the list.\n * >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsNoDuplicatesNoDuplicatesNoDuplicatesNoDuplicatesNoDuplicatesNoDuplicatesNoDuplicatesNoDuplicates = (\n  l\n) => {\n  return l.length? l.sort((a, b) => b - a).slice(0, 1).reduce((acc, curr) => acc + curr, 0) : undefined;\n};\n\n/**\n * Returns the mode of the elements in the list.\n * >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsNoDuplicatesNoDuplicatesNoDuplicatesNoDuplicatesNoDuplicatesNoDuplicatesNoDuplicatesNoDuplicates = (\n  l\n) => {\n  return l.length? l.sort((a, b) => b - a).slice(0, 1).reduce((acc, curr) => acc + curr, 0) : undefined;\n};\n\n/**\n * Returns the mode of the elements in the list.\n * >>> modeElement([1, 2, 3])\n  3\n  >>> modeElement([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n  3\n  */\nconst modeElementsNoDuplicatesNoDuplicatesNoDuplicatesNoDuplicate", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/36", "prompt": "/*Rindicates how often the digit 7 appears in integers smaller than n, which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n", "canonical_solution": "  var ns = [], ans = 0;\n  for (let i = 0; i < n; i++)\n    if (i % 11 == 0 || i % 13 == 0)\n      ns.push(i);\n  var s = ns.map(x => x.toString()).join('');\n  for (const c of s)\n    ans += (c == '7');\n  return ans;\n}\n\n", "test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n  console.assert(fizzBuzz(100) === 3)\n  console.assert(fizzBuzz(200) === 6)\n  console.assert(fizzBuzz(4000) === 192)\n  console.assert(fizzBuzz(10000) === 639)\n  console.assert(fizzBuzz(100000) === 8026)\n}\n\ntestFizzBuzz()\n", "declaration": "\nconst fizzBuzz = (n) => {\n", "example_test": "const testFizzBuzz = () => {\n  console.assert(fizzBuzz(50) === 0)\n  console.assert(fizzBuzz(78) === 2)\n  console.assert(fizzBuzz(79) === 3)\n}\ntestFizzBuzz()\n", "entry_point": "fizzBuzz", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Rindicates how often the digit 7 appears in integers smaller than n, which are divisible by 11 or 13.\n  >>> fizzBuzz(50)\n  0\n  >>> fizzBuzz(78)\n  2\n  >>> fizzBuzz(79)\n  3\n  */\nconst fizzBuzz = (n) => {\n  if (n < 10) {\n    return n;\n  }\n  if (n % 10 === 0 || n % 10 === 1) {\n    return `${n}`;\n  }\n  if (n % 10 === 2) {\n    return `${n}Fizz`;\n  }\n  if (n % 10 === 3) {\n    return `${n}Buzz`;\n  }\n  return `${n}FizzBuzz`;\n};\n\n/*\n  >>> fizzBuzz(100)\n  0\n  >>> fizzBuzz(101)\n  1\n  >>> fizzBuzz(102)\n  2\n  >>> fizzBuzz(103)\n  3\n  >>> fizzBuzz(104)\n  4\n  >>> fizzBuzz(105)\n  5\n  >>> fizzBuzz(106)\n  6\n  >>> fizzBuzz(107)\n  7\n  >>> fizzBuzz(108)\n  8\n  >>> fizzBuzz(109)\n  9\n  >>> fizzBuzz(111)\n  10\n  >>> fizzBuzz(112)\n  11\n  >>> fizzBuzz(113)\n  12\n  >>> fizzBuzz(114)\n  13\n  >>> fizzBuzz(115)\n  14\n  >>> fizzBuzz(116)\n  15\n  >>> fizzBuzz(117)\n  16\n  >>> fizzBuzz(118)\n  17\n  >>> fizzBuzz(119)\n  18\n  >>> fizzBuzz(120)\n  19\n  >>> fizzBuzz(121)\n  20\n  >>> fizzBuzz(122)\n  21\n  >>> fizzBuzz(123)\n  22\n  >>> fizzBuzz(124)\n  23\n  >>> fizzBuzz(125)\n  24\n  >>> fizzBuzz(126)\n  25\n  >>> fizzBuzz(127)\n  26\n  >>> fizzBuzz(128)\n  27\n  >>> fizzBuzz(129)\n  28\n  >>> fizzBuzz(130)\n  29\n  >>> fizzBuzz(131)\n  30\n  >>> fizzBuzz(132)\n  31\n  >>> fizzBuzz(133)\n  32\n  >>> fizzBuzz(134)\n  33\n  >>> fizzBuzz(135)\n  34\n  >>> fizzBuzz(136)\n  35\n  >>> fizzBuzz(137)\n  36\n  >>> fizzBuzz(138)\n  37\n  >>> fizzBuzz(139)\n  38\n  >>> fizzBuzz(140)\n  39\n  >>> fizzBuzz(141)\n  40\n  >>> fizzBuzz(142)\n  41\n  >>> fizzBuzz(143)\n  42\n  >>> fizzBuzz(144)\n  43\n  >>> fizzBuzz(145)\n  44\n  >>> fizzBuzz(146)\n  45\n  >>> fizzBuzz(147)\n  46\n  >>> fizzBuzz(148)\n  47\n  >>> fizzBuzz(149)\n  48\n  >>> fizzBuzz(150)\n  49\n  >>> fizzBuzz(151)\n  50\n  >>> fizzBuzz(152)\n  51\n  >>> fizzBuzz(153)\n  52\n  >>> fizzBuzz(154)\n  53\n  >>> fizzBuzz(155)\n  54\n  >>> fizzBuzz(156)\n  55\n  >>> fizzBuzz(157)\n  56\n  >>> fizzBuzz(158)\n  57\n  >>> fizzBuzz(159)\n  58\n  >>> fizzBuzz(160)\n  59\n  >>> fizzBuzz(161)\n  60\n  >>> fizzBuzz(162)\n  61\n  >>> fizzBuzz(163)\n  62\n  >>> fizzBuzz(164)\n  63\n  >>> fizzBuzz(165)\n  64\n  >>> fizzBuzz(166)\n  65\n  >>> fizzBuzz(167)\n  66\n  >>> fizzBuzz(168)\n  67\n  >>> fizzBuzz(169)\n  68\n  >>> fizzBuzz(170)\n  69\n  >>> fizzBuzz(171)\n  70\n  >>> fizzBuzz(172)\n  71\n  >>> fizzBuzz(173)\n  72\n  >>> fizzBuzz(174)\n  73\n  >>> fizzBuzz(175)\n  74\n  >>> fizzBuzz(176)\n  75\n  >>> fizzBuzz(177)\n  76\n  >>> fizzBuzz(178)\n  77\n  >>> fizzBuzz(179)\n  78\n  >>> fizzBuzz(180)\n  79\n  >>> fizzBuzz(181)\n  80\n  >>> fizzBuzz(182)\n  81\n  >>> fizzBuzz(183)\n  82\n  >>> fizzBuzz(184)\n  83\n  >>> fizzBuzz(185)\n  84\n  >>> fizzBuzz(186)\n  85\n  >>> fizzBuzz(187)\n  86\n  >>> fizzBuzz(188)\n  87\n  >>> fizzBuzz(189)\n  88\n  >>> fizzBuzz(190)\n  89\n  >>> fizzBuzz(191)\n  90\n  >>> fizzBuzz(192)\n  91\n  >>> fizzBuzz(193)\n  92\n  >>> fizzBuzz(194)\n  93\n  >>> fizzBuzz(195)\n  94\n  >>> fizzBuzz(196)\n  95\n  >>> fizzBuzz(197)\n  96\n  >>> fizzBuzz(198)\n  97\n  >>> fizzBuzz(199)\n  98\n  >>> fizzBuzz(200)\n  99\n  >>> fizzBuzz(201)\n  100\n  >>> fizzBuzz(202)\n  101\n  >>> fizzBuzz(203)\n  102\n  >>> fizzBuzz(204)\n  103\n  >>> fizzBuzz(205)\n  104\n  >>> fizzBuzz(206)\n  105\n  >>> fizzBuzz(207)\n  106\n  >>> ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/37", "prompt": "/*Tits function takes a list l and returns a list l'so that l' is identical to l in the odd indices, while its values in the even indices correspond to the values of the even indices of l but are sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n", "canonical_solution": "  var even = l.filter((item, index) => index % 2 == 0);\n  even.sort((a, b) => (a - b));\n  return l.map((item, index) => (index % 2 == 0 ? even[index / 2] : item));\n}\n\n", "test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) ===\n    JSON.stringify([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123]))\n  console.assert(JSON.stringify(\n    sortEven([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) ===\n    JSON.stringify([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10]))\n}\n\ntestSortEven()\n", "declaration": "\nconst sortEven = (l) => {\n", "example_test": "const testSortEven = () => {\n  console.assert(JSON.stringify(sortEven([1, 2, 3])) ===\n    JSON.stringify([1, 2, 3]))\n  console.assert(JSON.stringify(\n    sortEven([5,6,3,4])) ===\n    JSON.stringify([3,6,5,4]))\n}\ntestSortEven()\n", "entry_point": "sortEven", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Tits function takes a list l and returns a list l'so that l' is identical to l in the odd indices, while its values in the even indices correspond to the values of the even indices of l but are sorted.\n  >>> sortEven([1, 2, 3])\n  [1, 2, 3]\n  >>> sortEven([5, 6, 3, 4])\n  [3, 6, 5, 4]\n  */\nconst sortEven = (l) => {\n  return l.sort((a, b) => a % 2 === 1? b : a);\n};\n\n/**\n  Sorts odd indices into a list by swapping the odd indices with their even indices. For example, sortOdd([0, 2, 1]) returns [0, 2, 1].\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  */\nconst sortOdd = (l) => {\n  return l.sort((a, b) => a % 2 === 1? b : a);\n};\n\n/**\n  Sorts even indices into a list by swapping the even indices with their odd indices. For example, sortEven([0, 2, 1]) returns [0, 2, 1].\n  >>> sortEven([0, 2, 1])\n  [0, 2, 1]\n  >>> sortEven([0, 2, 1])\n  [0, 2, 1]\n  >>> sortEven([0, 2, 1])\n  [0, 2, 1]\n  */\nconst sortEven = (l) => {\n  return l.sort((a, b) => a % 2 === 1? a : b);\n};\n\n/**\n  Sorts odd indices into a list by swapping the even indices with their odd indices. For example, sortOdd([0, 2, 1]) returns [0, 2, 1].\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  */\nconst sortOdd = (l) => {\n  return l.sort((a, b) => a % 2 === 1? b : a);\n};\n\n/**\n  Sorts even indices into a list by swapping the odd indices with their even indices. For example, sortEven([0, 2, 1]) returns [0, 2, 1].\n  >>> sortEven([0, 2, 1])\n  [0, 2, 1]\n  >>> sortEven([0, 2, 1])\n  [0, 2, 1]\n  >>> sortEven([0, 2, 1])\n  [0, 2, 1]\n  */\nconst sortEven = (l) => {\n  return l.sort((a, b) => a % 2 === 1? a : b);\n};\n\n/**\n  Sorts odd indices into a list by swapping the even indices with their odd indices. For example, sortOdd([0, 2, 1]) returns [0, 2, 1].\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  */\nconst sortOdd = (l) => {\n  return l.sort((a, b) => a % 2 === 1? b : a);\n};\n\n/**\n  Sorts even indices into a list by swapping the odd indices with their even indices. For example, sortEven([0, 2, 1]) returns [0, 2, 1].\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  */\nconst sortEven = (l) => {\n  return l.sort((a, b) => a % 2 === 1? a : b);\n};\n\n/**\n  Sorts odd indices into a list by swapping the even indices with their odd indices. For example, sortOdd([0, 2, 1]) returns [0, 2, 1].\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  */\nconst sortOdd = (l) => {\n  return l.sort((a, b) => a % 2 === 1? b : a);\n};\n\n/**\n  Sorts even indices into a list by swapping the odd indices with their even indices. For example, sortEven([0, 2, 1]) returns [0, 2, 1].\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  */\nconst sortEven = (l) => {\n  return l.sort((a, b) => a % 2 === 1? a : b);\n};\n\n/**\n  Sorts odd indices into a list by swapping the even indices with their odd indices. For example, sortOdd([0, 2, 1]) returns [0, 2, 1].\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  */\nconst sortOdd = (l) => {\n  return l.sort((a, b) => a % 2 === 1? b : a);\n};\n\n/**\n  Sorts even indices into a list by swapping the odd indices with their even indices. For example, sortEven([0, 2, 1]) returns [0, 2, 1].\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  */\nconst sortEven = (l) => {\n  return l.sort((a, b) => a % 2 === 1? a : b);\n};\n\n/**\n  Sorts odd indices into a list by swapping the even indices with their odd indices. For example, sortOdd([0, 2, 1]) returns [0, 2, 1].\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  */\nconst sortOdd = (l) => {\n  return l.sort((a, b) => a % 2 === 1? b : a);\n};\n\n/**\n  Sorts even indices into a list by swapping the odd indices with their even indices. For example, sortEven([0, 2, 1]) returns [0, 2, 1].\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  */\nconst sortEven = (l) => {\n  return l.sort((a, b) => a % 2 === 1? a : b);\n};\n\n/**\n  Sorts odd indices into a list by swapping the even indices with their odd indices. For example, sortOdd([0, 2, 1]) returns [0, 2, 1].\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  */\nconst sortOdd = (l) => {\n  return l.sort((a, b) => a % 2 === 1? b : a);\n};\n\n/**\n  Sorts even indices into a list by swapping the odd indices with their even indices. For example, sortEven([0, 2, 1]) returns [0, 2, 1].\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  >>> sortOdd([0, 2, 1])\n  [0, 2, 1]\n  */\nconst sortEven = (l) => {", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/38", "prompt": "/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n", "canonical_solution": "  return encodeCyclic(encodeCyclic(s));\n}\n\n", "test": "const testDecodeCyclic = () => {\n  const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i));\n\n  for (let i = 0; i < 100; i++) {\n    let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n    str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n    let encoded_str = encodeCyclic(str);\n    console.assert(decodeCyclic(encoded_str) === str);\n  }\n}\n\ntestDecodeCyclic()\n", "declaration": "const encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\nconst decodeCyclic = (s) => {\n", "example_test": "", "entry_point": "encodeCyclic", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*\n  returns encoded string by cycling groups of three characters.\n  */\nconst encodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(3 * i, Math.min((3 * i + 3), s.length)));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  takes as input string encoded with encode_cyclic function. Returns decoded string.\n  */\nconst decodeCyclic = (s) => {\n  var groups = [], groups2 = [];\n  for (let i = 0; i < Math.floor((s.length + 2) / 3); i++) {\n    groups.push(s.slice(0, 3 * i));\n  }\n  for (const group of groups) {\n    if (group.length == 3)\n      groups2.push(group.slice(1) + group[0]);\n    else\n      groups2.push(group);\n  }\n  return groups2.join('');\n}\n\n/*\n  returns true if string contains only digits, letters and underscores. Returns false otherwise.\n  */\nconst isDigit = (s) => {\n  return /^[0-9a-zA-Z]+$/.test(s);\n}\n\n/*\n  returns true if string contains only letters. Returns false otherwise.\n  */\nconst isLetter = (s) => {\n  return /^[a-zA-Z]+$/.test(s);\n}\n\n/*\n  returns true if string contains only underscores. Returns false otherwise.\n  */\nconst isUnderscore = (s) => {\n  return /^_+$/.test(s);\n}\n\n/*\n  returns true if string contains only digits. Returns false otherwise.\n  */\nconst isDigit2 = (s) => {\n  return /^[0-9a-zA-Z]+$/.test(s);\n}\n\n/*\n  returns true if string contains only letters. Returns false otherwise.\n  */\nconst isLetter2 = (s) => {\n  return /^[a-zA-Z]+$/.test(s);\n}\n\n/*\n  returns true if string contains only underscores. Returns false otherwise.\n  */\nconst isUnderscore2 = (s) => {\n  return /^_+$/.test(s);\n}\n\n/*\n  returns true if string contains only digits. Returns false otherwise.\n  */\nconst isDigit3 = (s) => {\n  return /^[0-9a-zA-Z]+$/.test(s);\n}\n\n/*\n  returns true if string contains only letters. Returns false otherwise.\n  */\nconst isLetter3 = (s) => {\n  return /^[a-zA-Z]+$/.test(s);\n}\n\n/*\n  returns true if string contains only underscores. Returns false otherwise.\n  */\nconst isUnderscore3 = (s) => {\n  return /^_+$/.test(s);\n}\n\n/*\n  returns true if string contains only digits. Returns false otherwise.\n  */\nconst isDigit4 = (s) => {\n  return /^[0-9a-zA-Z]+$/.test(s);\n}\n\n/*\n  returns true if string contains only letters. Returns false otherwise.\n  */\nconst isLetter4 = (s) => {\n  return /^[a-zA-Z]+$/.test(s);\n}\n\n/*\n  returns true if string contains only underscores. Returns false otherwise.\n  */\nconst isUnderscore4 = (s) => {\n  return /^_+$/.test(s);\n}\n\n/*\n  returns true if string contains only digits. Returns false otherwise.\n  */\nconst isDigit5 = (s) => {\n  return /^[0-9a-zA-Z]+$/.test(s);\n}\n\n/*\n  returns true if string contains only letters. Returns false otherwise.\n  */\nconst isLetter5 = (s) => {\n  return /^[a-zA-Z]+$/.test(s);\n}\n\n/*\n  returns true if string contains only underscores. Returns false otherwise.\n  */\nconst isUnderscore5 = (s) => {\n  return /^_+$/.test(s);\n}\n\n/*\n  returns true if string contains only digits. Returns false otherwise.\n  */\nconst isDigit6 = (s) => {\n  return /^[0-9a-zA-Z]+$/.test(s);\n}\n\n/*\n  returns true if string contains only letters. Returns false otherwise.\n  */\nconst isLetter6 = (s) => {\n  return /^[a-zA-Z]+$/.test(s);\n}\n\n/*\n  returns true if string contains only underscores. Returns false otherwise.\n  */\nconst isUnderscore6 = (s) => {\n  return /^_+$/.test(s);\n}\n\n/*\n  returns true if string contains only digits. Returns false otherwise.\n  */\nconst isDigit7 = (s) => {\n  return /^[0-9a-zA-Z]+$/.test(s);\n}\n\n/*\n  returns true if string contains only letters. Returns false otherwise.\n  */\nconst isLetter7 = (s) => {\n  return /^[a-zA-Z]+$/.test(s);\n}\n\n/*\n  returns true if string contains only underscores. Returns false otherwise.\n  */\nconst isUnderscore7 = (s) => {\n  return /^_+$/.test(s);\n}\n\n/*\n  returns true if string contains only digits. Returns false otherwise.\n  */\nconst isDigit8 = (s) => {\n  return /^[0-9a-zA-Z]+$/.test(s);\n}\n\n/*\n  returns true if string contains only letters. Returns false otherwise.\n  */\nconst isLetter8 = (s) => {\n  return /^[a-zA-Z]+$/.test(s);\n}\n\n/*\n  returns true if string contains only underscores. Returns false otherwise.\n  */\nconst isUnderscore8 = (s) => {\n  return /^_+$/.test(s);\n}\n\n/*\n  returns true if string contains only digits. Returns false otherwise.\n  */\nconst isDigit9 = (s) => {\n  return /^[0-9a-zA-Z]+$/.test(s);\n}\n\n/*\n  returns true if string contains only letters. Returns false otherwise.\n  */\nconst isLetter9 = (s) => {\n  return /^[a-zA-Z]+$/.test(s);\n}\n\n/*\n  returns true if string contains only underscores. Returns false otherwise.\n  */\nconst isUnderscore9 = (s) => {\n  return /^_+$/.test(s);\n}\n\n/*\n  returns true if string contains only digits. Returns false otherwise.\n  */\nconst isDigit10 = (s) => {\n  return /^[0-9a-zA-Z]+$/.test(s);\n}\n\n/*\n  returns true if string contains only letters. Returns false otherwise.\n  */\nconst isLetter10 = (s) => {\n  return /^[a-zA-Z]+$/.test(s);\n}\n\n/*\n  returns true if string contains only underscores. Returns false otherwise.\n  */\nconst isUnderscore10 = (s) => {\n  return /^_+$/.test(s);\n}\n\n/*\n  returns true if string contains only digits. Returns false otherwise.\n  */\nconst isDigit11 = (s) => {\n  return /^[0-9a-zA-Z]+$/.test(s);\n}\n\n/*\n  returns true if string contains only letters. Returns false otherwise.\n  */\nconst isLetter11 = (s) => {\n  return /^[a-zA-Z]+$/.test(s);\n}\n\n/*\n  returns true if string contains only underscores. Returns false otherwise.\n  */\nconst isUnderscore11 = (s) => {\n  return /^_+$/.test(s);\n}\n\n/*\n  returns true if string contains only digits. Returns false otherwise.\n  */\nconst isDigit12 = (s) => {\n  return /^[0-9a-zA-Z]+$/.test(s);\n}\n\n/*\n  returns true if string contains only letters. Returns false otherwise.\n  */\nconst isLetter12 = (s) => {\n  return /^[a-zA-Z]+$/.test(s);\n}\n\n/*\n  returns true if string contains only underscores. Returns false otherwise.\n  */\nconst isUnderscore12 = (s) => {\n  return /^_+$/.test(s);\n}\n\n/*\n  returns true if string contains only digits. Returns false otherwise.\n  */\nconst isDigit13 = (s) => {\n  return /^[0-9a-zA-Z]+$/.test(s);\n}\n\n/*\n  returns true if string contains only letters. Returns false otherwise.\n  */\nconst isLetter13 = (s) => {\n  return /^[a-zA-Z]+$/.test(s);\n}\n\n/*", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/39", "prompt": "/*\n  primeFib returns the n-th number, which is a Fibonacci number, and also a prime number.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n", "canonical_solution": "  var isPrime = function (p) {\n    if (p < 2)\n      return false;\n    for (let k = 2; k < Math.min(Math.floor(Math.sqrt(p)) + 1, p - 1); k++) {\n      if (p % k == 0)\n        return false;\n    }\n    return true;\n  }\n\n  var f = [0, 1];\n  while (true) {\n    f.push(f.at(-1) + f.at(-2));\n    if (isPrime(f.at(-1)))\n      n -= 1;\n    if (n == 0)\n      return f.at(-1);\n  }\n}\n\n", "test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n  console.assert(primeFib(6) === 233)\n  console.assert(primeFib(7) === 1597)\n  console.assert(primeFib(8) === 28657)\n  console.assert(primeFib(9) === 514229)\n  console.assert(primeFib(10) === 433494437)\n}\n\ntestPrimeFib()\n", "declaration": "\nconst primeFib = (n) => {\n", "example_test": "const testPrimeFib = () => {\n  console.assert(primeFib(1) === 2)\n  console.assert(primeFib(2) === 3)\n  console.assert(primeFib(3) === 5)\n  console.assert(primeFib(4) === 13)\n  console.assert(primeFib(5) === 89)\n}\ntestPrimeFib()\n", "entry_point": "primeFib", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  primeFib returns the n-th number, which is a Fibonacci number, and also a prime number.\n  >>> primeFib(1)\n  2\n  >>> primeFib(2)\n  3\n  >>> primeFib(3)\n  5\n  >>> primeFib(4)\n  13\n  >>> primeFib(5)\n  89\n  */\nconst primeFib = (n) => {\n  if (n < 2) {\n    return n;\n  }\n  if (n % 2 === 0) {\n    return 2;\n  }\n  if (n % 3 === 0) {\n    return 3;\n  }\n  if (n % 5 === 0) {\n    return 5;\n  }\n  return primeFib(n-2)+primeFib(n-3);\n};\n\n/**\n * A generator that generates prime numbers. A prime number is a natural number that is\n * greater than 1 that has no positive divisors other than 1 and itself.\n *\n * >>> primes(2)\n * [2, 3, 5, 7]\n *\n * >>> primes(3)\n * [2, 3, 5, 7]\n *\n * >>> primes(5)\n * [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\n *\n * >>> primes(100)\n * [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\n *\n * >>> primes(1000)\n * [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\n *\n * >>> primes(10000)\n * [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]\n *\n * >>> primes(100000)", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/4", "prompt": "/* For a given list of input numbers, calculate the mean absolute deviation around the mean value of this dataset. The mean absolute deviation is the mean absolute difference between each element and a midpoint (mean in this case): MAD = average | x - x _ mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n", "canonical_solution": "  var mean = numbers.reduce((prev, item) => {\n    return prev + item;\n  }, 0) / numbers.length;\n  return numbers.reduce((prev, item) => {\n    return prev + Math.abs(item - mean);\n  }, 0) / numbers.length;\n\n}\n\n", "test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0]) - 2.0 / 3.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0) < 1e-6\n  )\n}\n\ntestMeanAbsoluteDeviation()\n", "declaration": "\nconst meanAbsoluteDeviation = (numbers) => {\n", "example_test": "const testMeanAbsoluteDeviation = () => {\n  console.assert(\n    Math.abs(meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n  )\n}\ntestMeanAbsoluteDeviation()\n", "entry_point": "meanAbsoluteDeviation", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* For a given list of input numbers, calculate the mean absolute deviation around the mean value of this dataset. The mean absolute deviation is the mean absolute difference between each element and a midpoint (mean in this case): MAD = average | x - x _ mean |\n  >>> meanAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  1.0\n  */\nconst meanAbsoluteDeviation = (numbers) => {\n  const means = numbers.map(n => Math.round(n));\n  const mean = means.reduce((a, b) => a + b, 0) / means.length;\n  const deviations = numbers.map(n => Math.abs(n - mean));\n  const mean = means.reduce((a, b) => a + b, 0) / means.length;\n  return deviations.reduce((a, b) => a + b, 0) / numbers.length;\n};\n\n/**\n * Given a list of input numbers, calculate the median absolute deviation around the mean value of this dataset. The median absolute deviation is the median absolute difference between each element and a midpoint (mean in this case): MME = average | x - x _ median |\n  >>> medianAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  2.0\n  */\nconst medianAbsoluteDeviation = (numbers) => {\n  const medians = numbers.map(n => Math.round(n));\n  const mean = medians.reduce((a, b) => a + b, 0) / medians.length;\n  const deviations = numbers.map(n => Math.abs(n - mean));\n  const median = medians.reduce((a, b) => a + b, 0) / medians.length;\n  return deviations.reduce((a, b) => a + b, 0) / numbers.length;\n};\n\n/**\n * Given a list of input numbers, calculate the mode absolute deviation around the mean value of this dataset. The mode absolute deviation is the mode absolute difference between each element and a midpoint (mean in this case): MME = average | x - x _ mode |\n  >>> modeAbsoluteDeviation([1.0, 2.0, 3.0, 4.0])\n  2.0\n  */\nconst modeAbsoluteDeviation = (numbers) => {\n  const modes = numbers.map(n => Math.round(n));\n  const mean = modes.reduce((a, b) => a + b, 0) / modes.length;\n  const deviations = numbers.map(n => Math.abs(n - mean));\n  const mode = modes.reduce((a, b) => a + b, 0) / modes.length;\n  return deviations.reduce((a, b) => a + b, 0) / numbers.length;\n};\n\n/**\n * Given a list of input numbers, calculate the standard deviation of this dataset. The standard deviation is the square root of the mean absolute deviation around the mean value of this dataset. The standard deviation is the square root of the median absolute deviation around the mean value of this dataset. The standard deviation is the square root of the mode absolute deviation around the mean value of this dataset. The standard deviation is the square root of the mean absolute deviation around the median value of this dataset. The standard deviation is the square root of the median absolute deviation around the median value of this dataset. The standard deviation is the square root of the mode absolute deviation around the median value of this dataset. The standard deviation is the square root of the mean absolute deviation around the mode value of this dataset. The standard deviation is the square root of the median absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mode absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mean absolute deviation around the mode value of this dataset. The standard deviation is the square root of the median absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mode absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mean absolute deviation around the mode value of this dataset. The standard deviation is the square root of the median absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mode absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mean absolute deviation around the mode value of this dataset. The standard deviation is the square root of the median absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mode absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mean absolute deviation around the mode value of this dataset. The standard deviation is the square root of the median absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mode absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mean absolute deviation around the mode value of this dataset. The standard deviation is the square root of the median absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mode absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mean absolute deviation around the mode value of this dataset. The standard deviation is the square root of the median absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mode absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mean absolute deviation around the mode value of this dataset. The standard deviation is the square root of the median absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mode absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mean absolute deviation around the mode value of this dataset. The standard deviation is the square root of the median absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mode absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mean absolute deviation around the mode value of this dataset. The standard deviation is the square root of the median absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mode absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mean absolute deviation around the mode value of this dataset. The standard deviation is the square root of the median absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mode absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mean absolute deviation around the mode value of this dataset. The standard deviation is the square root of the median absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mode absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mean absolute deviation around the mode value of this dataset. The standard deviation is the square root of the median absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mode absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mean absolute deviation around the mode value of this dataset. The standard deviation is the square root of the median absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mode absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mean absolute deviation around the mode value of this dataset. The standard deviation is the square root of the median absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mode absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mean absolute deviation around the mode value of this dataset. The standard deviation is the square root of the median absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mode absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mean absolute deviation around the mode value of this dataset. The standard deviation is the square root of the median absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mode absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mean absolute deviation around the mode value of this dataset. The standard deviation is the square root of the median absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mode absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mean absolute deviation around the mode value of this dataset. The standard deviation is the square root of the median absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mode absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mean absolute deviation around the mode value of this dataset. The standard deviation is the square root of the median absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mode absolute deviation around the mode value of this dataset. The standard deviation is the square root of the mean absolute deviation around the mode value of this dataset", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/40", "prompt": "/*\n  triplesSumToZero takes a list of integers as input. It returns true if there are three unique elements in the list that add up to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      for (let k = j + 1; k < l.length; k++)\n        if (l[i] + l[j] + l[k] == 0)\n          return true;\n  return false;\n}\n\n", "test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -1]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([1, 2, 5, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n  console.assert(triplesSumToZero([1]) === false)\n  console.assert(triplesSumToZero([1, 3, 5, -100]) === false)\n  console.assert(triplesSumToZero([100, 3, 5, -100]) === false)\n}\n\ntestTriplesSumToZero()\n", "declaration": "\nconst triplesSumToZero = (l) => {\n", "example_test": "const testTriplesSumToZero = () => {\n  console.assert(triplesSumToZero([1, 3, 5, 0]) === false)\n  console.assert(triplesSumToZero([1, 3, -2, 1]) === true)\n  console.assert(triplesSumToZero([1, 2, 3, 7]) === false)\n  console.assert(triplesSumToZero([2, 4, -5, 3, 9, 7]) === true)\n}\ntestTriplesSumToZero()\n", "entry_point": "triplesSumToZero", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  triplesSumToZero takes a list of integers as input. It returns true if there are three unique elements in the list that add up to zero, and false otherwise.\n\n  >>> triplesSumToZero([1, 3, 5, 0])\n  false\n  >>> triplesSumToZero([1, 3, -2, 1])\n  true\n  >>> triplesSumToZero([1, 2, 3, 7])\n  false\n  >>> triplesSumToZero([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToZero([1])\n  false\n  */\nconst triplesSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 0) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  triplesSumToOne takes a list of integers as input. It returns true if there are three unique elements in the list that add up to one, and false otherwise.\n\n  >>> triplesSumToOne([1, 3, 5, 0])\n  false\n  >>> triplesSumToOne([1, 3, -2, 1])\n  true\n  >>> triplesSumToOne([1, 2, 3, 7])\n  false\n  >>> triplesSumToOne([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToOne([1])\n  false\n  */\nconst triplesSumToOne = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 1) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  triplesSumToTwo takes a list of integers as input. It returns true if there are three unique elements in the list that add up to two, and false otherwise.\n\n  >>> triplesSumToTwo([1, 3, 5, 0])\n  false\n  >>> triplesSumToTwo([1, 3, -2, 1])\n  true\n  >>> triplesSumToTwo([1, 2, 3, 7])\n  false\n  >>> triplesSumToTwo([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToTwo([1])\n  false\n  */\nconst triplesSumToTwo = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 2) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  triplesSumToThree takes a list of integers as input. It returns true if there are three unique elements in the list that add up to three, and false otherwise.\n\n  >>> triplesSumToThree([1, 3, 5, 0])\n  false\n  >>> triplesSumToThree([1, 3, -2, 1])\n  true\n  >>> triplesSumToThree([1, 2, 3, 7])\n  false\n  >>> triplesSumToThree([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToThree([1])\n  false\n  */\nconst triplesSumToThree = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 3) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  triplesSumToFour takes a list of integers as input. It returns true if there are three unique elements in the list that add up to four, and false otherwise.\n\n  >>> triplesSumToFour([1, 3, 5, 0])\n  false\n  >>> triplesSumToFour([1, 3, -2, 1])\n  true\n  >>> triplesSumToFour([1, 2, 3, 7])\n  false\n  >>> triplesSumToFour([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToFour([1])\n  false\n  */\nconst triplesSumToFour = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 4) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  triplesSumToFive takes a list of integers as input. It returns true if there are three unique elements in the list that add up to five, and false otherwise.\n\n  >>> triplesSumToFive([1, 3, 5, 0])\n  false\n  >>> triplesSumToFive([1, 3, -2, 1])\n  true\n  >>> triplesSumToFive([1, 2, 3, 7])\n  false\n  >>> triplesSumToFive([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToFive([1])\n  false\n  */\nconst triplesSumToFive = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 5) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  triplesSumToSix takes a list of integers as input. It returns true if there are three unique elements in the list that add up to six, and false otherwise.\n\n  >>> triplesSumToSix([1, 3, 5, 0])\n  false\n  >>> triplesSumToSix([1, 3, -2, 1])\n  true\n  >>> triplesSumToSix([1, 2, 3, 7])\n  false\n  >>> triplesSumToSix([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToSix([1])\n  false\n  */\nconst triplesSumToSix = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 6) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  triplesSumToSeven takes a list of integers as input. It returns true if there are three unique elements in the list that add up to seven, and false otherwise.\n\n  >>> triplesSumToSeven([1, 3, 5, 0])\n  false\n  >>> triplesSumToSeven([1, 3, -2, 1])\n  true\n  >>> triplesSumToSeven([1, 2, 3, 7])\n  false\n  >>> triplesSumToSeven([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToSeven([1])\n  false\n  */\nconst triplesSumToSeven = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 7) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  triplesSumToEight takes a list of integers as input. It returns true if there are three unique elements in the list that add up to eight, and false otherwise.\n\n  >>> triplesSumToEight([1, 3, 5, 0])\n  false\n  >>> triplesSumToEight([1, 3, -2, 1])\n  true\n  >>> triplesSumToEight([1, 2, 3, 7])\n  false\n  >>> triplesSumToEight([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToEight([1])\n  false\n  */\nconst triplesSumToEight = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 8) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  triplesSumToNine takes a list of integers as input. It returns true if there are three unique elements in the list that add up to nine, and false otherwise.\n\n  >>> triplesSumToNine([1, 3, 5, 0])\n  false\n  >>> triplesSumToNine([1, 3, -2, 1])\n  true\n  >>> triplesSumToNine([1, 2, 3, 7])\n  false\n  >>> triplesSumToNine([2, 4, -5, 3, 9, 7])\n  true\n  >>> triplesSumToNine([1])\n  false\n  */\nconst triplesSumToNine = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n    if (sum === 9) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*\n  triplesSumToTen takes a list of integers as input. It returns ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/41", "prompt": "/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n", "canonical_solution": "  return Math.pow(n, 2);\n}\n\n", "test": "const testCarRaceCollision = () => {\n  console.assert(carRaceCollision(2) === 4)\n  console.assert(carRaceCollision(3) === 9)\n  console.assert(carRaceCollision(4) === 16)\n  console.assert(carRaceCollision(8) === 64)\n  console.assert(carRaceCollision(10) === 100)\n}\n\ntestCarRaceCollision()\n", "declaration": "\nconst carRaceCollision = (n) => {\n", "example_test": "", "entry_point": "carRaceCollision", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*\n  Imagine a road that's a perfectly straight infinitely long line.\n  n cars are driving left to right;  simultaneously, a different set of n cars\n  are driving right to left.   The two sets of cars start out being very far from\n  each other.  All cars move in the same speed.  Two cars are said to collide\n  when a car that's moving left to right hits a car that's moving right to left.\n  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n  in their trajectory as if they did not collide.\n\n  This function outputs the number of such collisions.\n  */\nconst carRaceCollision = (n) => {\n  const collisions = 0;\n  const cars = Array.from({ length: n }, (_, i) => i);\n  let carIndex = 0;\n  let carSpeed = 0;\n  let carLeft = 0;\n  let carRight = 0;\n  let carLeftSpeed = 0;\n  let carRightSpeed = 0;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollided = false;\n  let carRightCollided = false;\n  let carLeftCollide", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/42", "prompt": "/*Return list with elements increased by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n", "canonical_solution": "  return l.map(e => e + 1);\n}\n\n", "test": "const testIncrList = () => {\n  console.assert(JSON.stringify(incrList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(incrList([3, 2, 1])) === JSON.stringify([4, 3, 2])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\n\ntestIncrList()\n", "declaration": "\nconst incrList = (l) => {\n", "example_test": "const testIncrList = () => {\n  console.assert(\n    JSON.stringify(incrList([1, 2, 3])) === JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(incrList([5, 2, 5, 2, 3, 3, 9, 0, 123])) ===\n      JSON.stringify([6, 3, 6, 3, 4, 4, 10, 1, 124])\n  )\n}\ntestIncrList()\n", "entry_point": "incrList", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Return list with elements increased by 1.\n  >>> incrList([1, 2, 3])\n  [2, 3, 4]\n  >>> incrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst incrList = (l) => {\n  let result = []\n  l.forEach((item, index) => {\n    result.push(item + 1)\n  })\n  return result\n}\n\n/*Return list with elements decreased by 1.\n  >>> decrList([1, 2, 3])\n  [2, 3, 4]\n  >>> decrList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst decrList = (l) => {\n  let result = []\n  l.forEach((item, index) => {\n    result.push(item - 1)\n  })\n  return result\n}\n\n/*Return list with elements multiplied by 1.\n  >>> multList([1, 2, 3])\n  [2, 3, 4]\n  >>> multList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst multList = (l) => {\n  let result = []\n  l.forEach((item, index) => {\n    result.push(item * 1)\n  })\n  return result\n}\n\n/*Return list with elements divided by 1.\n  >>> divList([1, 2, 3])\n  [2, 3, 4]\n  >>> divList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst divList = (l) => {\n  let result = []\n  l.forEach((item, index) => {\n    result.push(item / 1)\n  })\n  return result\n}\n\n/*Return list with elements raised to the power of n.\n  >>> powList([1, 2, 3])\n  [2, 3, 4]\n  >>> powList([5, 3, 5, 2, 3, 3, 9, 0, 123])\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst powList = (l) => {\n  let result = []\n  l.forEach((item, index) => {\n    result.push(Math.pow(item, index))\n  })\n  return result\n}\n\n/*Return list with elements raised to the power of n and multiplied by 1.\n  >>> powList([1, 2, 3], 2)\n  [2, 3, 4]\n  >>> powList([5, 3, 5, 2, 3, 3, 9, 0, 123], 2)\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst powList = (l, n) => {\n  let result = []\n  l.forEach((item, index) => {\n    result.push(Math.pow(item, index) * n)\n  })\n  return result\n}\n\n/*Return list with elements raised to the power of n and divided by 1.\n  >>> powList([1, 2, 3], 2)\n  [2, 3, 4]\n  >>> powList([5, 3, 5, 2, 3, 3, 9, 0, 123], 2)\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst powList = (l, n) => {\n  let result = []\n  l.forEach((item, index) => {\n    result.push(Math.pow(item, index) / n)\n  })\n  return result\n}\n\n/*Return list with elements raised to the power of n and multiplied by n and divided by 1.\n  >>> powList([1, 2, 3], 2, 2)\n  [2, 3, 4]\n  >>> powList([5, 3, 5, 2, 3, 3, 9, 0, 123], 2, 2)\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst powList = (l, n, n) => {\n  let result = []\n  l.forEach((item, index) => {\n    result.push(Math.pow(item, index) * n / n)\n  })\n  return result\n}\n\n/*Return list with elements raised to the power of n and multiplied by n and divided by n.\n  >>> powList([1, 2, 3], 2, 2, 2)\n  [2, 3, 4]\n  >>> powList([5, 3, 5, 2, 3, 3, 9, 0, 123], 2, 2, 2)\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst powList = (l, n, n, n) => {\n  let result = []\n  l.forEach((item, index) => {\n    result.push(Math.pow(item, index) * n / n / n)\n  })\n  return result\n}\n\n/*Return list with elements raised to the power of n and multiplied by n and divided by n.\n  >>> powList([1, 2, 3], 2, 2, 2, 2)\n  [2, 3, 4]\n  >>> powList([5, 3, 5, 2, 3, 3, 9, 0, 123], 2, 2, 2, 2)\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst powList = (l, n, n, n, n) => {\n  let result = []\n  l.forEach((item, index) => {\n    result.push(Math.pow(item, index) * n / n / n / n)\n  })\n  return result\n}\n\n/*Return list with elements raised to the power of n and multiplied by n and divided by n and raised to the power of n.\n  >>> powList([1, 2, 3], 2, 2, 2, 2, 2)\n  [2, 3, 4]\n  >>> powList([5, 3, 5, 2, 3, 3, 9, 0, 123], 2, 2, 2, 2, 2)\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst powList = (l, n, n, n, n, n) => {\n  let result = []\n  l.forEach((item, index) => {\n    result.push(Math.pow(item, index) * n / n / n / n / n)\n  })\n  return result\n}\n\n/*Return list with elements raised to the power of n and multiplied by n and divided by n and raised to the power of n.\n  >>> powList([1, 2, 3], 2, 2, 2, 2, 2, 2)\n  [2, 3, 4]\n  >>> powList([5, 3, 5, 2, 3, 3, 9, 0, 123], 2, 2, 2, 2, 2, 2)\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst powList = (l, n, n, n, n, n, n) => {\n  let result = []\n  l.forEach((item, index) => {\n    result.push(Math.pow(item, index) * n / n / n / n / n / n)\n  })\n  return result\n}\n\n/*Return list with elements raised to the power of n and multiplied by n and divided by n and raised to the power of n and raised to the power of n.\n  >>> powList([1, 2, 3], 2, 2, 2, 2, 2, 2, 2)\n  [2, 3, 4]\n  >>> powList([5, 3, 5, 2, 3, 3, 9, 0, 123], 2, 2, 2, 2, 2, 2, 2)\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst powList = (l, n, n, n, n, n, n, n) => {\n  let result = []\n  l.forEach((item, index) => {\n    result.push(Math.pow(item, index) * n / n / n / n / n / n / n)\n  })\n  return result\n}\n\n/*Return list with elements raised to the power of n and multiplied by n and divided by n and raised to the power of n and raised to the power of n and raised to the power of n.\n  >>> powList([1, 2, 3], 2, 2, 2, 2, 2, 2, 2, 2)\n  [2, 3, 4]\n  >>> powList([5, 3, 5, 2, 3, 3, 9, 0, 123], 2, 2, 2, 2, 2, 2, 2, 2, 2)\n  [6, 4, 6, 3, 4, 4, 10, 1, 124]\n  */\nconst powList = (l, n, n, n, n, n, n, n, n) => {\n  let result = []\n  l.forEach((item, index) => {\n    result.push(Math.pow(item, index) * n / n / n / n / n / n / n / n / n)\n  })\n  return result\n}\n\n/*Return list with elements raised to the power of n and multiplied by n and divided by n and raised to the power of n and raised to the power of n and raised to the power of n and raised to the power of n and raised to the power of n and raised to the power of n and raised to the power of n and raised to the power of n and raised to the power of n and raised to the power of n and raised to the power of n and raise", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/43", "prompt": "/*\n  pairsSumToZero takes a list of integers as input. It returns true if there are two different elements in the list that add up to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n", "canonical_solution": "  for (let i = 0; i < l.length; i++)\n    for (let j = i + 1; j < l.length; j++)\n      if (l[i] + l[j] == 0)\n        return true;\n  return false;\n}\n\n", "test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n  console.assert(pairsSumToZero([1]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 30]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 3, 2, 31]) === true)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 30]) === false)\n  console.assert(pairsSumToZero([-3, 9, -1, 4, 2, 31]) === false)\n}\n\ntestPairsSumToZero()\n", "declaration": "\nconst pairsSumToZero = (l) => {\n", "example_test": "const testPairsSumToZero = () => {\n  console.assert(pairsSumToZero([1, 3, 5, 0]) === false)\n  console.assert(pairsSumToZero([1, 3, -2, 1]) === false)\n  console.assert(pairsSumToZero([1, 2, 3, 7]) === false)\n  console.assert(pairsSumToZero([2, 4, -5, 3, 5, 7]) === true)\n}\ntestPairsSumToZero()\n", "entry_point": "pairsSumToZero", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  pairsSumToZero takes a list of integers as input. It returns true if there are two different elements in the list that add up to zero, and false otherwise.\n  >>> pairsSumToZero([1, 3, 5, 0])\n  false\n  >>> pairsSumToZero([1, 3, -2, 1])\n  false\n  >>> pairsSumToZero([1, 2, 3, 7])\n  false\n  >>> pairsSumToZero([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToZero([1])\n  false\n  */\nconst pairsSumToZero = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 0;\n};\n\n/*\n  pairsSumToOne takes a list of integers as input. It returns true if there are two different elements in the list that add up to one, and false otherwise.\n  >>> pairsSumToOne([1, 3, 5, 0])\n  false\n  >>> pairsSumToOne([1, 3, -2, 1])\n  false\n  >>> pairsSumToOne([1, 2, 3, 7])\n  false\n  >>> pairsSumToOne([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToOne([1])\n  false\n  */\nconst pairsSumToOne = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 1;\n};\n\n/*\n  pairsSumToTwo takes a list of integers as input. It returns true if there are two different elements in the list that add up to two, and false otherwise.\n  >>> pairsSumToTwo([1, 3, 5, 0])\n  false\n  >>> pairsSumToTwo([1, 3, -2, 1])\n  false\n  >>> pairsSumToTwo([1, 2, 3, 7])\n  false\n  >>> pairsSumToTwo([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToTwo([1])\n  false\n  */\nconst pairsSumToTwo = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 2;\n};\n\n/*\n  pairsSumToThree takes a list of integers as input. It returns true if there are two different elements in the list that add up to three, and false otherwise.\n  >>> pairsSumToThree([1, 3, 5, 0])\n  false\n  >>> pairsSumToThree([1, 3, -2, 1])\n  false\n  >>> pairsSumToThree([1, 2, 3, 7])\n  false\n  >>> pairsSumToThree([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToThree([1])\n  false\n  */\nconst pairsSumToThree = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 3;\n};\n\n/*\n  pairsSumToFour takes a list of integers as input. It returns true if there are two different elements in the list that add up to four, and false otherwise.\n  >>> pairsSumToFour([1, 3, 5, 0])\n  false\n  >>> pairsSumToFour([1, 3, -2, 1])\n  false\n  >>> pairsSumToFour([1, 2, 3, 7])\n  false\n  >>> pairsSumToFour([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToFour([1])\n  false\n  */\nconst pairsSumToFour = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 4;\n};\n\n/*\n  pairsSumToFive takes a list of integers as input. It returns true if there are two different elements in the list that add up to five, and false otherwise.\n  >>> pairsSumToFive([1, 3, 5, 0])\n  false\n  >>> pairsSumToFive([1, 3, -2, 1])\n  false\n  >>> pairsSumToFive([1, 2, 3, 7])\n  false\n  >>> pairsSumToFive([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToFive([1])\n  false\n  */\nconst pairsSumToFive = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 5;\n};\n\n/*\n  pairsSumToSix takes a list of integers as input. It returns true if there are two different elements in the list that add up to six, and false otherwise.\n  >>> pairsSumToSix([1, 3, 5, 0])\n  false\n  >>> pairsSumToSix([1, 3, -2, 1])\n  false\n  >>> pairsSumToSix([1, 2, 3, 7])\n  false\n  >>> pairsSumToSix([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToSix([1])\n  false\n  */\nconst pairsSumToSix = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 6;\n};\n\n/*\n  pairsSumToSeven takes a list of integers as input. It returns true if there are two different elements in the list that add up to seven, and false otherwise.\n  >>> pairsSumToSeven([1, 3, 5, 0])\n  false\n  >>> pairsSumToSeven([1, 3, -2, 1])\n  false\n  >>> pairsSumToSeven([1, 2, 3, 7])\n  false\n  >>> pairsSumToSeven([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToSeven([1])\n  false\n  */\nconst pairsSumToSeven = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 7;\n};\n\n/*\n  pairsSumToEight takes a list of integers as input. It returns true if there are two different elements in the list that add up to eight, and false otherwise.\n  >>> pairsSumToEight([1, 3, 5, 0])\n  false\n  >>> pairsSumToEight([1, 3, -2, 1])\n  false\n  >>> pairsSumToEight([1, 2, 3, 7])\n  false\n  >>> pairsSumToEight([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToEight([1])\n  false\n  */\nconst pairsSumToEight = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 8;\n};\n\n/*\n  pairsSumToNine takes a list of integers as input. It returns true if there are two different elements in the list that add up to nine, and false otherwise.\n  >>> pairsSumToNine([1, 3, 5, 0])\n  false\n  >>> pairsSumToNine([1, 3, -2, 1])\n  false\n  >>> pairsSumToNine([1, 2, 3, 7])\n  false\n  >>> pairsSumToNine([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToNine([1])\n  false\n  */\nconst pairsSumToNine = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 9;\n};\n\n/*\n  pairsSumToTen takes a list of integers as input. It returns true if there are two different elements in the list that add up to ten, and false otherwise.\n  >>> pairsSumToTen([1, 3, 5, 0])\n  false\n  >>> pairsSumToTen([1, 3, -2, 1])\n  false\n  >>> pairsSumToTen([1, 2, 3, 7])\n  false\n  >>> pairsSumToTen([2, 4, -5, 3, 5, 7])\n  true\n  >>> pairsSumToTen([1])\n  false\n  */\nconst pairsSumToTen = (l) => {\n  let sum = 0;\n  for (let i = 0; i < l.length; i++) {\n    sum += l[i];\n  }\n  return sum === 10;\n};\n\n/*\n  pairsSumToEleven takes a list of integers as input. It returns true if there are two different elements in the list that add up to eleven, and false otherwise.\n  >>> pairsSumToEleven([1, 3, 5, 0])\n  false\n  >>> pairsSumTo", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/44", "prompt": "/*Cdepend numerical base of the input number x to the base. Returns the string representation after the conversion. Base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n", "canonical_solution": "  var ret = \"\";\n  while (x > 0) {\n    ret = (x % base).toString() + ret;\n    x = Math.floor(x / base);\n  }\n  return ret;\n}\n\n", "test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(9, 3) === '100')\n  console.assert(changeBase(234, 2) === '11101010')\n  console.assert(changeBase(16, 2) === '10000')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n\n  for (let i = 2; i < 8; i++) {\n    console.assert(changeBase(i, i + 1) === i.toString())\n  }\n}\n\ntestChangeBase()\n", "declaration": "\nconst changeBase = (x, base) => {\n", "example_test": "const testChangeBase = () => {\n  console.assert(changeBase(8, 3) === '22')\n  console.assert(changeBase(8, 2) === '1000')\n  console.assert(changeBase(7, 2) === '111')\n}\ntestChangeBase()\n", "entry_point": "changeBase", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Cdepend numerical base of the input number x to the base. Returns the string representation after the conversion. Base numbers are less than 10.\n  >>> changeBase(8, 3)\n  '22'\n  >>> changeBase(8, 2)\n  '1000'\n  >>> changeBase(7, 2)\n  '111'\n  */\nconst changeBase = (x, base) => {\n  if (base < 10) {\n    return String(base) + x.toString();\n  }\n  return x.toString().split('').reverse().map(n => changeBase(Number(n), base - 1)).join('');\n};\n\n/**\n * Converts a string to a number in base 10. Throws an error if the string is not a number.\n * Base numbers are less than 10.\n * Throws an error if the string is not a number.\n */\nconst toNumber = (str, base) => {\n  if (Number.isInteger(str)) {\n    return str;\n  }\n  if (Number.isInteger(Number(str))) {\n    return Number(str);\n  }\n  if (Number.isInteger(Number(Number(str)))) {\n    return Number(Number(str));\n  }\n  if (Number.isInteger(Number(Number(Number(str)))) {\n    return Number(Number(Number(Number(str)));\n  }\n  if (Number.isInteger(Number(Number(Number(Number(str)))) {\n    return Number(Number(Number(Number(Number(Number(str)))));\n  }\n  if (Number.isInteger(Number(Number(Number(Number(Number(Number(str)))) {\n    return Number(Number(Number(Number(Number(Number(Number(Number(str)))))));\n  }\n  if (Number.isInteger(Number(Number(Number(Number(Number(Number(Number(str)))) {\n    return Number(Number(Number(Number(Number(Number(Number(Number(Number(str)))))))));\n  }\n  if (Number.isInteger(Number(Number(Number(Number(Number(Number(Number(Number(Number(str)))) {\n    return Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(str)))))))))));\n  }\n  if (Number.isInteger(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(str)))) {\n    return Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(str)))))))))))))));\n  }\n  if (Number.isInteger(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(str)))) {\n    return Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(str)))))))))))))))))));\n  }\n  if (Number.isInteger(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(str)))) {\n    return Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(str)))) {\n    return Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(str)))) {\n    return Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(str)))) {\n    return Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(str)))) {\n    return Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(str)))) {\n    return Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(str)))) {\n    return Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(str)))) {\n    return Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(Number(", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/45", "prompt": "/*GThe length of one side is the same and the return face is high for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n", "canonical_solution": "  return a * h / 2.0;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n  console.assert(triangleArea(2, 2) === 2.0)\n  console.assert(triangleArea(10, 8) === 40.0)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, h) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(5, 3) === 7.5)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*GThe length of one side is the same and the return face is high for a triangle.\n  >>> triangleArea(5, 3)\n  7.5\n  */\nconst triangleArea = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea2 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea3 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea4 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea5 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea6 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea7 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea8 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea9 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea10 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea11 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea12 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea13 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea14 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea15 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea16 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea17 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea18 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea19 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea20 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea21 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea22 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea23 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea24 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea25 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea26 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea27 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = Math.sqrt(a * a + h * h);\n  return Math.max(s, 0);\n};\n\n/*\n  >>> triangleArea(6, 3)\n  8.5\n  */\nconst triangleArea28 = (a, h) => {\n  const a = Math.abs(a);\n  const h = Math.abs(h);\n  const s = ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/46", "prompt": "/*TThe Fib4 sequence is a sequence similar to the Fibbonacci sequence, which is defined as: fib4 (0) - > 0 fib4 (1) - > 0 fib4 (2) - > 2 fib4 (3) - > 0 fib4 (n-1) - > fib4 (n-2) + fib4 (n-3) + fib4 (n-4).\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n", "canonical_solution": "  var results = [0, 0, 2, 0];\n  if (n < 4)\n    return results[n];\n  for (let i = 4; i < n + 1; i++) {\n    results.push(results.at(-1) + results.at(-2) +\n                results.at(-3) + results.at(-4));\n    results.shift();\n  }\n  return results.pop();\n}\n\n", "test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(8) === 28)\n  console.assert(fib4(10) === 104)\n  console.assert(fib4(12) === 386)\n}\n\ntestFib4()\n", "declaration": "\nconst fib4 = (n) => {\n", "example_test": "const testFib4 = () => {\n  console.assert(fib4(5) === 4)\n  console.assert(fib4(6) === 8)\n  console.assert(fib4(7) === 14)\n}\ntestFib4()\n", "entry_point": "fib4", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*TThe Fib4 sequence is a sequence similar to the Fibbonacci sequence, which is defined as: fib4 (0) - > 0 fib4 (1) - > 0 fib4 (2) - > 2 fib4 (3) - > 0 fib4 (n-1) - > fib4 (n-2) + fib4 (n-3) + fib4 (n-4).\n  >>> fib4(5)\n  4\n  >>> fib4(6)\n  8\n  >>> fib4(7)\n  14\n  */\nconst fib4 = (n) => {\n  if (n <= 1) return 1;\n  return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4);\n};\n\n/*\n  >>> fib5(10)\n  55\n  >>> fib5(20)\n  110\n  >>> fib5(30)\n  230\n  >>> fib5(50)\n  720\n  >>> fib5(100)\n  5040\n  >>> fib5(1000)\n  50400\n  >>> fib5(10000)\n  504000\n  >>> fib5(100000)\n  50400000\n  >>> fib5(1000000)\n  504000000\n  >>> fib5(10000000)\n  5040000000\n  >>> fib5(100000000)\n  50400000000\n  >>> fib5(1000000000)\n  504000000000\n  >>> fib5(10000000000)\n  5040000000000\n  >>> fib5(100000000000)\n  50400000000000\n  >>> fib5(1000000000000)\n  504000000000000\n  >>> fib5(1000000000000)\n  5040000000000000\n  >>> fib5(100000000000000)\n  50400000000000000\n  >>> fib5(100000000000000)\n  504000000000000000\n  >>> fib5(10000000000000000)\n  5040000000000000000\n  >>> fib5(100000000000000000)\n  50400000000000000000\n  >>> fib5(1000000000000000000)\n  504000000000000000000\n  >>> fib5(10000000000000000000)\n  5040000000000000000000\n  >>> fib5(100000000000000000000)\n  50400000000000000000000\n  >>> fib5(100000000000000000000)\n  504000000000000000000000\n  >>> fib5(10000000000000000000000)\n  5040000000000000000000000\n  >>> fib5(10000000000000000000000)\n  50400000000000000000000000\n  >>> fib5(1000000000000000000000000)\n  504000000000000000000000000\n  >>> fib5(10000000000000000000000000)\n  5040000000000000000000000000\n  >>> fib5(100000000000000000000000000)\n  50400000000000000000000000000\n  >>> fib5(1000000000000000000000000000)\n  504000000000000000000000000000\n  >>> fib5(10000000000000000000000000000)\n  5040000000000000000000000000000\n  >>> fib5(10000000000000000000000000000)\n  50400000000000000000000000000000\n  >>> fib5(1000000000000000000000000000000)\n  504000000000000000000000000000000\n  >>> fib5(1000000000000000000000000000000)\n  5040000000000000000000000000000000\n  >>> fib5(100000000000000000000000000000000)\n  50400000000000000000000000000000000\n  >>> fib5(1000000000000000000000000000000000)\n  504000000000000000000000000000000000\n  >>> fib5(10000000000000000000000000000000000)\n  5040000000000000000000000000000000000\n  >>> fib5(100000000000000000000000000000000000)\n  50400000000000000000000000000000000000\n  >>> fib5(1000000000000000000000000000000000000)\n  504000000000000000000000000000000000000\n  >>> fib5(1000000000000000000000000000000000000)\n  5040000000000000000000000000000000000000\n  >>> fib5(100000000000000000000000000000000000000)\n  50400000000000000000000000000000000000000\n  >>> fib5(100000000000000000000000000000000000000)\n  504000000000000000000000000000000000000000\n  >>> fib5(10000000000000000000000000000000000000000)\n  5040000000000000000000000000000000000000000\n  >>> fib5(100000000000000000000000000000000000000000)\n  50400000000000000000000000000000000000000000\n  >>> fib5(10000000000000000000000000000000000)\n  5040000000000000000000000000000000000\n  >>> fib5(100000000000000000000000000000000000)\n  50400000000000000000000000000000000000\n  >>> fib5(1000000000000000000000000000000000000)\n  504000000000000000000000000000000000000\n  >>> fib5(1000000000000000000000000000000000000)\n  5040000000000000000000000000000000000000\n  >>> fib5(100000000000000000000000000000000000000)\n  50400000000000000000000000000000000000000\n  >>> fib5(100000000000000000000000000000000000000)\n  504000000000000000000000000000000000000000\n  >>> fib5(10000000000000000000000000000000000000000)\n  5040000000000000000000000000000000000000000\n  >>> fib5(100000000000000000000000000000000000000000)\n  50400000000000000000000000000000000000000000\n  >>> fib5(10000000000000000000000000000000000)\n  5040000000000000000000000000000000000\n  >>> fib5(100000000000000000000000000000000000)\n  50400000000000000000000000000000000000\n  >>> fib5(1000000000000000000000000000000000000)\n  504000000000000000000000000000000000000\n  >>> fib5(1000000000000000000000000000000000000)\n  5040000000000000000000000000000000000000\n  >>> fib5(100000000000000000000000000000000000000)\n  50400000000000000000000000000000000000000\n  >>> fib5(100000000000000000000000000000000000000)\n  504000000000000000000000000000000000000000\n  >>> fib5(10000000000000000000000000000000000000000)\n  5040000000000000000000000000000000000000000\n  >>> fib5(100000000000000000000000000000000000000000)\n  50400000000000000000000000000000000000000000\n  >>> fib5(10000000000000000000000000000000000)\n  5040000000000000000000000000000000000\n  >>> fib5(100000000000000000000000000000000000)\n  50400000000000000000000000000000000000\n  >>> fib5(1000000000000000000000000000000000000)\n  504000000000000000000000000000000000000\n  >>> fib5(1000000000000000000000000000000000000)\n  5040000000000000000000000000000000000000\n  >>> fib5(100000000000000000000000000000000000000)\n  50400000000000000000000000000000000000000\n  >>> fib5(100000000000000000000000000000000000000)\n  504000000000000000000000000000000000000000\n  >>> fib5(10000000000000000000000000000000000000000)\n  5040000000000000000000000000000000000000000\n  >>> fib5(100000000000000000000000000000000000000000)\n  50400000000000000000000000000000000000000000\n  >>> fib5(10000000000000000000000000000000000)\n  5040000000000000000000000000000000000\n  >>> fib5(100000000000000000000000000000000000)\n  50400000000000000000000000000000000000\n  >>> fib5(1000000000000000000000000000000000000)\n  504000000000000000000000000000000000000\n  >>> fib5(1000000000000000000000000000000000000)\n  5040000000000000000000000000000000000000\n  >>> fib5(100000000000000000000000000000000000000)\n  50400000000000000000000000000000000000000\n  >>> fib5(100000000000000000000000000000000000000)\n  504000000000000000000000000000000000000000\n  >>> fib5(10000000000000000000000000000000000000000)\n  5040000000000000000000000000000000000000000\n  >>> fib5(100000000000000000000000000000000000000000)\n  50400000000000000000000000000000000000000000\n  >>> fib5(10000000000000000000000000000000000)\n  5040000000000000000000000000000000000\n  >>> fib5(100000000000000000000000000000000000)\n  50400000000000000000000000000000000000\n  >>> fib5(1000000000000000000000000000000000000)\n  504000000000000000000000000000000000000\n  ", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/47", "prompt": "/*RThe median number of items in the list.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n", "canonical_solution": "  l.sort((a, b) => a - b);\n  var len = l.length;\n  if (l.length % 2 == 1)\n    return l[Math.floor(len / 2)];\n  else\n    return (l[len / 2 - 1] + l[len / 2]) / 2.0;\n}\n\n", "test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n  console.assert(median([5]) === 5)\n  console.assert(median([6, 5]) === 5.5)\n  console.assert(median([8, 1, 3, 9, 9, 2, 7]) === 7)\n}\n\ntestMedian()\n", "declaration": "\nconst median = (l) => {\n", "example_test": "const testMedian = () => {\n  console.assert(median([3, 1, 2, 4, 5]) === 3)\n  console.assert(median([-10, 4, 6, 1000, 10, 20]) === 8.0)\n}\ntestMedian()\n", "entry_point": "median", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*RThe median number of items in the list.\n  >>> median([3, 1, 2, 4, 5])\n  3\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst median = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n >> 1;\n  let i = Math.floor(n/2);\n  let j = (i+1)%n;\n  return ((l[j] + l[(i+1)%n])/2).__floor__();\n};\n\n/*\n  >>> median([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n >> 1;\n  let i = Math.floor(n/2);\n  let j = (i+1)%n;\n  return ((l[j] + l[(i+1)%n])/2).__floor__();\n};\n\n/*\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n >> 1;\n  let i = Math.floor(n/2);\n  let j = (i+1)%n;\n  return ((l[j] + l[(i+1)%n])/2).__floor__();\n};\n\n/*\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n >> 1;\n  let i = Math.floor(n/2);\n  let j = (i+1)%n;\n  return ((l[j] + l[(i+1)%n])/2).__floor__();\n};\n\n/*\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n >> 1;\n  let i = Math.floor(n/2);\n  let j = (i+1)%n;\n  return ((l[j] + l[(i+1)%n])/2).__floor__();\n};\n\n/*\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n >> 1;\n  let i = Math.floor(n/2);\n  let j = (i+1)%n;\n  return ((l[j] + l[(i+1)%n])/2).__floor__();\n};\n\n/*\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n >> 1;\n  let i = Math.floor(n/2);\n  let j = (i+1)%n;\n  return ((l[j] + l[(i+1)%n])/2).__floor__();\n};\n\n/*\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n >> 1;\n  let i = Math.floor(n/2);\n  let j = (i+1)%n;\n  return ((l[j] + l[(i+1)%n])/2).__floor__();\n};\n\n/*\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n >> 1;\n  let i = Math.floor(n/2);\n  let j = (i+1)%n;\n  return ((l[j] + l[(i+1)%n])/2).__floor__();\n};\n\n/*\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n >> 1;\n  let i = Math.floor(n/2);\n  let j = (i+1)%n;\n  return ((l[j] + l[(i+1)%n])/2).__floor__();\n};\n\n/*\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n >> 1;\n  let i = Math.floor(n/2);\n  let j = (i+1)%n;\n  return ((l[j] + l[(i+1)%n])/2).__floor__();\n};\n\n/*\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n >> 1;\n  let i = Math.floor(n/2);\n  let j = (i+1)%n;\n  return ((l[j] + l[(i+1)%n])/2).__floor__();\n};\n\n/*\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n >> 1;\n  let i = Math.floor(n/2);\n  let j = (i+1)%n;\n  return ((l[j] + l[(i+1)%n])/2).__floor__();\n};\n\n/*\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n >> 1;\n  let i = Math.floor(n/2);\n  let j = (i+1)%n;\n  return ((l[j] + l[(i+1)%n])/2).__floor__();\n};\n\n/*\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n >> 1;\n  let i = Math.floor(n/2);\n  let j = (i+1)%n;\n  return ((l[j] + l[(i+1)%n])/2).__floor__();\n};\n\n/*\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n >> 1;\n  let i = Math.floor(n/2);\n  let j = (i+1)%n;\n  return ((l[j] + l[(i+1)%n])/2).__floor__();\n};\n\n/*\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n >> 1;\n  let i = Math.floor(n/2);\n  let j = (i+1)%n;\n  return ((l[j] + l[(i+1)%n])/2).__floor__();\n};\n\n/*\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n >> 1;\n  let i = Math.floor(n/2);\n  let j = (i+1)%n;\n  return ((l[j] + l[(i+1)%n])/2).__floor__();\n};\n\n/*\n  >>> medianOf([-10, 4, 6, 1000, 10, 20])\n  8.0\n  */\nconst medianOf = (l) => {\n  let n = l.length;\n  if (n <= 1) return 0;\n  let m = n ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/48", "prompt": "/*\n  Tests if the given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n", "canonical_solution": "  for (let i = 0; i < text.length; i++)\n    if (text[i] != text.at(-i-1))\n      return false;\n  return true;\n}\n\n", "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n  console.assert(isPalindrome('xywyx') === true)\n  console.assert(isPalindrome('xywyz') === false)\n  console.assert(isPalindrome('xywzx') === false)\n}\n\ntestIsPalindrome()\n", "declaration": "\nconst isPalindrome = (text) => {\n", "example_test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome('') === true)\n  console.assert(isPalindrome('aba') === true)\n  console.assert(isPalindrome('aaaaa') === true)\n  console.assert(isPalindrome('zbcd') === false)\n}\ntestIsPalindrome()\n", "entry_point": "isPalindrome", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Tests if the given string is a palindrome\n  >>> isPalindrome('')\n  true\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindrome = (text) => {\n  let reversedText = '';\n  for (let i = text.length - 1; i >= 0; i--) {\n    reversedText += text.charAt(i);\n  }\n  return reversedText === text;\n};\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindrome('aba')\n  true\n  >>> isPalindrome('aaaaa')\n  true\n  >>> isPalindrome('zbcd')\n  false\n  */\nconst isPalindromeReversed = (text) => {\n  let reversedText = '';\n  for (let i = text.length - 1; i >= 0; i--) {\n    reversedText += text.charAt(i);\n  }\n  return reversedText === text;\n};\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindromeReversed('aba')\n  true\n  >>> isPalindromeReversed('aaaaa')\n  true\n  >>> isPalindromeReversed('zbcd')\n  false\n  */\nconst isPalindromeReversedReversed = (text) => {\n  let reversedText = '';\n  for (let i = text.length - 1; i >= 0; i--) {\n    reversedText += text.charAt(i);\n  }\n  return reversedText === text;\n};\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindromeReversedReversed('aba')\n  true\n  >>> isPalindromeReversedReversed('aaaaa')\n  true\n  >>> isPalindromeReversedReversed('zbcd')\n  false\n  */\nconst isPalindromeReversedReversedReversed = (text) => {\n  let reversedText = '';\n  for (let i = text.length - 1; i >= 0; i--) {\n    reversedText += text.charAt(i);\n  }\n  return reversedText === text;\n};\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindromeReversedReversedReversed('aba')\n  true\n  >>> isPalindromeReversedReversedReversed('aaaaa')\n  true\n  >>> isPalindromeReversedReversedReversed('zbcd')\n  false\n  */\nconst isPalindromeReversedReversedReversedReversed = (text) => {\n  let reversedText = '';\n  for (let i = text.length - 1; i >= 0; i--) {\n    reversedText += text.charAt(i);\n  }\n  return reversedText === text;\n};\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindromeReversedReversedReversedReversed('aba')\n  true\n  >>> isPalindromeReversedReversedReversedReversed('aaaaa')\n  true\n  >>> isPalindromeReversedReversedReversedReversed('zbcd')\n  false\n  */\nconst isPalindromeReversedReversedReversedReversedReversed = (text) => {\n  let reversedText = '';\n  for (let i = text.length - 1; i >= 0; i--) {\n    reversedText += text.charAt(i);\n  }\n  return reversedText === text;\n};\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindromeReversedReversedReversedReversedReversed('aba')\n  true\n  >>> isPalindromeReversedReversedReversedReversedReversed('aaaaa')\n  true\n  >>> isPalindromeReversedReversedReversedReversedReversed('zbcd')\n  false\n  */\nconst isPalindromeReversedReversedReversedReversedReversed = (text) => {\n  let reversedText = '';\n  for (let i = text.length - 1; i >= 0; i--) {\n    reversedText += text.charAt(i);\n  }\n  return reversedText === text;\n};\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindromeReversedReversedReversedReversedReversed('aba')\n  true\n  >>> isPalindromeReversedReversedReversedReversedReversed('aaaaa')\n  true\n  >>> isPalindromeReversedReversedReversedReversedReversed('zbcd')\n  false\n  */\nconst isPalindromeReversedReversedReversedReversedReversedReversed = (text) => {\n  let reversedText = '';\n  for (let i = text.length - 1; i >= 0; i--) {\n    reversedText += text.charAt(i);\n  }\n  return reversedText === text;\n};\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindromeReversedReversedReversedReversedReversedReversed('aba')\n  true\n  >>> isPalindromeReversedReversedReversedReversedReversedReversed('aaaaa')\n  true\n  >>> isPalindromeReversedReversedReversedReversedReversedReversed('zbcd')\n  false\n  */\nconst isPalindromeReversedReversedReversedReversedReversedReversedReversed = (text) => {\n  let reversedText = '';\n  for (let i = text.length - 1; i >= 0; i--) {\n    reversedText += text.charAt(i);\n  }\n  return reversedText === text;\n};\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindromeReversedReversedReversedReversedReversedReversedReversed('aba')\n  true\n  >>> isPalindromeReversedReversedReversedReversedReversedReversedReversedReversed('aaaaa')\n  true\n  >>> isPalindromeReversedReversedReversedReversedReversedReversedReversedReversed('zbcd')\n  false\n  */\nconst isPalindromeReversedReversedReversedReversedReversedReversedReversedReversedReversed = (text) => {\n  let reversedText = '';\n  for (let i = text.length - 1; i >= 0; i--) {\n    reversedText += text.charAt(i);\n  }\n  return reversedText === text;\n};\n\n/*\n  Tests if the given string is a palindrome\n  >>> isPalindromeReversedReversedReversedReversedReversedReversedReversedReversed('aba')\n  true\n  >>> isPalindromeReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed('aaaaa')\n  true\n  >>> isPalindromeReversedReversedReversedReversedReversedReversedReversedReversedReversed('zbcd')\n  false\n  */\nconst isPalindromeReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReverse", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/49", "prompt": "/*Return 2 ^ n modulo p (Attention Numeric).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n", "canonical_solution": "  var ret = 1;\n  for (let i = 0; i < n; i++)\n    ret = (2 * ret) % p;\n  return ret;\n}\n\n", "test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n  console.assert(modp(30, 5) === 4)\n  console.assert(modp(31, 5) === 3)\n}\n\ntestModp()\n", "declaration": "\nconst modp = (n, p) => {\n", "example_test": "const testModp = () => {\n  console.assert(modp(3, 5) === 3)\n  console.assert(modp(1101, 101) === 2)\n  console.assert(modp(0, 101) === 1)\n  console.assert(modp(3, 11) === 8)\n  console.assert(modp(100, 101) === 1)\n}\ntestModp()\n", "entry_point": "modp", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Return 2 ^ n modulo p (Attention Numeric).\n  >>> modp(3, 5)\n  3\n  >>> modp(1101, 101)\n  2\n  >>> modp(0, 101)\n  1\n  >>> modp(3, 11)\n  8\n  >>> modp(100, 101)\n  1\n  */\nconst modp = (n, p) => {\n  const m = n | 0\n  const r = p | 0\n  const s = m % p\n  const t = r - s\n  const u = t < 0? m + s + t : t - s + m\n  return u\n}\n\n/*\n  Return n modulo p (Attention Numeric).\n  >>> modn(3, 5)\n  3\n  >>> modn(1101, 101)\n  2\n  >>> modn(0, 101)\n  1\n  >>> modn(3, 11)\n  8\n  >>> modn(100, 101)\n  1\n  */\nconst modn = (n, p) => {\n  const m = n | 0\n  const r = p | 0\n  const s = m % p\n  const t = r - s\n  const u = t < 0? m + s + t : t - s + m\n  return u\n}\n\n/*\n  Return n modulo p (Attention Numeric).\n  >>> modnn(3, 5)\n  3\n  >>> modnn(1101, 101)\n  2\n  >>> modnn(0, 101)\n  1\n  >>> modnn(3, 11)\n  8\n  >>> modnn(100, 101)\n  1\n  */\nconst modnn = (n, p) => {\n  const m = n | 0\n  const r = p | 0\n  const s = m % p\n  const t = r - s\n  const u = t < 0? m + s + t : t - s + m\n  return u\n}\n\n/*\n  Return n modulo p (Attention Numeric).\n  >>> modnn(3, 5)\n  3\n  >>> modnn(1101, 101)\n  2\n  >>> modnnn(3, 11)\n  8\n  >>> modnnn(100, 101)\n  1\n  */\nconst modnnn = (n, p) => {\n  const m = n | 0\n  const r = p | 0\n  const s = m % p\n  const t = r - s\n  const u = t < 0? m + s + t : t - s + m\n  return u\n}\n\n/*\n  Return n modulo p (Attention Numeric).\n  >>> modnn(3, 5)\n  3\n  >>> modnn(1101, 101)\n  2\n  >>> modnnn(3, 11)\n  8\n  >>> modnnn(100, 101)\n  1\n  */\nconst modnnnn = (n, p) => {\n  const m = n | 0\n  const r = p | 0\n  const s = m % p\n  const t = r - s\n  const u = t < 0? m + s + t : t - s + m\n  return u\n}\n\n/*\n  Return n modulo p (Attention Numeric).\n  >>> modnn(3, 5)\n  3\n  >>> modnn(1101, 101)\n  2\n  >>> modnnn(3, 11)\n  8\n  >>> modnnn(100, 101)\n  1\n  */\nconst modnnnnn = (n, p) => {\n  const m = n | 0\n  const r = p | 0\n  const s = m % p\n  const t = r - s\n  const u = t < 0? m + s + t : t - s + m\n  return u\n}\n\n/*\n  Return n modulo p (Attention Numeric).\n  >>> modnn(3, 5)\n  3\n  >>> modnn(1101, 101)\n  2\n  >>> modnnn(3, 11)\n  8\n  >>> modnnn(100, 101)\n  1\n  */\nconst modnnnnnn = (n, p) => {\n  const m = n | 0\n  const r = p | 0\n  const s = m % p\n  const t = r - s\n  const u = t < 0? m + s + t : t - s + m\n  return u\n}\n\n/*\n  Return n modulo p (Attention Numeric).\n  >>> modnn(3, 5)\n  3\n  >>> modnn(1101, 101)\n  2\n  >>> modnnn(3, 11)\n  8\n  >>> modnnn(100, 101)\n  1\n  */\nconst modnnnnnnn = (n, p) => {\n  const m = n | 0\n  const r = p | 0\n  const s = m % p\n  const t = r - s\n  const u = t < 0? m + s + t : t - s + m\n  return u\n}\n\n/*\n  Return n modulo p (Attention Numeric).\n  >>> modnn(3, 5)\n  3\n  >>> modnn(1101, 101)\n  2\n  >>> modnnn(3, 11)\n  8\n  >>> modnnn(100, 101)\n  1\n  */\nconst modnnnnnnnn = (n, p) => {\n  const m = n | 0\n  const r = p | 0\n  const s = m % p\n  const t = r - s\n  const u = t < 0? m + s + t : t - s + m\n  return u\n}\n\n/*\n  Return n modulo p (Attention Numeric).\n  >>> modnn(3, 5)\n  3\n  >>> modnn(1101, 101)\n  2\n  >>> modnnn(3, 11)\n  8\n  >>> modnnn(100, 101)\n  1\n  */\nconst modnnnnnnnnn = (n, p) => {\n  const m = n | 0\n  const r = p | 0\n  const s = m % p\n  const t = r - s\n  const u = t < 0? m + s + t : t - s + m\n  return u\n}\n\n/*\n  Return n modulo p (Attention Numeric).\n  >>> modnn(3, 5)\n  3\n  >>> modnn(1101, 101)\n  2\n  >>> modnnn(3, 11)\n  8\n  >>> modnnn(100, 101)\n  1\n  */\nconst modnnnnnnnnnn = (n, p) => {\n  const m = n | 0\n  const r = p | 0\n  const s = m % p\n  const t = r - s\n  const u = t < 0? m + s + t : t - s + m\n  return u\n}\n\n/*\n  Return n modulo p (Attention Numeric).\n  >>> modnn(3, 5)\n  3\n  >>> modnn(1101, 101)\n  2\n  >>> modnnn(3, 11)\n  8\n  >>> modnnn(100, 101)\n  1\n  */\nconst modnnnnnnnnn = (n, p) => {\n  const m = n | 0\n  const r = p | 0\n  const s = m % p\n  const t = r - s\n  const u = t < 0? m + s + t : t - s + m\n  return u\n}\n\n/*\n  Return n modulo p (Attention Numeric).\n  >>> modnn(3, 5)\n  3\n  >>> modnn(1101, 101)\n  2\n  >>> modnnn(3, 11)\n  8\n  >>> modnnn(100, 101)\n  1\n  */\nconst modnnnnnnnnnnn = (n, p) => {\n  const m = n | 0\n  const r = p | 0\n  const s = m % p\n  const t = r - s\n  const u = t < 0? m + s + t : t - s + m\n  return u\n}\n\n/*\n  Return n modulo p (Attention Numeric", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/5", "prompt": "/* Insert a number \"delimeter\" between two consecutive elements of the \"Numbers\" input list.\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n", "canonical_solution": "  if (!Array.isArray(numbers) || numbers.length == 0)\n    return [];\n  var result = [];\n  for (const n of numbers) {\n    result.push(n, delimeter);\n  }\n  result.pop();\n  return result;\n}\n\n", "test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 7)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([5, 6, 3, 2], 8)) === JSON.stringify([5, 8, 6, 8, 3, 8, 2])\n  )\n  console.assert(\n    JSON.stringify(\n      intersperse([2, 2, 2], 2)) === JSON.stringify([2, 2, 2, 2, 2])\n  )\n}\n\ntestIntersperse()\n", "declaration": "\nconst intersperse = (numbers, delimeter) => {\n", "example_test": "const testIntersperse = () => {\n  console.assert(JSON.stringify(intersperse([], 4)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      intersperse([1,2,3], 4)) === JSON.stringify([1,4,2,4,3])\n  )\n}\ntestIntersperse()\n", "entry_point": "intersperse", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Insert a number \"delimeter\" between two consecutive elements of the \"Numbers\" input list.\n  >>> intersperse([], 4)\n  []\n  >>> intersperse([1, 2, 3], 4)\n  [1, 4, 2, 4, 3]\n  */\nconst intersperse = (numbers, delimeter) => {\n  const result = [];\n  let current = 0;\n  let next = numbers.length;\n  while (next > 0) {\n    result.push(numbers[current]);\n    current++;\n    if (next === delimeter) {\n      break;\n    }\n    next--;\n  }\n  return result;\n};\n\n/**\n * Remove all occurrences of a value from an array.\n * If no value is found, an empty array is returned.\n * If multiple values are found, only the first occurrence is returned.\n * If no value is found and multiple values are found, an empty array is returned.\n * If multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found, an empty array is returned.\n * If multiple values are found and multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and multiple values are found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and no value is found, an empty array is returned.\n * If multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and multiple values are found and ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/50", "prompt": "/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n", "canonical_solution": "  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n", "test": "const testDecodeShift = () => {\n    const letters = new Array(26)\n    .fill(null)\n    .map((v, i) => String.fromCharCode(97 + i))\n\n    for (let i = 0; i < 100; i++) {\n      let str = new Array(Math.floor(Math.random() * 20)).fill(null);\n      str = str.map(item => letters[Math.floor(Math.random() * letters.length)]).join('');\n      let encoded_str = encodeShift(str)\n      console.assert(decodeShift(encoded_str) === str)\n    }\n\n}\n\ntestDecodeShift()\n", "declaration": "const encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\nconst decodeShift = (s) => {\n", "example_test": "", "entry_point": "encodeShift", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*\n  returns encoded string by shifting every character by 5 in the alphabet.\n  */\nconst encodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) + 5 - \"a\".charCodeAt(0)) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeShift = (s) => {\n  return s.split(\"\").map(ch => String.fromCharCode(\n    ((ch.charCodeAt(0) - 5 + 26) % 26) + \"a\".charCodeAt(0)\n  )).join(\"\");\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encode = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decode = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeAll = (s) => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeAll = (s) => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeAllInt = s => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeAllInt = s => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeAllIntsInt = s => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeAllIntsInt = s => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeAllIntsIntAll = s => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeAllIntsIntAll = s => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeAllIntsIntAllInt = s => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeAllIntsIntAllInt = s => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeAllIntsIntAllIntAll = s => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeAllIntsIntAllIntAll = s => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeAllIntsIntAllIntAllInt = s => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeAllIntsIntAllIntAllInt = s => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeAllIntsIntAllIntAllIntAll = s => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeAllIntsIntAllIntAllIntAll = s => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeAllIntsIntAllIntAllIntAllInt = s => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeAllIntsIntAllIntAllIntAllInt = s => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeAllIntsIntAllIntAllIntAllIntAll = s => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeAllIntsIntAllIntAllIntAllIntAll = s => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeAllIntsIntAllIntAllIntAllIntAllInt = s => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeAllIntsIntAllIntAllIntAllIntAllInt = s => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeAllIntsIntAllIntAllIntAllIntAllIntAll = s => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeAllIntsIntAllIntAllIntAllIntAllIntAll = s => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeAllIntsIntAllIntAllIntAllIntAllIntAllInt = s => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeAllIntsIntAllIntAllIntAllIntAllIntAllInt = s => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeAllIntsIntAllIntAllIntAllIntAllIntAllIntAllIntAll = s => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeAllIntsIntAllIntAllIntAllIntAllIntAllIntAll = s => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeAllIntsIntAllIntAllIntAllIntAllIntAllIntAllIntAll = s => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeAllIntsIntAllIntAllIntAllIntAllIntAllIntAllIntAll = s => {\n  return decodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst encodeAllIntsIntAllIntAllIntAllIntAllIntAllIntAllIntAllIntAll = s => {\n  return encodeShift(s);\n}\n\n/*\n  takes as input string encoded with encode_shift function. Returns decoded string.\n  */\nconst decodeAllIntsIntAllIntAllIntAll", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/51", "prompt": "/*\n  removeVowels is a function that takes strings and returns strings without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n", "canonical_solution": "  return text.split(\"\")\n             .filter(s => ![\"a\", \"e\", \"i\", \"o\", \"u\"]\n                      .includes(s.toLowerCase())\n                    )\n             .join(\"\")\n}\n\n", "test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('fedcba') === 'fdcb')\n  console.assert(removeVowels('eeeee') === '')\n  console.assert(removeVowels('acBAA') === 'cB')\n  console.assert(removeVowels('EcBOO') === 'cB')\n  console.assert(removeVowels('ybcd') === 'ybcd')\n}\n\ntestRemoveVowels()\n", "declaration": "\nconst removeVowels = (text) => {\n", "example_test": "const testRemoveVowels = () => {\n  console.assert(removeVowels('') === '')\n  console.assert(removeVowels('abcdef\\nghijklm') === 'bcdf\\nghjklm')\n  console.assert(removeVowels('abcdef') === 'bcdf')\n  console.assert(removeVowels('aaaaa') === '')\n  console.assert(removeVowels('aaBAA') === 'B')\n  console.assert(removeVowels('zbcd') === 'zbcd')\n}\ntestRemoveVowels()\n", "entry_point": "removeVowels", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  removeVowels is a function that takes strings and returns strings without vowels.\n  >>> removeVowels('')\n  ''\n  >>> removeVowels(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels('abcdef')\n  'bcdf'\n  >>> removeVowels('aaaaa')\n  ''\n  >>> removeVowels('aaBAA')\n  'B'\n  >>> removeVowels('zbcd')\n  'zbcd'\n  */\nconst removeVowels = (text) => {\n  let vowels = text.split('')\n  let newText = ''\n  vowels.forEach((vowel) => {\n    if (vowel === 'a' || vowel === 'e' || vowel === 'i' || vowel === 'o' || vowel === 'u') {\n      newText += vowel\n    }\n  })\n  return newText\n}\n\n/*\n  removeVowels2 takes a string and returns a string without vowels.\n  >>> removeVowels2('')\n  ''\n  >>> removeVowels2(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels2('abcdef')\n  'bcdf'\n  >>> removeVowels2('aaaaa')\n  ''\n  >>> removeVowels2('aaBAA')\n  'B'\n  >>> removeVowels2('zbcd')\n  'zbcd'\n  */\nconst removeVowels2 = (text) => {\n  let vowels = text.split('')\n  let newText = ''\n  vowels.forEach((vowel) => {\n    if (vowel === 'a' || vowel === 'e' || vowel === 'i' || vowel === 'o' || vowel === 'u') {\n      newText += vowel\n    }\n  })\n  return newText\n}\n\n/*\n  removeVowels3 takes a string and returns a string without vowels.\n  >>> removeVowels3('')\n  ''\n  >>> removeVowels3(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels3('abcdef')\n  'bcdf'\n  >>> removeVowels3('aaaaa')\n  ''\n  >>> removeVowels3('aaBAA')\n  'B'\n  >>> removeVowels3('zbcd')\n  'zbcd'\n  */\nconst removeVowels3 = (text) => {\n  let vowels = text.split('')\n  let newText = ''\n  vowels.forEach((vowel) => {\n    if (vowel === 'a' || vowel === 'e' || vowel === 'i' || vowel === 'o' || vowel === 'u') {\n      newText += vowel\n    }\n  })\n  return newText\n}\n\n/*\n  removeVowels4 takes a string and returns a string without vowels.\n  >>> removeVowels4('')\n  ''\n  >>> removeVowels4(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels4('abcdef')\n  'bcdf'\n  >>> removeVowels4('aaaaa')\n  ''\n  >>> removeVowels4('aaBAA')\n  'B'\n  >>> removeVowels4('zbcd')\n  'zbcd'\n  */\nconst removeVowels4 = (text) => {\n  let vowels = text.split('')\n  let newText = ''\n  vowels.forEach((vowel) => {\n    if (vowel === 'a' || vowel === 'e' || vowel === 'i' || vowel === 'o' || vowel === 'u') {\n      newText += vowel\n    }\n  })\n  return newText\n}\n\n/*\n  removeVowels5 takes a string and returns a string without vowels.\n  >>> removeVowels5('')\n  ''\n  >>> removeVowels5(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels5('abcdef')\n  'bcdf'\n  >>> removeVowels5('aaaaa')\n  ''\n  >>> removeVowels5('aaBAA')\n  'B'\n  >>> removeVowels5('zbcd')\n  'zbcd'\n  */\nconst removeVowels5 = (text) => {\n  let vowels = text.split('')\n  let newText = ''\n  vowels.forEach((vowel) => {\n    if (vowel === 'a' || vowel === 'e' || vowel === 'i' || vowel === 'o' || vowel === 'u') {\n      newText += vowel\n    }\n  })\n  return newText\n}\n\n/*\n  removeVowels6 takes a string and returns a string without vowels.\n  >>> removeVowels6('')\n  ''\n  >>> removeVowels6(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels6('abcdef')\n  'bcdf'\n  >>> removeVowels6('aaaaa')\n  ''\n  >>> removeVowels6('aaBAA')\n  'B'\n  >>> removeVowels6('zbcd')\n  'zbcd'\n  */\nconst removeVowels6 = (text) => {\n  let vowels = text.split('')\n  let newText = ''\n  vowels.forEach((vowel) => {\n    if (vowel === 'a' || vowel === 'e' || vowel === 'i' || vowel === 'o' || vowel === 'u') {\n      newText += vowel\n    }\n  })\n  return newText\n}\n\n/*\n  removeVowels7 takes a string and returns a string without vowels.\n  >>> removeVowels7('')\n  ''\n  >>> removeVowels7(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels7('abcdef')\n  'bcdf'\n  >>> removeVowels7('aaaaa')\n  ''\n  >>> removeVowels7('aaBAA')\n  'B'\n  >>> removeVowels7('zbcd')\n  'zbcd'\n  */\nconst removeVowels7 = (text) => {\n  let vowels = text.split('')\n  let newText = ''\n  vowels.forEach((vowel) => {\n    if (vowel === 'a' || vowel === 'e' || vowel === 'i' || vowel === 'o' || vowel === 'u') {\n      newText += vowel\n    }\n  })\n  return newText\n}\n\n/*\n  removeVowels8 takes a string and returns a string without vowels.\n  >>> removeVowels8('')\n  ''\n  >>> removeVowels8(\"abcdef\\nghijklm\")\n  'bcdf\\nghjklm'\n  >>> removeVowels8('abcdef')\n  'bcdf'\n  >>> removeVowels8('aaaaa')\n  ''\n  >>> removeVowels8('aaBAA')\n  'B'\n  >>> removeVowels8('zbcd')\n  'zbcd'\n  */\nconst removeVowels8 = (text) => {\n  let vowels = text.split('')\n  let newText = ''\n  vowels.forEach((vowel) => {\n    if (vowel === 'a' || vowel === 'e' || vowel === 'i' || vowel === 'o' || vowel === 'u') {\n      new", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/52", "prompt": "/*Return true if all numbers in list l are below the t threshold.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n", "canonical_solution": "  for (const e of l)\n    if (e >= t)\n      return false;\n  return true;\n}\n\n", "test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n  console.assert(belowThreshold([1, 20, 4, 10], 21) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 22) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 11) === true)\n  console.assert(belowThreshold([1, 8, 4, 10], 10) === false)\n}\n\ntestBelowThreshold()\n", "declaration": "\nconst belowThreshold = (l, t) => {\n", "example_test": "const testBelowThreshold = () => {\n  console.assert(belowThreshold([1, 2, 4, 10], 100) === true)\n  console.assert(belowThreshold([1, 20, 4, 10], 5) === false)\n}\ntestBelowThreshold()\n", "entry_point": "belowThreshold", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Return true if all numbers in list l are below the t threshold.\n  >>> belowThreshold([1, 2, 4, 10], 100)\n  true\n  >>> belowThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst belowThreshold = (l, t) => {\n  return l.some((n) => n < t);\n};\n\n/*Return true if all numbers in list l are above the t threshold.\n  >>> aboveThreshold([1, 2, 4, 10], 100)\n  true\n  >>> aboveThreshold([1, 20, 4, 10], 5)\n  false\n  */\nconst aboveThreshold = (l, t) => {\n  return l.some((n) => n > t);\n};\n\n/*Return true if all numbers in list l are equal to a given number.\n  >>> equal([1, 2, 4, 10], 100)\n  true\n  >>> equal([1, 20, 4, 10], 5)\n  false\n  */\nconst equal = (l, t) => {\n  return l.every((n) => n === t);\n};\n\n/*Return true if all numbers in list l are greater than a given number.\n  >>> greaterThan([1, 2, 4, 10], 100)\n  true\n  >>> greaterThan([10, 20, 4, 10], 5)\n  false\n  */\nconst greaterThan = (l, t) => {\n  return l.every((n) => n > t);\n};\n\n/*Return true if all numbers in list l are less than a given number.\n  >>> lessThan([1, 2, 4, 10], 100)\n  true\n  >>> lessThan([10, 20, 4, 10], 5)\n  false\n  */\nconst lessThan = (l, t) => {\n  return l.every((n) => n < t);\n};\n\n/*Return true if all numbers in list l are a multiple of t.\n  >>> multipleOf([1, 2, 4, 10], 5)\n  true\n  >>> multipleOf([10, 20, 4, 10], 5)\n  false\n  */\nconst multipleOf = (l, t) => {\n  return l.every((n) => n % t === 0);\n};\n\n/*Return true if all numbers in list l are a prime number.\n  >>> prime([2, 3, 5, 7, 11, 13, 17, 19])\n  true\n  >>> prime([2, 3, 5, 7, 11, 13, 17, 19])\n  false\n  */\nconst prime = (l) => {\n  return l.every((n) => isPrime(n));\n};\n\n/*Return true if all numbers in list l are a perfect square\n  >>> perfect([])\n  true\n  >>> perfect([1])\n  false\n  */\nconst perfect = (l) => {\n  return l.every((n) => isPerfectSquare(n));\n};\n\n/*Return true if all numbers in list l are a perfect cube\n  >>> perfectCube([])\n  true\n  >>> perfectCube([2])\n  false\n  */\nconst perfectCube = (l) => {\n  return l.every((n) => isPerfectCube(n));\n};\n\n/*Return true if all numbers in list l are a perfect cube\n  >>> perfectCube([2])\n  true\n  >>> perfectCube([2])\n  false\n  */\nconst perfectCube = (l) => {\n  return l.every((n) => isPerfectCube(n));\n};\n\n/*Return true if all numbers in list l are a perfect cube\n  >>> perfectCube([2])\n  true\n  >>> perfectCube([2])\n  false\n  */\nconst perfectCube = (l) => {\n  return l.every((n) => isPerfectCube(n));\n};\n\n/*Return true if all numbers in list l are a perfect cube\n  >>> perfectCube([2])\n  true\n  >>> perfectCube([2])\n  false\n  */\nconst perfectCube = (l) => {\n  return l.every((n) => isPerfectCube(n));\n};\n\n/*Return true if all numbers in list l are a perfect cube\n  >>> perfectCube([2])\n  true\n  >>> perfectCube([2])\n  false\n  */\nconst perfectCube = (l) => {\n  return l.every((n) => isPerfectCube(n));\n};\n\n/*Return true if all numbers in list l are a perfect cube\n  >>> perfectCube([2])\n  true\n  >>> perfectCube([2])\n  false\n  */\nconst perfectCube = (l) => {\n  return l.every((n) => isPerfectCube(n));\n};\n\n/*Return true if all numbers in list l are a perfect cube\n  >>> perfectCube([2])\n  true\n  >>> perfectCube([2])\n  false\n  */\nconst perfectCube = (l) => {\n  return l.every((n) => isPerfectCube(n));\n};\n\n/*Return true if all numbers in list l are a perfect cube\n  >>> perfectCube([2])\n  true\n  >>> perfectCube([2])\n  false\n  */\nconst perfectCube = (l) => {\n  return l.every((n) => isPerfectCube(n));\n};\n\n/*Return true if all numbers in list l are a perfect cube\n  >>> perfectCube([2])\n  true\n  >>> perfectCube([2])\n  false\n  */\nconst perfectCube = (l) => {\n  return l.every((n) => isPerfectCube(n));\n};\n\n/*Return true if all numbers in list l are a perfect cube\n  >>> perfectCube([2])\n  true\n  >>> perfectCube([2])\n  false\n  */\nconst perfectCube = (l) => {\n  return l.every((n) => isPerfectCube(n));\n};\n\n/*Return true if all numbers in list l are a perfect cube\n  >>> perfectCube([2])\n  true\n  >>> perfectCube([2])\n  false\n  */\nconst perfectCube = (l) => {\n  return l.every((n) => isPerfectCube(n));\n};\n\n/*Return true if all numbers in list l are a perfect cube\n  >>> perfectCube([2])\n  true\n  >>> perfectCube([2])\n  false\n  */\nconst perfectCube = (l) => {\n  return l.every((n) => isPerfectCube(n));\n};\n\n/*Return true if all numbers in list l are a perfect cube\n  >>> perfectCube([2])\n  true\n  >>> perfectCube([2])\n  false\n  */\nconst perfectCube = (l) => {\n  return l.every((n) => isPerfectCube(n));\n};\n\n/*Return true if all numbers in list l are a perfect cube\n  >>> perfectCube([2])\n  true\n  >>> perfectCube([2])\n  false\n  */\nconst perfectCube = (l) => {\n  return l.every((n) => isPerfectCube(n));\n};\n\n/*Return true if all numbers in list l are a perfect cube\n  >>> perfectCube([2])\n  true\n  >>> perfectCube([2])\n  false\n  */\nconst perfectCube = (l) => {\n  return l.every((n) => isPerfectCube(n));\n};\n\n/*Return true if all numbers in list l are a perfect cube\n  >>> perfectCube([2])\n  true\n  >>> perfectCube([2])\n  false\n  */\nconst perfectCube = (l) => {\n  return l.every((n) => isPerfectCube(n));\n};\n\n/*Return true if all numbers in list l are a perfect cube\n  >>> perfectCube([2])\n  true\n  >>> perfectCube([2])\n  false\n  */\nconst perfectCube = (l) => {\n  return l.every((n) => isPerfectCube(n));\n};\n\n/*Return true if all numbers in list l are a perfect cube\n  >>> perfectCube([2])\n  true", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/53", "prompt": "/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n", "canonical_solution": "  return x + y;\n}\n\n", "test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n\n  console.assert(add(0, 1) === 1)\n  console.assert(add(1, 0) === 1)\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n  console.assert(add(7, 5) === 12)\n\n  for (let i = 0; i < 100; i++) {\n    let x = getRandomIntInclusive()\n    let y = getRandomIntInclusive()\n    console.assert(x + y === add(x, y))\n  }\n}\n\ntestAdd()\n", "declaration": "\nconst add = (x, y) => {\n", "example_test": "const testAdd = () => {\n  const getRandomIntInclusive = (min = 0, max = 9) => {\n    min = Math.ceil(min)\n    max = Math.floor(max)\n    return Math.floor(Math.random() * (max - min + 1)) + min //\n  }\n  console.assert(add(2, 3) === 5)\n  console.assert(add(5, 7) === 12)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Add two numbers x and y\n  >>> add(2, 3)\n  5\n  >>> add(5, 7)\n  12\n  */\nconst add = (x, y) => {\n  return x + y;\n};\n\n/*\n  >>> subtract(2, 3)\n  1\n  >>> subtract(5, 7)\n  -1\n  */\nconst subtract = (x, y) => {\n  return x - y;\n};\n\n/*\n  >>> multiply(2, 3)\n  6\n  >>> multiply(5, 7)\n  24\n  */\nconst multiply = (a, b) => {\n  return a * b;\n};\n\n/*\n  >>> divide(2, 3)\n  2\n  >>> divide(5, 7)\n  0\n  */\nconst divide = (x, y) => {\n  return x / y;\n};\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  0\n  */\nconst mod = (x, y) => {\n  return x % y;\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst power = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> mod(2, 3)\n  2\n  >>> mod(5, 7)\n  0\n  */\nconst modPow = (x, y) => {\n  return x % y;\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powMod = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPowPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPowPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPowPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPowPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)\n  0\n  */\nconst powModPowPowPowPowPow = (x, y) => {\n  return Math.pow(x, y);\n};\n\n/*\n  >>> power(2, 3)\n  2\n  >>> power(5, 7)", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/54", "prompt": "/*\n  Check that two words have the same letters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n", "canonical_solution": "  return JSON.stringify([...new Set(s0)].sort()) === JSON.stringify([...new Set(s1)].sort());\n}\n\n", "test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n  console.assert(sameChars('aabb', 'aaccc') === false)\n}\n\ntestSameChars()\n", "declaration": "\nconst sameChars = (s0, s1) => {\n", "example_test": "const testSameChars = () => {\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc') === true)\n  console.assert(sameChars('abcd', 'dddddddabc') === true)\n  console.assert(sameChars('dddddddabc', 'abcd') === true)\n  console.assert(sameChars('eabcd', 'dddddddabc') === false)\n  console.assert(sameChars('abcd', 'dddddddabcf') === false)\n  console.assert(sameChars('eabcdzzzz', 'dddzzzzzzzddddabc') === false)\n}\ntestSameChars()\n", "entry_point": "sameChars", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Check that two words have the same letters.\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n  true\n  >>> sameChars('abcd', 'dddddddabc')\n  true\n  >>> sameChars('dddddddabc', 'abcd')\n  true\n  >>> sameChars('eabcd', 'dddddddabc')\n  false\n  >>> sameChars('abcd', 'dddddddabce')\n  false\n  >>> sameChars('eabcdzzzz', 'dddzzzzzzzddddabc')\n  false\n  */\nconst sameChars = (s0, s1) => {\n  const len = s1.length\n  const chars = s0.split('')\n  const len = chars.length\n  const chars0 = chars.slice(0, len)\n  const chars1 = chars.slice(len)\n  if (chars0.length!== chars1.length) {\n    return false\n  }\n  for (let i = 0; i < len; i++) {\n    if (chars0[i]!== chars1[i]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n  Return the number of letters in `s`.\n  >>> letters('abcd')\n  3\n  >>> letters('abc')\n  1\n  >>> letters('')\n  0\n  */\nconst letters = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) > 'z') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Return the number of digits in `s`.\n  >>> digits('abcd')\n  3\n  >>> digits('abc')\n  2\n  >>> digits('')\n  0\n  */\nconst digits = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) < '0') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Return the number of uppercase letters in `s`.\n  >>> uppercaseLetters('abcd')\n  3\n  >>> uppercaseLetters('abc')\n  2\n  >>> uppercaseLetters('')\n  0\n  */\nconst uppercaseLetters = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) >= 'A' && s.charAt(i) <= 'Z') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Return the number of lowercase letters in `s`.\n  >>> lowercaseLetters('abcd')\n  3\n  >>> lowercaseLetters('abc')\n  2\n  >>> lowercaseLetters('')\n  0\n  */\nconst lowercaseLetters = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) >= 'a' && s.charAt(i) <= 'z') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Return the number of uppercase digits in `s`.\n  >>> uppercaseDigits('abcd')\n  3\n  >>> uppercaseDigits('abc')\n  2\n  >>> uppercaseDigits('')\n  0\n  */\nconst uppercaseDigits = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) >= '0' && s.charAt(i) <= '9') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Return the number of lowercase digits in `s`.\n  >>> lowercaseDigits('abcd')\n  3\n  >>> lowercaseDigits('abc')\n  2\n  >>> lowercaseDigits('')\n  0\n  */\nconst lowercaseDigits = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) >= 'a' && s.charAt(i) <= 'z') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Return the number of words in `s`.\n  >>> words('abcd')\n  3\n  >>> words('abc')\n  2\n  >>> words('')\n  0\n  */\nconst words = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) > 'z' && s.charAt(i) < 'a') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Return the number of sentences in `s`.\n  >>> sentences('abcd')\n  3\n  >>> sentences('abc')\n  2\n  >>> sentences('')\n  0\n  */\nconst sentences = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) > 'z' && s.charAt(i) < 'a') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Return the number of paragraphs in `s`.\n  >>> paragraphs('abcd')\n  3\n  >>> paragraphs('abc')\n  2\n  >>> paragraphs('')\n  0\n  */\nconst paragraphs = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) > 'z' && s.charAt(i) < 'a') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Return the number of sentences in `s`.\n  >>> sentences('abcd')\n  3\n  >>> sentences('abc')\n  2\n  >>> sentences('')\n  0\n  */\nconst sentences = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) > 'z' && s.charAt(i) < 'a') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Return the number of sentences in `s`.\n  >>> sentences('abcd')\n  3\n  >>> sentences('abc')\n  2\n  >>> sentences('')\n  0\n  */\nconst sentences = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) > 'z' && s.charAt(i) < 'a') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Return the number of sentences in `s`.\n  >>> sentences('abcd')\n  3\n  >>> sentences('abc')\n  2\n  >>> sentences('')\n  0\n  */\nconst sentences = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) > 'z' && s.charAt(i) < 'a') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Return the number of sentences in `s`.\n  >>> sentences('abcd')\n  3\n  >>> sentences('abc')\n  2\n  >>> sentences('')\n  0\n  */\nconst sentences = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) > 'z' && s.charAt(i) < 'a') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Return the number of sentences in `s`.\n  >>> sentences('abcd')\n  3\n  >>> sentences('abc')\n  2\n  >>> sentences('')\n  0\n  */\nconst sentences = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) > 'z' && s.charAt(i) < 'a') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Return the number of sentences in `s`.\n  >>> sentences('abcd')\n  3\n  >>> sentences('abc')\n  2\n  >>> sentences('')\n  0\n  */\nconst sentences = (s) => {\n  let count = 0\n  for (let i = 0; i < s.length; i++) {\n    if (s.charAt(i) > 'z' && s.charAt(i) < 'a') {\n      count++\n    }\n  }\n  return count\n}\n\n/*\n  Return the number of sentences in `s`.\n  >>> sentences('abcd')\n  3\n  >>> sentences('abc')\n  2\n  >>> sentences('')\n  0\n  */\nconst ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/55", "prompt": "/*RThe Fibonacci number is the ninth.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n", "canonical_solution": "  if (n == 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n}\n\n", "test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n  console.assert(fib(11) === 89)\n  console.assert(fib(12) === 144)\n}\n\ntestFib()\n", "declaration": "\nconst fib = (n) => {\n", "example_test": "const testFib = () => {\n  console.assert(fib(10) === 55)\n  console.assert(fib(1) === 1)\n  console.assert(fib(8) === 21)\n}\ntestFib()\n", "entry_point": "fib", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*RThe Fibonacci number is the ninth.\n  >>> fib(10)\n  55\n  >>> fib(1)\n  1\n  >>> fib(8)\n  21\n  */\nconst fib = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib2 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib3 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib4 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib5 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib6 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib7 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib8 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib9 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib10 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib11 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib12 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib13 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib14 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib15 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib16 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib17 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib18 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib19 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib20 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib21 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib22 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib23 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib24 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib25 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib26 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(6)\n  110\n  >>> fib(7)\n  151\n  */\nconst fib27 = (n) => {\n  if (n < 2) return 1;\n  return fib(n-1) + fib(n-2);\n};\n\n/*\n  >>> fib(5)\n  55\n  >>> fib(", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/56", "prompt": "/* brackets is a string of \"<\" and \">.\" returns false if each opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"<\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('<><><<><>><>') === true)\n  console.assert(correctBracketing('<><><<<><><>><>><<><><<>>>') === true)\n  console.assert(correctBracketing('<<<><>>>>') === false)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n  console.assert(correctBracketing('<<<<') === false)\n  console.assert(correctBracketing('>') === false)\n  console.assert(correctBracketing('<<>') === false)\n  console.assert(correctBracketing('<><><<><>><>><<>') === false)\n  console.assert(correctBracketing('<><><<><>><>>><>') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('<>') === true)\n  console.assert(correctBracketing('<<><>>') === true)\n  console.assert(correctBracketing('><<>') === false)\n  console.assert(correctBracketing('<') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string of \"<\" and \">.\" returns false if each opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"<\")\n  false\n  >>> correctBracketing(\"<>\")\n  false\n  >>> correctBracketing(\"<<><>>\")\n  false\n  >>> correctBracketing(\"><<>\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const bracketingRegex = new RegExp(`^${brackets}+$`);\n  return bracketingRegex.test(string);\n};\n\nconst isWhitespace = (char) => {\n  return char === \" \" || char === \"\\t\" || char === \"\\n\" || char === \"\\r\";\n};\n\nconst isNewline = (char) => {\n  return char === \"\\n\" || char === \"\\r\";\n};\n\nconst isDigit = (char) => {\n  return char >= \"0\" && char <= \"9\";\n};\n\nconst isLetter = (char) => {\n  return char >= \"a\" && char <= \"z\";\n};\n\nconst isLetterOrDigit = (char) => {\n  return isLetter(char) || isDigit(char);\n};\n\nconst isLetterOrDigitOrNewline = (char) => {\n  return isLetterOrDigit(char) || isNewline(char);\n};\n\nconst isLetterOrDigitOrNewlineOrWhitespace = (char) => {\n  return isLetterOrDigitOrNewline(char) || isWhitespace(char);\n};\n\nconst isLetterOrDigitOrNewlineOrWhitespaceOrNewline = (char) => {\n  return isLetterOrDigitOrNewlineOrWhitespace(char) || isNewline(char);\n};\n\nconst isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespace = (char) => {\n  return isLetterOrDigitOrNewlineOrWhitespaceOrNewline(char) || isWhitespace(char);\n};\n\nconst isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline = (char) => {\n  return isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespace(char) || isNewline(char);\n};\n\nconst isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespace = (char) => {\n  return isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline(char) || isWhitespace(char);\n};\n\nconst isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline = (char) => {\n  return isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline(char) || isNewline(char);\n};\n\nconst isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline = (char) => {\n  return isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline(char) || isWhitespace(char);\n};\n\nconst isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline = (char) => {\n  return isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline(char) || isNewline(char);\n};\n\nconst isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespace = (char) => {\n  return isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline(char) || isWhitespace(char);\n};\n\nconst isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline = (char) => {\n  return isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline(char) || isNewline(char);\n};\n\nconst isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespace = (char) => {\n  return isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline(char) || isWhitespace(char);\n};\n\nconst isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespace = (char) => {\n  return isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline(char) || isWhitespace(char);\n};\n\nconst isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline = (char) => {\n  return isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline(char) || isNewline(char);\n};\n\nconst isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespace = (char) => {\n  return isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline(char) || isWhitespace(char);\n};\n\nconst isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespace = (char) => {\n  return isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline(char) || isWhitespace(char);\n};\n\nconst isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline = (char) => {\n  return isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline(char) || isNewline(char);\n};\n\nconst isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespace = (char) => {\n  return isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline(char) || isWhitespace(char);\n};\n\nconst isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespace = (char) => {\n  return isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewlineOrWhitespaceOrNewline(char) || isWhitespace(char);\n};\n\nconst isLetterOrDigitOrNewlineOrWhitespaceOrNewlineOrWhitespaceOr", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/57", "prompt": "/*RIt is true that list elements monotonously increase or decrease.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n", "canonical_solution": "  var sort1 = [...l].sort((a, b) => a - b);\n  var sort2 = [...l].sort((a, b) => b - a);\n  if (JSON.stringify(l) === JSON.stringify(sort1) ||\n      JSON.stringify(l) === JSON.stringify(sort2))\n    return true;\n  return false;\n}\n\n", "test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 2, 4, 20]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n  console.assert(monotonic([4, 1, 1, 0]) === true)\n  console.assert(monotonic([1, 2, 3, 2, 5, 60]) === false)\n  console.assert(monotonic([1, 2, 3, 4, 5, 60]) === true)\n  console.assert(monotonic([9, 9, 9, 9]) === true)\n}\n\ntestMonotonic()\n", "declaration": "\nconst monotonic = (l) => {\n", "example_test": "const testMonotonic = () => {\n  console.assert(monotonic([1, 2, 4, 10]) === true)\n  console.assert(monotonic([1, 20, 4, 10]) === false)\n  console.assert(monotonic([4, 1, 0, -10]) === true)\n}\ntestMonotonic()\n", "entry_point": "monotonic", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*RIt is true that list elements monotonously increase or decrease.\n  >>> monotonic([1, 2, 4, 20])\n  true\n  >>> monotonic([1, 20, 4, 10])\n  false\n  >>> monotonic([4, 1, 0, -10])\n  true\n  */\nconst monotonic = (l) => {\n  let i = l.length - 1;\n  let j = l[0];\n  let k = 0;\n  while (true) {\n    if (l[j] < l[k]) {\n      i++;\n      j++;\n    } else {\n      j--;\n      k++;\n    }\n    if (i === j) {\n      return true;\n    }\n  }\n};\n\n/**\n * Returns true if two lists are equal, false otherwise.\n *\n * Two lists are equal if they have the same length and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n * to each other.\n *\n * Two lists are equal if they have the same elements and each element is equal\n", "passed": 0, "run_status": 3, "passed_evalplus": 0, "run_status_evalplus": 3, "passed_he": 0, "run_status_he": 3, "passed_ep": 0, "run_status_ep": 3}
{"task_id": "JavaScript/58", "prompt": "/*RHe sorted out unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n", "canonical_solution": "  var ret = new Set();\n  for (const e1 of l1)\n    for (const e2 of l2)\n      if (e1 == e2)\n        ret.add(e1);\n  return [...ret].sort();\n}\n\n", "test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [3, 2, 4])) ===\n      JSON.stringify([2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(common([4, 3, 2, 8], [])) === JSON.stringify([])\n  )\n}\n\ntestCommon()\n", "declaration": "\nconst common = (l1, l2) => {\n", "example_test": "const testCommon = () => {\n  console.assert(\n    JSON.stringify(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n     === JSON.stringify([1, 5, 653])\n  )\n  console.assert(\n    JSON.stringify(common([5, 3, 2, 8], [3, 2]))\n     === JSON.stringify([2, 3])\n  )\n}\ntestCommon()\n", "entry_point": "common", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*RHe sorted out unique common elements for two lists.\n  >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n  [1, 5, 653]\n  >>> common([5, 3, 2, 8], [3, 2])\n  [2, 3]\n\n  */\nconst common = (l1, l2) => {\n  let result = []\n  let i = 0\n  let j = 0\n  let k = 0\n\n  while (i < l1.length && j < l2.length) {\n    if (l1[i] === l2[j]) {\n      result.push(l1[i])\n      i++\n      j++\n    } else {\n      if (j > l2.length) {\n        break\n      }\n      result.push(l2[j])\n      j++\n    }\n  }\n\n  while (i < l1.length) {\n    result.push(l1[i])\n    i++\n  }\n\n  while (j < l2.length) {\n    result.push(l2[j])\n    j++\n  }\n\n  return result\n}\n\n/*\n  Given two sorted arrays, return their intersection.\n\n  >>> intersect([], [])\n  []\n  >>> intersect([2, 3], [1, 2])\n  [2, 3]\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []\n  >>> intersect([2, 3], [1, 2])\n  []", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/59", "prompt": "/*RSuppose n > 1 and is not a prime number.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n", "canonical_solution": "  var isPrime = function (k) {\n    if (k < 2)\n      return false;\n    for (let i = 2; i < k - 1; i++)\n      if (k % i == 0)\n        return false;\n    return true;\n  }\n\n  var largest = 1;\n  for (let j = 2; j < n + 1; j++)\n    if (n % j == 0 && isPrime(j))\n      largest = Math.max(largest, j);\n  return largest;\n}\n\n", "test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(15) === 5)\n  console.assert(largestPrimeFactor(27) === 3)\n  console.assert(largestPrimeFactor(63) === 7)\n  console.assert(largestPrimeFactor(330) === 11)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\n\ntestLargestPrimeFactor()\n", "declaration": "\nconst largestPrimeFactor = (n) => {\n", "example_test": "const testLargestPrimeFactor = () => {\n  console.assert(largestPrimeFactor(2048) === 2)\n  console.assert(largestPrimeFactor(13195) === 29)\n}\ntestLargestPrimeFactor()\n", "entry_point": "largestPrimeFactor", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*RSuppose n > 1 and is not a prime number.\n  >>> largestPrimeFactor(13195)\n  29\n  >>> largestPrimeFactor(2048)\n  2\n  */\nconst largestPrimeFactor = (n) => {\n  let factor = 1;\n  let i = 2;\n  while (true) {\n    if (n % i === 0) {\n      n = n / i;\n      factor++;\n    } else {\n      return factor;\n    }\n    if (n <= 1) {\n      break;\n    }\n    i++;\n  }\n};\n\n/**\n * Returns the number of trailing zeros of a number.\n *\n * @param {number} num\n * @return {number}\n */\nconst trailingZeros = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = num % 10;\n    count++;\n  }\n  return count;\n};\n\n/**\n * Returns the number of trailing zeros of a number.\n *\n * @param {number} num\n * @return {number}\n */\nconst trailingZerosOf = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = num % 10;\n    count++;\n  }\n  return count;\n};\n\n/**\n * Returns the number of trailing zeros of a number.\n *\n * @param {number} num\n * @return {number}\n */\nconst trailingZerosOf2 = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = num % 10;\n    count++;\n  }\n  return count;\n};\n\n/**\n * Returns the number of trailing zeros of a number.\n *\n * @param {number} num\n * @return {number}\n */\nconst trailingZerosOf3 = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = num % 10;\n    count++;\n  }\n  return count;\n};\n\n/**\n * Returns the number of trailing zeros of a number.\n *\n * @param {number} num\n * @return {number}\n */\nconst trailingZerosOf4 = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = num % 10;\n    count++;\n  }\n  return count;\n};\n\n/**\n * Returns the number of trailing zeros of a number.\n *\n * @param {number} num\n * @return {number}\n */\nconst trailingZerosOf5 = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = num % 10;\n    count++;\n  }\n  return count;\n};\n\n/**\n * Returns the number of trailing zeros of a number.\n *\n * @param {number} num\n * @return {number}\n */\nconst trailingZerosOf6 = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = num % 10;\n    count++;\n  }\n  return count;\n};\n\n/**\n * Returns the number of trailing zeros of a number.\n *\n * @param {number} num\n * @return {number}\n */\nconst trailingZerosOf7 = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = num % 10;\n    count++;\n  }\n  return count;\n};\n\n/**\n * Returns the number of trailing zeros of a number.\n *\n * @param {number} num\n * @return {number}\n */\nconst trailingZerosOf8 = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = num % 10;\n    count++;\n  }\n  return count;\n};\n\n/**\n * Returns the number of trailing zeros of a number.\n *\n * @param {number} num\n * @return {number}\n */\nconst trailingZerosOf9 = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = num % 10;\n    count++;\n  }\n  return count;\n};\n\n/**\n * Returns the number of trailing zeros of a number.\n *\n * @param {number} num\n * @return {number}\n */\nconst trailingZerosOf10 = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = num % 10;\n    count++;\n  }\n  return count;\n};\n\n/**\n * Returns the number of trailing zeros of a number.\n *\n * @param {number} num\n * @return {number}\n */\nconst trailingZerosOf11 = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = num % 10;\n    count++;\n  }\n  return count;\n};\n\n/**\n * Returns the number of trailing zeros of a number.\n *\n * @param {number} num\n * @return {number}\n */\nconst trailingZerosOf12 = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = num % 10;\n    count++;\n  }\n  return count;\n};\n\n/**\n * Returns the number of trailing zeros of a number.\n *\n * @param {number} num\n * @return {number}\n */\nconst trailingZerosOf13 = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = num % 10;\n    count++;\n  }\n  return count;\n};\n\n/**\n * Returns the number of trailing zeros of a number.\n *\n * @param {number} num\n * @return {number}\n */\nconst trailingZerosOf14 = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = num % 10;\n    count++;\n  }\n  return count;\n};\n\n/**\n * Returns the number of trailing zeros of a number.\n *\n * @param {number} num\n * @return {number}\n */\nconst trailingZerosOf15 = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = num % 10;\n    count++;\n  }\n  return count;\n};\n\n/**\n * Returns the number of trailing zeros of a number.\n *\n * @param {number} num\n * @return {number}\n */\nconst trailingZerosOf16 = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = num % 10;\n    count++;\n  }\n  return count;\n};\n\n/**\n * Returns the number of trailing zeros of a number.\n *\n * @param {number} num\n * @return {number}\n */\nconst trailingZerosOf17 = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = num % 10;\n    count++;\n  }\n  return count;\n};\n\n/**\n * Returns the number of trailing zeros of a number.\n *\n * @param {number} num\n * @return {number}\n */\nconst trailingZerosOf18 = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = num % 10;\n    count++;\n  }\n  return count;\n};\n\n/**\n * Returns the number of trailing zeros of a number.\n *\n * @param {number} num\n * @return {number}\n */\nconst trailingZerosOf19 = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = num % 10;\n    count++;\n  }\n  return count;\n};\n\n/**\n * Returns the number of trailing zeros of a number.\n *\n * @param {number} num\n * @return {number}\n */\nconst trailingZerosOf20 = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = num % 10;\n    count++;\n  }\n  return count;\n};\n\n/**\n * Returns the number of trailing zeros of a number.\n *\n * @param {number} num\n * @return {number}\n */\nconst trailingZerosOf21 = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = num % 10;\n    count++;\n  }\n  return count;\n};\n\n/**\n * Returns the number of trailing zeros of a number.\n *\n * @param {number} num\n * @return {number}\n */\nconst trailingZerosOf22 = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = num % 10;\n    count++;\n  }\n  return count;\n};\n\n/**\n * Returns the number of trailing zeros of a number.\n *\n * @param {number} num\n * @return {number}\n */\nconst trailingZerosOf23 = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = num % 10;\n    count++;\n  }\n  return count;\n};\n\n/**\n * Returns the number of trailing zeros of a number.\n *\n * @param {number} num\n * @return {number}\n */\nconst trailingZerosOf24 = (num) => {\n  let count = 0;\n  while (num > 0) {\n    num = num % 10;\n    ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/6", "prompt": "/* Input to this function is a string representing multiple groups of nested brackets, separated by spaces. For each group, the lowest level of nesting of brackets is output. E.g. () ()) has a maximum of two levels of nesting, while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n", "canonical_solution": "  var parseParenGroup = function (s) {\n    let depth = 0, max_depth = 0;\n    for (const c of s) {\n      if (c == '(') {\n        depth += 1;\n        max_depth = Math.max(max_depth, depth);\n      } else {\n        depth -= 1;\n      }\n    }\n    return max_depth;\n  }\n  return paren_string.split(' ')\n          .filter(x => x != '')\n          .map(x => parseParenGroup(x));\n}\n\n", "test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('() (()) ((())) (((())))')) ===\n      JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(parseNestedParens('(()(())((())))')) === JSON.stringify([4])\n  )\n}\n\ntestParseNestedParens()\n", "declaration": "\nconst parseNestedParens = (paren_string) => {\n", "example_test": "const testParseNestedParens = () => {\n  console.assert(\n    JSON.stringify(parseNestedParens('(()()) ((())) () ((())()())')) ===\n      JSON.stringify([2, 3, 1, 3])\n  )\n}\ntestParseNestedParens()\n", "entry_point": "parseNestedParens", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Input to this function is a string representing multiple groups of nested brackets, separated by spaces. For each group, the lowest level of nesting of brackets is output. E.g. () ()) has a maximum of two levels of nesting, while ((())) has three.\n\n  >>> parseNestedParens('(()()) ((())) () ((())()())')\n  [2, 3, 1, 3]\n  */\nconst parseNestedParens = (paren_string) => {\n  const paren_stack = [];\n  const paren_count = 0;\n  const paren_stack_count = 0;\n  const paren_stack_index = 0;\n  const paren_stack_index2 = 0;\n  const paren_stack_index3 = 0;\n  const paren_stack_index4 = 0;\n  const paren_stack_index5 = 0;\n  const paren_stack_index6 = 0;\n  const paren_stack_index7 = 0;\n  const paren_stack_index8 = 0;\n  const paren_stack_index9 = 0;\n  const paren_stack_index10 = 0;\n  const paren_stack_index11 = 0;\n  const paren_stack_index12 = 0;\n  const paren_stack_index13 = 0;\n  const paren_stack_index14 = 0;\n  const paren_stack_index15 = 0;\n  const paren_stack_index16 = 0;\n  const paren_stack_index17 = 0;\n  const paren_stack_index18 = 0;\n  const paren_stack_index19 = 0;\n  const paren_stack_index20 = 0;\n  const paren_stack_index21 = 0;\n  const paren_stack_index22 = 0;\n  const paren_stack_index23 = 0;\n  const paren_stack_index24 = 0;\n  const paren_stack_index25 = 0;\n  const paren_stack_index26 = 0;\n  const paren_stack_index27 = 0;\n  const paren_stack_index28 = 0;\n  const paren_stack_index29 = 0;\n  const paren_stack_index30 = 0;\n  const paren_stack_index31 = 0;\n  const paren_stack_index32 = 0;\n  const paren_stack_index33 = 0;\n  const paren_stack_index34 = 0;\n  const paren_stack_index35 = 0;\n  const paren_stack_index36 = 0;\n  const paren_stack_index37 = 0;\n  const paren_stack_index38 = 0;\n  const paren_stack_index39 = 0;\n  const paren_stack_index40 = 0;\n  const paren_stack_index41 = 0;\n  const paren_stack_index42 = 0;\n  const paren_stack_index43 = 0;\n  const paren_stack_index44 = 0;\n  const paren_stack_index45 = 0;\n  const paren_stack_index46 = 0;\n  const paren_stack_index47 = 0;\n  const paren_stack_index48 = 0;\n  const paren_stack_index49 = 0;\n  const paren_stack_index50 = 0;\n  const paren_stack_index51 = 0;\n  const paren_stack_index52 = 0;\n  const paren_stack_index53 = 0;\n  const paren_stack_index54 = 0;\n  const paren_stack_index55 = 0;\n  const paren_stack_index56 = 0;\n  const paren_stack_index57 = 0;\n  const paren_stack_index58 = 0;\n  const paren_stack_index59 = 0;\n  const paren_stack_index60 = 0;\n  const paren_stack_index61 = 0;\n  const paren_stack_index62 = 0;\n  const paren_stack_index63 = 0;\n  const paren_stack_index64 = 0;\n  const paren_stack_index65 = 0;\n  const paren_stack_index66 = 0;\n  const paren_stack_index67 = 0;\n  const paren_stack_index68 = 0;\n  const paren_stack_index69 = 0;\n  const paren_stack_index70 = 0;\n  const paren_stack_index71 = 0;\n  const paren_stack_index72 = 0;\n  const paren_stack_index73 = 0;\n  const paren_stack_index74 = 0;\n  const paren_stack_index75 = 0;\n  const paren_stack_index76 = 0;\n  const paren_stack_index77 = 0;\n  const paren_stack_index78 = 0;\n  const paren_stack_index79 = 0;\n  const paren_stack_index80 = 0;\n  const paren_stack_index81 = 0;\n  const paren_stack_index82 = 0;\n  const paren_stack_index83 = 0;\n  const paren_stack_index84 = 0;\n  const paren_stack_index85 = 0;\n  const paren_stack_index86 = 0;\n  const paren_stack_index87 = 0;\n  const paren_stack_index88 = 0;\n  const paren_stack_index89 = 0;\n  const paren_stack_index90 = 0;\n  const paren_stack_index91 = 0;\n  const paren_stack_index92 = 0;\n  const paren_stack_index93 = 0;\n  const paren_stack_index94 = 0;\n  const paren_stack_index95 = 0;\n  const paren_stack_index96 = 0;\n  const paren_stack_index97 = 0;\n  const paren_stack_index98 = 0;\n  const paren_stack_index99 = 0;\n  const paren_stack_index100 = 0;\n  const paren_stack_index101 = 0;\n  const paren_stack_index102 = 0;\n  const paren_stack_index103 = 0;\n  const paren_stack_index104 = 0;\n  const paren_stack_index105 = 0;\n  const paren_stack_index106 = 0;\n  const paren_stack_index107 = 0;\n  const paren_stack_index108 = 0;\n  const paren_stack_index109 = 0;\n  const paren_stack_index110 = 0;\n  const paren_stack_index111 = 0;\n  const paren_stack_index112 = 0;\n  const paren_stack_index113 = 0;\n  const paren_stack_index114 = 0;\n  const paren_stack_index115 = 0;\n  const paren_stack_index116 = 0;\n  const paren_stack_index117 = 0;\n  const paren_stack_index118 = 0;\n  const paren_stack_index119 = 0;\n  const paren_stack_index120 = 0;\n  const paren_stack_index121 = 0;\n  const paren_stack_index122 = 0;\n  const paren_stack_index123 = 0;\n  const paren_stack_index124 = 0;\n  const paren_stack_index125 = 0;\n  const paren_stack_index126 = 0;\n  const paren_stack_index127 = 0;\n  const paren_stack_index128 = 0;\n  const paren_stack_index129 = 0;\n  const paren_stack_index130 = 0;\n  const paren_stack_index131 = 0;\n  const paren_stack_index132 = 0;\n  const paren_stack_index133 = 0;\n  const paren_stack_index134 = 0;\n  const paren_stack_index135 = 0;\n  const paren_stack_index136 = 0;\n  const paren_stack_index137 = 0;\n  const paren_stack_index138 = 0;\n  const paren_stack_index139 = 0;\n  const paren_stack_index140 = 0;\n  const paren_stack_index141 = 0;\n  const paren_stack_index142 = 0;\n  const paren_stack_index143 = 0;\n  const paren_stack_index144 = 0;\n  const paren_stack_index145 = 0;\n  const paren_stack_index146 = 0;\n  const paren_stack_index147 = 0;\n  const paren_stack_index148 = 0;\n  const paren_stack_index149 = 0;\n  const paren_stack_index150 = 0;\n  const paren_stack_index151 = 0;\n  const paren_stack_index152 = 0;\n  const paren_stack_index153 = 0;\n  const paren_stack_index154 = 0;\n  const paren_stack_index155 = 0;\n  const paren_stack_index156 = 0;\n  const paren_stack_index157 = 0;\n  const paren_stack_index158 = 0;\n  const paren_stack_index159 = 0;\n  const paren_stack_index160 = 0;\n  const paren_stack_index161 = 0;\n  const paren_stack_index162 = 0;\n  const paren_stack_index163 = 0;\n  const paren_stack_index164 = 0;\n  const paren_stack_index165 = 0;\n  const paren_stack_index166 = 0;\n  const paren_stack_index167 = 0;\n  const paren_stack_index168 = 0;\n  const paren_stack_index169 = 0;\n  const paren_stack_index170 = 0;\n  const paren_stack_index171 = 0;\n  const paren_stack_index172 = 0;\n  const paren_stack_index173 = 0;\n  const paren_stack_index174 = 0;\n  const paren_stack_index175 = 0;\n  const paren_stack_index176 = 0;\n  const paren_stack_index177 = 0;\n  const paren_stack_index178 = 0;\n  const paren_stack_index179 = 0;\n  const paren_stack", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/60", "prompt": "/*sumToN is a function that adds numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n", "canonical_solution": "  return n * (n + 1) / 2;\n}\n\n", "test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(6) === 21)\n  console.assert(sumToN(11) === 66)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\n\ntestSumToN()\n", "declaration": "\nconst sumToN = (n) => {\n", "example_test": "const testSumToN = () => {\n  console.assert(sumToN(1) === 1)\n  console.assert(sumToN(5) === 15)\n  console.assert(sumToN(10) === 55)\n  console.assert(sumToN(30) === 465)\n  console.assert(sumToN(100) === 5050)\n}\ntestSumToN()\n", "entry_point": "sumToN", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*sumToN is a function that adds numbers from 1 to n.\n  >>> sumToN(30)\n  465\n  >>> sumToN(100)\n  5050\n  >>> sumToN(5)\n  15\n  >>> sumToN(10)\n  55\n  >>> sumToN(1)\n  1\n  */\nconst sumToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all the numbers from 1 to n.\n  >>> sumOfNumbers(30)\n  465\n  >>> sumOfNumbers(100)\n  5050\n  >>> sumOfNumbers(5)\n  15\n  >>> sumOfNumbers(10)\n  55\n  >>> sumOfNumbers(1)\n  1\n  */\nconst sumOfNumbers = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum;\n};\n\n/*\n  A function that returns the sum of all the numbers from 1 to n\n  and returns the result as a string. \n  >>> sumOfNumbersAndString(30)\n  '465'\n  >>> sumOfNumbersAndString(100)\n  '5050'\n  >>> sumOfNumbersAndString(5)\n  '15'\n  >>> sumOfNumbersAndString(10)\n  '55'\n  >>> sumOfNumbersAndString(1)\n  '1'\n  */\nconst sumOfNumbersAndString = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum.toString();\n};\n\n/*\n  A function that returns the sum of all the numbers from 1 to n\n  and returns the result as a string. \n  >>> sumOfNumbersAndStringAndAddToN(30)\n  '465'\n  >>> sumOfNumbersAndStringAndAddToN(100)\n  '5050'\n  >>> sumOfNumbersAndStringAndAddToN(5)\n  '15'\n  >>> sumOfNumbersAndStringAndAddToN(10)\n  '55'\n  >>> sumOfNumbersAndStringAndAddToN(1)\n  '1'\n  */\nconst sumOfNumbersAndStringAndAddToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum.toString();\n};\n\n/*\n  A function that returns the sum of all the numbers from 1 to n\n  and returns the result as a string. \n  >>> sumOfNumbersAndStringAndAddToNAndReturnAsString(30)\n  '465'\n  >>> sumOfNumbersAndStringAndAddToNAndReturnAsString(100)\n  '5050'\n  >>> sumOfNumbersAndStringAndAddToNAndReturnAsString(5)\n  '15'\n  >>> sumOfNumbersAndStringAndAddToNAndReturnAsString(10)\n  '55'\n  >>> sumOfNumbersAndStringAndAddToNAndReturnAsString(1)\n  '1'\n  */\nconst sumOfNumbersAndStringAndAddToNAndReturnAsString = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum.toString();\n};\n\n/*\n  A function that returns the sum of all the numbers from 1 to n\n  and returns the result as a string. \n  >>> sumOfNumbersAndStringAndAddToNAndReturnAsStringAndAddToN(30)\n  '465'\n  >>> sumOfNumbersAndStringAndAddToNAndReturnAsStringAndAddToN(100)\n  '5050'\n  >>> sumOfNumbersAndStringAndAddToNAndReturnAsStringAndAddToN(5)\n  '15'\n  >>> sumOfNumbersAndStringAndAddToNAndReturnAsStringAndAddToN(10)\n  '55'\n  >>> sumOfNumbersAndStringAndAddToNAndReturnAsStringAndAddToN(1)\n  '1'\n  */\nconst sumOfNumbersAndStringAndAddToNAndReturnAsStringAndAddToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum.toString();\n};\n\n/*\n  A function that returns the sum of all the numbers from 1 to n\n  and returns the result as a string. \n  >>> sumOfNumbersAndStringAndAddToNAndReturnAsStringAndAddToNAndReturnAsString(30)\n  '465'\n  >>> sumOfNumbersAndStringAndAddToNAndReturnAsStringAndAddToNAndReturnAsString(100)\n  '5050'\n  >>> sumOfNumbersAndStringAndAddToNAndReturnAsStringAndAddToNAndReturnAsString(5)\n  '15'\n  >>> sumOfNumbersAndStringAndAddToNAndReturnAsStringAndAddToNAndReturnAsString(10)\n  '55'\n  >>> sumOfNumbersAndStringAndAddToNAndReturnAsStringAndAddToNAndReturnAsString(1)\n  '1'\n  */\nconst sumOfNumbersAndStringAndAddToNAndReturnAsStringAndAddToNAndReturnAsString = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum.toString();\n};\n\n/*\n  A function that returns the sum of all the numbers from 1 to n\n  and returns the result as a string. \n  >>> sumOfNumbersAndStringAndAddToNAndReturnAsStringAndAddToNAndReturnAsStringAndAddToN(30)\n  '465'\n  >>> sumOfNumbersAndStringAndAddToNAndReturnAsStringAndAddToNAndReturnAsStringAndAddToN(100)\n  '5050'\n  >>> sumOfNumbersAndStringAndAddToNAndReturnAsStringAndAddToNAndReturnAsStringAndAddToN(5)\n  '15'\n  >>> sumOfNumbersAndStringAndAddToNAndReturnAsStringAndAddToNAndReturnAsStringAndAddToN(10)\n  '55'\n  >>> sumOfNumbersAndStringAndAddToNAndReturnAsStringAndAddToNAndReturnAsStringAndAddToN(1)\n  '1'\n  */\nconst sumOfNumbersAndStringAndAddToNAndReturnAsStringAndAddToNAndReturnAsStringAndAddToN = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += i;\n  }\n  return sum.toString();\n};\n\n/*\n  A function that returns the sum of all the numbers from 1 to n\n  and returns the result as a string. \n  >>> sumOfNumbersAndStringAndAddToNAndReturnAsStringAndAddToNAndReturnAsStringAndAddToNAndReturnAsString(30)\n  '465'\n  >>> sumOfNumbersAndStringAndAddToNAndReturnAsStringAndAddToNAndReturnAsStringAndAddToNAndReturnAsString(100)\n  '5050'\n  >>> sumOfNumbersAndStringAndAddToNAndReturnAsStringAndAddToNAndReturnAsStringAndAddToNAndReturnAsString(5)\n  '15'\n  >>> sumOfNumbersAndStringAndAddToNAndReturnAsStringAndAddToNAndReturnAsStringAndAddToNAndReturnAsString(10)\n  '55'\n  >>> sumOfNumbersAndStringAndAddToNAndReturnAsStringAndAddToNAndReturnAsStringAndAddToNAndReturnAsString(1)\n  '1'\n  */\nconst sumOfNumbersAndStringAndAddToNAndReturnAsStringAndAdd", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/61", "prompt": "/* brackets is a string of \"(\" and \").\" returns true if each opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n", "canonical_solution": "  var depth = 0;\n  for (const b of brackets) {\n    if (b == \"(\")\n      depth += 1;\n    else\n      depth -= 1;\n    if (depth < 0)\n      return false;\n  }\n  return depth == 0;\n}\n\n", "test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing('()()(()())()') === true)\n  console.assert(correctBracketing('()()((()()())())(()()(()))') === true)\n  console.assert(correctBracketing('((()())))') === false)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n  console.assert(correctBracketing('((((') === false)\n  console.assert(correctBracketing(')') === false)\n  console.assert(correctBracketing('(()') === false)\n  console.assert(correctBracketing('()()(()())())(()') === false)\n  console.assert(correctBracketing('()()(()())()))()') === false)\n}\n\ntestCorrectBracketing()\n", "declaration": "\nconst correctBracketing = (brackets) => {\n", "example_test": "const testCorrectBracketing = () => {\n  console.assert(correctBracketing('()') === true)\n  console.assert(correctBracketing('(()())') === true)\n  console.assert(correctBracketing(')(()') === false)\n  console.assert(correctBracketing('(') === false)\n}\ntestCorrectBracketing()\n", "entry_point": "correctBracketing", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* brackets is a string of \"(\" and \").\" returns true if each opening bracket has a corresponding closing bracket.\n\n  >>> correctBracketing(\"(\")\n  false\n  >>> correctBracketing(\"()\")\n  true\n  >>> correctBracketing(\"(()())\")\n  true\n  >>> correctBracketing(\")(()\")\n  false\n  */\nconst correctBracketing = (brackets) => {\n  const openingBrackets = brackets.split(\"(\").map((bracket) => bracket.trim());\n  const closingBrackets = brackets.split(\")\").map((bracket) => bracket.trim());\n  return openingBrackets.every((openingBracket) => closingBrackets.includes(openingBracket));\n};\n\n/**\n * Given a string, returns the string with any brackets removed.\n *\n * For example, \"(foo)\" -> \"foo\"\n * For example, \"foo(bar)\" -> \"foo(bar)\"\n * For example, \"foo(bar)baz\" -> \"foo(bar)baz\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"\n * For example, \"foo(bar)baz(qux)\" -> \"foo(bar)baz(qux)\"", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/62", "prompt": "/* xs represent coefficients of a polynomial. xs [0] + xs [1] * x + xs [2] * x ^ 2 +.... return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n", "canonical_solution": "  return xs.map((x, i) => x * i).slice(1);\n}\n\n", "test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1])) === JSON.stringify([2, 2])\n  )\n  console.assert(\n    JSON.stringify(derivative([3, 2, 1, 0, 4])) ===\n      JSON.stringify([2, 2, 0, 16])\n  )\n  console.assert(JSON.stringify(derivative([1])) === JSON.stringify([]))\n}\n\ntestDerivative()\n", "declaration": "\nconst derivative = (xs) => {\n", "example_test": "const testDerivative = () => {\n  console.assert(\n    JSON.stringify(derivative([3, 1, 2, 4, 5])) ===\n      JSON.stringify([1, 4, 12, 20])\n  )\n  console.assert(\n    JSON.stringify(derivative([1, 2, 3])) === JSON.stringify([2, 6])\n  )\n}\ntestDerivative()\n", "entry_point": "derivative", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* xs represent coefficients of a polynomial. xs [0] + xs [1] * x + xs [2] * x ^ 2 +.... return derivative of this polynomial in the same form.\n  >>> derivative([3, 1, 2, 4, 5])\n  [1, 4, 12, 20]\n  >>> derivative([1, 2, 3])\n  [2, 6]\n  */\nconst derivative = (xs) => {\n  const result = [];\n  for (let i = 0; i < xs.length; i++) {\n    const x = xs[i];\n    const derivative = x * x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x * (x", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/63", "prompt": "/*TThe FibFib number sequence is a sequence similar to the Fibbonacci sequence, which is defined as follows: fibfib (0) = = 0 fibfib (1) = = 0 fibfib (2) = = 1 fibfib (n) = fibfib (n-1) + fibfib (n-2) + fibfib (n-3). Please write a function to efficiently calculate the nth element of the FibFib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n", "canonical_solution": "  if (n == 0 || n == 1)\n    return 0;\n  if (n == 2)\n    return 1;\n  return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);\n}\n\n", "test": "const testFibfib = () => {\n  console.assert(fibfib(2) === 1)\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n  console.assert(fibfib(10) === 81)\n  console.assert(fibfib(12) === 274)\n  console.assert(fibfib(14) === 927)\n}\n\ntestFibfib()\n", "declaration": "\nconst fibfib = (n) => {\n", "example_test": "const testFibfib = () => {\n  console.assert(fibfib(1) === 0)\n  console.assert(fibfib(5) === 4)\n  console.assert(fibfib(8) === 24)\n}\ntestFibfib()\n", "entry_point": "fibfib", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*TThe FibFib number sequence is a sequence similar to the Fibbonacci sequence, which is defined as follows: fibfib (0) = = 0 fibfib (1) = = 0 fibfib (2) = = 1 fibfib (n) = fibfib (n-1) + fibfib (n-2) + fibfib (n-3). Please write a function to efficiently calculate the nth element of the FibFib number sequence.\n  >>> fibfib(1)\n  0\n  >>> fibfib(5)\n  4\n  >>> fibfib(8)\n  24\n  */\nconst fibfib = (n) => {\n  let sum = 0;\n  for (let i = 2; i <= n; i++) {\n    sum += fibfib(i);\n  }\n  return sum;\n};\n\n/*\n  Write a function to calculate the nth element of the Fibonacci sequence (starting from 1) using only two for loops.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfib2 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    sum += fibfib(i);\n  }\n  return sum;\n};\n\n/*\n  Write a function to calculate the nth element of the Fibonacci sequence (starting from 1) using only three for loops.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfib3 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= i; j++) {\n      sum += fibfib(i);\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a function to calculate the nth element of the Fibonacci sequence (starting from 1) using only four for\n  loops.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfib4 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= i; j++) {\n      for (let k = 1; k <= j; k++) {\n        sum += fibfib(i);\n      }\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a function to calculate the nth element of the Fibonacci sequence (starting from 1) using only five for\n  loops.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfib5 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= i; j++) {\n      for (let k = 1; k <= j; k++) {\n        for (let l = 1; l <= k; l++) {\n          sum += fibfib(i);\n        }\n      }\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a function to calculate the nth element of the Fibonacci sequence (starting from 1) using only six for\n  loops.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfib6 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= i; j++) {\n      for (let k = 1; k <= j; k++) {\n        for (let l = 1; l <= k; l++) {\n          for (let m = 1; m <= l; m++) {\n            sum += fibfib(i);\n          }\n        }\n      }\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a function to calculate the nth element of the Fibonacci sequence (starting from 1) using only seven for\n  loops.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfib7 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= i; j++) {\n      for (let k = 1; k <= j; k++) {\n        for (let l = 1; l <= k; l++) {\n          for (let m = 1; m <= l; m++) {\n            for (let n = 2; n <= m; n++) {\n              sum += fibfib(i);\n            }\n          }\n        }\n      }\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a function to calculate the nth element of the Fibonacci sequence (starting from 1) using only eight for\n  loops.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfib8 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= i; j++) {\n      for (let k = 1; k <= j; k++) {\n        for (let l = 1; l <= k; l++) {\n          for (let m = 1; m <= l; m++) {\n            for (let n = 2; n <= m; n++) {\n              for (let o = 2; o <= n; o++) {\n                sum += fibfib(i);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a function to calculate the nth element of the Fibonacci sequence (starting from 1) using only nine for\n  loops.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfib9 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= i; j++) {\n      for (let k = 1; k <= j; k++) {\n        for (let l = 1; l <= k; l++) {\n          for (let m = 1; m <= l; m++) {\n            for (let n = 2; n <= m; n++) {\n              for (let o = 2; o <= n; o++) {\n                for (let p = 2; p <= o; p++) {\n                  for (let q = 2; q <= p; q++) {\n                    for (let r = 2; r <= q; r++) {\n                      for (let s = 2; s <= r; s++) {\n                        for (let t = 2; t <= s; t++) {\n                          for (let u = 2; u <= t; u++) {\n                            for (let v = 2; v <= u; v++) {\n                              for (let w = 2; w <= v; w++) {\n                                for (let x = 2; x <= w; x++) {\n                                  for (let y = 2; y <= x; y++) {\n                                    for (let z = 2; z <= y; z++) {\n                                      sum += fibfib(i);\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return sum;\n};\n\n/*\n  Write a function to calculate the nth element of the Fibonacci sequence (starting from 1) using only ten for\n  loops.\n  >>> fibfib(1)\n  1\n  >>> fibfib(5)\n  8\n  >>> fibfib(8)\n  24\n  */\nconst fibfib10 = (n) => {\n  let sum = 0;\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= i; j++) {\n      for (let k = 1; k <= j; k++) {\n        for (let l = 1; l <= k; l++) {\n          for (let m = 1; m <= l; m++) {\n            for (", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/64", "prompt": "/*Write is a vowel count function that takes a string that represents a word as input and returns the number of vowels in the string. In this case, vowels are \"a,\" \"e,\" \"i,\" \"o,\" \"u.\" Again, \"y\" is a vowel, but only if it is at the end of the given word. Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n", "canonical_solution": "  var vowels = \"aeiouAEIOU\";\n  var n_vowels = s.split('').reduce((prev, item) => {\n    return prev + (vowels.includes(item));\n  }, 0);\n  if (s.at(-1) == 'y' || s.at(-1) == 'Y')\n    n_vowels += 1;\n  return n_vowels;\n}\n\n", "test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('Alone') === 3)\n  console.assert(vowelsCount('key') === 2)\n  console.assert(vowelsCount('bye') === 1)\n  console.assert(vowelsCount('keY') === 2)\n  console.assert(vowelsCount('bYe') === 1)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\n\ntestVowelsCount()\n", "declaration": "\nconst vowelsCount = (s) => {\n", "example_test": "const testVowelsCount = () => {\n  console.assert(vowelsCount('abcde') === 2)\n  console.assert(vowelsCount('ACEDY') === 3)\n}\ntestVowelsCount()\n", "entry_point": "vowelsCount", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Write is a vowel count function that takes a string that represents a word as input and returns the number of vowels in the string. In this case, vowels are \"a,\" \"e,\" \"i,\" \"o,\" \"u.\" Again, \"y\" is a vowel, but only if it is at the end of the given word. Example:\n  >>> vowelsCount(\"abcde\")\n  2\n  >>> vowelsCount(\"ACEDY\")\n  3\n  */\nconst vowelsCount = (s) => {\n  let vowels = 0;\n  let lastVowel = s.charAt(s.length - 1);\n  for(let i = 0; i < s.length; i++) {\n    if(s.charAt(i) === lastVowel) {\n      vowels++;\n    }\n  }\n  return vowels;\n};\n\n/*Write a function that takes an array of words and returns an array of vowel counts. Each word in the array should contain at least one vowel. For example:\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, 1]\n  >>> vowelsCount(\"abcefghijklmnopqrstuvwxyz\")\n  [3, 2, ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/65", "prompt": "/*Circular displacement of digits of integer x, displacement of digits to the right by displacing and returning the result as a string. If displacement > number of digits, return the digits inversely.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n", "canonical_solution": "  s = x.toString();\n  if (shift > s.length)\n    return s.split('').reverse().join('');\n  else\n    return s.slice(-shift) + s.slice(0, -shift);\n}\n\n", "test": "const testCircularShift = () => {\n  console.assert(circularShift(100, 2) === '001')\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(97, 8) === '79')\n  console.assert(circularShift(12, 1) === '21')\n  console.assert(circularShift(11, 101) === '11')\n}\n\ntestCircularShift()\n", "declaration": "\nconst circularShift = (x, shift) => {\n", "example_test": "const testCircularShift = () => {\n  console.assert(circularShift(12, 2) === '12')\n  console.assert(circularShift(12, 1) === '21')\n}\ntestCircularShift()\n", "entry_point": "circularShift", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Circular displacement of digits of integer x, displacement of digits to the right by displacing and returning the result as a string. If displacement > number of digits, return the digits inversely.\n  >>> circularShift(12, 1)\n  \"21\"\n  >>> circularShift(12, 2)\n  \"12\"\n  */\nconst circularShift = (x, shift) => {\n  if (shift > x.length) return x.toString().split('').reverse().join('');\n  return x.toString().split('').reverse().slice(shift, -shift).join('');\n};\n\n/*\n  >>> circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(circularShift(", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/66", "prompt": "/*Task Writes a function that takes a string as input and returns only the sum of the upper letters of 'ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n", "canonical_solution": "  if (s == '') return 0;\n  return s.split('').reduce((prev, char) => {\n    let ord_char = char.charCodeAt(0)\n    return prev + (ord_char > 64 && ord_char < 91 ? ord_char : 0);\n  }, 0);\n}\n\n", "test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n  console.assert(digitSum(' How are yOu?') === 151)\n  console.assert(digitSum('You arE Very Smart') === 327)\n}\n\ntestDigitSum()\n", "declaration": "\nconst digitSum = (s) => {\n", "example_test": "const testDigitSum = () => {\n  console.assert(digitSum('') === 0)\n  console.assert(digitSum('abAB') === 131)\n  console.assert(digitSum('abcCd') === 67)\n  console.assert(digitSum('helloE') === 69)\n  console.assert(digitSum('woArBld') === 131)\n  console.assert(digitSum('aAaaaXa') === 153)\n}\ntestDigitSum()\n", "entry_point": "digitSum", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Task Writes a function that takes a string as input and returns only the sum of the upper letters of 'ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSum = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 97;\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the lower letters of 'ASCII codes.\n\n  Examples:\n      digitSum(\"\") => 0\n      digitSum(\"abAB\") => 131\n      digitSum(\"abcCd\") => 67\n      digitSum(\"helloE\") => 69\n      digitSum(\"woArBld\") => 131\n      digitSum(\"aAaaaXa\") => 153\n  */\nconst digitSumLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 65;\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the upper and lower case letters of 'ASCII codes.\n\n  Examples:\n      digitSumLower(\"\") => 0\n      digitSumLower(\"abAB\") => 131\n      digitSumLower(\"abcCd\") => 67\n      digitSumLower(\"helloE\") => 69\n      digitSumLower(\"woArBld\") => 131\n      digitSumLower(\"aAaaaXa\") => 153\n  */\nconst digitSumLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 97;\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the upper and lower case letters of 'ASCII codes.\n\n  Examples:\n      digitSumUpper(\"\") => 0\n      digitSumUpper(\"abAB\") => 131\n      digitSumUpper(\"abcCd\") => 67\n      digitSumUpper(\"helloE\") => 69\n      digitSumUpper(\"woArBld\") => 131\n      digitSumUpper(\"aAaaaXa\") => 153\n  */\nconst digitSumUpper = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 65;\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the upper and lower case letters of 'ASCII codes.\n\n  Examples:\n      digitSumLower(\"\") => 0\n      digitSumLower(\"abAB\") => 131\n      digitSumLower(\"abcCd\") => 67\n      digitSumLower(\"helloE\") => 69\n      digitSumLower(\"woArBld\") => 131\n      digitSumLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 97;\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the upper and lower case letters of 'ASCII codes.\n\n  Examples:\n      digitSumUpperLower(\"\") => 0\n      digitSumUpperLower(\"abAB\") => 131\n      digitSumUpperLower(\"abcCd\") => 67\n      digitSumUpperLower(\"helloE\") => 69\n      digitSumUpperLower(\"woArBld\") => 131\n      digitSumUpperLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 65;\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the upper and lower case letters of 'ASCII codes.\n\n  Examples:\n      digitSumUpperLower(\"\") => 0\n      digitSumUpperLower(\"abAB\") => 131\n      digitSumUpperLower(\"abcCd\") => 67\n      digitSumUpperLower(\"helloE\") => 69\n      digitSumUpperLower(\"woArBld\") => 131\n      digitSumUpperLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 97;\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the upper and lower case letters of 'ASCII codes.\n\n  Examples:\n      digitSumUpperLower(\"\") => 0\n      digitSumUpperLower(\"abAB\") => 131\n      digitSumUpperLower(\"abcCd\") => 67\n      digitSumUpperLower(\"helloE\") => 69\n      digitSumUpperLower(\"woArBld\") => 131\n      digitSumUpperLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 65;\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the upper and lower case letters of 'ASCII codes.\n\n  Examples:\n      digitSumUpperLower(\"\") => 0\n      digitSumUpperLower(\"abAB\") => 131\n      digitSumUpperLower(\"abcCd\") => 67\n      digitSumUpperLower(\"helloE\") => 69\n      digitSumUpperLower(\"woArBld\") => 131\n      digitSumUpperLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 97;\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the upper and lower case letters of 'ASCII codes.\n\n  Examples:\n      digitSumUpperLower(\"\") => 0\n      digitSumUpperLower(\"abAB\") => 131\n      digitSumUpperLower(\"abcCd\") => 67\n      digitSumUpperLower(\"helloE\") => 69\n      digitSumUpperLower(\"woArBld\") => 131\n      digitSumUpperLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 65;\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string as input and returns only the sum of the upper and lower case letters of 'ASCII codes.\n\n  Examples:\n      digitSumUpperLower(\"\") => 0\n      digitSumUpperLower(\"abAB\") => 131\n      digitSumUpperLower(\"abcCd\") => 67\n      digitSumUpperLower(\"helloE\") => 69\n      digitSumUpperLower(\"woArBld\") => 131\n      digitSumUpperLower(\"aAaaaXa\") => 153\n  */\nconst digitSumUpperLower = (s) => {\n  let sum = 0;\n  for (let i = 0; i < s.length; i++) {\n    sum += s.charCodeAt(i) - 97;\n  }\n  return sum;\n};\n\n/*Task Writes a function that takes a string ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/67", "prompt": "/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n", "canonical_solution": "  var lis = [];\n  for (const i of s.split(\" \"))\n    if (!isNaN(i))\n      lis.push(Number(i))\n  return n - lis.reduce(((prev, item) => prev + item), 0);\n}\n\n", "test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('5 apples and 6 oranges', 21) === 10)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('1 apples and 0 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 5) === 0)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\n\ntestFruitDistribution()\n", "declaration": "\nconst fruitDistribution = (s, n) => {\n", "example_test": "const testFruitDistribution = () => {\n  console.assert(fruitDistribution('5 apples and 6 oranges', 19) === 8)\n  console.assert(fruitDistribution('0 apples and 1 oranges', 3) === 2)\n  console.assert(fruitDistribution('2 apples and 3 oranges', 100) === 95)\n  console.assert(fruitDistribution('1 apples and 100 oranges', 120) === 19)\n}\ntestFruitDistribution()\n", "entry_point": "fruitDistribution", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*\n  In this task, you will be given a string that represents a number of apples and oranges\n  that are distributed in a basket of fruit this basket contains\n  apples, oranges, and mango fruits. Given the string that represents the total number of\n  the oranges and apples and an integer that represent the total number of the fruits\n  in the basket return the number of the mango fruits in the basket.\n  for examble:\n  fruitDistribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n  fruitDistribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n  fruitDistribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n  fruitDistribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n  */\nconst fruitDistribution = (s, n) => {\n  let total = 0;\n  let fruits = [];\n  let apples = 0, oranges = 0;\n  let mango = 0;\n  let fruitCount = 0;\n  let fruitArray = [];\n  let fruitArray2 = [];\n  let fruitArray3 = [];\n  let fruitArray4 = [];\n  let fruitArray5 = [];\n  let fruitArray6 = [];\n  let fruitArray7 = [];\n  let fruitArray8 = [];\n  let fruitArray9 = [];\n  let fruitArray10 = [];\n  let fruitArray11 = [];\n  let fruitArray12 = [];\n  let fruitArray13 = [];\n  let fruitArray14 = [];\n  let fruitArray15 = [];\n  let fruitArray16 = [];\n  let fruitArray17 = [];\n  let fruitArray18 = [];\n  let fruitArray19 = [];\n  let fruitArray20 = [];\n  let fruitArray21 = [];\n  let fruitArray22 = [];\n  let fruitArray23 = [];\n  let fruitArray24 = [];\n  let fruitArray25 = [];\n  let fruitArray26 = [];\n  let fruitArray27 = [];\n  let fruitArray28 = [];\n  let fruitArray29 = [];\n  let fruitArray30 = [];\n  let fruitArray31 = [];\n  let fruitArray32 = [];\n  let fruitArray33 = [];\n  let fruitArray34 = [];\n  let fruitArray35 = [];\n  let fruitArray36 = [];\n  let fruitArray37 = [];\n  let fruitArray38 = [];\n  let fruitArray39 = [];\n  let fruitArray40 = [];\n  let fruitArray41 = [];\n  let fruitArray42 = [];\n  let fruitArray43 = [];\n  let fruitArray44 = [];\n  let fruitArray45 = [];\n  let fruitArray46 = [];\n  let fruitArray47 = [];\n  let fruitArray48 = [];\n  let fruitArray49 = [];\n  let fruitArray50 = [];\n  let fruitArray51 = [];\n  let fruitArray52 = [];\n  let fruitArray53 = [];\n  let fruitArray54 = [];\n  let fruitArray55 = [];\n  let fruitArray56 = [];\n  let fruitArray57 = [];\n  let fruitArray58 = [];\n  let fruitArray59 = [];\n  let fruitArray60 = [];\n  let fruitArray61 = [];\n  let fruitArray62 = [];\n  let fruitArray63 = [];\n  let fruitArray64 = [];\n  let fruitArray65 = [];\n  let fruitArray66 = [];\n  let fruitArray67 = [];\n  let fruitArray68 = [];\n  let fruitArray69 = [];\n  let fruitArray70 = [];\n  let fruitArray71 = [];\n  let fruitArray72 = [];\n  let fruitArray73 = [];\n  let fruitArray74 = [];\n  let fruitArray75 = [];\n  let fruitArray76 = [];\n  let fruitArray77 = [];\n  let fruitArray78 = [];\n  let fruitArray79 = [];\n  let fruitArray80 = [];\n  let fruitArray81 = [];\n  let fruitArray82 = [];\n  let fruitArray83 = [];\n  let fruitArray84 = [];\n  let fruitArray85 = [];\n  let fruitArray86 = [];\n  let fruitArray87 = [];\n  let fruitArray88 = [];\n  let fruitArray89 = [];\n  let fruitArray90 = [];\n  let fruitArray91 = [];\n  let fruitArray92 = [];\n  let fruitArray93 = [];\n  let fruitArray94 = [];\n  let fruitArray95 = [];\n  let fruitArray96 = [];\n  let fruitArray97 = [];\n  let fruitArray98 = [];\n  let fruitArray99 = [];\n  let fruitArray100 = [];\n  let fruitArray101 = [];\n  let fruitArray102 = [];\n  let fruitArray103 = [];\n  let fruitArray104 = [];\n  let fruitArray105 = [];\n  let fruitArray106 = [];\n  let fruitArray107 = [];\n  let fruitArray108 = [];\n  let fruitArray109 = [];\n  let fruitArray110 = [];\n  let fruitArray111 = [];\n  let fruitArray112 = [];\n  let fruitArray113 = [];\n  let fruitArray114 = [];\n  let fruitArray115 = [];\n  let fruitArray116 = [];\n  let fruitArray117 = [];\n  let fruitArray118 = [];\n  let fruitArray119 = [];\n  let fruitArray120 = [];\n  let fruitArray121 = [];\n  let fruitArray122 = [];\n  let fruitArray123 = [];\n  let fruitArray124 = [];\n  let fruitArray125 = [];\n  let fruitArray126 = [];\n  let fruitArray127 = [];\n  let fruitArray128 = [];\n  let fruitArray129 = [];\n  let fruitArray130 = [];\n  let fruitArray131 = [];\n  let fruitArray132 = [];\n  let fruitArray133 = [];\n  let fruitArray134 = [];\n  let fruitArray135 = [];\n  let fruitArray136 = [];\n  let fruitArray137 = [];\n  let fruitArray138 = [];\n  let fruitArray139 = [];\n  let fruitArray140 = [];\n  let fruitArray141 = [];\n  let fruitArray142 = [];\n  let fruitArray143 = [];\n  let fruitArray144 = [];\n  let fruitArray145 = [];\n  let fruitArray146 = [];\n  let fruitArray147 = [];\n  let fruitArray148 = [];\n  let fruitArray149 = [];\n  let fruitArray150 = [];\n  let fruitArray151 = [];\n  let fruitArray152 = [];\n  let fruitArray153 = [];\n  let fruitArray154 = [];\n  let fruitArray155 = [];\n  let fruitArray156 = [];\n  let fruitArray157 = [];\n  let fruitArray158 = [];\n  let fruitArray159 = [];\n  let fruitArray160 = [];\n  let fruitArray161 = [];\n  let fruitArray162 = [];\n  let fruitArray163 = [];\n  let fruitArray164 = [];\n  let fruitArray165 = [];\n  let fruitArray166 = [];\n  let fruitArray167 = [];\n  let fruitArray168 = [];\n  let fruitArray169 = [];\n  let fruitArray170 = [];\n  let fruitArray171 = [];\n  let fruitArray172 = [];\n  let fruitArray173 = [];\n  let fruitArray174 = [];\n  let fruitArray175 = [];\n  let fruitArray176 = [];\n  let fruitArray177 = [];\n  let fruitArray178 = [];\n  let fruitArray179 = [];\n  let fruitArray180 = [];\n  let fruitArray181 = [];\n  let fruitArray182 = [];\n  let fruitArray183 = [];\n  let fruitArray184 = [];\n  let fruitArray185 = [];\n  let fruitArray186 = [];\n  let fruitArray187 = [];\n  let fruitArray188 = [];\n  let fruitArray189 = [];\n  let fruitArray190 = [];\n  let fruitArray191 = [];\n  let fruitArray192 = [];\n  let fruitArray193 = [];\n  let fruitArray194 = [];\n  let fruitArray195 = [];\n  let fruitArray196 = [];\n  let fruitArray197 = [];\n  let fruitArray198 = [];\n  let fruitArray199 = [];\n  let fruitArray200 = [];\n  let fruitArray201 = [];\n  let fruitArray202 = [];\n  let fruitArray203 = [];\n  let fruitArray204 = [];\n  let fruitArray205 = [];\n  let fruitArray206 = [];\n  let fruitArray207 = [];\n  let fruitArray208 = [];\n  let fruitArray209 = [];\n  let fruitArray210 = [];\n  let fruitArray211 = [];\n  let fruitArray212 = [];\n  let fruitArray213 = [];\n  let fruitArray214 = [];", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/68", "prompt": "/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to pluck one of the nodes and return it.\n  The plucked node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The plucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n", "canonical_solution": "  if (arr.length == 0) return [];\n  var evens = arr.filter(x => x % 2 == 0);\n  if (evens.length == 0) return [];\n  return [Math.min(...evens), arr.indexOf(Math.min(...evens))];\n}\n\n", "test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n  console.assert(\n    JSON.stringify(pluck([1, 2, 3, 0, 5, 3])) === JSON.stringify([0, 3])\n  )\n  console.assert(\n    JSON.stringify(pluck([5, 4, 8, 4, 8])) === JSON.stringify([4, 1])\n  )\n  console.assert(JSON.stringify(pluck([7, 6, 7, 1])) === JSON.stringify([6, 1]))\n  console.assert(JSON.stringify(pluck([7, 9, 7, 1])) === JSON.stringify([]))\n}\n\ntestPluck()\n", "declaration": "\nconst pluck = (arr) => {\n", "example_test": "const testPluck = () => {\n  console.assert(JSON.stringify(pluck([4, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([1, 2, 3])) === JSON.stringify([2, 1]))\n  console.assert(JSON.stringify(pluck([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(pluck([5, 0, 3, 0, 4, 2])) === JSON.stringify([0, 1])\n  )\n}\ntestPluck()\n", "entry_point": "pluck", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*\n  \"Given an array representing a branch of a tree that has non-negative integer nodes\n  your task is to pluck one of the nodes and return it.\n  The plucked node should be the node with the smallest even value.\n  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n  The plucked node should be returned in a list, [ smalest_value, its index ],\n  If there are no even values or the given array is empty, return [].\n\n  Example 1:\n      Input: [4,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 2:\n      Input: [1,2,3]\n      Output: [2, 1]\n      Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n  Example 3:\n      Input: []\n      Output: []\n\n  Example 4:\n      Input: [5, 0, 3, 0, 4, 2]\n      Output: [0, 1]\n      Explanation: 0 is the smallest value, but  there are two zeros,\n                   so we will choose the first zero, which has the smallest index.\n\n  Constraints:\n      * 1 <= nodes.length <= 10000\n      * 0 <= node.value\n  */\nconst pluck = (arr) => {\n  const len = arr.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let smallestEven = 0;\n  let smallestIndex = 0;\n  while (i < len) {\n    if (arr[i] % 2 === 0) {\n      smallestEven = arr[i];\n      smallestIndex = i;\n    }\n    i++;\n  }\n  while (j < len) {\n    if (arr[j] % 2 === 0) {\n      smallestEven = arr[j];\n      smallestIndex = j;\n    }\n    j++;\n  }\n  while (k < len) {\n    if (arr[k] % 2 === 0) {\n      smallestEven = arr[k];\n      smallestIndex = k;\n    }\n    k++;\n  }\n  return [smallestEven, smallestIndex];\n};\n\n// Given an array representing a tree with non-negative integer nodes,\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest odd value.\n// If multiple nodes with the same smallest odd value are found return the node that has smallest index.\n\n// The plucked node should be returned in a list, [ odd_value, its index ],\n// If there are no odd values or the given array is empty, return [].\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest odd value, and 2 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest odd value, and 2 has the smallest index.\n\n// Example 3:\n//     Input: []\n//     Output: []\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the smallest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the smallest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n */\nconst pluckOdd = (arr) => {\n  const len = arr.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let odd = 0;\n  let smallestOdd = 0;\n  let smallestIndex = 0;\n  while (i < len) {\n    if (arr[i] % 2 === 1) {\n      odd = arr[i];\n      smallestOdd = odd;\n      smallestIndex = i;\n    }\n    i++;\n  }\n  while (j < len) {\n    if (arr[j] % 2 === 1) {\n      odd = arr[j];\n      smallestOdd = odd;\n      smallestIndex = j;\n    }\n    j++;\n  }\n  while (k < len) {\n    if (arr[k] % 2 === 1) {\n      odd = arr[k];\n      smallestOdd = odd;\n      smallestIndex = k;\n    }\n    k++;\n  }\n  return [smallestOdd, smallestIndex];\n};\n\n// Given an array representing a tree with non-negative integer nodes,\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest positive value.\n// If multiple nodes with the same smallest positive value are found return the node that has smallest index.\n\n// The plucked node should be returned in a list, [ positive_value, its index ],\n// If there are no positive values or the given array is empty, return [].\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest positive value, and 2 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest positive value, and 2 has the smallest index.\n\n// Example 3:\n//     Input: []\n//     Output: []\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the smallest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the smallest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n */\nconst pluckPositive = (arr) => {\n  const len = arr.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let positive = 0;\n  let smallestPositive = 0;\n  let smallestIndex = 0;\n  while (i < len) {\n    if (arr[i] > 0) {\n      positive = arr[i];\n      smallestPositive = positive;\n      smallestIndex = i;\n    }\n    i++;\n  }\n  while (j < len) {\n    if (arr[j] > 0) {\n      positive = arr[j];\n      smallestPositive = positive;\n      smallestIndex = j;\n    }\n    j++;\n  }\n  while (k < len) {\n    if (arr[k] > 0) {\n      positive = arr[k];\n      smallestPositive = positive;\n      smallestIndex = k;\n    }\n    k++;\n  }\n  return [smallestPositive, smallestIndex];\n};\n\n// Given an array representing a tree with non-negative integer nodes,\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest negative value.\n// If multiple nodes with the same smallest negative value are found return the node that has smallest index.\n\n// The plucked node should be returned in a list, [ negative_value, its index ],\n// If there are no negative values or the given array is empty, return [].\n\n// Example 1:\n//     Input: [4,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest negative value, and 2 has the smallest index.\n\n// Example 2:\n//     Input: [1,2,3]\n//     Output: [2, 1]\n//     Explanation: 2 has the smallest negative value, and 2 has the smallest index.\n\n// Example 3:\n//     Input: []\n//     Output: []\n\n// Example 4:\n//     Input: [5, 0, 3, 0, 4, 2]\n//     Output: [0, 1]\n//     Explanation: 0 is the smallest value, but  there are two zeros,\n//                   so we will choose the first zero, which has the smallest index.\n\n// Constraints:\n//     1 <= nodes.length <= 10000\n//     0 <= node.value\n */\nconst pluckNegative = (arr) => {\n  const len = arr.length;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  let negative = 0;\n  let smallestNegative = 0;\n  let smallestIndex = 0;\n  while (i < len) {\n    if (arr[i] < 0) {\n      negative = arr[i];\n      smallestNegative = negative;\n      smallestIndex = i;\n    }\n    i++;\n  }\n  while (j < len) {\n    if (arr[j] < 0) {\n      negative = arr[j];\n      smallestNegative = negative;\n      smallestIndex = j;\n    }\n    j++;\n  }\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/69", "prompt": "/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n", "canonical_solution": "  var frq = new Array(Math.max(...lst) + 1).fill(0);\n  for (const i of lst)\n    frq[i] += 1;\n  var ans = -1;\n  for (let i = 1; i < frq.length; i++)\n    if (frq[i] >= i)\n      ans = i;\n  return ans;\n}\n\n", "test": "const testSearch = () => {\n  console.assert(search([5, 5, 5, 5, 1]) === 1)\n  console.assert(search([4, 1, 4, 1, 4, 4]) === 4)\n  console.assert(search([3, 3]) === -1)\n  console.assert(search([8, 8, 8, 8, 8, 8, 8, 8]) === 8)\n  console.assert(search([2, 3, 3, 2, 2]) === 2)\n  console.assert(\n    search([\n      2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1,\n    ]) === 1\n  )\n  console.assert(search([3, 2, 8, 2]) === 2)\n  console.assert(search([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) === 1)\n  console.assert(search([8, 8, 3, 6, 5, 6, 4]) === -1)\n  console.assert(\n    search([\n      6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5,\n      7, 9,\n    ]) === 1\n  )\n  console.assert(search([1, 9, 10, 1, 3]) === 1)\n  console.assert(\n    search([\n      6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3,\n      10,\n    ]) === 5\n  )\n  console.assert(search([1]) === 1)\n  console.assert(\n    search([\n      8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5,\n    ]) === 4\n  )\n  console.assert(\n    search([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) === 2\n  )\n  console.assert(search([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) === 1)\n  console.assert(\n    search([\n      9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7,\n      10, 2, 8, 10, 9, 4,\n    ]) === 4\n  )\n  console.assert(\n    search([\n      2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7,\n    ]) === 4\n  )\n  console.assert(\n    search([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) === 2\n  )\n  console.assert(\n    search([\n      5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8,\n    ]) === -1\n  )\n  console.assert(search([10]) === -1)\n  console.assert(search([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) === 2)\n  console.assert(search([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) === 1)\n  console.assert(\n    search([\n      7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6,\n    ]) === 1\n  )\n  console.assert(search([3, 10, 10, 9, 2]) === -1)\n}\n\ntestSearch()\n", "declaration": "\nconst search = (lst) => {\n", "example_test": "const testSearch = () => {\n  console.assert(search([4, 1, 2, 2, 3, 1]) === 2)\n  console.assert(search([1, 2, 2, 3, 3, 3, 4, 4, 4]) === 3)\n  console.assert(search([5, 5, 4, 4, 4]) === -1)\n}\ntestSearch()\n", "entry_point": "search", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 2\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest integer number, which is greater than zero and has a frequency greater than or equal to the value of the integer itself. Frequency of an integer is the number of times it appears in the list. If no such value exists, return -1.\n  Examples:\n      search([4, 1, 2, 2, 3, 1])) == 3\n      search([1, 2, 2, 3, 3, 3, 4, 4, 4])) == 3\n      search([5, 5, 4, 4, 4])) == -1\n  */\nconst search = (lst) => {\n  let max = 0;\n  let freq = 0;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n      freq = i;\n    }\n  }\n  return max;\n};\n\n/*\n  You get a non-empty list of positive integers. Returns the largest ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/7", "prompt": "/* Filter an input list of strings only for strings that contain a specific substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n", "canonical_solution": "  return strings.filter(x => x.indexOf(substring) != -1);\n}\n\n", "test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'john')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xxx'\n      )\n    ) === JSON.stringify(['xxx', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'],\n        'xx'\n      )\n    ) === JSON.stringify(['xxx', 'aaaxxy', 'xxxAAA', 'xxx'])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(['grunt', 'trumpet', 'prune', 'gruesome'], 'run')\n    ) === JSON.stringify(['grunt', 'prune'])\n  )\n}\n\ntestFilterBySubstring()\n", "declaration": "\nconst filterBySubstring = (strings, substring) => {\n", "example_test": "const testFilterBySubstring = () => {\n  console.assert(\n    JSON.stringify(filterBySubstring([], 'a')) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(\n      filterBySubstring(\n        ['abc', 'bacd', 'cde', 'array'], 'a'\n      )\n    ) === JSON.stringify(['abc', 'bacd', 'array'])\n  )\n}\ntestFilterBySubstring()\n", "entry_point": "filterBySubstring", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Filter an input list of strings only for strings that contain a specific substring\n  >>> filterBySubstring([], 'a')\n  []\n  >>> filterBySubstring(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'array']\n  */\nconst filterBySubstring = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) > -1);\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a substring\n  >>> filterFirstOccurrence([], 'a')\n  []\n  >>> filterFirstOccurrence(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['abc', 'bacd', 'cde']\n  */\nconst filterFirstOccurrence = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for the last occurrence of a substring\n  >>> filterLastOccurrence([], 'a')\n  []\n  >>> filterLastOccurrence(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterLastOccurrence = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === string.length - substring.length);\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a substring\n  >>> filterFirstOccurrenceLast([], 'a')\n  []\n  >>> filterFirstOccurrenceLast(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterFirstOccurrenceLast = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === string.length - substring.length);\n};\n\n/**\n * Filter an input list of strings only for the last occurrence of a substring\n  >>> filterLastOccurrenceLast([], 'a')\n  []\n  >>> filterLastOccurrenceLast(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterLastOccurrenceLast = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === string.length - substring.length);\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a substring\n  >>> filterFirstOccurrenceLast([], 'a')\n  []\n  >>> filterFirstOccurrenceLast(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterFirstOccurrenceFirst = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for the last occurrence of a substring\n  >>> filterLastOccurrenceFirst([], 'a')\n  []\n  >>> filterLastOccurrenceFirst(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterLastOccurrenceFirst = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === string.length - substring.length);\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a substring\n  >>> filterFirstOccurrenceFirst([], 'a')\n  []\n  >>> filterFirstOccurrenceFirst(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterFirstOccurrenceLast = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for the last occurrence of a substring\n  >>> filterLastOccurrenceLast([], 'a')\n  []\n  >>> filterLastOccurrenceLast(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterLastOccurrenceLast = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === string.length - substring.length);\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a substring\n  >>> filterFirstOccurrenceLast([], 'a')\n  []\n  >>> filterFirstOccurrenceLast(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterFirstOccurrenceFirst = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for the last occurrence of a substring\n  >>> filterLastOccurrenceFirst([], 'a')\n  []\n  >>> filterLastOccurrenceFirst(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterLastOccurrenceFirst = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === string.length - substring.length);\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a substring\n  >>> filterFirstOccurrenceFirst([], 'a')\n  []\n  >>> filterFirstOccurrenceFirst(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterFirstOccurrenceLast = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for the last occurrence of a substring\n  >>> filterLastOccurrenceLast([], 'a')\n  []\n  >>> filterLastOccurrenceLast(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterLastOccurrenceLast = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === string.length - substring.length);\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a substring\n  >>> filterFirstOccurrenceFirst([], 'a')\n  []\n  >>> filterFirstOccurrenceFirst(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterFirstOccurrenceFirst = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for the last occurrence of a substring\n  >>> filterLastOccurrenceFirst([], 'a')\n  []\n  >>> filterLastOccurrenceFirst(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterLastOccurrenceFirst = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === string.length - substring.length);\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a substring\n  >>> filterFirstOccurrenceLast([], 'a')\n  []\n  >>> filterFirstOccurrenceLast(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterFirstOccurrenceFirst = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === 0);\n};\n\n/**\n * Filter an input list of strings only for the last occurrence of a substring\n  >>> filterLastOccurrenceFirst([], 'a')\n  []\n  >>> filterLastOccurrenceFirst(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterLastOccurrenceFirst = (strings, substring) => {\n  return strings.filter(string => string.indexOf(substring) === string.length - substring.length);\n};\n\n/**\n * Filter an input list of strings only for the first occurrence of a substring\n  >>> filterFirstOccurrenceFirst([], 'a')\n  []\n  >>> filterFirstOccurrenceFirst(['abc', 'bacd', 'cde', 'array'], 'a')\n  ['array', 'cde', 'bacd']\n  */\nconst filterFirstOccurrenceLast = (", "passed": 1, "run_status": 0, "passed_evalplus": 1, "run_status_evalplus": 0, "passed_he": 1, "run_status_he": 0, "passed_ep": 1, "run_status_ep": 0}
{"task_id": "JavaScript/70", "prompt": "/*\n  Strange sorting is when you start with the minimum, then with the maximum of the remaining integers, then with the minimum, and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n", "canonical_solution": "  var res = [], sw = true;\n  while (lst.length) {\n    res.push(sw ? Math.min(...lst) : Math.max(...lst));\n    lst.splice(lst.indexOf(res.at(-1)), 1);\n    sw = !sw;\n  }\n  return res;\n}\n\n", "test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9])) ===\n      JSON.stringify([5, 9, 6, 8, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5])) ===\n      JSON.stringify([1, 5, 2, 4, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 6, 7, 8, 9, 1])) ===\n      JSON.stringify([1, 9, 5, 8, 6, 7])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4, 5, 6, 7, 8])) ===\n      JSON.stringify([1, 8, 2, 7, 3, 6, 4, 5])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([0, 2, 2, 2, 5, 5, -5, -5])) ===\n      JSON.stringify([-5, 5, -5, 5, 0, 2, 2, 2])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([111111])) === JSON.stringify([111111])\n  )\n}\n\ntestStrangeSortList()\n", "declaration": "\nconst strangeSortList = (lst) => {\n", "example_test": "const testStrangeSortList = () => {\n  console.assert(\n    JSON.stringify(strangeSortList([1, 2, 3, 4])) ===\n      JSON.stringify([1, 4, 2, 3])\n  )\n  console.assert(\n    JSON.stringify(strangeSortList([5, 5, 5, 5])) ===\n      JSON.stringify([5, 5, 5, 5])\n  )\n  console.assert(JSON.stringify(strangeSortList([])) === JSON.stringify([]))\n}\ntestStrangeSortList()\n", "entry_point": "strangeSortList", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Strange sorting is when you start with the minimum, then with the maximum of the remaining integers, then with the minimum, and so on.\n\n  Examples:\n  strangeSortList([1, 2, 3, 4]) == [1, 4, 2, 3]\n  strangeSortList([5, 5, 5, 5]) == [5, 5, 5, 5]\n  strangeSortList([]) == []\n  */\nconst strangeSortList = (lst) => {\n  let min;\n  let max;\n  let minIndex;\n  let maxIndex;\n  let minValue;\n  let maxValue;\n\n  if (lst.length === 0) {\n    return lst;\n  }\n\n  min = lst[0];\n  max = lst[0];\n\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < min) {\n      min = lst[i];\n      minIndex = i;\n    }\n    if (lst[i] > max) {\n      max = lst[i];\n      maxIndex = i;\n    }\n  }\n\n  if (minIndex === maxIndex) {\n    return [min];\n  }\n\n  minValue = lst[minIndex];\n  maxValue = lst[maxIndex];\n\n  return [min, minValue, maxValue, maxIndex];\n};\n\n/*\n  Given a sorted array and a value, find the index of the first element in the array that is greater than the value.\n\n  Examples:\n  findGreaterThan([5, 2, 8, 3], 8) == 3\n  findGreaterThan([5, 2, 8, 3], 3) == 3\n  findGreaterThan([5, 2, 8, 3], 2) == 3\n  findGreaterThan([5, 2, 8, 3], 1) == 1\n  findGreaterThan([5, 2, 8, 3], 0) == 0\n  */\nconst findGreaterThan = (lst, value) => {\n  let minIndex;\n  let minValue;\n  let maxIndex;\n  let maxValue;\n\n  if (lst.length === 0) {\n    return -1;\n  }\n\n  minIndex = -1;\n  minValue = lst[0];\n  maxIndex = lst.length;\n\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < minValue) {\n      minValue = lst[i];\n      minIndex = i;\n    }\n    if (lst[i] > maxValue) {\n      maxValue = lst[i];\n      maxIndex = i;\n    }\n  }\n\n  if (minIndex === maxIndex) {\n    return minIndex;\n  }\n\n  return minIndex;\n};\n\n/*\n  Given a sorted array and a value, find the index of the first element in the array that is less than the value.\n\n  Examples:\n  findLessThan([5, 2, 8, 3], 8) == 3\n  findLessThan([5, 2, 8, 3], 3) == 3\n  findLessThan([5, 2, 8, 3], 2) == 3\n  findLessThan([5, 2, 8, 3], 1) == 1\n  findLessThan([5, 2, 8, 3], 0) == 0\n  */\nconst findLessThan = (lst, value) => {\n  let minIndex;\n  let minValue;\n  let maxIndex;\n  let maxValue;\n\n  if (lst.length === 0) {\n    return -1;\n  }\n\n  minIndex = -1;\n  minValue = lst[0];\n  maxIndex = lst.length;\n\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > minValue) {\n      minValue = lst[i];\n      minIndex = i;\n    }\n    if (lst[i] < maxValue) {\n      maxValue = lst[i];\n      maxIndex = i;\n    }\n  }\n\n  if (minIndex === maxIndex) {\n    return minIndex;\n  }\n\n  return minIndex;\n};\n\n/*\n  Given a sorted array and a value, find the index of the first element in the array that is equal to the value.\n\n  Examples:\n  findEqualTo([5, 2, 8, 3], 8) == 3\n  findEqualTo([5, 2, 8, 3], 3) == 3\n  findEqualTo([5, 2, 8, 3], 2) == 3\n  findEqualTo([5, 2, 8, 3], 1) == 1\n  findEqualTo([5, 2, 8, 3], 0) == 0\n  */\nconst findEqualTo = (lst, value) => {\n  let minIndex;\n  let minValue;\n  let maxIndex;\n  let maxValue;\n\n  if (lst.length === 0) {\n    return -1;\n  }\n\n  minIndex = -1;\n  minValue = lst[0];\n  maxIndex = lst.length;\n\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] === value) {\n      minValue = lst[i];\n      minIndex = i;\n    }\n    if (lst[i] > maxValue) {\n      maxValue = lst[i];\n      maxIndex = i;\n    }\n  }\n\n  if (minIndex === maxIndex) {\n    return minIndex;\n  }\n\n  return minIndex;\n};\n\n/*\n  Given a sorted array and a value, find the index of the first element in the array that is less than or equal to the value.\n\n  Examples:\n  findLessOrEqualTo([5, 2, 8, 3], 8) == 3\n  findLessOrEqualTo([5, 2, 8, 3], 3) == 3\n  findLessOrEqualTo([5, 2, 8, 3], 2) == 3\n  findLessOrEqualTo([5, 2, 8, 3], 1) == 1\n  findLessOrEqualTo([5, 2, 8, 3], 0) == 0\n  */\nconst findLessOrEqualTo = (lst, value) => {\n  let minIndex;\n  let minValue;\n  let maxIndex;\n  let maxValue;\n\n  if (lst.length === 0) {\n    return -1;\n  }\n\n  minIndex = -1;\n  minValue = lst[0];\n  maxIndex = lst.length;\n\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] <= value) {\n      minValue = lst[i];\n      minIndex = i;\n    }\n    if (lst[i] >= value) {\n      maxValue = lst[i];\n      maxIndex = i;\n    }\n  }\n\n  if (minIndex === maxIndex) {\n    return minIndex;\n  }\n\n  return minIndex;\n};\n\n/*\n  Given a sorted array and a value, find the index of the first element in the array that is greater than or equal to the value.\n\n  Examples:\n  findGreaterOrEqualTo([5, 2, 8, 3], 8) == 3\n  findGreaterOrEqualTo([5, 2, 8, 3], 3) == 3\n  findGreaterOrEqualTo([5, 2, 8, 3], 2) == 3\n  findGreaterOrEqualTo([5, 2, 8, 3], 1) == 1\n  findGreaterOrEqualTo([5, 2, 8, 3], 0) == 0\n  */\nconst findGreaterOrEqualTo = (lst, value) => {\n  let minIndex;\n  let minValue;\n  let maxIndex;\n  let maxValue;\n\n  if (lst.length === 0) {\n    return -1;\n  }\n\n  minIndex = -1;\n  minValue = lst[0];\n  maxIndex = lst.length;\n\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] >= value) {\n      minValue = lst[i];\n      minIndex = i;\n    }\n    if (lst[i] <= value) {\n      maxValue = lst[i];\n      maxIndex = i;\n    }\n  }\n\n  if (minIndex === maxIndex) {\n    return minIndex;\n  }\n\n  return minIndex;\n};\n\n/*\n  Given a sorted array and a value, find the index of the first element in the array that is equal to the value.\n\n  Examples:\n  findEqualOrEqualTo([5, 2, 8, 3], 8) == 3\n  findEqualOrEqualTo([5, 2, 8, 3], 3) == 3\n  findEqualOrEqualTo([5, 2, 8, 3], 2) == 3\n  findEqualOrEqualTo([5, 2, 8, 3], 1) == 1\n  findEqualOrEqualTo([5, 2, 8, 3], 0) == 0\n  */\nconst findEqualOrEqualTo = (lst, value) => {\n  let minIndex;\n  let minValue;\n  let maxIndex;\n  let maxValue;\n\n  if (lst.length === 0) {\n    return -1;\n  }\n\n  minIndex = -1;\n  minValue = lst[0];\n  maxIndex = lst.length;\n\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] === value) {\n      minValue = lst[i];\n      minIndex = i;\n    }\n    if (lst[i] >= value) {\n      maxValue = lst[i];\n      maxIndex = i;\n    }\n  }\n\n  if (minIndex === maxIndex) {\n    return minIndex;\n  }\n\n  return minIndex;\n};\n\n/*\n  Given a sorted array and a value, find the index of the first element in the array that is greater than the value.\n\n  Examples:\n  findGreaterThan", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/71", "prompt": "/*\n  Given the length of the three sides of a triangle. Return the area of the triangle rounded to 2 decimal points if the three sides form a valid triangle. Otherwise, return -1 Three sides a valid triangle if the sum of two sides is greater than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n", "canonical_solution": "  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  var s = (a + b + c) / 2;\n  var area = Math.pow(s * (s - a) * (s - b) * (s - c), 0.5);\n  area = area.toFixed(2);\n  return area;\n}\n\n", "test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n  console.assert(triangleArea(4, 8, 5) == 8.18)\n  console.assert(triangleArea(2, 2, 2) == 1.73)\n  console.assert(triangleArea(1, 2, 3) == -1)\n  console.assert(triangleArea(10, 5, 7) == 16.25)\n  console.assert(triangleArea(2, 6, 3) == -1)\n  console.assert(triangleArea(1, 1, 1) == 0.43)\n  console.assert(triangleArea(2, 2, 10) == -1)\n}\n\ntestTriangleArea()\n", "declaration": "\nconst triangleArea = (a, b, c) => {\n", "example_test": "const testTriangleArea = () => {\n  console.assert(triangleArea(3, 4, 5) == 6.0)\n  console.assert(triangleArea(1, 2, 10) == -1)\n}\ntestTriangleArea()\n", "entry_point": "triangleArea", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Given the length of the three sides of a triangle. Return the area of the triangle rounded to 2 decimal points if the three sides form a valid triangle. Otherwise, return -1 Three sides a valid triangle if the sum of two sides is greater than the third side.\n  Example:\n  triangleArea(3, 4, 5) == 6.00\n  triangleArea(1, 2, 10) == -1\n  */\nconst triangleArea = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n\n  if (side1 + side2 + side3 <= 0) {\n    return -1;\n  }\n\n  return side1 + side2 + side3;\n};\n\n/*\n  Given the length of the three sides of a rectangle. Return the area of the rectangle rounded to 2 decimal points if the three sides form a valid rectangle. Otherwise, return -1 Three sides a valid rectangle if the sum of two sides is greater than the third side.\n  Example:\n  rectangleArea(3, 4, 5) == 6.00\n  rectangleArea(1, 2, 10) == -1\n  */\nconst rectangleArea = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n\n  if (side1 + side2 + side3 <= 0) {\n    return -1;\n  }\n\n  return side1 + side2 + side3;\n};\n\n/*\n  Given the length of the three sides of a circle. Return the area of the circle rounded to 2 decimal points if the three sides form a valid circle. Otherwise, return -1 Three sides a valid circle if the sum of two sides is greater than the third side.\n  Example:\n  circleArea(3, 4, 5) == 6.00\n  circleArea(1, 2, 10) == -1\n  */\nconst circleArea = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n\n  if (side1 + side2 + side3 <= 0) {\n    return -1;\n  }\n\n  return side1 + side2 + side3;\n};\n\n/*\n  Given the length of the three sides of a square. Return the area of the square rounded to 2 decimal points if the three sides form a valid square. Otherwise, return -1 Three sides a valid square if the sum of two sides is greater than the third side.\n  Example:\n  squareArea(3, 4, 5) == 6.00\n  squareArea(1, 2, 10) == -1\n  */\nconst squareArea = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n\n  if (side1 + side2 + side3 <= 0) {\n    return -1;\n  }\n\n  return side1 + side2 + side3;\n};\n\n/*\n  Given the length of the three sides of a pentagon. Return the area of the pentagon rounded to 2 decimal points if the three sides form a valid pentagon. Otherwise, return -1 Three sides a valid pentagon if the sum of two sides is greater than the third side.\n  Example:\n  pentagonArea(3, 4, 5) == 6.00\n  pentagonArea(1, 2, 10) == -1\n  */\nconst pentagonArea = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n\n  if (side1 + side2 + side3 <= 0) {\n    return -1;\n  }\n\n  return side1 + side2 + side3;\n};\n\n/*\n  Given the length of the three sides of a hexagon. Return the area of the hexagon rounded to 2 decimal points if the three sides form a valid hexagon. Otherwise, return -1 Three sides a valid hexagon if the sum of two sides is greater than the third side.\n  Example:\n  hexagonArea(3, 4, 5) == 6.00\n  hexagonArea(1, 2, 10) == -1\n  */\nconst hexagonArea = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n\n  if (side1 + side2 + side3 <= 0) {\n    return -1;\n  }\n\n  return side1 + side2 + side3;\n};\n\n/*\n  Given the length of the three sides of a heptagon. Return the area of the heptagon rounded to 2 decimal points if the three sides form a valid heptagon. Otherwise, return -1 Three sides a valid heptagon if the sum of two sides is greater than the third side.\n  Example:\n  heptagonArea(3, 4, 5) == 6.00\n  heptagonArea(1, 2, 10) == -1\n  */\nconst heptagonArea = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n\n  if (side1 + side2 + side3 <= 0) {\n    return -1;\n  }\n\n  return side1 + side2 + side3;\n};\n\n/*\n  Given the length of the three sides of a decagon. Return the area of the decagon rounded to 2 decimal points if the three sides form a valid decagon. Otherwise, return -1 Three sides a valid decagon if the sum of two sides is greater than the third side.\n  Example:\n  decagonArea(3, 4, 5) == 6.00\n  decagonArea(1, 2, 10) == -1\n  */\nconst decagonArea = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n\n  if (side1 + side2 + side3 <= 0) {\n    return -1;\n  }\n\n  return side1 + side2 + side3;\n};\n\n/*\n  Given the length of the three sides of a trigon. Return the area of the trigon rounded to 2 decimal points if the three sides form a valid trigon. Otherwise, return -1 Three sides a valid trigon if the sum of two sides is greater than the third side.\n  Example:\n  trigonArea(3, 4, 5) == 6.00\n  trigonArea(1, 2, 10) == -1\n  */\nconst trigonArea = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n\n  if (side1 + side2 + side3 <= 0) {\n    return -1;\n  }\n\n  return side1 + side2 + side3;\n};\n\n/*\n  Given the length of the three sides of a hexagon. Return the area of the hexagon rounded to 2 decimal points if the three sides form a valid hexagon. Otherwise, return -1 Three sides a valid hexagon if the sum of two sides is greater than the third side.\n  Example:\n  hexagonArea(3, 4, 5) == 6.00\n  hexagonArea(1, 2, 10) == -1\n  */\nconst hexagonArea = (a, b, c) => {\n  const side1 = Math.sqrt(a * a + b * b);\n  const side2 = Math.sqrt(a * a + c * c);\n  const side3 = Math.sqrt(b * b + c * c);\n\n  if (side1 + side2 + side3 <= 0) {\n    return -1;\n  }\n\n  return side1 + side2 + side3;\n};\n\n/*\n  Given the length of the three sides of a heptagon. Return the area of the heptagon rounded to 2 decimal points if the three sides form a valid heptagon. Otherwise, return -1 Th", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/72", "prompt": "/*\n  Write a function that returns true when the object q flies, and false otherwise. If the object q flies when it is balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n", "canonical_solution": "  if (q.reduce(((prev, item) => prev + item), 0) > w)\n    return false;\n  var i = 0, j = q.length - 1;\n  while (i < j) {\n    if (q[i] != q[j])\n      return false;\n    i++;\n    j--;\n  }\n  return true;\n}\n\n", "test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n  console.assert(willItFly([1, 2, 3], 6) === false)\n  console.assert(willItFly([5], 5) === true)\n}\n\ntestWillItFly()\n", "declaration": "\nconst willItFly = (q, w) => {\n", "example_test": "const testWillItFly = () => {\n  console.assert(willItFly([3, 2, 3], 9) === true)\n  console.assert(willItFly([1, 2], 5) === false)\n  console.assert(willItFly([3], 5) === true)\n  console.assert(willItFly([3, 2, 3], 1) === false)\n}\ntestWillItFly()\n", "entry_point": "willItFly", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that returns true when the object q flies, and false otherwise. If the object q flies when it is balanced (it is a palindromic list) and the sum of its elements is less than or equal to the maximum possible weight w.\n\n  Example:\n  willItFly([1, 2], 5)  false\n  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n  willItFly([3, 2, 3], 1)  false\n  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n  willItFly([3, 2, 3], 9)  true\n  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n  willItFly([3], 5)  true\n  # 3 is less than the maximum possible weight, and it's balanced.\n  */\nconst willItFly = (q, w) => {\n  const maxWeight = Math.max(...q);\n  const sumWeight = q.reduce((a, b) => a + b);\n  return sumWeight <= maxWeight && sumWeight % w === 0;\n};\n\nmodule.exports = willItFly;\n\n},{}],9:[function(require,module,exports){\n/**\n * A function that takes an array of numbers and a weight and returns true if the array is balanced and false otherwise.\n *\n * Example:\n * balance([3, 1, 2, 1], 5)  true\n * balance([3, 2, 1], 1)  false\n * balance([3, 2, 1], 9)  false\n * balance([3, 2, 1], 5)  false\n * balance([3, 2, 1], 1)  false\n * balance([3, 2, 1], 9)  false\n */\nconst balance = (arr, w) => {\n  const maxWeight = Math.max(...arr);\n  const sumWeight = arr.reduce((a, b) => a + b);\n  return sumWeight <= maxWeight && sumWeight % w === 0;\n};\n\nmodule.exports = balance;\n\n},{}],10:[function(require,module,exports){\n/**\n * A function that takes an array of numbers and a weight and returns true if the array is balanced and false otherwise.\n *\n * Example:\n * balance([3, 1, 2, 1], 5)  true\n * balance([3, 2, 1], 1)  false\n * balance([3, 2, 1], 9)  false\n * balance([3, 2, 1], 5)  false\n * balance([3, 2, 1], 1)  false\n * balance([3, 2, 1], 9)  false\n */\nconst balance = (arr, w) => {\n  const maxWeight = Math.max(...arr);\n  const sumWeight = arr.reduce((a, b) => a + b);\n  return sumWeight <= maxWeight && sumWeight % w === 0;\n};\n\nmodule.exports = balance;\n\n},{}],11:[function(require,module,exports){\n/**\n * A function that takes an array of numbers and a weight and returns true if the array is balanced and false otherwise.\n *\n * Example:\n * balance([3, 1, 2, 1], 5)  true\n * balance([3, 2, 1], 1)  false\n * balance([3, 2, 1], 9)  false\n * balance([3, 2, 1], 5)  false\n * balance([3, 2, 1], 1)  false\n * balance([3, 2, 1], 9)  false\n */\nconst balance = (arr, w) => {\n  const maxWeight = Math.max(...arr);\n  const sumWeight = arr.reduce((a, b) => a + b);\n  return sumWeight <= maxWeight && sumWeight % w === 0;\n};\n\nmodule.exports = balance;\n\n},{}],12:[function(require,module,exports){\n/**\n * A function that takes an array of numbers and a weight and returns true if the array is balanced and false otherwise.\n *\n * Example:\n * balance([3, 1, 2, 1], 5)  true\n * balance([3, 2, 1], 1)  false\n * balance([3, 2, 1], 9)  false\n * balance([3, 2, 1], 5)  false\n * balance([3, 2, 1], 1)  false\n * balance([3, 2, 1], 9)  false\n */\nconst balance = (arr, w) => {\n  const maxWeight = Math.max(...arr);\n  const sumWeight = arr.reduce((a, b) => a + b);\n  return sumWeight <= maxWeight && sumWeight % w === 0;\n};\n\nmodule.exports = balance;\n\n},{}],13:[function(require,module,exports){\n/**\n * A function that takes an array of numbers and a weight and returns true if the array is balanced and false otherwise.\n *\n * Example:\n * balance([3, 1, 2, 1], 5)  true\n * balance([3, 2, 1], 1)  false\n * balance([3, 2, 1], 9)  false\n * balance([3, 2, 1], 5)  false\n * balance([3, 2, 1], 1)  false\n * balance([3, 2, 1], 9)  false\n */\nconst balance = (arr, w) => {\n  const maxWeight = Math.max(...arr);\n  const sumWeight = arr.reduce((a, b) => a + b);\n  return sumWeight <= maxWeight && sumWeight % w === 0;\n};\n\nmodule.exports = balance;\n\n},{}],14:[function(require,module,exports){\n/**\n * A function that takes an array of numbers and a weight and returns true if the array is balanced and false otherwise.\n *\n * Example:\n * balance([3, 1, 2, 1], 5)  true\n * balance([3, 2, 1], 1)  false\n * balance([3, 2, 1], 9)  false\n * balance([3, 2, 1], 5)  false\n * balance([3, 2, 1], 1)  false\n * balance([3, 2, 1], 9)  false\n */\nconst balance = (arr, w) => {\n  const maxWeight = Math.max(...arr);\n  const sumWeight = arr.reduce((a, b) => a + b);\n  return sumWeight <= maxWeight && sumWeight % w === 0;\n};\n\nmodule.exports = balance;\n\n},{}],15:[function(require,module,exports){\n/**\n * A function that takes an array of numbers and a weight and returns true if the array is balanced and false otherwise.\n *\n * Example:\n * balance([3, 1, 2, 1], 5)  true\n * balance([3, 2, 1], 1)  false\n * balance([3, 2, 1], 9)  false\n * balance([3, 2, 1], 5)  false\n * balance([3, 2, 1], 1)  false\n * balance([3, 2, 1], 9)  false\n */\nconst balance = (arr, w) => {\n  const maxWeight = Math.max(...arr);\n  const sumWeight = arr.reduce((a, b) => a + b);\n  return sumWeight <= maxWeight && sumWeight % w === 0;\n};\n\nmodule.exports = balance;\n\n},{}],16:[function(require,module,exports){\n/**\n * A function that takes an array of numbers and a weight and returns true if the array is balanced and false otherwise.\n *\n * Example:\n * balance([3, 1, 2, 1], 5)  true\n * balance([3, 2, 1], 1)  false\n * balance([3, 2, 1], 9)  false\n * balance([3, 2, 1], 5)  false\n * balance([3, 2, 1], 1)  false\n * balance([3, 2, 1], 9)  false\n */\nconst balance = (arr, w) => {\n  const maxWeight = Math.max(...arr);\n  const sumWeight = arr.reduce((a, b) => a + b);\n  return sumWeight <= maxWeight && sumWeight % w === 0;\n};\n\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/73", "prompt": "/*\n  A palindromic array is an array that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n", "canonical_solution": "  var ans = 0;\n  for (let i = 0; i < Math.floor(arr.length / 2); i++)\n    if (arr[i] != arr.at(-i - 1))\n      ans++;\n  return ans;\n}\n\n", "test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 4, 2]) === 1)\n  console.assert(smallestChange([1, 4, 4, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n  console.assert(smallestChange([1]) === 0)\n  console.assert(smallestChange([0, 1]) === 1)\n}\n\ntestSmallestChange()\n", "declaration": "\nconst smallestChange = (arr) => {\n", "example_test": "const testSmallestChange = () => {\n  console.assert(smallestChange([1, 2, 3, 5, 4, 7, 9, 6]) === 4)\n  console.assert(smallestChange([1, 2, 3, 4, 3, 2, 2]) === 1)\n  console.assert(smallestChange([1, 2, 3, 2, 1]) === 0)\n  console.assert(smallestChange([3, 1, 1, 3]) === 0)\n}\ntestSmallestChange()\n", "entry_point": "smallestChange", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  A palindromic array is an array that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange([1,2,3,5,4,7,9,6]) == 4\n  smallestChange([1, 2, 3, 4, 3, 2, 2]) == 1\n  smallestChange([1, 2, 3, 2, 1]) == 0\n  */\nconst smallestChange = (arr) => {\n  let min;\n  let max = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n    }\n    if (arr[i] < min) {\n      min = arr[i];\n    }\n  }\n  return min > max? min : max;\n};\n\n/*\n  A palindromic number is a number that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange(123) == 123\n  smallestChange(123) == 123\n  smallestChange(123) == 123\n  smallestChange(123) == 123\n  */\nconst smallestChange = (num) => {\n  let min;\n  let max = num;\n  for (let i = 1; i < num.length; i++) {\n    if (num[i] > max) {\n      max = num[i];\n    }\n    if (num[i] < min) {\n      min = num[i];\n    }\n  }\n  return min > max? min : max;\n};\n\n/*\n  A palindromic string is a string that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange(\"abc\") == 3\n  smallestChange(\"abc\") == 3\n  smallestChange(\"abc\") == 3\n  smallestChange(\"abc\") == 3\n  */\nconst smallestChange = (str) => {\n  let min;\n  let max = str.length;\n  for (let i = 1; i < str.length; i++) {\n    if (str[i] > max) {\n      max = str[i];\n    }\n    if (str[i] < min) {\n      min = str[i];\n    }\n  }\n  return min > max? min : max;\n};\n\n/*\n  A palindromic array is a string that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange([1,2,3,4,5,6,7]) == 6\n  smallestChange([1,2,3,4,5,6,7]) == 6\n  smallestChange([1,2,3,4,5,6,7]) == 6\n  smallestChange([1,2,3,4,5,6,7]) == 6\n  */\nconst smallestChange = (arr) => {\n  let min;\n  let max = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n    }\n    if (arr[i] < min) {\n      min = arr[i];\n    }\n  }\n  return min > max? min : max;\n};\n\n/*\n  A palindromic number is a number that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange(123) == 123\n  smallestChange(123) == 123\n  smallestChange(123) == 123\n  smallestChange(123) == 123\n  */\nconst smallestChange = (num) => {\n  let min;\n  let max = num;\n  for (let i = 1; i < num.length; i++) {\n    if (num[i] > max) {\n      max = num[i];\n    }\n    if (num[i] < min) {\n      min = num[i];\n    }\n  }\n  return min > max? min : max;\n};\n\n/*\n  A palindromic string is a string that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange(\"abc\") == 3\n  smallestChange(\"abc\") == 3\n  smallestChange(\"abc\") == 3\n  smallestChange(\"abc\") == 3\n  */\nconst smallestChange = (str) => {\n  let min;\n  let max = str.length;\n  for (let i = 1; i < str.length; i++) {\n    if (str[i] > max) {\n      max = str[i];\n    }\n    if (str[i] < min) {\n      min = str[i];\n    }\n  }\n  return min > max? min : max;\n};\n\n/*\n  A palindromic array is a string that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange([1,2,3,4,5,6,7]) == 6\n  smallestChange([1,2,3,4,5,6,7]) == 6\n  smallestChange([1,2,3,4,5,6,7]) == 6\n  smallestChange([1,2,3,4,5,6,7]) == 6\n  */\nconst smallestChange = (arr) => {\n  let min;\n  let max = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n    }\n    if (arr[i] < min) {\n      min = arr[i];\n    }\n  }\n  return min > max? min : max;\n};\n\n/*\n  A palindromic number is a number that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange(123) == 123\n  smallestChange(123) == 123\n  smallestChange(123) == 123\n  smallestChange(123) == 123\n  */\nconst smallestChange = (num) => {\n  let min;\n  let max = num;\n  for (let i = 1; i < num.length; i++) {\n    if (num[i] > max) {\n      max = num[i];\n    }\n    if (num[i] < min) {\n      min = num[i];\n    }\n  }\n  return min > max? min : max;\n};\n\n/*\n  A palindromic string is a string that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange(\"abc\") == 3\n  smallestChange(\"abc\") == 3\n  smallestChange(\"abc\") == 3\n  smallestChange(\"abc\") == 3\n  */\nconst smallestChange = (str) => {\n  let min;\n  let max = str.length;\n  for (let i = 1; i < str.length; i++) {\n    if (str[i] > max) {\n      max = str[i];\n    }\n    if (str[i] < min) {\n      min = str[i];\n    }\n  }\n  return min > max? min : max;\n};\n\n/*\n  A palindromic array is a string that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange([1,2,3,4,5,6,7]) == 6\n  smallestChange([1,2,3,4,5,6,7]) == 6\n  smallestChange([1,2,3,4,5,6,7]) == 6\n  smallestChange([1,2,3,4,5,6,7]) == 6\n  */\nconst smallestChange = (arr) => {\n  let min;\n  let max = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n    }\n    if (arr[i] < min) {\n      min = arr[i];\n    }\n  }\n  return min > max? min : max;\n};\n\n/*\n  A palindromic number is a number that is read forward and backward. In a change, you can convert one element to another element.\n\n  For example:\n  smallestChange(123) == 123\n  smallestChange(123) == 123\n  smallestChange(123) == 123\n  smallestChange(123) == 123\n  */\nconst smallestChange = (num) => {\n  let min;\n  let max = num;\n  for (let i = 1; i < num.length; i++) {\n    if (num[i] > max) {\n      max = num[i];\n    }\n    if (num[i] < min) {\n      min = num[i];\n    }\n  }\n  return min > max? min ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/74", "prompt": "/*\n  Write a function that accepts two lists of strings and returns the list that is the total number of characters in all strings of the list less than the other list. If both lists have the same number of characters, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n", "canonical_solution": "  var l1 = lst1.reduce(((prev, item) => prev + item.length), 0);\n  var l2 = lst2.reduce(((prev, item) => prev + item.length), 0);\n  if (l1 <= l2)\n    return lst1;\n  else\n    return lst2;\n}\n\n", "test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hi', 'hi'])) ===\n      JSON.stringify(['hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hii'])) ===\n      JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch([], ['this'])) === JSON.stringify([])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['this'], [])) === JSON.stringify([])\n  )\n}\n\ntestTotalMatch()\n", "declaration": "\nconst totalMatch = (lst1, lst2) => {\n", "example_test": "const testTotalMatch = () => {\n  console.assert(JSON.stringify(totalMatch([], [])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(\n      totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])\n    ) === JSON.stringify(['hi', 'admin'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['4'], ['1', '2', '3', '4', '5'])) ===\n      JSON.stringify(['4'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'Hi'])) ===\n      JSON.stringify(['hI', 'Hi'])\n  )\n  console.assert(\n    JSON.stringify(totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])) ===\n      JSON.stringify(['hI', 'hi', 'hi'])\n  )\n}\ntestTotalMatch()\n", "entry_point": "totalMatch", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that accepts two lists of strings and returns the list that is the total number of characters in all strings of the list less than the other list. If both lists have the same number of characters, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let total = 0;\n  lst1.forEach(item => {\n    if (lst2.includes(item)) {\n      total += 1;\n    }\n  });\n  return total;\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that is the total number of characters in all strings of the list greater than the other list. If both lists have the same number of characters, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let total = 0;\n  lst2.forEach(item => {\n    if (lst1.includes(item)) {\n      total += 1;\n    }\n  });\n  return total;\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that is the total number of characters in all strings of the list equal to the other list. If both lists have the same number of characters, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let total = 0;\n  lst1.forEach(item => {\n    if (item === lst2) {\n      total += 1;\n    }\n  });\n  return total;\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that is the total number of characters in all strings of the list not equal to the other list. If both lists have the same number of characters, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let total = 0;\n  lst2.forEach(item => {\n    if (item!== lst1) {\n      total += 1;\n    }\n  });\n  return total;\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that is the total number of characters in all strings of the list in the opposite order. If both lists have the same number of characters, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let total = 0;\n  lst1.forEach(item => {\n    if (item < lst2) {\n      total += 1;\n    }\n  });\n  return total;\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that is the total number of characters in all strings of the list in the opposite order. If both lists have the same number of characters, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let total = 0;\n  lst2.forEach(item => {\n    if (item > lst1) {\n      total += 1;\n    }\n  });\n  return total;\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that is the total number of characters in all strings of the list in the opposite order. If both lists have the same number of characters, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let total = 0;\n  lst1.forEach(item => {\n    if (item < lst2) {\n      total += 1;\n    }\n  });\n  return total;\n};\n\n/*\n  Write a function that accepts two lists of strings and returns the list that is the total number of characters in all strings of the list in the opposite order. If both lists have the same number of characters, return the first list.\n\n  Examples\n  totalMatch([], [])  []\n  totalMatch(['hi', 'admin'], ['hI', 'Hi'])  ['hI', 'Hi']\n  totalMatch(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'])  ['hi', 'admin']\n  totalMatch(['hi', 'admin'], ['hI', 'hi', 'hi'])  ['hI', 'hi', 'hi']\n  totalMatch(['4'], ['1', '2', '3', '4', '5'])  ['4']\n  */\nconst totalMatch = (lst1, lst2) => {\n  let total = 0;\n  lst2.forEach(", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/75", "prompt": "/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n", "canonical_solution": "  var isPrime = function (n) {\n    for (let j = 2; j < n; j++)\n      if (n % j == 0)\n        return false;\n    return true;\n  }\n\n  for (let i = 2; i < 101; i++) {\n    if (!isPrime(i)) continue;\n    for (let j = 2; j < 101; j++) {\n      if (!isPrime(j)) continue;\n      for (let k = 2; k < 101; k++) {\n        if (!isPrime(k)) continue;\n        if (i*j*k == a)\n          return true;\n      }\n    }\n  }\n  return false;\n}\n\n", "test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(5) === false)\n  console.assert(isMultiplyPrime(30) === true)\n  console.assert(isMultiplyPrime(8) === true)\n  console.assert(isMultiplyPrime(10) === false)\n  console.assert(isMultiplyPrime(125) === true)\n  console.assert(isMultiplyPrime(3 * 5 * 7) === true)\n  console.assert(isMultiplyPrime(3 * 6 * 7) === false)\n  console.assert(isMultiplyPrime(9 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 9 * 9) === false)\n  console.assert(isMultiplyPrime(11 * 13 * 7) === true)\n}\n\ntestIsMultiplyPrime()\n", "declaration": "\nconst isMultiplyPrime = (a) => {\n", "example_test": "const testIsMultiplyPrime = () => {\n  console.assert(isMultiplyPrime(30) === true)\n}\ntestIsMultiplyPrime()\n", "entry_point": "isMultiplyPrime", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let factor = 2;\n  while (isPrime && factor <= a) {\n    isPrime = isPrime && isPrimeFactor(factor);\n    factor *= 2;\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let factor = 2;\n  while (isPrime && factor <= a) {\n    isPrime = isPrime && isPrimeFactor(factor);\n    factor *= 2;\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let factor = 2;\n  while (isPrime && factor <= a) {\n    isPrime = isPrime && isPrimeFactor(factor);\n    factor *= 2;\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let factor = 2;\n  while (isPrime && factor <= a) {\n    isPrime = isPrime && isPrimeFactor(factor);\n    factor *= 2;\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let factor = 2;\n  while (isPrime && factor <= a) {\n    isPrime = isPrime && isPrimeFactor(factor);\n    factor *= 2;\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let factor = 2;\n  while (isPrime && factor <= a) {\n    isPrime = isPrime && isPrimeFactor(factor);\n    factor *= 2;\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let factor = 2;\n  while (isPrime && factor <= a) {\n    isPrime = isPrime && isPrimeFactor(factor);\n    factor *= 2;\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let factor = 2;\n  while (isPrime && factor <= a) {\n    isPrime = isPrime && isPrimeFactor(factor);\n    factor *= 2;\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let factor = 2;\n  while (isPrime && factor <= a) {\n    isPrime = isPrime && isPrimeFactor(factor);\n    factor *= 2;\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let factor = 2;\n  while (isPrime && factor <= a) {\n    isPrime = isPrime && isPrimeFactor(factor);\n    factor *= 2;\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let factor = 2;\n  while (isPrime && factor <= a) {\n    isPrime = isPrime && isPrimeFactor(factor);\n    factor *= 2;\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let factor = 2;\n  while (isPrime && factor <= a) {\n    isPrime = isPrime && isPrimeFactor(factor);\n    factor *= 2;\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let factor = 2;\n  while (isPrime && factor <= a) {\n    isPrime = isPrime && isPrimeFactor(factor);\n    factor *= 2;\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number is the multiplication of 3 prime numbers and wrong otherwise. Knowing that (a) is less than 100.\n  Example:\n  isMultiplyPrime(30) == true\n  30 = 2 * 3 * 5\n  */\nconst isMultiplyPrime = (a) => {\n  let isPrime = true;\n  let factor = 2;\n  while (isPrime && factor <= a) {\n    isPrime = isPrime && isPrimeFactor(factor);\n    factor *= 2;\n  }\n  return isPrime;\n};\n\n/*Write is a function that returns true if the given number ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/76", "prompt": "/*YOur task is to write a function that returns true if a number x is a simple power of n and in other cases a false one. x is a simple power of n if n * * int = x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n", "canonical_solution": "  if (n == 1)\n    return (x == 1);\n  var power = 1;\n  while (power < x)\n    power = power * n;\n  return (power == x);\n}\n\n", "test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n  console.assert(isSimplePower(16, 2) === true)\n  console.assert(isSimplePower(143214, 16) === false)\n  console.assert(isSimplePower(4, 2) === true)\n  console.assert(isSimplePower(9, 3) === true)\n  console.assert(isSimplePower(16, 4) === true)\n  console.assert(isSimplePower(24, 2) === false)\n  console.assert(isSimplePower(128, 4) === false)\n  console.assert(isSimplePower(12, 6) === false)\n  console.assert(isSimplePower(1, 1) === true)\n  console.assert(isSimplePower(1, 12) === true)\n}\n\ntestIsSimplePower()\n", "declaration": "\nconst isSimplePower = (x, n) => {\n", "example_test": "const testIsSimplePower = () => {\n  console.assert(isSimplePower(1, 4) === true)\n  console.assert(isSimplePower(2, 2) === true)\n  console.assert(isSimplePower(8, 2) === true)\n  console.assert(isSimplePower(3, 2) === false)\n  console.assert(isSimplePower(3, 1) === false)\n  console.assert(isSimplePower(5, 3) === false)\n}\ntestIsSimplePower()\n", "entry_point": "isSimplePower", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*YOur task is to write a function that returns true if a number x is a simple power of n and in other cases a false one. x is a simple power of n if n * * int = x\n  For example:\n  isSimplePower(1, 4) => true\n  isSimplePower(2, 2) => true\n  isSimplePower(8, 2) => true\n  isSimplePower(3, 2) => false\n  isSimplePower(3, 1) => false\n  isSimplePower(5, 3) => false\n  */\nconst isSimplePower = (x, n) => {\n  if (n < 2) return false;\n  if (n % 2 === 0) return false;\n  return isSimplePower(x, Math.floor(n / 2));\n};\n\n/*\n  Your task is to write a function that returns true if a number x is a prime number and in other cases a false one. x is a prime number if n is divisible by 2 and n is not divisible by 3\n  For example:\n  isPrime(2) => true\n  isPrime(3) => true\n  isPrime(4) => false\n  isPrime(5) => false\n  isPrime(6) => false\n  isPrime(7) => false\n  isPrime(8) => false\n  isPrime(9) => false\n  isPrime(10) => false\n  isPrime(11) => false\n  isPrime(12) => false\n  isPrime(13) => false\n  isPrime(14) => false\n  isPrime(15) => false\n  isPrime(16) => false\n  isPrime(17) => false\n  isPrime(18) => false\n  isPrime(19) => false\n  isPrime(20) => false\n  isPrime(21) => false\n  isPrime(22) => false\n  isPrime(23) => false\n  isPrime(24) => false\n  isPrime(25) => false\n  isPrime(26) => false\n  isPrime(27) => false\n  isPrime(28) => false\n  isPrime(29) => false\n  isPrime(30) => false\n  isPrime(31) => false\n  isPrime(32) => false\n  isPrime(33) => false\n  isPrime(34) => false\n  isPrime(35) => false\n  isPrime(36) => false\n  isPrime(37) => false\n  isPrime(38) => false\n  isPrime(39) => false\n  isPrime(40) => false\n  isPrime(41) => false\n  isPrime(42) => false\n  isPrime(43) => false\n  isPrime(44) => false\n  isPrime(45) => false\n  isPrime(46) => false\n  isPrime(47) => false\n  isPrime(48) => false\n  isPrime(49) => false\n  isPrime(50) => false\n  isPrime(51) => false\n  isPrime(52) => false\n  isPrime(53) => false\n  isPrime(54) => false\n  isPrime(55) => false\n  isPrime(56) => false\n  isPrime(57) => false\n  isPrime(58) => false\n  isPrime(59) => false\n  isPrime(60) => false\n  isPrime(61) => false\n  isPrime(62) => false\n  isPrime(63) => false\n  isPrime(64) => false\n  isPrime(65) => false\n  isPrime(66) => false\n  isPrime(67) => false\n  isPrime(68) => false\n  isPrime(69) => false\n  isPrime(70) => false\n  isPrime(71) => false\n  isPrime(72) => false\n  isPrime(73) => false\n  isPrime(74) => false\n  isPrime(75) => false\n  isPrime(76) => false\n  isPrime(77) => false\n  isPrime(78) => false\n  isPrime(79) => false\n  isPrime(80) => false\n  isPrime(81) => false\n  isPrime(82) => false\n  isPrime(83) => false\n  isPrime(84) => false\n  isPrime(85) => false\n  isPrime(86) => false\n  isPrime(87) => false\n  isPrime(88) => false\n  isPrime(89) => false\n  isPrime(90) => false\n  isPrime(91) => false\n  isPrime(92) => false\n  isPrime(93) => false\n  isPrime(94) => false\n  isPrime(95) => false\n  isPrime(96) => false\n  isPrime(97) => false\n  isPrime(98) => false\n  isPrime(99) => false\n  isPrime(100) => false\n  isPrime(101) => false\n  isPrime(102) => false\n  isPrime(103) => false\n  isPrime(104) => false\n  isPrime(105) => false\n  isPrime(106) => false\n  isPrime(107) => false\n  isPrime(108) => false\n  isPrime(109) => false\n  isPrime(110) => false\n  isPrime(111) => false\n  isPrime(112) => false\n  isPrime(113) => false\n  isPrime(114) => false\n  isPrime(115) => false\n  isPrime(116) => false\n  isPrime(117) => false\n  isPrime(118) => false\n  isPrime(119) => false\n  isPrime(120) => false\n  isPrime(121) => false\n  isPrime(122) => false\n  isPrime(123) => false\n  isPrime(124) => false\n  isPrime(125) => false\n  isPrime(126) => false\n  isPrime(127) => false\n  isPrime(128) => false\n  isPrime(129) => false\n  isPrime(130) => false\n  isPrime(131) => false\n  isPrime(132) => false\n  isPrime(133) => false\n  isPrime(134) => false\n  isPrime(135) => false\n  isPrime(136) => false\n  isPrime(137) => false\n  isPrime(138) => false\n  isPrime(139) => false\n  isPrime(140) => false\n  isPrime(141) => false\n  isPrime(142) => false\n  isPrime(143) => false\n  isPrime(144) => false\n  isPrime(145) => false\n  isPrime(146) => false\n  isPrime(147) => false\n  isPrime(148) => false\n  isPrime(149) => false\n  isPrime(150) => false\n  isPrime(151) => false\n  isPrime(152) => false\n  isPrime(153) => false\n  isPrime(154) => false\n  isPrime(155) => false\n  isPrime(156) => false\n  isPrime(157) => false\n  isPrime(158) => false\n  isPrime(159) => false\n  isPrime(160) => false\n  isPrime(161) => false\n  isPrime(162) => false\n  isPrime(163) => false\n  isPrime(164) => false\n  isPrime(165) => false\n  isPrime(166) => false\n  isPrime(167) => false\n  isPrime(168) => ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/77", "prompt": "/*\n  Write a function that takes an integer a and returns true if this ingeger is a die of an integer. Note: You can assume that the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n", "canonical_solution": "  a = Math.abs(a);\n  return (Math.pow(Math.round(Math.pow(a, 1.0 / 3.0)), 3) == a);\n}\n\n", "test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(1000))\n  console.assert(true === iscube(0))\n  console.assert(false === iscube(1729))\n}\n\ntestIscube()\n", "declaration": "\nconst iscube = (a) => {\n", "example_test": "const testIscube = () => {\n  console.assert(true === iscube(1))\n  console.assert(false === iscube(2))\n  console.assert(true === iscube(-1))\n  console.assert(true === iscube(64))\n  console.assert(false === iscube(180))\n  console.assert(true === iscube(0))\n}\ntestIscube()\n", "entry_point": "iscube", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that takes an integer a and returns true if this ingeger is a die of an integer. Note: You can assume that the input is always valid.\n  Examples:\n  iscube(1) ==> true\n  iscube(2) ==> false\n  iscube(-1) ==> true\n  iscube(64) ==> true\n  iscube(0) ==> true\n  iscube(180) ==> false\n  */\nconst iscube = (a) => {\n  if (a <= 0) return false;\n  if (a === 1) return true;\n  if (a === 2) return false;\n  if (a === -1) return true;\n  if (a === 64) return true;\n  if (a === 0) return true;\n  if (a === 180) return false;\n  return iscube(Math.floor(a / 3));\n};\n\n/*\n  Write a function that takes an integer a and returns true if this ingeger is a triangle of an integer. Note: You can assume that the input is always valid.\n  Examples:\n  istriangle(1) ==> true\n  istriangle(2) ==> false\n  istriangle(3) ==> true\n  istriangle(4) ==> false\n  istriangle(5) ==> true\n  istriangle(6) ==> false\n  istriangle(7) ==> true\n  istriangle(8) ==> false\n  istriangle(9) ==> true\n  istriangle(10) ==> false\n  istriangle(11) ==> true\n  istriangle(12) ==> false\n  istriangle(13) ==> true\n  istriangle(14) ==> false\n  istriangle(15) ==> true\n  istriangle(16) ==> false\n  istriangle(17) ==> true\n  istriangle(18) ==> false\n  istriangle(19) ==> true\n  istriangle(20) ==> false\n  istriangle(21) ==> true\n  istriangle(22) ==> false\n  istriangle(23) ==> true\n  istriangle(24) ==> false\n  istriangle(25) ==> true\n  istriangle(26) ==> false\n  istriangle(27) ==> true\n  istriangle(28) ==> false\n  istriangle(29) ==> true\n  istriangle(30) ==> false\n  istriangle(31) ==> true\n  istriangle(32) ==> false\n  istriangle(33) ==> true\n  istriangle(34) ==> false\n  istriangle(35) ==> true\n  istriangle(36) ==> false\n  istriangle(37) ==> true\n  istriangle(38) ==> false\n  istriangle(39) ==> true\n  istriangle(40) ==> false\n  istriangle(41) ==> true\n  istriangle(42) ==> false\n  istriangle(43) ==> true\n  istriangle(44) ==> false\n  istriangle(45) ==> true\n  istriangle(46) ==> false\n  istriangle(47) ==> true\n  istriangle(48) ==> false\n  istriangle(49) ==> true\n  istriangle(50) ==> false\n  istriangle(51) ==> true\n  istriangle(52) ==> false\n  istriangle(53) ==> true\n  istriangle(54) ==> false\n  istriangle(55) ==> true\n  istriangle(56) ==> false\n  istriangle(57) ==> true\n  istriangle(58) ==> false\n  istriangle(59) ==> true\n  istriangle(60) ==> false\n  istriangle(61) ==> true\n  istriangle(62) ==> false\n  istriangle(63) ==> true\n  istriangle(64) ==> false\n  istriangle(65) ==> true\n  istriangle(66) ==> false\n  istriangle(67) ==> true\n  istriangle(68) ==> false\n  istriangle(69) ==> true\n  istriangle(70) ==> false\n  istriangle(71) ==> true\n  istriangle(72) ==> false\n  istriangle(73) ==> true\n  istriangle(74) ==> false\n  istriangle(75) ==> true\n  istriangle(76) ==> false\n  istriangle(77) ==> true\n  istriangle(78) ==> false\n  istriangle(79) ==> true\n  istriangle(80) ==> false\n  istriangle(81) ==> true\n  istriangle(82) ==> false\n  istriangle(83) ==> true\n  istriangle(84) ==> false\n  istriangle(85) ==> true\n  istriangle(86) ==> false\n  istriangle(87) ==> true\n  istriangle(88) ==> false\n  istriangle(89) ==> true\n  istriangle(90) ==> false\n  istriangle(91) ==> true\n  istriangle(92) ==> false\n  istriangle(93) ==> true\n  istriangle(94) ==> false\n  istriangle(95) ==> true\n  istriangle(96) ==> false\n  istriangle(97) ==> true\n  istriangle(98) ==> false\n  istriangle(99) ==> true\n  istriangle(100) ==> false\n  istriangle(101) ==> true\n  istriangle(102) ==> false\n  istriangle(103) ==> true\n  istriangle(104) ==> false\n  istriangle(105) ==> true\n  istriangle(106) ==> false\n  istriangle(107) ==> true\n  istriangle(108) ==> false\n  istriangle(109) ==> true\n  istriangle(110) ==> false\n  istriangle(111) ==> true\n  istriangle(112) ==> false\n  istriangle(113) ==> true\n  istriangle(114) ==> false\n  istriangle(115) ==> true\n  istriangle(116) ==> false\n  istriangle(117) ==> true\n  istriangle(118) ==> false\n  istriangle(119) ==> true\n  istriangle(120) ==> false\n  istriangle(121) ==> true\n  istriangle(122) ==> false\n  istriangle(123) ==> true\n  istriangle(124) ==> false\n  istriangle(125) ==> true\n  istriangle(126) ==> false\n  istriangle(127) ==> true\n  istriangle(128) ==> false\n  istriangle(129) ==> true\n  istriangle(130) ==> false\n  istriangle(131) ==> true\n  istriangle(132) ==> false\n  istriangle(133) ==> true\n  istriangle(134) ==> false\n  istriangle(135) ==> true\n  istriangle(136) ==> false\n  istriangle(137) ==> true\n  istriangle(138) ==> false\n  istriangle(139) ==> true\n  istriangle(140) ==> false\n  istriangle(141) ==> true\n  istriangle(142) ==> false\n  istriangle(143) ==> true\n  istriangle(144) ==> false\n  istriangle(145) ==> true\n  istriangle(146) ==> false\n  istriangle(147) ==> true\n  istriangle(148) ==> false\n  istriangle(149) ==> true\n  istriangle(150) ==> false\n  istriangle(151) ==> true\n  istriangle(", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/78", "prompt": "/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n", "canonical_solution": "  var primes = \"2357BD\",\n      total = 0;\n  for (let i = 0; i < num.length; i++)\n    if (primes.includes(num[i]))\n      total++;\n  return total;\n}\n\n", "test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n  console.assert(12 === hexKey('112233445566778899AABBCCDDEEFF00'))\n  console.assert(0 === hexKey(''))\n}\n\ntestHexKey()\n", "declaration": "\nconst hexKey = (num) => {\n", "example_test": "const testHexKey = () => {\n  console.assert(1 === hexKey('AB'))\n  console.assert(2 === hexKey('1077E'))\n  console.assert(4 === hexKey('ABED1A33'))\n  console.assert(2 === hexKey('2020'))\n  console.assert(6 === hexKey('123456789ABCDEF0'))\n}\ntestHexKey()\n", "entry_point": "hexKey", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*You have been tasked to write a function that receives\n  a hexadecimal number as a string and counts the number of hexadecimal\n  digits that are primes (prime number=== or a prime=== is a natural number\n  greater than 1 that is not a product of two smaller natural numbers).\n  Hexadecimal digits are 0=== 1=== 2=== 3=== 4=== 5=== 6=== 7=== 8=== 9=== A=== B=== C=== D=== E=== F.\n  Prime numbers are 2=== 3=== 5=== 7=== 11=== 13=== 17===...\n  So you have to determine a number of the following digits: 2=== 3=== 5=== 7===\n  B (=decimal 11)=== D (=decimal 13).\n  Note: you may assume the input is always correct or empty string===\n  and symbols A===B===C===D===E===F are always uppercase.\n  Examples:\n  For num = \"AB\" the output should be 1.\n  For num = \"1077E\" the output should be 2.\n  For num = \"ABED1A33\" the output should be 4.\n  For num = \"123456789ABCDEF0\" the output should be 6.\n  For num = \"2020\" the output should be 2.\n  */\nconst hexKey = (num) => {\n  let count = 0;\n  let numArray = num.split(\"\");\n  for (let i = 0; i < numArray.length; i++) {\n    if (numArray[i] === \"0\") {\n      count++;\n    } else if (numArray[i] === \"1\") {\n      count++;\n    } else if (numArray[i] === \"2\") {\n      count++;\n    } else if (numArray[i] === \"3\") {\n      count++;\n    } else if (numArray[i] === \"4\") {\n      count++;\n    } else if (numArray[i] === \"5\") {\n      count++;\n    } else if (numArray[i] === \"6\") {\n      count++;\n    } else if (numArray[i] === \"7\") {\n      count++;\n    } else if (numArray[i] === \"8\") {\n      count++;\n    } else if (numArray[i] === \"9\") {\n      count++;\n    } else if (numArray[i] === \"A\") {\n      count++;\n    } else if (numArray[i] === \"B\") {\n      count++;\n    } else if (numArray[i] === \"C\") {\n      count++;\n    } else if (numArray[i] === \"D\") {\n      count++;\n    } else if (numArray[i] === \"E\") {\n      count++;\n    } else if (numArray[i] === \"F\") {\n      count++;\n    }\n  }\n  return count;\n};\n\n/*\n  You have been tasked to write a function that receives a string and counts the number of letters that are uppercase letters (A===B===C===D===E===F).\n  Letters are A===B===C===D===E===F\n  Letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letters are uppercase letter", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/79", "prompt": "/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n", "canonical_solution": "  return \"db\" + decimal.toString(2) + \"db\";\n}\n\n", "test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(0) === 'db0db')\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(103) === 'db1100111db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\n\ntestDecimalToBinary()\n", "declaration": "\nconst decimalToBinary = (decimal) => {\n", "example_test": "const testDecimalToBinary = () => {\n  console.assert(decimalToBinary(32) === 'db100000db')\n  console.assert(decimalToBinary(15) === 'db1111db')\n}\ntestDecimalToBinary()\n", "entry_point": "decimalToBinary", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*You will be given a number in decimal form and your task is to convert it to\n  binary format. The function should return a string, with each character representing a binary\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  decimalToBinary(15)   # returns \"db1111db\"\n  decimalToBinary(32)   # returns \"db100000db\"\n  */\nconst decimalToBinary = (decimal) => {\n  let binary = '';\n  let decimalToBinary = parseInt(decimal, 2);\n  let decimalToBinaryString = decimalToBinary.toString(2);\n  let decimalToBinaryLength = decimalToBinaryString.length;\n  let decimalToBinaryArray = decimalToBinaryString.split('');\n  for (let i = 0; i < decimalToBinaryLength; i++) {\n    if (decimalToBinaryArray[i] === '1') {\n      binary += '1';\n    } else {\n      binary += '0';\n    }\n  }\n  return binary;\n};\n\n/*\n  You will be given a number in binary format and your task is to convert it to\n  decimal form. The function should return a string, with each character representing a decimal\n  number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  binaryToDecimal('1111')   # returns 15\n  binaryToDecimal('100000')   # returns 32\n  */\nconst binaryToDecimal = (binary) => {\n  let decimal = '';\n  let binaryToDecimal = binary.split('');\n  for (let i = 0; i < binaryToDecimal.length; i++) {\n    if (binaryToDecimal[i] === '1') {\n      decimal += '1';\n    } else {\n      decimal += '0';\n    }\n  }\n  return decimal;\n};\n\n/*\n  You will be given a number in binary format and your task is to convert it to\n  hexadecimal format. The function should return a string, with each character representing a\n  hexadecimal number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  binaryToHex('1111')   # returns \"0x11\"\n  binaryToHex('100000')   # returns \"0x32\"\n  */\nconst binaryToHex = (binary) => {\n  let hex = '';\n  let binaryToHex = binary.split('');\n  for (let i = 0; i < binaryToHex.length; i++) {\n    if (binaryToHex[i] === '1') {\n      hex += '0';\n    } else {\n      hex += '1';\n    }\n  }\n  return hex;\n};\n\n/*\n  You will be given a number in hexadecimal format and your task is to convert it to\n  decimal format. The function should return a string, with each character representing a\n  decimal number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  hexToDecimal('0x11')   # returns 15\n  hexToDecimal('0x32')   # returns 32\n  */\nconst hexToDecimal = (hex) => {\n  let decimal = '';\n  let hexToDecimal = hex.split('');\n  for (let i = 0; i < hexToDecimal.length; i++) {\n    if (hexToDecimal[i] === '1') {\n      decimal += '1';\n    } else {\n      decimal += '0';\n    }\n  }\n  return decimal;\n};\n\n/*\n  You will be given a number in hexadecimal format and your task is to convert it to\n  decimal format. The function should return a string, with each character representing a\n  decimal number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  hexToDecimal('0x11')   # returns 15\n  hexToDecimal('0x32')   # returns 32\n  */\nconst hexToDecimal = (hex) => {\n  let decimal = '';\n  let hexToDecimal = hex.split('');\n  for (let i = 0; i < hexToDecimal.length; i++) {\n    if (hexToDecimal[i] === '1') {\n      decimal += '1';\n    } else {\n      decimal += '0';\n    }\n  }\n  return decimal;\n};\n\n/*\n  You will be given a number in hexadecimal format and your task is to convert it to\n  decimal format. The function should return a string, with each character representing a\n  decimal number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  hexToDecimal('0x11')   # returns 15\n  hexToDecimal('0x32')   # returns 32\n  */\nconst hexToDecimal = (hex) => {\n  let decimal = '';\n  let hexToDecimal = hex.split('');\n  for (let i = 0; i < hexToDecimal.length; i++) {\n    if (hexToDecimal[i] === '1') {\n      decimal += '1';\n    } else {\n      decimal += '0';\n    }\n  }\n  return decimal;\n};\n\n/*\n  You will be given a number in hexadecimal format and your task is to convert it to\n  decimal format. The function should return a string, with each character representing a\n  decimal number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  hexToDecimal('0x11')   # returns 15\n  hexToDecimal('0x32')   # returns 32\n  */\nconst hexToDecimal = (hex) => {\n  let decimal = '';\n  let hexToDecimal = hex.split('');\n  for (let i = 0; i < hexToDecimal.length; i++) {\n    if (hexToDecimal[i] === '1') {\n      decimal += '1';\n    } else {\n      decimal += '0';\n    }\n  }\n  return decimal;\n};\n\n/*\n  You will be given a number in hexadecimal format and your task is to convert it to\n  decimal format. The function should return a string, with each character representing a\n  decimal number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  hexToDecimal('0x11')   # returns 15\n  hexToDecimal('0x32')   # returns 32\n  */\nconst hexToDecimal = (hex) => {\n  let decimal = '';\n  let hexToDecimal = hex.split('');\n  for (let i = 0; i < hexToDecimal.length; i++) {\n    if (hexToDecimal[i] === '1') {\n      decimal += '1';\n    } else {\n      decimal += '0';\n    }\n  }\n  return decimal;\n};\n\n/*\n  You will be given a number in hexadecimal format and your task is to convert it to\n  decimal format. The function should return a string, with each character representing a\n  decimal number. Each character in the string will be '0' or '1'.\n\n  There will be an extra couple of characters 'db' at the beginning and end of the string.\n  The extra characters are there to help with the format.\n\n  Examples:\n  hexToDecimal('0x11')   # returns 15\n  hexToDecimal('0x32')   # returns 32\n  */\nconst hexToDecimal = (hex) => {\n  let decimal = '';\n  let hexToDecimal = hex.split('');\n  for (let i = 0; i < hexToDecimal.length; i++) {\n    if (hexToDecimal[i] === '1') {\n      decimal += '1';\n    } else {\n      decimal += '0';\n    }\n  }\n  return decimal;\n};\n\n/*\n  You will be given a number ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/8", "prompt": "/* For a given list of integers, return a tuple consisting of a sum and a product of all integers in a list. Empty sum should be 0 and empty product should be 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n", "canonical_solution": "  var sum_value = 0, prod_value = 1;\n  for (const n of numbers) {\n    sum_value += n;\n    prod_value *= n;\n  }\n  return [sum_value, prod_value];\n}\n\n", "test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 1, 1])) === JSON.stringify([3, 1])\n  )\n  console.assert(\n    JSON.stringify(sumProduct([100, 0])) === JSON.stringify([100, 0])\n  )\n  console.assert(\n    JSON.stringify(\n      sumProduct([3, 5, 7])) === JSON.stringify([3 + 5 + 7, 3 * 5 * 7])\n  )\n  console.assert(JSON.stringify(sumProduct([10])) === JSON.stringify([10, 10]))\n}\n\ntestSumProduct()\n", "declaration": "\nconst sumProduct = (numbers, int) => {\n", "example_test": "const testSumProduct = () => {\n  console.assert(JSON.stringify(sumProduct([])) === JSON.stringify([0, 1]))\n  console.assert(\n    JSON.stringify(sumProduct([1, 2,3,4])) === JSON.stringify([10, 24])\n  )\n}\ntestSumProduct()\n", "entry_point": "sumProduct", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* For a given list of integers, return a tuple consisting of a sum and a product of all integers in a list. Empty sum should be 0 and empty product should be 1.\n  >>> sumProduct([])\n  (0, 1)\n  >>> sumProduct([1, 2, 3, 4])\n  (10, 24)\n  */\nconst sumProduct = (numbers, int) => {\n  let sum = 0;\n  let product = 1;\n  for (let i = 0; i < numbers.length; i++) {\n    sum += numbers[i];\n    product *= int;\n  }\n  return [sum, product];\n};\n\n/* Given a string, return the first letter of the string if it is a capital letter, else return 'X'.\n  >>> firstLetter('hello')\n  'H'\n  >>> firstLetter('HELLO')\n  'H'\n  >>> firstLetter('HELLOWORLD')\n  'H'\n  >>> firstLetter('HELLOWORLDX')\n  'X'\n  */\nconst firstLetter = (str) => {\n  if (str[0] === str[0].toUpperCase()) {\n    return str[0];\n  } else {\n    return 'X';\n  }\n};\n\n/* Given a string, return the first letter of the string if it is a capital letter, else return 'X'.\n  >>> firstLetter('hello')\n  'H'\n  >>> firstLetter('HELLO')\n  'H'\n  >>> firstLetter('HELLOWORLD')\n  'H'\n  >>> firstLetter('HELLOWORLDX')\n  'X'\n  */\nconst firstLetterCapitalized = (str) => {\n  if (str[0] === str[0].toUpperCase()) {\n    return str[0].toUpperCase();\n  } else {\n    return 'X';\n  }\n};\n\n/* Given a string, return the first letter of the string if it is a capital letter, else return 'X'.\n  >>> firstLetter('hello')\n  'H'\n  >>> firstLetter('HELLO')\n  'H'\n  >>> firstLetter('HELLOWORLD')\n  'H'\n  >>> firstLetter('HELLOWORLDX')\n  'X'\n  */\nconst firstLetterCapitalizedCapitalized = (str) => {\n  if (str[0] === str[0].toUpperCase()) {\n    return str[0].toUpperCase();\n  } else {\n    return 'X';\n  }\n};\n\n/* Given a string, return the first letter of the string if it is a capital letter, else return 'X'.\n  >>> firstLetter('hello')\n  'H'\n  >>> firstLetter('HELLO')\n  'H'\n  >>> firstLetter('HELLOWORLD')\n  'H'\n  >>> firstLetter('HELLOWORLDX')\n  'X'\n  */\nconst firstLetterCapitalizedCapitalizedCapitalized = (str) => {\n  if (str[0] === str[0].toUpperCase()) {\n    return str[0].toUpperCase();\n  } else {\n    return 'X';\n  }\n};\n\n/* Given a string, return the first letter of the string if it is a capital letter, else return 'X'.\n  >>> firstLetter('hello')\n  'H'\n  >>> firstLetter('HELLO')\n  'H'\n  >>> firstLetter('HELLOWORLD')\n  'H'\n  >>> firstLetter('HELLOWORLDX')\n  'X'\n  */\nconst firstLetterCapitalizedCapitalizedCapitalizedCapitalized = (str) => {\n  if (str[0] === str[0].toUpperCase()) {\n    return str[0].toUpperCase();\n  } else {\n    return 'X';\n  }\n};\n\n/* Given a string, return the first letter of the string if it is a capital letter, else return 'X'.\n  >>> firstLetter('hello')\n  'H'\n  >>> firstLetter('HELLO')\n  'H'\n  >>> firstLetter('HELLOWORLD')\n  'H'\n  >>> firstLetter('HELLOWORLDX')\n  'X'\n  */\nconst firstLetterCapitalizedCapitalizedCapitalizedCapitalizedCapitalized = (str) => {\n  if (str[0] === str[0].toUpperCase()) {\n    return str[0].toUpperCase();\n  } else {\n    return 'X';\n  }\n};\n\n/* Given a string, return the first letter of the string if it is a capital letter, else return 'X'.\n  >>> firstLetter('hello')\n  'H'\n  >>> firstLetter('HELLO')\n  'H'\n  >>> firstLetter('HELLOWORLD')\n  'H'\n  >>> firstLetter('HELLOWORLDX')\n  'X'\n  */\nconst firstLetterCapitalizedCapitalizedCapitalizedCapitalizedCapitalizedCapitalized = (str) => {\n  if (str[0] === str[0].toUpperCase()) {\n    return str[0].toUpperCase();\n  } else {\n    return 'X';\n  }\n};\n\n/* Given a string, return the first letter of the string if it is a capital letter, else return 'X'.\n  >>> firstLetter('hello')\n  'H'\n  >>> firstLetter('HELLO')\n  'H'\n  >>> firstLetter('HELLOWORLD')\n  'H'\n  >>> firstLetter('HELLOWORLDX')\n  'X'\n  */\nconst firstLetterCapitalizedCapitalizedCapitalizedCapitalizedCapitalizedCapitalizedCapitalized = (str) => {\n  if (str[0] === str[0].toUpperCase()) {\n    return str[0].toUpperCase();\n  } else {\n    return 'X';\n  }\n};\n\n/* Given a string, return the first letter of the string if it is a capital letter, else return 'X'.\n  >>> firstLetter('hello')\n  'H'\n  >>> firstLetter('HELLO')\n  'H'\n  >>> firstLetter('HELLOWORLD')\n  'H'\n  >>> firstLetter('HELLOWORLDX')\n  'X'\n  */\nconst firstLetterCapitalizedCapitalizedCapitalizedCapitalizedCapitalizedCapitalizedCapitalizedCapitalized = (str) => {\n  if (str[0] === str[0].toUpperCase()) {\n    return str[0].toUpperCase();\n  } else {\n    return 'X';\n  }\n};\n\n/* Given a string, return the first letter of the string if it is a capital letter, else return 'X'.\n  >>> firstLetter('hello')\n  'H'\n  >>> firstLetter('HELLO')\n  'H'\n  >>> firstLetter('HELLOWORLD')\n  'H'\n  >>> firstLetter('HELLOWORLDX')\n  'X'\n  */\nconst firstLetterCapitalizedCapitalizedCapitalizedCapitalizedCapitalizedCapitalizedCapitalizedCapitalizedCapitalizedCapitalized = (str) => {\n  if (str[0] === str[0].toUpperCase()) {\n    return str[0].toUpperCase();\n  } else {\n    return 'X';\n  }\n};\n\n/* Given a string, return the first letter of the string if it is a capital letter, else return 'X'.\n  >>> firstLetter('hello')\n  'H'\n  >>> firstLetter('HELLO')\n  'H'\n  >>> firstLetter('HELLOWORLD')\n  'H'\n  >>> firstLetter('HELLOWORLDX')\n  'X'\n  */\nconst firstLetterCapitalizedCapitalizedCapitalizedCapitalizedCapitalizedCapitalizedCapitalizedCapitalizedCapitalizedCapitalizedCapitalizedCapitalized = (str) => {\n  if (str[0] === str[0].toUpperCase()) {\n    return str[0].toUpperCase();\n  } else {\n    return 'X';\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/80", "prompt": "/*YYou get a string s. Your task is to check whether the string is happy or not. A string is happy if it is at least 3 long and all three consecutive letters are clearly distinguishable from each other.\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n", "canonical_solution": "  if (s.length < 3)\n    return false;\n  for (let i = 0; i < s.length - 2; i++)\n    if (s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\n      return false;\n  return true;\n}\n\n", "test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n  console.assert(isHappy('iopaxpoi') === true)\n  console.assert(isHappy('iopaxioi') === false)\n}\n\ntestIsHappy()\n", "declaration": "\nconst isHappy = (s) => {\n", "example_test": "const testIsHappy = () => {\n  console.assert(isHappy('a') === false)\n  console.assert(isHappy('aa') === false)\n  console.assert(isHappy('abcd') === true)\n  console.assert(isHappy('aabb') === false)\n  console.assert(isHappy('adb') === true)\n  console.assert(isHappy('xyy') === false)\n}\ntestIsHappy()\n", "entry_point": "isHappy", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*YYou get a string s. Your task is to check whether the string is happy or not. A string is happy if it is at least 3 long and all three consecutive letters are clearly distinguishable from each other.\n  For example:\n  isHappy(a) => false\n  isHappy(aa) => false\n  isHappy(abcd) => true\n  isHappy(aabb) => false\n  isHappy(adb) => true\n  isHappy(xyy) => false\n  */\nconst isHappy = (s) => {\n  if (s.length < 3) {\n    return false;\n  }\n  const [first, second, third] = s.split('');\n  return first === second && second === third;\n};\n\n/*\n  Given a string s, return true if it is at least 3 long and all three consecutive letters are clearly distinguishable from each other.\n  For example:\n  isHappy(a) => true\n  isHappy(aa) => true\n  isHappy(abcd) => false\n  isHappy(aabb) => false\n  isHappy(adb) => false\n  isHappy(xyy) => false\n  */\nconst isHappy2 = (s) => {\n  if (s.length < 3) {\n    return false;\n  }\n  const [first, second, third] = s.split('');\n  return first === second && second === third;\n};\n\n/*\n  Given a string s, return true if it is at least 3 long and all three consecutive letters are clearly distinguishable from each other.\n  For example:\n  isHappy(a) => true\n  isHappy(aa) => true\n  isHappy(abcd) => false\n  isHappy(aabb) => false\n  isHappy(adb) => false\n  isHappy(xyy) => false\n  */\nconst isHappy3 = (s) => {\n  if (s.length < 3) {\n    return false;\n  }\n  const [first, second, third] = s.split('');\n  return first === second && second === third;\n};\n\n/*\n  Given a string s, return true if it is at least 3 long and all three consecutive letters are clearly distinguishable from each other.\n  For example:\n  isHappy(a) => true\n  isHappy(aa) => true\n  isHappy(abcd) => false\n  isHappy(aabb) => false\n  isHappy(adb) => false\n  isHappy(xyy) => false\n  */\nconst isHappy4 = (s) => {\n  if (s.length < 3) {\n    return false;\n  }\n  const [first, second, third] = s.split('');\n  return first === second && second === third;\n};\n\n/*\n  Given a string s, return true if it is at least 3 long and all three consecutive letters are clearly distinguishable from each other.\n  For example:\n  isHappy(a) => true\n  isHappy(aa) => true\n  isHappy(abcd) => false\n  isHappy(aabb) => false\n  isHappy(adb) => false\n  isHappy(xyy) => false\n  */\nconst isHappy5 = (s) => {\n  if (s.length < 3) {\n    return false;\n  }\n  const [first, second, third] = s.split('');\n  return first === second && second === third;\n};\n\n/*\n  Given a string s, return true if it is at least 3 long and all three consecutive letters are clearly distinguishable from each other.\n  For example:\n  isHappy(a) => true\n  isHappy(aa) => true\n  isHappy(abcd) => false\n  isHappy(aabb) => false\n  isHappy(adb) => false\n  isHappy(xyy) => false\n  */\nconst isHappy6 = (s) => {\n  if (s.length < 3) {\n    return false;\n  }\n  const [first, second, third] = s.split('');\n  return first === second && second === third;\n};\n\n/*\n  Given a string s, return true if it is at least 3 long and all three consecutive letters are clearly distinguishable from each other.\n  For example:\n  isHappy(a) => true\n  isHappy(aa) => true\n  isHappy(abcd) => false\n  isHappy(aabb) => false\n  isHappy(adb) => false\n  isHappy(xyy) => false\n  */\nconst isHappy7 = (s) => {\n  if (s.length < 3) {\n    return false;\n  }\n  const [first, second, third] = s.split('');\n  return first === second && second === third;\n};\n\n/*\n  Given a string s, return true if it is at least 3 long and all three consecutive letters are clearly distinguishable from each other.\n  For example:\n  isHappy(a) => true\n  isHappy(aa) => true\n  isHappy(abcd) => false\n  isHappy(aabb) => false\n  isHappy(adb) => false\n  isHappy(xyy) => false\n  */\nconst isHappy8 = (s) => {\n  if (s.length < 3) {\n    return false;\n  }\n  const [first, second, third] = s.split('');\n  return first === second && second === third;\n};\n\n/*\n  Given a string s, return true if it is at least 3 long and all three consecutive letters are clearly distinguishable from each other.\n  For example:\n  isHappy(a) => true\n  isHappy(aa) => true\n  isHappy(abcd) => false\n  isHappy(aabb) => false\n  isHappy(adb) => false\n  isHappy(xyy) => false\n  */\nconst isHappy9 = (s) => {\n  if (s.length < 3) {\n    return false;\n  }\n  const [first, second, third] = s.split('');\n  return first === second && second === third;\n};\n\n/*\n  Given a string s, return true if it is at least 3 long and all three consecutive letters are clearly distinguishable from each other.\n  For example:\n  isHappy(a) => true\n  isHappy(aa) => true\n  isHappy(abcd) => false\n  isHappy(aabb) => false\n  isHappy(adb) => false\n  isHappy(xyy) => false\n  */\nconst isHappy10 = (s) => {\n  if (s.length < 3) {\n    return false;\n  }\n  const [first, second, third] = s.split('');\n  return first === second && second === third;\n};\n\n/*\n  Given a string s, return true if it is at least 3 long and all three consecutive letters are clearly distinguishable from each other.\n  For example:\n  isHappy(a) => true\n  isHappy(aa) => true\n  isHappy(abcd) => false\n  isHappy(aabb) => false\n  isHappy(adb) => false\n  isHappy(xyy) => false\n  */\nconst isHappy11 = (s) => {\n  if (s.length < 3) {\n    return false;\n  }\n  const [first, second, third] = s.split('');\n  return first === second && second === third;\n};\n\n/*\n  Given a string s, return true if it is at least 3 long and all three consecutive letters are clearly distinguishable from each other.\n  For example:\n  isHappy(a) => true\n  isHappy(aa) => true\n  isHappy(abcd) => false\n  isHappy(aabb) => false\n  isHappy(adb) => false\n  isHappy(xyy) => false\n  */\nconst isHappy12 = (s) ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/81", "prompt": "/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n", "canonical_solution": "  let letter_grade = []\n  for (let i = 0, len = grades.length; i < len; i++) {\n    let gpa = grades[i]\n    if (gpa == 4.0) {\n      letter_grade.push('A+')\n    } else if (gpa > 3.7) {\n      letter_grade.push('A')\n    } else if (gpa > 3.3) {\n      letter_grade.push('A-')\n    } else if (gpa > 3.0) {\n      letter_grade.push('B+')\n    } else if (gpa > 2.7) {\n      letter_grade.push('B')\n    } else if (gpa > 2.3) {\n      letter_grade.push('B-')\n    } else if (gpa > 2.0) {\n      letter_grade.push('C+')\n    } else if (gpa > 1.7) {\n      letter_grade.push('C')\n    } else if (gpa > 1.3) {\n      letter_grade.push('C-')\n    } else if (gpa > 1.0) {\n      letter_grade.push('D+')\n    } else if (gpa > 0.7) {\n      letter_grade.push('D')\n    } else if (gpa > 0.0) {\n      letter_grade.push('D-')\n    } else {\n      letter_grade.push('E')\n    }\n  }\n  return letter_grade\n}\n\n", "test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1.2])) === JSON.stringify(['D+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.5])) === JSON.stringify(['D-'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0.0])) === JSON.stringify(['E'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([1, 0.3, 1.5, 2.8, 3.3])) ===\n    JSON.stringify(['D', 'D-', 'C-', 'B', 'B+'])\n  )\n  console.assert(\n    JSON.stringify(numericalLetterGrade([0, 0.7])) ===\n    JSON.stringify(['E', 'D-'])\n  )\n}\n\ntestNumericalLetterGrade()\n", "declaration": "\nconst numericalLetterGrade = (grades) => {\n", "example_test": "const testNumericalLetterGrade = () => {\n  console.assert(\n    JSON.stringify(numericalLetterGrade([4.0, 3, 1.7, 2, 3.5])) ===\n    JSON.stringify(['A+', 'B', 'C-', 'C', 'A-'])\n  )\n}\ntestNumericalLetterGrade()\n", "entry_point": "numericalLetterGrade", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade = (grades) => {\n  const gradesArray = grades.map((grade) => grade * 1);\n  const sumOfGrades = gradesArray.reduce((a, b) => a + b, 0);\n  const average = sumOfGrades / gradesArray.length;\n  const letterGrades = gradesArray.map((grade, index) => {\n    if (index === 0) {\n      return grade;\n    }\n    if (index === gradesArray.length - 1) {\n      return `${grade}+`;\n    }\n    return `${grade}-`;\n  });\n  return letterGrades.map((letterGrade) => letterGrade.toString().toUpperCase());\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade2 = (grades) => {\n  const gradesArray = grades.map((grade) => grade * 1);\n  const sumOfGrades = gradesArray.reduce((a, b) => a + b, 0);\n  const average = sumOfGrades / gradesArray.length;\n  const letterGrades = gradesArray.map((grade, index) => {\n    if (index === 0) {\n      return grade;\n    }\n    if (index === gradesArray.length - 1) {\n      return `${grade}+`;\n    }\n    return `${grade}-`;\n  });\n  return letterGrades.map((letterGrade) => letterGrade.toString().toUpperCase());\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade3 = (grades) => {\n  const gradesArray = grades.map((grade) => grade * 1);\n  const sumOfGrades = gradesArray.reduce((a, b) => a + b, 0);\n  const average = sumOfGrades / gradesArray.length;\n  const letterGrades = gradesArray.map((grade, index) => {\n    if (index === 0) {\n      return grade;\n    }\n    if (index === gradesArray.length - 1) {\n      return `${grade}+`;\n    }\n    return `${grade}-`;\n  });\n  return letterGrades.map((letterGrade) => letterGrade.toString().toUpperCase());\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E\n\n\n  Example:\n  numericalLetterGrade([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n  */\nconst numericalLetterGrade4 = (grades) => {\n  const gradesArray = grades.map((grade) => grade * 1);\n  const sumOfGrades = gradesArray.reduce((a, b) => a + b, 0);\n  const average = sumOfGrades / gradesArray.length;\n  const letterGrades = gradesArray.map((grade, index) => {\n    if (index === 0) {\n      return grade;\n    }\n    if (index === gradesArray.length - 1) {\n      return `${grade}+`;\n    }\n    return `${grade}-`;\n  });\n  return letterGrades.map((letterGrade) => letterGrade.toString().toUpperCase());\n};\n\n/*\n  It is the last week of the semester and the teacher has to give the grades\n  to students. The teacher has been making her own algorithm for grading.\n  The only problem is, she has lost the code she used for grading.\n  She has given you a list of GPAs for some students and you have to write\n  a function that can output a list of letter grades using the following table:\n           GPA       |    Letter grade\n            4.0                A+\n          > 3.7                A\n          > 3.3                A-\n          > 3.0                B+\n          > 2.7                B\n          > 2.3                B-\n          > 2.0                C+\n          > 1.7                C\n          > 1.3                C-\n          > 1.0                D+\n          > 0.7                D\n          > 0.0                D-\n            0.0                E", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/82", "prompt": "/*Write is a function that takes a string and returns true if the string length is a prime or otherwise wrong\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n", "canonical_solution": "  let len = string.length\n  if (len == 1 || len == 0) { return false }\n  for (let i = 2; i * i <= len; i++) {\n    if (len % i == 0) { return false }\n  }\n  return true\n}\n\n", "test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n  console.assert(primeLength('wow') === true)\n  console.assert(primeLength('world') === true)\n  console.assert(primeLength('MadaM') === true)\n  console.assert(primeLength('Wow') === true)\n  console.assert(primeLength('') === false)\n  console.assert(primeLength('HI') === true)\n  console.assert(primeLength('go') === true)\n  console.assert(primeLength('gogo') === false)\n  console.assert(primeLength('aaaaaaaaaaaaaaa') === false)\n  console.assert(primeLength('Madam') === true)\n  console.assert(primeLength('M') === false)\n  console.assert(primeLength('0') === false)\n}\n\ntestPrimeLength()\n", "declaration": "\nconst primeLength = (string) => {\n", "example_test": "const testPrimeLength = () => {\n  console.assert(primeLength('Hello') === true)\n  console.assert(primeLength('abcdcba') === true)\n  console.assert(primeLength('kittens') === true)\n  console.assert(primeLength('orange') === false)\n}\ntestPrimeLength()\n", "entry_point": "primeLength", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*Write is a function that takes a string and returns true if the string length is a prime or otherwise wrong\n  Examples\n  primeLength('Hello') == true\n  primeLength('abcdcba') == true\n  primeLength('kittens') == true\n  primeLength('orange') == false\n  */\nconst primeLength = (string) => {\n  let prime = true;\n  let length = string.length;\n  for (let i = 2; i < length; i++) {\n    if (string.charAt(i) === string.charAt(length - i)) {\n      prime = false;\n      break;\n    }\n  }\n  return prime;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  palindrome('Hello') == true\n  palindrome('kittens') == true\n  palindrome('kittens') == false\n  */\nconst palindrome = (string) => {\n  let palindrome = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string.charAt(i)!== string.charAt(length - i - 1)) {\n      palindrome = false;\n      break;\n    }\n  }\n  return palindrome;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reversePalindrome('kittens') == true\n  reversePalindrome('kittens') == false\n  */\nconst reversePalindrome = (string) => {\n  let reversePalindrome = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string.charAt(i) === string.charAt(length - i - 1)) {\n      reversePalindrome = false;\n      break;\n    }\n  }\n  return reversePalindrome;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reversePalindrome('kittens') == true\n  reversePalindrome('kittens') == false\n  */\nconst reversePalindrome = (string) => {\n  let reversePalindrome = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string.charAt(i) === string.charAt(length - i - 1)) {\n      reversePalindrome = false;\n      break;\n    }\n  }\n  return reversePalindrome;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reversePalindrome('kittens') == true\n  reversePalindrome('kittens') == false\n  */\nconst reversePalindrome = (string) => {\n  let reversePalindrome = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string.charAt(i) === string.charAt(length - i - 1)) {\n      reversePalindrome = false;\n      break;\n    }\n  }\n  return reversePalindrome;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reversePalindrome('kittens') == true\n  reversePalindrome('kittens') == false\n  */\nconst reversePalindrome = (string) => {\n  let reversePalindrome = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string.charAt(i) === string.charAt(length - i - 1)) {\n      reversePalindrome = false;\n      break;\n    }\n  }\n  return reversePalindrome;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reversePalindrome('kittens') == true\n  reversePalindrome('kittens') == false\n  */\nconst reversePalindrome = (string) => {\n  let reversePalindrome = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string.charAt(i) === string.charAt(length - i - 1)) {\n      reversePalindrome = false;\n      break;\n    }\n  }\n  return reversePalindrome;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reversePalindrome('kittens') == true\n  reversePalindrome('kittens') == false\n  */\nconst reversePalindrome = (string) => {\n  let reversePalindrome = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string.charAt(i) === string.charAt(length - i - 1)) {\n      reversePalindrome = false;\n      break;\n    }\n  }\n  return reversePalindrome;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reversePalindrome('kittens') == true\n  reversePalindrome('kittens') == false\n  */\nconst reversePalindrome = (string) => {\n  let reversePalindrome = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string.charAt(i) === string.charAt(length - i - 1)) {\n      reversePalindrome = false;\n      break;\n    }\n  }\n  return reversePalindrome;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reversePalindrome('kittens') == true\n  reversePalindrome('kittens') == false\n  */\nconst reversePalindrome = (string) => {\n  let reversePalindrome = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string.charAt(i) === string.charAt(length - i - 1)) {\n      reversePalindrome = false;\n      break;\n    }\n  }\n  return reversePalindrome;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reversePalindrome('kittens') == true\n  reversePalindrome('kittens') == false\n  */\nconst reversePalindrome = (string) => {\n  let reversePalindrome = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string.charAt(i) === string.charAt(length - i - 1)) {\n      reversePalindrome = false;\n      break;\n    }\n  }\n  return reversePalindrome;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reversePalindrome('kittens') == true\n  reversePalindrome('kittens') == false\n  */\nconst reversePalindrome = (string) => {\n  let reversePalindrome = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string.charAt(i) === string.charAt(length - i - 1)) {\n      reversePalindrome = false;\n      break;\n    }\n  }\n  return reversePalindrome;\n};\n\n/*Write is a function that takes a string and returns true if the string is a palindrome or otherwise wrong\n  Examples\n  reversePalindrome('kittens') == true\n  reversePalindrome('kittens') == false\n  */\nconst reversePalindrome = (string) => {\n  let reversePalindrome = true;\n  let length = string.length;\n  for (let i = length - 1; i >= 0; i--) {\n    if (string.charAt(i) === string.charAt(length - i - 1)) {\n      reversePalindrome = false;\n      break;\n    }\n  }\n  return reversePalindro", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/83", "prompt": "/*\n  For a positive integer n, the number of n-digit positive integers starting or ending with 1 is returned. * / const startsOneEnds = (n) = > {\n", "canonical_solution": "  if (n == 1) { return 1 }\n  let t = 18\n  for (let i = 2; i < n; i++) {\n    t = t * 10\n  }\n  return t\n}\n\n", "test": "const testStartsOneEnds = () => {\n  console.assert(startsOneEnds(1) === 1)\n  console.assert(startsOneEnds(2) === 18)\n  console.assert(startsOneEnds(3) === 180)\n  console.assert(startsOneEnds(4) === 1800)\n  console.assert(startsOneEnds(5) === 18000)\n}\n\ntestStartsOneEnds()\n", "declaration": "\nconst startsOneEnds = (n) => {\n", "example_test": "", "entry_point": "startsOneEnds", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  For a positive integer n, the number of n-digit positive integers starting or ending with 1 is returned. * / const startsOneEnds = (n) = > {\n  n = 0\n  while n <= 9\n    n += n\n  end\n  while n >= 10\n    n -= n\n  end\n  n\n}\n*/\nfunction startsOneEnds(n) {\n  return n <= 9? n : n % 10 + startsWith(n % 10, 1);\n}\n\nfunction endsOneStarts(n) {\n  return n >= 10? n : n % 10 + startsWith(n % 10, 1);\n}\n\nfunction startsWith(str, prefix) {\n  return str.indexOf(prefix, 0) === 0;\n}\n\nfunction endsWith(str, suffix) {\n  return str.indexOf(suffix, str.length - suffix.length)!== -1;\n}\n\nfunction padStart(str, targetLength, padString) {\n  var result = String(str);\n  targetLength = targetLength >> 0;\n  if (targetLength > result.length) {\n    result.length = targetLength;\n  }\n  if (padString!== undefined) {\n    var padding = repeat(padString, targetLength);\n    while (result.length < targetLength) {\n      result += padding;\n    }\n  }\n  return result;\n}\n\nfunction padEnd(str, targetLength, padString) {\n  var result = String(str);\n  targetLength = targetLength >> 0;\n  if (targetLength > result.length) {\n    result.length = targetLength;\n  }\n  if (padString!== undefined) {\n    var padding = repeat(padString, targetLength - result.length);\n    while (result.length < targetLength) {\n      result += padding;\n    }\n  }\n  return result;\n}\n\nfunction repeat(str, n) {\n  var result = '';\n  while (n > 0) result += str;\n  return result;\n}\n\nfunction trim(str) {\n  return str.replace(/^\\s+|\\s+$/g, '');\n}\n\nfunction truncate(str, options) {\n  if (typeof options ==='string') {\n    options = { length: options };\n  } else if (options && options.length) {\n    options = { length: options.length };\n  }\n  var length = options.length;\n  var index = -1;\n  var result = String(str);\n  while (++index < length) {\n    if (result.length < options.length) {\n      break;\n    }\n    var next = index + options.length;\n    result = String(result).slice(0, next);\n  }\n  return result;\n}\n\nfunction words(str, delimiter) {\n  str = trim(str);\n  return words(str.toLowerCase(), delimiter);\n}\n\nfunction lines(str, delimiter) {\n  str = trim(str);\n  return lines(str.toLowerCase(), delimiter);\n}\n\nfunction camelCase(str) {\n  return str.replace(/-+(.)?/g, function(match, chr) {\n    return chr? chr.toUpperCase() : '';\n  });\n}\n\nfunction snakeCase(str) {\n  return str.replace(/[A-Z]/g, function(match) {\n    return match.toLowerCase();\n  });\n}\n\nfunction capitalize(str) {\n  return str[0].toUpperCase() + str.substr(1);\n}\n\nfunction decapitalize(str) {\n  return str.charAt(0).toLowerCase() + str.substr(1);\n}\n\nfunction dasherize(str) {\n  return str.replace(/::/g, '/')\n   .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\n   .replace(/([a-z\\d])([A-Z])/g, '$1_$2')\n   .replace(/_/g, '-')\n   .toLowerCase();\n}\n\nfunction underscore(str) {\n  return str.replace(/([a-z\\d])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\n   .replace(/([a-z\\d])([A-Z])/g, '$1_$2')\n   .replace(/_/g, '-')\n   .toLowerCase();\n}\n\nfunction classify(str) {\n  return str.replace(/(?:^|[-_\\/])(\\w)/g, function(match, chr) {\n    return chr? chr.toUpperCase() : '';\n  });\n}\n\nfunction kebabCase(str) {\n  return str.replace(/([a-z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([a-z])/g, '$1_$2')\n   .replace(/([a-z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '$1_$2')\n   .replace(/([A-Z])([A-Z])/g, '", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/84", "prompt": "/*GIf you use a positive integer N, return the sum total of its digits in binary form.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n", "canonical_solution": "  let t = 0\n  while (N > 0) {\n    t += N % 10\n    N = (N - N % 10) / 10\n  }\n  return t.toString(2)\n}\n\n", "test": "const testSolve = () => {\n  console.assert(solve(1000) === '1')\n  console.assert(solve(150) === '110')\n  console.assert(solve(147) === '1100')\n  console.assert(solve(333) === '1001')\n  console.assert(solve(963) === '10010')\n}\n\ntestSolve()\n", "declaration": "\nconst solve = (N) => {\n", "example_test": "", "entry_point": "solve", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*GIf you use a positive integer N, return the sum total of its digits in binary form.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = N; i >= 0; i--) {\n    sum += parseInt(i.toString(2), 2);\n  }\n  return sum.toString();\n};\n\n/*\n  Given a positive integer N, return the sum of its digits in decimal form.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be 1000.\n      For N = 150, the sum of digits will be 6 the output should be 150.\n      For N = 147, the sum of digits will be 12 the output should be 147.\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of decimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = N; i >= 0; i--) {\n    sum += parseInt(i, 10);\n  }\n  return sum;\n};\n\n/*\n  Given a positive integer N, return the sum of its digits in octal form.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be 1000.\n      For N = 150, the sum of digits will be 6 the output should be 150.\n      For N = 147, the sum of digits will be 12 the output should be 147.\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of octal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = N; i >= 0; i--) {\n    sum += parseInt(i, 8);\n  }\n  return sum;\n};\n\n/*\n  Given a positive integer N, return the sum of its digits in hexadecimal form.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be 1000.\n      For N = 150, the sum of digits will be 6 the output should be 150.\n      For N = 147, the sum of digits will be 12 the output should be 147.\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of hexadecimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = N; i >= 0; i--) {\n    sum += parseInt(i, 16);\n  }\n  return sum;\n};\n\n/*\n  Given a positive integer N, return the sum of its digits in binary form.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = N; i >= 0; i--) {\n    sum += parseInt(i.toString(2), 2);\n  }\n  return sum;\n};\n\n/*\n  Given a positive integer N, return the sum of its digits in decimal form.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be 1000.\n      For N = 150, the sum of digits will be 6 the output should be 150.\n      For N = 147, the sum of digits will be 12 the output should be 147.\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of decimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = N; i >= 0; i--) {\n    sum += parseInt(i, 10);\n  }\n  return sum;\n};\n\n/*\n  Given a positive integer N, return the sum of its digits in octal form.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be 1000.\n      For N = 150, the sum of digits will be 6 the output should be 150.\n      For N = 147, the sum of digits will be 12 the output should be 147.\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of octal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = N; i >= 0; i--) {\n    sum += parseInt(i, 8);\n  }\n  return sum;\n};\n\n/*\n  Given a positive integer N, return the sum of its digits in hexadecimal form.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be 1000.\n      For N = 150, the sum of digits will be 6 the output should be 150.\n      For N = 147, the sum of digits will be 12 the output should be 147.\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of hexadecimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = N; i >= 0; i--) {\n    sum += parseInt(i, 16);\n  }\n  return sum;\n};\n\n/*\n  Given a positive integer N, return the sum of its digits in binary form.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be \"1\".\n      For N = 150, the sum of digits will be 6 the output should be \"110\".\n      For N = 147, the sum of digits will be 12 the output should be \"1100\".\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of binary number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = N; i >= 0; i--) {\n    sum += parseInt(i.toString(2), 2);\n  }\n  return sum;\n};\n\n/*\n  Given a positive integer N, return the sum of its digits in decimal form.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be 1000.\n      For N = 150, the sum of digits will be 6 the output should be 150.\n      For N = 147, the sum of digits will be 12 the output should be 147.\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of decimal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = N; i >= 0; i--) {\n    sum += parseInt(i, 10);\n  }\n  return sum;\n};\n\n/*\n  Given a positive integer N, return the sum of its digits in octal form.\n  \n  Example\n      For N = 1000, the sum of digits will be 1 the output should be 1000.\n      For N = 150, the sum of digits will be 6 the output should be 150.\n      For N = 147, the sum of digits will be 12 the output should be 147.\n  \n  Variables:\n      @N integer\n           Constraints: 0  N  10000.\n  Output:\n       a string of octal number\n  */\nconst solve = (N) => {\n  let sum = 0;\n  for (let i = N; i >= 0; i--) {\n    sum += parseInt(i, 8);", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/85", "prompt": "/*Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 1; i < lst.length; i += 2) {\n    if (lst[i] % 2 == 0) {\n      t += lst[i]\n    }\n  }\n  return t\n}\n\n", "test": "const testAdd = () => {\n  console.assert(add([4, 88]) === 88)\n  console.assert(add([4, 5, 6, 7, 2, 122]) === 122)\n  console.assert(add([4, 0, 6, 7]) === 0)\n  console.assert(add([4, 4, 6, 8]) === 12)\n}\n\ntestAdd()\n", "declaration": "\nconst add = (lst) => {\n", "example_test": "const testAdd = () => {\n  console.assert(add([4, 2, 6, 7]) === 2)\n}\ntestAdd()\n", "entry_point": "add", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*Given a non-empty list of integers lst. add the even elements that are at odd indices..\n\n\n  Examples:\n      add([4, 2, 6, 7]) ==> 2 \n  */\nconst add = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (odd - even > 1) {\n    if (lst[even] % 2 === 0) {\n      even++;\n    } else {\n      odd--;\n    }\n  }\n  return even + lst[even];\n};\n\n/*Given a non-empty list of integers lst. return the maximum element in the list.\n\n\n  Examples:\n      max([4, 2, 6, 7]) ==> 7\n  */\nconst max = (lst) => {\n  let max = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n  }\n  return max;\n};\n\n/*Given a non-empty list of integers lst. return the minimum element in the list.\n\n\n  Examples:\n      min([4, 2, 6, 7]) ==> 4\n  */\nconst min = (lst) => {\n  let min = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < min) {\n      min = lst[i];\n    }\n  }\n  return min;\n};\n\n/*Given a non-empty list of integers lst. return the sum of all the elements in the list.\n\n\n  Examples:\n      sum([4, 2, 6, 7]) ==> 10\n  */\nconst sum = (lst) => {\n  let sum = 0;\n  for (let i = 0; i < lst.length; i++) {\n    sum += lst[i];\n  }\n  return sum;\n};\n\n/*Given a non-empty list of integers lst. return true if all the elements in the list are even.\n\n\n  Examples:\n      isEven([4, 2, 6, 7]) ==> true\n  */\nconst isEven = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (odd - even > 1) {\n    if (lst[even] % 2 === 0) {\n      even++;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Given a non-empty list of integers lst. return true if all the elements in the list are odd.\n\n\n  Examples:\n      isOdd([4, 2, 6, 7]) ==> false\n  */\nconst isOdd = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (odd - even > 1) {\n    if (lst[even] % 2 === 1) {\n      even++;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Given a non-empty list of integers lst. return true if all the elements in the list are divisible by 3.\n\n\n  Examples:\n      isDivisible([4, 2, 6, 7]) ==> true\n  */\nconst isDivisible = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (odd - even > 1) {\n    if (lst[even] % 3 === 0) {\n      even++;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Given a non-empty list of integers lst. return true if all the elements in the list are divisible by 5.\n\n\n  Examples:\n      isDivisible([4, 2, 6, 7]) ==> false\n  */\nconst isDivisibleBy5 = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (odd - even > 1) {\n    if (lst[even] % 5 === 0) {\n      even++;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Given a non-empty list of integers lst. return true if all the elements in the list are divisible by 7.\n\n\n  Examples:\n      isDivisibleBy5([4, 2, 6, 7]) ==> true\n  */\nconst isDivisibleBy7 = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (odd - even > 1) {\n    if (lst[even] % 7 === 0) {\n      even++;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Given a non-empty list of integers lst. return true if all the elements in the list are divisible by 9.\n\n\n  Examples:\n      isDivisibleBy7([4, 2, 6, 7]) ==> false\n  */\nconst isDivisibleBy9 = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (odd - even > 1) {\n    if (lst[even] % 9 === 0) {\n      even++;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Given a non-empty list of integers lst. return true if all the elements in the list are divisible by 11.\n\n\n  Examples:\n      isDivisibleBy9([4, 2, 6, 7]) ==> false\n  */\nconst isDivisibleBy11 = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (odd - even > 1) {\n    if (lst[even] % 11 === 0) {\n      even++;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Given a non-empty list of integers lst. return true if all the elements in the list are divisible by 13.\n\n\n  Examples:\n      isDivisibleBy11([4, 2, 6, 7]) ==> false\n  */\nconst isDivisibleBy13 = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (odd - even > 1) {\n    if (lst[even] % 13 === 0) {\n      even++;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Given a non-empty list of integers lst. return true if all the elements in the list are divisible by 15.\n\n\n  Examples:\n      isDivisibleBy13([4, 2, 6, 7]) ==> false\n  */\nconst isDivisibleBy15 = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (odd - even > 1) {\n    if (lst[even] % 15 === 0) {\n      even++;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Given a non-empty list of integers lst. return true if all the elements in the list are divisible by 17.\n\n\n  Examples:\n      isDivisibleBy15([4, 2, 6, 7]) ==> false\n  */\nconst isDivisibleBy17 = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (odd - even > 1) {\n    if (lst[even] % 17 === 0) {\n      even++;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Given a non-empty list of integers lst. return true if all the elements in the list are divisible by 19.\n\n\n  Examples:\n      isDivisibleBy17([4, 2, 6, 7]) ==> false\n  */\nconst isDivisibleBy19 = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (odd - even > 1) {\n    if (lst[even] % 19 === 0) {\n      even++;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Given a non-empty list of integers lst. return true if all the elements in the list are divisible by 23.\n\n\n  Examples:\n      isDivisibleBy19([4, 2, 6, 7]) ==> false\n  */\nconst isDivisibleBy23 = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (odd - even > 1) {\n    if (lst[even] % 23 === 0) {\n      even++;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Given a non-empty list of integers lst. return true if all the elements in the list are divisible by 29.\n\n\n  Examples:\n      isDivisibleBy23([4, 2, 6, 7]) ==> false\n  */\nconst isDivisibleBy29 = (lst) => {\n  let even = 0;\n  let odd = lst.length;\n  while (odd - even > 1) {\n    if (lst[even] % 29 === 0) {\n      even++;\n    } else {\n      return false;\n    }\n  }\n  return true;\n};\n\n/*Given a non-empty list of integers lst. return true if all the elements in the list are divisible by 31.", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/86", "prompt": "/*\n  Write a function that takes a string and returns an ordered version of it. The ordered version of string is a string in which all words (separated by spaces) are replaced by a new word in which all characters are ordered in ascending order based on the ascii value. Note: You should keep the order of words and spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n", "canonical_solution": "  let arr = s.split(/\\s/)\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      let ind = j\n      for (let k = j + 1; k < arr[i].length; k++) {\n        if (arr[i][k].charCodeAt() < arr[i][ind].charCodeAt()) {\n          ind = k\n        }\n      }\n      if (ind > j) {\n        arr[i] = arr[i].slice(0, j) + arr[i][ind] + arr[i].slice(j + 1, ind) + arr[i][j] + arr[i].slice(ind + 1, arr[i].length)\n      }\n    }\n  }\n  let t = ''\n  for (let i = 0; i < arr.length; i++) {\n    if (i > 0) {\n      t = t + ' '\n    }\n    t = t + arr[i]\n  }\n  return t\n}\n\n", "test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('number') === 'bemnru')\n  console.assert(antiShuffle('abcd') === 'abcd')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n  console.assert(antiShuffle('') === '')\n  console.assert(\n    antiShuffle('Hi. My name is Mister Robot. How are you?') ===\n    '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n  )\n}\n\ntestAntiShuffle()\n", "declaration": "\nconst antiShuffle = (s) => {\n", "example_test": "const testAntiShuffle = () => {\n  console.assert(antiShuffle('Hi') === 'Hi')\n  console.assert(antiShuffle('hello') === 'ehllo')\n  console.assert(antiShuffle('Hello World!!!') === 'Hello !!!Wdlor')\n}\ntestAntiShuffle()\n", "entry_point": "antiShuffle", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that takes a string and returns an ordered version of it. The ordered version of string is a string in which all words (separated by spaces) are replaced by a new word in which all characters are ordered in ascending order based on the ascii value. Note: You should keep the order of words and spaces in the sentence.\n\n  For example:\n  antiShuffle('Hi') returns 'Hi'\n  antiShuffle('hello') returns 'ehllo'\n  antiShuffle('Hello World!!!') returns 'Hello!!!Wdlor'\n  */\nconst antiShuffle = (s) => {\n  let newArr = [];\n  let newStr = '';\n  let wordArr = [];\n  let spaceArr = [];\n  let charArr = [];\n  let newStrArr = [];\n  let newStrArr2 = [];\n  let newStrArr3 = [];\n  let newStrArr4 = [];\n  let newStrArr5 = [];\n  let newStrArr6 = [];\n  let newStrArr7 = [];\n  let newStrArr8 = [];\n  let newStrArr9 = [];\n  let newStrArr10 = [];\n  let newStrArr11 = [];\n  let newStrArr12 = [];\n  let newStrArr13 = [];\n  let newStrArr14 = [];\n  let newStrArr15 = [];\n  let newStrArr16 = [];\n  let newStrArr17 = [];\n  let newStrArr18 = [];\n  let newStrArr19 = [];\n  let newStrArr20 = [];\n  let newStrArr21 = [];\n  let newStrArr22 = [];\n  let newStrArr23 = [];\n  let newStrArr24 = [];\n  let newStrArr25 = [];\n  let newStrArr26 = [];\n  let newStrArr27 = [];\n  let newStrArr28 = [];\n  let newStrArr29 = [];\n  let newStrArr30 = [];\n  let newStrArr31 = [];\n  let newStrArr32 = [];\n  let newStrArr33 = [];\n  let newStrArr34 = [];\n  let newStrArr35 = [];\n  let newStrArr36 = [];\n  let newStrArr37 = [];\n  let newStrArr38 = [];\n  let newStrArr39 = [];\n  let newStrArr40 = [];\n  let newStrArr41 = [];\n  let newStrArr42 = [];\n  let newStrArr43 = [];\n  let newStrArr44 = [];\n  let newStrArr45 = [];\n  let newStrArr46 = [];\n  let newStrArr47 = [];\n  let newStrArr48 = [];\n  let newStrArr49 = [];\n  let newStrArr50 = [];\n  let newStrArr51 = [];\n  let newStrArr52 = [];\n  let newStrArr53 = [];\n  let newStrArr54 = [];\n  let newStrArr55 = [];\n  let newStrArr56 = [];\n  let newStrArr57 = [];\n  let newStrArr58 = [];\n  let newStrArr59 = [];\n  let newStrArr60 = [];\n  let newStrArr61 = [];\n  let newStrArr62 = [];\n  let newStrArr63 = [];\n  let newStrArr64 = [];\n  let newStrArr65 = [];\n  let newStrArr66 = [];\n  let newStrArr67 = [];\n  let newStrArr68 = [];\n  let newStrArr69 = [];\n  let newStrArr70 = [];\n  let newStrArr71 = [];\n  let newStrArr72 = [];\n  let newStrArr73 = [];\n  let newStrArr74 = [];\n  let newStrArr75 = [];\n  let newStrArr76 = [];\n  let newStrArr77 = [];\n  let newStrArr78 = [];\n  let newStrArr79 = [];\n  let newStrArr80 = [];\n  let newStrArr81 = [];\n  let newStrArr82 = [];\n  let newStrArr83 = [];\n  let newStrArr84 = [];\n  let newStrArr85 = [];\n  let newStrArr86 = [];\n  let newStrArr87 = [];\n  let newStrArr88 = [];\n  let newStrArr89 = [];\n  let newStrArr90 = [];\n  let newStrArr91 = [];\n  let newStrArr92 = [];\n  let newStrArr93 = [];\n  let newStrArr94 = [];\n  let newStrArr95 = [];\n  let newStrArr96 = [];\n  let newStrArr97 = [];\n  let newStrArr98 = [];\n  let newStrArr99 = [];\n  let newStrArr100 = [];\n  let newStrArr101 = [];\n  let newStrArr102 = [];\n  let newStrArr103 = [];\n  let newStrArr104 = [];\n  let newStrArr105 = [];\n  let newStrArr106 = [];\n  let newStrArr107 = [];\n  let newStrArr108 = [];\n  let newStrArr109 = [];\n  let newStrArr110 = [];\n  let newStrAr1111 = [];\n  let newStrArr112 = [];\n  let newStrArr113 = [];\n  let newStrArr114 = [];\n  let newStrArr115 = [];\n  let newStrArr116 = [];\n  let newStrArr117 = [];\n  let newStrArr118 = [];\n  let newStrArr119 = [];\n  let newStrArr120 = [];\n  let newStrAr121 = [];\n  let newStrAr122 = [];\n  let newStrAr123 = [];\n  let newStrArr124 = [];\n  let newStrArr125 = [];\n  let newStrArr126 = [];\n  let newStrArr127 = [];\n  let newStrArr128 = [];\n  let newStrArr129 = [];\n  let newStrArr130 = [];\n  let newStrArr131 = [];\n  let newStrArr132 = [];\n  let newStrArr133 = [];\n  let newStrArr134 = [];\n  let newStrArr135 = [];\n  let newStrArr136 = [];\n  let newStrArr137 = [];\n  let newStrArr138 = [];\n  let newStrArr139 = [];\n  let newStrArr140 = [];\n  let newStrArr141 = [];\n  let newStrArr142 = [];\n  let newStrArr143 = [];\n  let newStrArr144 = [];\n  let newStrArr145 = [];\n  let newStrArr146 = [];\n  let newStrArr147 = [];\n  let newStrArr148 = [];\n  let newStrArr149 = [];\n  let newStrArr150 = [];\n  let newStrArr151 = [];\n  let newStrArr152 = [];\n  let newStrArr153 = [];\n  let newStrArr154 = [];\n  let newStrArr155 = [];\n  let newStrArr156 = [];\n  let newStrArr157 = [];\n  let newStrArr158 = [];\n  let newStrArr159 = [];\n  let newStrArr160 = [];\n  let newStrArr161 = [];\n  let newStrArr162 = [];\n  let newStrArr163 = [];\n  let newStrArr164 = [];\n  let newStrArr165 = [];\n  let newStrArr166 = [];\n  let newStrArr167 = [];\n  let newStrArr168 = [];\n  let newStrArr169 = [];\n  let newStrArr170 = [];\n  let newStrArr171 = [];\n  let newStrArr172 = [];\n  let newStrArr173 = [];\n  let newStrArr174 = [];\n  let newStrArr175 = [];\n  let newStrArr176 = [];\n  let newStrArr177 = [];\n  let newStrArr178 = [];\n  let newStrArr179 = [];\n  let newStrArr180 = [];\n  let newStrArr181 = [];\n  let newStrArr182 = [];\n  let newStrArr183 = [];\n  let newStrArr184 = [];\n  let newStrArr185 = [];\n  let newStrArr186 = [];\n  let newStrArr187 = [];\n  let newStrArr188 = [];\n  let newStrArr189 = [];\n  let newStrArr190 = [];\n  let newStrArr191 = [];\n  let newStrArr192 = [];\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/87", "prompt": "/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n", "canonical_solution": "  let t = []\n  for (let i = 0; i < lst.length; i++) {\n    for (let j = lst[i].length - 1; j >= 0; j--) {\n      if (lst[i][j] == x) {\n        t.push((i, j))\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n        ],\n        2\n      )\n    ) === JSON.stringify([(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n  )\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 5, 6],\n          [1, 1, 3, 4, 5, 6],\n          [1, 2, 1, 4, 5, 6],\n          [1, 2, 3, 1, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) ===\n    JSON.stringify([\n      (0, 0),\n      (1, 0),\n      (2, 1),\n      (2, 0),\n      (3, 2),\n      (3, 0),\n      (4, 3),\n      (4, 0),\n      (5, 4),\n      (5, 0),\n      (6, 5),\n      (6, 0),\n    ])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(JSON.stringify(getRow([[1]], 2)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\n\ntestGetRow()\n", "declaration": "\nconst getRow = (lst, x) => {\n", "example_test": "const testGetRow = () => {\n  console.assert(\n    JSON.stringify(\n      getRow(\n        [\n          [1, 2, 3, 4, 5, 6],\n          [1, 2, 3, 4, 1, 6],\n          [1, 2, 3, 4, 5, 1],\n        ],\n        1\n      )\n    ) === JSON.stringify([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n  )\n  console.assert(JSON.stringify(getRow([], 1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(getRow([[], [1], [1, 2, 3]], 3)) === JSON.stringify([(2, 2)])\n  )\n}\ntestGetRow()\n", "entry_point": "getRow", "seed": 0, "perturbed": false, "gc": "<|endoftext|>/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRow = (lst, x) => {\n  const row = []\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i]\n    if (row[x]!== undefined) {\n      row.push([row[x], i])\n    }\n  }\n  row.sort((a, b) => b[1] - a[1])\n  return row\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getCol = (lst, x) => {\n  const col = []\n  for (let i = 0; i < lst.length; i++) {\n    const col = lst[i]\n    if (col[x]!== undefined) {\n      col.push([col[x], i])\n    }\n  }\n  col.sort((a, b) => a[1] - b[1])\n  return col\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRowCol = (lst, x) => {\n  const row = []\n  const col = []\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i]\n    const col = lst[i]\n    if (row[x]!== undefined) {\n      row.push([row[x], i])\n    }\n    if (col[x]!== undefined) {\n      col.push([col[x], i])\n    }\n  }\n  row.sort((a, b) => b[1] - a[1])\n  col.sort((a, b) => a[1] - b[1])\n  return [row, col]\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRowColRow = (lst, x) => {\n  const row = []\n  const col = []\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i]\n    const col = lst[i]\n    if (row[x]!== undefined) {\n      row.push([row[x], i])\n    }\n    if (col[x]!== undefined) {\n      col.push([col[x], i])\n    }\n  }\n  row.sort((a, b) => b[1] - a[1])\n  col.sort((a, b) => a[1] - b[1])\n  return [row, col]\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRowColColRow = (lst, x) => {\n  const row = []\n  const col = []\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i]\n    const col = lst[i]\n    if (row[x]!== undefined) {\n      row.push([row[x], i])\n    }\n    if (col[x]!== undefined) {\n      col.push([col[x], i])\n    }\n  }\n  row.sort((a, b) => b[1] - a[1])\n  col.sort((a, b) => a[1] - b[1])\n  return [row, col]\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is similar to matrix, however, unlike matrices,\n  each row may contain a different number of columns.\n  Given lst, and integer x, find integers x in the list,\n  and return list of tuples, [(x1, y1), (x2, y2)...] such that\n  each tuple is a coordinate - (row, columns), starting with 0.\n  Sort coordinates initially by rows in ascending order.\n  Also, sort coordinates of the row by columns in descending order.\n  \n  Examples:\n  getRow([\n    [1,2,3,4,5,6],\n    [1,2,3,4,1,6],\n    [1,2,3,4,5,1]\n  ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n  getRow([], 1) == []\n  getRow([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n  */\nconst getRowColColColRow = (lst, x) => {\n  const row = []\n  const col = []\n  for (let i = 0; i < lst.length; i++) {\n    const row = lst[i]\n    const col = lst[i]\n    if (row[x]!== undefined) {\n      row.push([row[x], i])\n    }\n    if (col[x]!== undefined) {\n      col.push([col[x], i])\n    }\n  }\n  row.sort((a, b) => b[1] - a[1])\n  col.sort((a, b) => a[1] - b[1])\n  return [row, col]\n}\n\n/*\n  You are given a 2 dimensional data, as a nested lists,\n  which is ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/88", "prompt": "/*\n  For an array of non-negative integers, return a copy of the given array after sorting. You sort the given array in ascending order if the sum (first index value, last index value) is odd, or sort it in descending order if the sum (first index value, last index value) is even. Note: * Do not change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n", "canonical_solution": "  let arr = array\n  let tot = arr[0] + arr[arr.length-1]\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if ((tot % 2 == 1 && arr[k] < arr[ind]) || (tot % 2 == 0 && arr[k] > arr[ind])) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  return arr\n}\n\n", "test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n  console.assert(JSON.stringify(sortArray([2, 1])) === JSON.stringify([1, 2]))\n  console.assert(JSON.stringify(sortArray([15, 42, 87, 32, 11, 0])) === JSON.stringify([0, 11, 15, 32, 42, 87]))\n  console.assert(JSON.stringify(sortArray([21, 14, 23, 11])) === JSON.stringify([23, 21, 14, 11]))\n}\n\ntestSortArray()\n", "declaration": "\nconst sortArray = (array) => {\n", "example_test": "const testSortArray = () => {\n  console.assert(JSON.stringify(sortArray([])) === JSON.stringify([]))\n  console.assert(JSON.stringify(sortArray([5])) === JSON.stringify([5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5])) === JSON.stringify([0, 1, 2, 3, 4, 5]))\n  console.assert(JSON.stringify(sortArray([2, 4, 3, 0, 1, 5, 6])) === JSON.stringify([6, 5, 4, 3, 2, 1, 0]))\n}\ntestSortArray()\n", "entry_point": "sortArray", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  For an array of non-negative integers, return a copy of the given array after sorting. You sort the given array in ascending order if the sum (first index value, last index value) is odd, or sort it in descending order if the sum (first index value, last index value) is even. Note: * Do not change the given array.\n\n  Examples:\n  * sortArray([]) => []\n  * sortArray([5]) => [5]\n  * sortArray([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n  * sortArray([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n  */\nconst sortArray = (array) => {\n  const sortedArray = array.sort((a, b) => a + b);\n  return sortedArray;\n};\n\n/**\n * Given an array of non-negative integers, return the number of distinct values present in that array. Note: * Do not change the given array.\n\n  Examples:\n  * distinct([1, 2, 3, 4]) => 4\n  * distinct([1, 1, 2, 3, 4]) => 3\n  * distinct([1, 1, 2, 3, 5, 4]) => 2\n  * distinct([1, 1, 2, 3, 5, 6, 4]) => 1\n  */\nconst distinct = (array) => {\n  let count = 0;\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given an array of non-negative integers, return the number of distinct values present in that array. Note: * Do not change the given array.\n\n  Examples:\n  * distinct([1, 2, 3, 4]) => 4\n  * distinct([1, 1, 2, 3, 4]) => 3\n  * distinct([1, 1, 2, 3, 5, 4]) => 2\n  * distinct([1, 1, 2, 3, 5, 6, 4]) => 1\n  */\nconst distinctArray = (array) => {\n  let count = 0;\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given an array of non-negative integers, return the number of distinct values present in that array. Note: * Do not change the given array.\n\n  Examples:\n  * distinct([1, 2, 3, 4]) => 4\n  * distinct([1, 1, 2, 3, 4]) => 3\n  * distinct([1, 1, 2, 3, 5, 4]) => 2\n  * distinct([1, 1, 2, 3, 5, 6, 4]) => 1\n  */\nconst distinctArray2 = (array) => {\n  let count = 0;\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given an array of non-negative integers, return the number of distinct values present in that array. Note: * Do not change the given array.\n\n  Examples:\n  * distinct([1, 2, 3, 4]) => 4\n  * distinct([1, 1, 2, 3, 4]) => 3\n  * distinct([1, 1, 2, 3, 5, 4]) => 2\n  * distinct([1, 1, 2, 3, 5, 6, 4]) => 1\n  */\nconst distinctArray3 = (array) => {\n  let count = 0;\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given an array of non-negative integers, return the number of distinct values present in that array. Note: * Do not change the given array.\n\n  Examples:\n  * distinct([1, 2, 3, 4]) => 4\n  * distinct([1, 1, 2, 3, 4]) => 3\n  * distinct([1, 1, 2, 3, 5, 4]) => 2\n  * distinct([1, 1, 2, 3, 5, 6, 4]) => 1\n  */\nconst distinctArray4 = (array) => {\n  let count = 0;\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given an array of non-negative integers, return the number of distinct values present in that array. Note: * Do not change the given array.\n\n  Examples:\n  * distinct([1, 2, 3, 4]) => 4\n  * distinct([1, 1, 2, 3, 4]) => 3\n  * distinct([1, 1, 2, 3, 5, 4]) => 2\n  * distinct([1, 1, 2, 3, 5, 6, 4]) => 1\n  */\nconst distinctArray5 = (array) => {\n  let count = 0;\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given an array of non-negative integers, return the number of distinct values present in that array. Note: * Do not change the given array.\n\n  Examples:\n  * distinct([1, 2, 3, 4]) => 4\n  * distinct([1, 1, 2, 3, 4]) => 3\n  * distinct([1, 1, 2, 3, 5, 4]) => 2\n  * distinct([1, 1, 2, 3, 5, 6, 4]) => 1\n  */\nconst distinctArray6 = (array) => {\n  let count = 0;\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given an array of non-negative integers, return the number of distinct values present in that array. Note: * Do not change the given array.\n\n  Examples:\n  * distinct([1, 2, 3, 4]) => 4\n  * distinct([1, 1, 2, 3, 4]) => 3\n  * distinct([1, 1, 2, 3, 5, 4]) => 2\n  * distinct([1, 1, 2, 3, 5, 6, 4]) => 1\n  */\nconst distinctArray7 = (array) => {\n  let count = 0;\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given an array of non-negative integers, return the number of distinct values present in that array. Note: * Do not change the given array.\n\n  Examples:\n  * distinct([1, 2, 3, 4]) => 4\n  * distinct([1, 1, 2, 3, 4]) => 3\n  * distinct([1, 1, 2, 3, 5, 4]) => 2\n  * distinct([1, 1, 2, 3, 5, 6, 4]) => 1\n  */\nconst distinctArray8 = (array) => {\n  let count = 0;\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given an array of non-negative integers, return the number of distinct values present in that array. Note: * Do not change the given array.\n\n  Examples:\n  * distinct([1, 2, 3, 4]) => 4\n  * distinct([1, 1, 2, 3, 4]) => 3\n  * distinct([1, 1, 2, 3, 5, 4]) => 2\n  * distinct([1, 1, 2, 3, 5, 6, 4]) => 1\n  */\nconst distinctArray9 = (array) => {\n  let count = 0;\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given an array of non-negative integers, return the number of distinct values present in that array. Note: * Do not change the given array.\n\n  Examples:\n  * distinct([1, 2, 3, 4]) => 4\n  * distinct([1, 1, 2, 3, 4]) => 3\n  * distinct([1, 1, 2, 3, 5, 4]) => 2\n  * distinct([1, 1, 2, 3, 5, 6, 4]) => 1\n  */\nconst distinctArray10 = (array) => {\n  let count = 0;\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given an array of non-negative integers, return the number of distinct values present in that array. Note: * Do not change the given array.\n\n  Examples:\n  * distinct([1, 2, 3, 4]) => 4\n  * distinct([1, 1, 2, 3, 4]) => 3\n  * distinct([1, 1, 2, 3, 5, 4]) => 2\n  * distinct([1, 1, 2, 3, 5, 6, 4]) => 1\n  */\nconst distinctArray11 = (array) => {\n  let count = 0;\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given an array of non-negative integers, return the number of distinct values present in that array. Note: * Do not change the given array.\n\n  Examples:\n  * distinct([1, 2, 3, 4]) => 4\n  * distinct([1, 1, 2, 3, 4]) => 3\n  * distinct([1, 1, 2, 3, 5, 4]) => 2\n  * distinct([1, 1, 2, 3, 5, 6, 4]) => 1\n  */\nconst distinctArray12 = (array) => {\n  let count = 0;\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] === 1) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\n * Given an array of non-negative integers, return the number of distinct values present in that array. Note: * Do not change the given array.\n\n  Examples:\n  * distinct([1, 2, 3, 4]) => 4\n  * distinct([1, 1, 2, 3, 4]) => 3\n  * distinct([1, 1, 2, 3, 5, 4]) => 2\n  * distinct([1, 1, 2, 3, 5, 6, 4]) => 1\n  */\nconst distinctArray13 = (array) => {\n  let count = 0;\n", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/89", "prompt": "/*CEncrypt a function that takes a string as argument and returns a string that is encrypted with the rotating alphabet. Rotate the alphabet so that the letters move down by two multiplied by two digits.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < s.length; i++) {\n    let p = s[i].charCodeAt() + 4\n    if (p > 122) { p -= 26 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n  console.assert(encrypt('faewfawefaewg') === 'jeiajeaijeiak')\n  console.assert(encrypt('hellomyfriend') === 'lippsqcjvmirh')\n  console.assert(\n    encrypt('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh') ===\n    'hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl'\n  )\n  console.assert(encrypt('a') === 'e')\n}\n\ntestEncrypt()\n", "declaration": "\nconst encrypt = (s) => {\n", "example_test": "const testEncrypt = () => {\n  console.assert(encrypt('hi') === 'lm')\n  console.assert(encrypt('asdfghjkl') === 'ewhjklnop')\n  console.assert(encrypt('gf') === 'kj')\n  console.assert(encrypt('et') === 'ix')\n}\ntestEncrypt()\n", "entry_point": "encrypt", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*CEncrypt a function that takes a string as argument and returns a string that is encrypted with the rotating alphabet. Rotate the alphabet so that the letters move down by two multiplied by two digits.\n  For example:\n  encrypt('hi') returns 'lm'\n  encrypt('asdfghjkl') returns 'ewhjklnop'\n  encrypt('gf') returns 'kj'\n  encrypt('et') returns 'ix'\n  */\nconst encrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotated = '';\n  for (let i = 0; i < s.length; i++) {\n    let letter = alphabet.charAt(i);\n    rotated += letter;\n  }\n  return rotated;\n};\n\n/*\n  Decrypt a function that takes a string as argument and returns a string that is decrypted with the rotating alphabet. Rotate the alphabet so that the letters move up by two multiplied by two digits.\n  For example:\n  decrypt('lm') returns 'hi'\n  decrypt('ewhjklnop') returns 'asdfghjkl'\n  decrypt('kj') returns 'gf'\n  decrypt('ix') returns 'et'\n  */\nconst decrypt = (s) => {\n  let alphabet = 'abcdefghijklmnopqrstuvwxyz';\n  let rotated = '';\n  for (let i = 0; i < s.length; i++) {\n    let letter = alphabet.charAt(i);\n    rotated += letter;\n  }\n  return rotated;\n};\n\n/*\n  A function that takes an integer as argument and returns a string that is rotated n times.\n  For example:\n  rotateN(3) returns 'defghijklmnopqrstuvwxyz'\n  rotateN(2) returns 'cdefghijklmnopqrstuvwxyz'\n  rotateN(1) returns 'bcdefghijklmnopqrstuvwxyz'\n  rotateN(0) returns 'abcdefghijklmnopqrstuvwxyz'\n  rotateN(-1) returns 'bcdefghijklmnopqrstuvwxyz'\n  rotateN(-2) returns 'cdefghijklmnopqrstuvwxyz'\n  rotateN(-3) returns 'defghijklmnopqrstuvwxyz'\n  rotateN(-4) returns 'bcdefghijklmnopqrstuvwxyz'\n  rotateN(-5) returns 'cdefghijklmnopqrstuvwxyz'\n  rotateN(-6) returns 'abcdefghijklmnopqrstuvwxyz'\n  rotateN(-7) returns 'bcdefghijklmnopqrstuvwxyz'\n  rotateN(-8) returns 'cdefghijklmnopqrstuvwxyz'\n  rotateN(-9) returns 'defghijklmnopqrstuvwxyz'\n  rotateN(-10) returns 'bcdefghijklmnopqrstuvwxyz'\n  rotateN(-11) returns 'cdefghijklmnopqrstuvwxyz'\n  rotateN(-12) returns 'abcdefghijklmnopqrstuvwxyz'\n  rotateN(-13) returns 'bcdefghijklmnopqrstuvwxyz'\n  rotateN(-14) returns 'cdefghijklmnopqrstuvwxyz'\n  rotateN(-15) returns 'defghijklmnopqrstuvwxyz'\n  rotateN(-16) returns 'bcdefghijklmnopqrstuvwxyz'\n  rotateN(-17) returns 'cdefghijklmnopqrstuvwxyz'\n  rotateN(-18) returns 'defghijklmnopqrstuvwxyz'\n  rotateN(-19) returns 'bcdefghijklmnopqrstuvwxyz'\n  rotateN(-20) returns 'cdefghijklmnopqrstuvwxyz'\n  rotateN(-21) returns 'abcdefghijklmnopqrstuvwxyz'\n  rotateN(-22) returns 'bcdefghijklmnopqrstuvwxyz'\n  rotateN(-23) returns 'cdefghijklmnopqrstuvwxyz'\n  rotateN(-24) returns 'abcdefghijklmnopqrstuvwxyz'\n  rotateN(-25) returns 'bcdefghijklmnopqrstuvwxyz'\n  rotateN(-26) returns 'cdefghijklmnopqrstuvwxyz'\n  rotateN(-27) returns 'abcdefghijklmnopqrstuvwxyz'\n  rotateN(-28) returns 'bcdefghijklmnopqrstuvwxyz'\n  rotateN(-29) returns 'cdefghijklmnopqrstuvwxyz'\n  rotateN(-30) returns 'abcdefghijklmnopqrstuvwxyz'\n  rotateN(-31) returns 'bcdefghijklmnopqrstuvwxyz'\n  rotateN(-32) returns 'cdefghijklmnopqrstuvwxyz'\n  rotateN(-33) returns 'abcdefghijklmnopqrstuvwxyz'\n  rotateN(-34) returns 'bcdefghijklmnopqrstuvwxyz'\n  rotateN(-35) returns 'cdefghijklmnopqrstuvwxyz'\n  rotateN(-36) returns 'abcdefghijklmnopqrstuvwxyz'\n  rotateN(-37) returns 'bcdefghijklmnopqrstuvwxyz'\n  rotateN(-38) returns 'cdefghijklmnopqrstuvwxyz'\n  rotateN(-39) returns 'abcdefghijklmnopqrstuvwxyz'\n  rotateN(-40) returns 'bcdefghijklmnopqrstuvwxyz'\n  rotateN(-41) returns 'cdefghijklmnopqrstuvwxyz'\n  rotateN(-42) returns 'abcdefghijklmnopqrstuvwxyz'\n  rotateN(-43) returns 'bcdefghijklmnopqrstuvwxyz'\n  rotateN(-44) returns 'cdefghijklmnopqrstuvwxyz'\n  rotateN(-45) returns 'abcdefghijklmnopqrstuvwxyz'\n  rotateN(-46) returns 'bcdefghijklmnopqrstuvwxyz'\n  rotateN(-47) returns 'cdefghijklmnopqrstuvwxyz'\n  rotateN(-48) returns 'abcdefghijklmnopqrstuvwxyz'\n  rotateN(-49) returns 'bcdefghijklmnopqrstuvwxyz'\n  rotateN(-50) returns 'cdefghijklmnopqrstuvwxyz'\n  rotateN(-51) returns 'abcdefghijklmnopqrstuvwxyz'\n  rotateN(-52) returns 'bcdefghijklmnopqrstuvwxyz'\n  rotateN(-53) returns 'cdefghijklmnopqrstuvw", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/9", "prompt": "/* Generate from a given list of integers a list of rotating maximum elements found up to a certain moment in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n", "canonical_solution": "  var running_max, result = [];\n  for (const n of numbers) {\n    if (running_max == undefined)\n      running_max = n;\n    else\n      running_max = Math.max(running_max, n);\n    result.push(running_max);\n  }\n  return result;\n}\n\n", "test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([])) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(rollingMax([1, 2, 3, 4])) === JSON.stringify([1, 2, 3, 4])\n  )\n  console.assert(\n    JSON.stringify(rollingMax([4, 3, 2, 1])) === JSON.stringify([4, 4, 4, 4])\n  )\n  console.assert(\n    JSON.stringify(\n      rollingMax([3, 2, 3, 100, 3])) === JSON.stringify([3, 3, 3, 100, 100])\n  )\n}\n\ntestRollingMax()\n", "declaration": "\nconst rollingMax = (numbers) => {\n", "example_test": "const testRollingMax = () => {\n  console.assert(JSON.stringify(rollingMax([1, 2, 3, 2, 3, 4, 2])) === JSON.stringify([1, 2, 3, 3, 3, 4, 4]))\n}\ntestRollingMax()\n", "entry_point": "rollingMax", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Generate from a given list of integers a list of rotating maximum elements found up to a certain moment in the sequence.\n  >>> rollingMax([1, 2, 3, 2, 3, 4, 2])\n  [1, 2, 3, 3, 3, 4, 4]\n  */\nconst rollingMax = (numbers) => {\n  const maxElement = numbers.reduce((acc, curr) => Math.max(acc, curr), 0);\n  return numbers.map((curr) => curr > maxElement? curr : maxElement);\n};\n\n/**\n * A helper function to convert a number to a string with thousands separators.\n * If no thousands separator is specified, it defaults to a comma\n * \n * >>> toThousands(123)\n * '123'\n * >>> toThousands(123, ',')\n * '12,000'\n * >>> toThousands(123, ',', 2)\n * '12,000'\n * >>> toThousands(123, ',', 3)\n * '1,234'\n * >>> toThousands(123, ',', 4)\n * '1,234,000'\n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * \n * ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/90", "prompt": "/*\n  Write a function nextSmallest () that returns the second smallest element in the list. Returns zero if there is no such element. nextSmallest ([1, 2, 3, 4, 5]) = = 2 nextSmallest ([5, 1, 4, 3, 2]) = = 2 nextSmallest ([]) = = null nextSmallest ([1, 1]) = = null * / const nextSmallest = (lst) = > {\n", "canonical_solution": "  let arr = lst\n  for (let j = 0; j < arr.length; j++) {\n    let ind = j\n    for (let k = j + 1; k < arr.length; k++) {\n      if (arr[k] < arr[ind]) {\n        ind = k\n      }\n    }\n    let tmp = arr[j]\n    arr[j] = arr[ind]\n    arr[ind] = tmp\n  }\n  let smallest = arr[0]\n  let pt = 1\n  while(pt<arr.length){\n    if(arr[pt]>smallest){\n      return arr[pt]\n    }\n    pt++\n  }\n  return null\n}\n\n", "test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n  console.assert(nextSmallest([1, 1, 1, 1, 0]) === 1)\n  console.assert(nextSmallest([1, 0 ** 0]) === null)\n  console.assert(nextSmallest([-35, 34, 12, -45]) === -35)\n}\n\ntestNextSmallest()\n", "declaration": "\nconst nextSmallest = (lst) => {\n", "example_test": "const testNextSmallest = () => {\n  console.assert(nextSmallest([1, 2, 3, 4, 5]) === 2)\n  console.assert(nextSmallest([5, 1, 4, 3, 2]) === 2)\n  console.assert(nextSmallest([]) === null)\n  console.assert(nextSmallest([1, 1]) === null)\n}\ntestNextSmallest()\n", "entry_point": "nextSmallest", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function nextSmallest () that returns the second smallest element in the list. Returns zero if there is no such element. nextSmallest ([1, 2, 3, 4, 5]) = = 2 nextSmallest ([5, 1, 4, 3, 2]) = = 2 nextSmallest ([]) = = null nextSmallest ([1, 1]) = = null * / const nextSmallest = (lst) = > {\n    if (lst == null || lst.length == 0) {\n      return null;\n    }\n    let smallest = lst[0];\n    for (let i = 1; i < lst.length; i++) {\n      if (lst[i] < smallest) {\n        smallest = lst[i];\n      }\n    }\n    return smallest;\n  }\n*/\nconst nextSmallest = (lst) => {\n  if (lst == null || lst.length == 0) {\n    return null;\n  }\n  let smallest = lst[0];\n  for (let i = 1; i < lst.length; i++) {\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest2 = (lst, i) => {\n  if (lst == null || lst.length == 0) {\n    return null;\n  }\n  let smallest = lst[i];\n  for (let j = i + 1; j < lst.length; j++) {\n    if (lst[j] < smallest) {\n      smallest = lst[j];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest3 = (lst, i) => {\n  if (lst == null || lst.length == 0) {\n    return null;\n  }\n  let smallest = lst[i];\n  for (let j = i + 1; j < lst.length; j++) {\n    if (lst[j] < smallest) {\n      smallest = lst[j];\n    }\n  }\n  for (let k = i; k < lst.length; k++) {\n    if (lst[k] < smallest) {\n      smallest = lst[k];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest4 = (lst, i) => {\n  if (lst == null || lst.length == 0) {\n    return null;\n  }\n  let smallest = lst[i];\n  for (let j = i + 1; j < lst.length; j++) {\n    if (lst[j] < smallest) {\n      smallest = lst[j];\n    }\n  }\n  for (let k = i; k < lst.length; k++) {\n    if (lst[k] < smallest) {\n      smallest = lst[k];\n    }\n  }\n  for (let l = i + 1; l < lst.length; l++) {\n    if (lst[l] < smallest) {\n      smallest = lst[l];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest5 = (lst, i) => {\n  if (lst == null || lst.length == 0) {\n    return null;\n  }\n  let smallest = lst[i];\n  for (let j = i + 1; j < lst.length; j++) {\n    if (lst[j] < smallest) {\n      smallest = lst[j];\n    }\n  }\n  for (let k = i; k < lst.length; k++) {\n    if (lst[k] < smallest) {\n      smallest = lst[k];\n    }\n  }\n  for (let l = i + 1; l < lst.length; l++) {\n    if (lst[l] < smallest) {\n      smallest = lst[l];\n    }\n  }\n  for (let m = i + 1; m < lst.length; m++) {\n    if (lst[m] < smallest) {\n      smallest = lst[m];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest6 = (lst, i) => {\n  if (lst == null || lst.length == 0) {\n    return null;\n  }\n  let smallest = lst[i];\n  for (let j = i + 1; j < lst.length; j++) {\n    if (lst[j] < smallest) {\n      smallest = lst[j];\n    }\n  }\n  for (let k = i; k < lst.length; k++) {\n    if (lst[k] < smallest) {\n      smallest = lst[k];\n    }\n  }\n  for (let l = i + 1; l < lst.length; l++) {\n    if (lst[l] < smallest) {\n      smallest = lst[l];\n    }\n  }\n  for (let m = i + 1; m < lst.length; m++) {\n    if (lst[m] < smallest) {\n      smallest = lst[m];\n    }\n  }\n  for (let n = i + 1; n < lst.length; n++) {\n    if (lst[n] < smallest) {\n      smallest = lst[n];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest7 = (lst, i) => {\n  if (lst == null || lst.length == 0) {\n    return null;\n  }\n  let smallest = lst[i];\n  for (let j = i + 1; j < lst.length; j++) {\n    if (lst[j] < smallest) {\n      smallest = lst[j];\n    }\n  }\n  for (let k = i; k < lst.length; k++) {\n    if (lst[k] < smallest) {\n      smallest = lst[k];\n    }\n  }\n  for (let l = i + 1; l < lst.length; l++) {\n    if (lst[l] < smallest) {\n      smallest = lst[l];\n    }\n  }\n  for (let m = i + 1; m < lst.length; m++) {\n    if (lst[m] < smallest) {\n      smallest = lst[m];\n    }\n  }\n  for (let n = i + 1; n < lst.length; n++) {\n    if (lst[n] < smallest) {\n      smallest = lst[n];\n    }\n  }\n  for (let o = i + 1; o < lst.length; o++) {\n    if (lst[o] < smallest) {\n      smallest = lst[o];\n    }\n  }\n  for (let p = i + 1; p < lst.length; p++) {\n    if (lst[p] < smallest) {\n      smallest = lst[p];\n    }\n  }\n  for (let q = i + 1; q < lst.length; q++) {\n    if (lst[q] < smallest) {\n      smallest = lst[q];\n    }\n  }\n  for (let r = i + 1; r < lst.length; r++) {\n    if (lst[r] < smallest) {\n      smallest = lst[r];\n    }\n  }\n  for (let s = i + 1; s < lst.length; s++) {\n    if (lst[s] < smallest) {\n      smallest = lst[s];\n    }\n  }\n  for (let t = i + 1; t < lst.length; t++) {\n    if (lst[t] < smallest) {\n      smallest = lst[t];\n    }\n  }\n  for (let u = i + 1; u < lst.length; u++) {\n    if (lst[u] < smallest) {\n      smallest = lst[u];\n    }\n  }\n  for (let v = i + 1; v < lst.length; v++) {\n    if (lst[v] < smallest) {\n      smallest = lst[v];\n    }\n  }\n  for (let w = i + 1; w < lst.length; w++) {\n    if (lst[w] < smallest) {\n      smallest = lst[w];\n    }\n  }\n  for (let x = i + 1; x < lst.length; x++) {\n    if (lst[x] < smallest) {\n      smallest = lst[x];\n    }\n  }\n  for (let y = i + 1; y < lst.length; y++) {\n    if (lst[y] < smallest) {\n      smallest = lst[y];\n    }\n  }\n  for (let z = i + 1; z < lst.length; z++) {\n    if (lst[z] < smallest) {\n      smallest = lst[z];\n    }\n  }\n  return smallest;\n};\n\nconst nextSmallest8 = (lst, i) => {\n  if (lst == null || lst.length == 0) {\n    return null;\n  }\n  let smallest = lst[i];\n  for (let j = i + 1; j < lst.length; j++) {\n    if (lst[j] < smallest) {\n      smallest = lst[j];\n    }\n  }\n  for (let k = i; k < lst.length; k++) {\n    if (lst[k] < smallest) {\n      smallest = lst[k];\n    }\n  }\n  for (let l = i + 1; l < lst.length; l++) {\n    if (lst[l] < smallest) {\n      smallest = lst[l];\n    }\n  }\n  for (let m = i + 1; m < lst.length; m", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/91", "prompt": "/*\n  Boredom is a sentence that begins with the word \"I.\" Sentences are delimited by. \",\"? \"or\"!. \"For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n", "canonical_solution": "  let t = 0\n  if (S[0] == 'I' && S[1] == ' ') { t = 1 }\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] == '.' || S[i] == '!' || S[i] == '?') {\n      if (S[i + 1] == ' ' && S[i + 2] == 'I' && S[i + 3] == ' ') {\n        t++\n      }\n    }\n  }\n  return t\n}\n\n", "test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('Is the sky blue?') === 0)\n  console.assert(isBored('I love It !') === 1)\n  console.assert(isBored('bIt') === 0)\n  console.assert(\n    isBored('I feel good today. I will be productive. will kill It') === 2\n  )\n  console.assert(isBored('You and I are going for a walk') === 0)\n}\n\ntestIsBored()\n", "declaration": "\nconst isBored = (S) => {\n", "example_test": "const testIsBored = () => {\n  console.assert(isBored('Hello world') === 0)\n  console.assert(isBored('The sky is blue. The sun is shining. I love this weather') === 1)\n}\ntestIsBored()\n", "entry_point": "isBored", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Boredom is a sentence that begins with the word \"I.\" Sentences are delimited by. \",\"? \"or\"!. \"For example:\n  >>> isBored(\"Hello world\")\n  0\n  >>> isBored(\"The sky is blue. The sun is shining. I love this weather\")\n  1\n  */\nconst isBored = (S) => {\n  const boredWords = [\"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.\", \"I.", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/92", "prompt": "/* Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n", "canonical_solution": "  if (x % 1 === 0 && y % 1 === 0 && z % 1 === 0 && (x + y === z || x + z === y || x === y + z)) {\n    return true\n  }\n  return false\n}\n\n", "test": "const testAnyInt = () => {\n  console.assert(anyInt(2, 3, 1) === true)\n  console.assert(anyInt(2.5, 2, 3) === false)\n  console.assert(anyInt(1.5, 5, 3.5) === false)\n  console.assert(anyInt(2, 6, 2) === false)\n  console.assert(anyInt(4, 2, 2) === true)\n  console.assert(anyInt(2.2, 2.2, 2.2) === false)\n  console.assert(anyInt(-4, 6, 2) === true)\n  console.assert(anyInt(2, 1, 1) === true)\n  console.assert(anyInt(3, 4, 7) === true)\n  console.assert(anyInt(3.0, 4, 7) === true)\n}\n\ntestAnyInt()\n", "declaration": "\nconst anyInt = (x, y, z) => {\n", "example_test": "const testAnyInt = () => {\n  console.assert(anyInt(5, 2, 7) === true)\n  console.assert(anyInt(3, 2, 2) === false)\n  console.assert(anyInt(3, -2, 1) === true)\n  console.assert(anyInt(3.6, -2.2, 2) === false)\n}\ntestAnyInt()\n", "entry_point": "anyInt", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  anyInt(5, 2, 7)  true\n  anyInt(3, 2, 2)  false\n  anyInt(3, -2, 1)  true\n  anyInt(3.6, -2.2, 2)  false\n  */\nconst anyInt = (x, y, z) => {\n  return x === y && y === z || x === -y && y === z || x === -z && y === z || x === y && -y === z || x === -y && -z === z || x === -z && -y === z || x === -z && -z === y || x === y && y === z || x === -y && -y === z || x === -z && -z === y || x === -z && -z === -y;\n};\n\n/* Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  allInt(5, 2, 7)  true\n  allInt(3, 2, 2)  false\n  allInt(3, -2, 1)  true\n  allInt(3.6, -2.2, 2)  false\n  */\nconst allInt = (x, y, z) => {\n  return x === y && y === z || x === -y && y === z || x === -z && y === z || x === y && -y === z || x === -y && -z === z || x === -z && -y === z || x === -z && -z === y || x === y && y === z || x === -y && y === z || x === -z && -y === z || x === -z && -z === -y;\n};\n\n/* Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  evenInt(5, 2, 7)  true\n  evenInt(3, 2, 2)  false\n  evenInt(3, -2, 1)  true\n  evenInt(3.6, -2.2, 2)  false\n  */\nconst evenInt = (x, y, z) => {\n  return x % 2 === 0 && y % 2 === 0 && z % 2 === 0;\n};\n\n/* Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  oddInt(5, 2, 7)  true\n  oddInt(3, 2, 2)  false\n  oddInt(3, -2, 1)  true\n  oddInt(3.6, -2.2, 2)  false\n  */\nconst oddInt = (x, y, z) => {\n  return x % 2 === 1 && y % 2 === 1 && z % 2 === 1;\n};\n\n/* Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  evenOdd(5, 2, 7)  true\n  evenOdd(3, 2, 2)  false\n  evenOdd(3, -2, 1)  true\n  evenOdd(3.6, -2.2, 2)  false\n  */\nconst evenOddInt = (x, y, z) => {\n  return x % 2 === 0 && y % 2 === 0 && z % 2 === 0;\n};\n\n/* Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  oddOdd(5, 2, 7)  true\n  oddOdd(3, 2, 2)  false\n  oddOdd(3, -2, 1)  true\n  oddOdd(3.6, -2.2, 2)  false\n  */\nconst oddOddInt = (x, y, z) => {\n  return x % 2 === 1 && y % 2 === 1 && z % 2 === 1;\n};\n\n/* Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  evenOdd(5, 2, 7)  true\n  evenOdd(3, 2, 2)  false\n  evenOdd(3, -2, 1)  true\n  evenOdd(3.6, -2.2, 2)  false\n  */\nconst evenOddEvenInt = (x, y, z) => {\n  return x % 2 === 0 && y % 2 === 0 && z % 2 === 0;\n};\n\n/* Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  oddOdd(5, 2, 7)  true\n  oddOdd(3, 2, 2)  false\n  oddOdd(3, -2, 1)  true\n  oddOdd(3.6, -2.2, 2)  false\n  */\nconst oddOddOddInt = (x, y, z) => {\n  return x % 2 === 1 && y % 2 === 1 && z % 2 === 1;\n};\n\n/* Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  evenOdd(5, 2, 7)  true\n  evenOdd(3, 2, 2)  false\n  evenOdd(3, -2, 1)  true\n  evenOdd(3.6, -2.2, 2)  false\n  */\nconst evenOddOddEvenInt = (x, y, z) => {\n  return x % 2 === 0 && y % 2 === 0 && z % 2 === 0;\n};\n\n/* Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  oddOdd(5, 2, 7)  true\n  oddOdd(3, 2, 2)  false\n  oddOdd(3, -2, 1)  true\n  oddOdd(3.6, -2.2, 2)  false\n  */\nconst oddOddOddOddInt = (x, y, z) => {\n  return x % 2 === 1 && y % 2 === 1 && z % 2 === 1;\n};\n\n/* Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  evenOdd(5, 2, 7)  true\n  evenOdd(3, 2, 2)  false\n  evenOdd(3, -2, 1)  true\n  evenOdd(3.6, -2.2, 2)  false\n  */\nconst evenOddOddOddEvenInt = (x, y, z) => {\n  return x % 2 === 0 && y % 2 === 0 && z % 2 === 0;\n};\n\n/* Create a function consisting of 3 numbers. Returns true if one of the numbers is equal to the sum of the other two and all numbers are integers. Returns false in all other cases.\n  Examples\n  oddOdd(5, 2, 7)  true\n  oddOdd(3, 2, 2)  false\n  oddOdd(3, -2, 1)  true\n  oddO", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/93", "prompt": "/*\n  Write a function that captures a message and encodes it so that it reverses the uppercase letters of all letters and replaces all vowels in the message with the letter that appears 2 places in front of that vowel in the English alphabet. Let's just say letters. Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n", "canonical_solution": "  let t = ''\n  for (let i = 0; i < message.length; i++) {\n    let p = message[i].charCodeAt()\n    if (p > 96) { p -= 32 }\n    else if (p!=32 && p < 96) { p += 32 }\n    if (p == 65 || p == 97 || p == 69 || p == 101 || p == 73 || p == 105 || p == 79 || p == 111 || p == 85 || p == 117) { p += 2 }\n    t += String.fromCharCode(p)\n  }\n  return t\n}\n\n", "test": "const testEncode = () => {\n  console.assert(encode('TEST') === 'tgst')\n  console.assert(encode('Mudasir') === 'mWDCSKR')\n  console.assert(encode('YES') === 'ygs')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n  console.assert(\n    encode('I DoNt KnOw WhAt tO WrItE') === 'k dQnT kNqW wHcT Tq wRkTg'\n  )\n}\n\ntestEncode()\n", "declaration": "\nconst encode = (message) => {\n", "example_test": "const testEncode = () => {\n  console.assert(encode('test') === 'TGST')\n  console.assert(encode('This is a message') === 'tHKS KS C MGSSCGG')\n}\ntestEncode()\n", "entry_point": "encode", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  Write a function that captures a message and encodes it so that it reverses the uppercase letters of all letters and replaces all vowels in the message with the letter that appears 2 places in front of that vowel in the English alphabet. Let's just say letters. Examples:\n  >>> encode('test')\n  'TGST'\n  >>> encode('This is a message')\n  'tHKS KS C MGSSCGG'\n  */\nconst encode = (message) => {\n  let reversed = '';\n  let vowels = 'aeiouAEIOU';\n  let letters = 'abcdefghijklmnopqrstuvwxyz';\n  let messageLength = message.length;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n  let messageLength = messageLength - 1;\n", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/94", "prompt": "/*YYou get a list of integers. You have to find the largest primary value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n", "canonical_solution": "  let t = 0\n  for (let i = 0; i < lst.length; i++) {\n    let p = 1\n    for (let j = 2; j * j <= lst[i]; j++) {\n      if (lst[i] % j == 0) { p = 0; break }\n    }\n    if (p == 1 && lst[i] > t) { t = lst[i] }\n  }\n  let k = 0\n  while (t != 0) {\n    k += t % 10\n    t = (t - t % 10) / 10\n  }\n  return k\n}\n\n", "test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n\n  console.assert(skjkasdkd([8191]) === 19)\n  console.assert(skjkasdkd([8191, 123456, 127, 7]) === 19)\n  console.assert(skjkasdkd([127, 97, 8192]) === 10)\n}\n\ntestSkjkasdkd()\n", "declaration": "\nconst skjkasdkd = (lst) => {\n", "example_test": "const testSkjkasdkd = () => {\n  console.assert(\n    skjkasdkd([\n      0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3,\n    ]) === 10\n  )\n  console.assert(\n    skjkasdkd([1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]) === 25\n  )\n  console.assert(\n    skjkasdkd([\n      1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3,\n    ]) === 13\n  )\n  console.assert(\n    skjkasdkd([0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]) === 11\n  )\n  console.assert(skjkasdkd([0, 81, 12, 3, 1, 21]) === 3)\n  console.assert(skjkasdkd([0, 8, 1, 2, 1, 7]) === 7)\n}\ntestSkjkasdkd()\n", "entry_point": "skjkasdkd", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*YYou get a list of integers. You have to find the largest primary value and return the sum of its digits.\n\n  Examples:\n  For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n  For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n  For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n  For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n  For lst = [0,81,12,3,1,21] the output should be 3\n  For lst = [0,8,1,2,1,7] the output should be 7\n  */\nconst skjkasdkd = (lst) => {\n  let sum = 0;\n  let max = 0;\n  let maxIndex = 0;\n  let maxDigit = 0;\n  let maxDigitIndex = 0;\n  let maxDigitDigit = 0;\n  let maxDigitDigitIndex = 0;\n  let maxDigitDigitDigit = 0;\n  let maxDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigitDigit = 0;\n  let maxDigitDigitDigitDigitIndex = 0;\n  let maxDigitDigitDigit", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/95", "prompt": "/*\n  If you specify a dictionary, you return true if all key strings are lowercase or all key strings are uppercase, otherwise you return false. If the specified dictionary is empty, the function should return false.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n", "canonical_solution": "  let c = 0\n  let lo = 1\n  let hi = 1\n  for (let key in dict) {\n    c++\n    for (let i = 0; i < key.length; i++) {\n      if (key[i].charCodeAt() < 65 || key[i].charCodeAt() > 90) { hi = 0 }\n      if (key[i].charCodeAt() < 97 || key[i].charCodeAt() > 122) { lo = 0 }\n    }\n  }\n  if ((lo == 0 && hi == 0) || c == 0) { return false }\n  return true\n}\n\n", "test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 5: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n  console.assert(checkDictCase({ fruit: 'Orange', taste: 'Sweet' }) === true)\n  console.assert(checkDictCase({}) === false)\n}\n\ntestCheckDictCase()\n", "declaration": "\nconst checkDictCase = (dict) => {\n", "example_test": "const testCheckDictCase = () => {\n  console.assert(checkDictCase({ p: 'pineapple', b: 'banana' }) === true)\n  console.assert(\n    checkDictCase({ p: 'pineapple', A: 'banana', B: 'banana' }) === false\n  )\n  console.assert(\n    checkDictCase({ p: 'pineapple', 8: 'banana', a: 'apple' }) === false\n  )\n  console.assert(\n    checkDictCase({ Name: 'John', Age: '36', City: 'Houston' }) === false\n  )\n  console.assert(checkDictCase({ STATE: 'NC', ZIP: '12345' }) === true)\n}\ntestCheckDictCase()\n", "entry_point": "checkDictCase", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  If you specify a dictionary, you return true if all key strings are lowercase or all key strings are uppercase, otherwise you return false. If the specified dictionary is empty, the function should return false.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCase = (dict) => {\n  let isCaseSensitive = true;\n  for (let key in dict) {\n    if (dict[key.toLowerCase()]!= dict[key.toUpperCase()]) {\n      isCaseSensitive = false;\n      break;\n    }\n  }\n  return isCaseSensitive;\n};\n\n/*\n  If you specify a dictionary, you return true if all key strings are lowercase or all key strings are uppercase, otherwise you return false. If the specified dictionary is empty, the function should return false.\n  Examples:\n  checkDictCase({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCase({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCase({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCase({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCase({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCaseInsensitive = (dict) => {\n  let isCaseSensitive = true;\n  for (let key in dict) {\n    if (dict[key.toLowerCase()] == dict[key.toUpperCase()]) {\n      isCaseSensitive = false;\n      break;\n    }\n  }\n  return isCaseSensitive;\n};\n\n/*\n  If you specify a dictionary, you return true if all key strings are lowercase or all key strings are uppercase, otherwise you return false. If the specified dictionary is empty, the function should return false.\n  Examples:\n  checkDictCaseInsensitive({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCaseInsensitive({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCaseInsensitive({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCaseInsensitive({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCaseInsensitive({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCaseInsensitiveInsensitive = (dict) => {\n  let isCaseSensitive = true;\n  for (let key in dict) {\n    if (dict[key.toLowerCase()] == dict[key.toUpperCase()]) {\n      isCaseSensitive = false;\n      break;\n    }\n  }\n  return isCaseSensitive;\n};\n\n/*\n  If you specify a dictionary, you return true if all key strings are lowercase or all key strings are uppercase, otherwise you return false. If the specified dictionary is empty, the function should return false.\n  Examples:\n  checkDictCaseInsensitiveInsensitive({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCaseInsensitiveInsensitive({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCaseInsensitiveInsensitive({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCaseInsensitiveInsensitive({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCaseInsensitiveInsensitive({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCaseInsensitiveInsensitiveInsensitive = (dict) => {\n  let isCaseSensitive = true;\n  for (let key in dict) {\n    if (dict[key.toLowerCase()] == dict[key.toUpperCase()]) {\n      isCaseSensitive = false;\n      break;\n    }\n  }\n  return isCaseSensitive;\n};\n\n/*\n  If you specify a dictionary, you return true if all key strings are lowercase or all key strings are uppercase, otherwise you return false. If the specified dictionary is empty, the function should return false.\n  Examples:\n  checkDictCaseInsensitiveInsensitiveInsensitive({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCaseInsensitiveInsensitiveInsensitive({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCaseInsensitiveInsensitiveInsensitive({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCaseInsensitiveInsensitiveInsensitive({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCaseInsensitiveInsensitiveInsensitive({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCaseInsensitiveInsensitiveInsensitiveInsensitive = (dict) => {\n  let isCaseSensitive = true;\n  for (let key in dict) {\n    if (dict[key.toLowerCase()] == dict[key.toUpperCase()]) {\n      isCaseSensitive = false;\n      break;\n    }\n  }\n  return isCaseSensitive;\n};\n\n/*\n  If you specify a dictionary, you return true if all key strings are lowercase or all key strings are uppercase, otherwise you return false. If the specified dictionary is empty, the function should return false.\n  Examples:\n  checkDictCaseInsensitiveInsensitiveInsensitive({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCaseInsensitiveInsensitiveInsensitive({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCaseInsensitiveInsensitiveInsensitive({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return false.\n  checkDictCaseInsensitiveInsensitiveInsensitive({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return false.\n  checkDictCaseInsensitiveInsensitiveInsensitive({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return true.\n  */\nconst checkDictCaseInsensitiveInsensitiveInsensitiveInsensitive = (dict) => {\n  let isCaseSensitive = true;\n  for (let key in dict) {\n    if (dict[key.toLowerCase()] == dict[key.toUpperCase()]) {\n      isCaseSensitive = false;\n      break;\n    }\n  }\n  return isCaseSensitive;\n};\n\n/*\n  If you specify a dictionary, you return true if all key strings are lowercase or all key strings are uppercase, otherwise you return false. If the specified dictionary is empty, the function should return false.\n  Examples:\n  checkDictCaseInsensitiveInsensitiveInsensitive({\"a\":\"apple\", \"b\":\"banana\"}) should return true.\n  checkDictCaseInsensitiveInsensitiveInsensitive({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return false.\n  checkDictCaseInsensitiveInsensitiveInsensitive({\"a\":\"apple\", 8:\"banana\", \"a\":\"", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/96", "prompt": "/*IImplement a function that takes a non-negative integer and returns an array of the first n integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n", "canonical_solution": "  let t = []\n  for (let i = 2; i < n; i++) {\n    let p = 1\n    for (let j = 2; j * j <= i; j++) {\n      if (i % j == 0) { p = 0; break }\n    }\n    if (p == 1) { t.push(i) }\n  }\n  return t\n}\n\n", "test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(6)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(7)) === JSON.stringify([2, 3, 5]))\n  console.assert(JSON.stringify(countUpTo(10)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(22)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(47)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43])\n  )\n  console.assert(\n    JSON.stringify(countUpTo(101)) ===\n    JSON.stringify([\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\n      71, 73, 79, 83, 89, 97,\n    ])\n  )\n}\n\ntestCountUpTo()\n", "declaration": "\nconst countUpTo = (n) => {\n", "example_test": "const testCountUpTo = () => {\n  console.assert(JSON.stringify(countUpTo(5)) === JSON.stringify([2, 3]))\n  console.assert(JSON.stringify(countUpTo(11)) === JSON.stringify([2, 3, 5, 7]))\n  console.assert(JSON.stringify(countUpTo(0)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(20)) ===\n    JSON.stringify([2, 3, 5, 7, 11, 13, 17, 19])\n  )\n  console.assert(JSON.stringify(countUpTo(1)) === JSON.stringify([]))\n  console.assert(\n    JSON.stringify(countUpTo(18)) === JSON.stringify([2, 3, 5, 7, 11, 13, 17])\n  )\n}\ntestCountUpTo()\n", "entry_point": "countUpTo", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*IImplement a function that takes a non-negative integer and returns an array of the first n integers that are prime numbers and less than n.\n  for example:\n  countUpTo(5) => [2,3]\n  countUpTo(11) => [2,3,5,7]\n  countUpTo(0) => []\n  countUpTo(20) => [2,3,5,7,11,13,17,19]\n  countUpTo(1) => []\n  countUpTo(18) => [2,3,5,7,11,13,17]\n  */\nconst countUpTo = (n) => {\n  let primes = [];\n  let i = 1;\n  let j = 1;\n  let k = 1;\n  let prime = true;\n  while (prime) {\n    prime = false;\n    for (let k = 0; k < n; k++) {\n      if (primes[k]) {\n        prime = true;\n      }\n    }\n    if (prime) {\n      primes.push(j);\n      j++;\n    }\n    i++;\n  }\n  return primes;\n};\n\n/**\n * Given a non-negative integer n, return an array of the numbers from 1 to n that are divisible by 3.\n */\nconst divisibleByThree = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/**\n * Given a non-negative integer n, return an array of the numbers from 1 to n that are divisible by 5.\n */\nconst divisibleByFive = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/**\n * Given a non-negative integer n, return an array of the numbers from 1 to n that are divisible by 7.\n */\nconst divisibleBySeven = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/**\n * Given a non-negative integer n, return an array of the numbers from 1 to n that are divisible by 9.\n */\nconst divisibleByNine = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/**\n * Given a non-negative integer n, return an array of the numbers from 1 to n that are divisible by 11.\n */\nconst divisibleByTen = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/**\n * Given a non-negative integer n, return an array of the numbers from 1 to n that are divisible by 13.\n */\nconst divisibleByEleven = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/**\n * Given a non-negative integer n, return an array of the numbers from 1 to n that are divisible by 17.\n */\nconst divisibleByTwelve = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/**\n * Given a non-negative integer n, return an array of the numbers from 1 to n that are divisible by 19.\n */\nconst divisibleByThirteen = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/**\n * Given a non-negative integer n, return an array of the numbers from 1 to n that are divisible by 23.\n */\nconst divisibleByFourteen = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/**\n * Given a non-negative integer n, return an array of the numbers from 1 to n that are divisible by 29.\n */\nconst divisibleByFifteen = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/**\n * Given a non-negative integer n, return an array of the numbers from 1 to n that are divisible by 31.\n */\nconst divisibleBySixteen = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/**\n * Given a non-negative integer n, return an array of the numbers from 1 to n that are divisible by 35.\n */\nconst divisibleBySeventeen = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/**\n * Given a non-negative integer n, return an array of the numbers from 1 to n that are divisible by 39.\n */\nconst divisibleByEighteen = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/**\n * Given a non-negative integer n, return an array of the numbers from 1 to n that are divisible by 42.\n */\nconst divisibleByNineteen = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/**\n * Given a non-negative integer n, return an array of the numbers from 1 to n that are divisible by 47.\n */\nconst divisibleByTwenty = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/**\n * Given a non-negative integer n, return an array of the numbers from 1 to n that are divisible by 53.\n */\nconst divisibleByThirty = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/**\n * Given a non-negative integer n, return an array of the numbers from 1 to n that are divisible by 59.\n */\nconst divisibleByForty = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/**\n * Given a non-negative integer n, return an array of the numbers from 1 to n that are divisible by 61.\n */\nconst divisibleByFifty = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/**\n * Given a non-negative integer n, return an array of the numbers from 1 to n that are divisible by 67.\n */\nconst divisibleBySixty = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/**\n * Given a non-negative integer n, return an array of the numbers from 1 to n that are divisible by 71.\n */\nconst divisibleBySeventy = (n) => {\n  let arr = [];\n  for (let i = 1; i <= n; i++) {\n    if (n % i === 0) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n/**\n * Given a non-negative integer n, return an array of the numbers from 1 to n that are divisible by 79.\n */\nconst divisibleByEighty = (n) => {\n  let ", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/97", "prompt": "/*CComplete the function that takes two integers and returns the product of their unit digits. Suppose the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n", "canonical_solution": "  if (a < 0) { a = -a }\n  if (b < 0) { b = -b }\n  return (a % 10) * (b % 10)\n}\n\n", "test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n  console.assert(multiply(76, 67) === 42)\n  console.assert(multiply(17, 27) === 49)\n  console.assert(multiply(0, 1) === 0)\n  console.assert(multiply(0, 0) === 0)\n}\n\ntestMultiply()\n", "declaration": "\nconst multiply = (a, b) => {\n", "example_test": "const testMultiply = () => {\n  console.assert(multiply(148, 412) === 16)\n  console.assert(multiply(19, 28) === 72)\n  console.assert(multiply(2020, 1851) === 0)\n  console.assert(multiply(14, -15) === 20)\n}\ntestMultiply()\n", "entry_point": "multiply", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*CComplete the function that takes two integers and returns the product of their unit digits. Suppose the input is always valid.\n  Examples:\n  multiply(148, 412) should return 16.\n  multiply(19, 28) should return 72.\n  multiply(2020, 1851) should return 0.\n  multiply(14,-15) should return 20.\n  */\nconst multiply = (a, b) => {\n  let product = 1;\n  let digit = 0;\n  let digits = [];\n  let digitSum = 0;\n  let digitSum2 = 0;\n  let digitSum3 = 0;\n  let digitSum4 = 0;\n  let digitSum5 = 0;\n  let digitSum6 = 0;\n  let digitSum7 = 0;\n  let digitSum8 = 0;\n  let digitSum9 = 0;\n  let digitSum10 = 0;\n  let digitSum11 = 0;\n  let digitSum12 = 0;\n  let digitSum13 = 0;\n  let digitSum14 = 0;\n  let digitSum15 = 0;\n  let digitSum16 = 0;\n  let digitSum17 = 0;\n  let digitSum18 = 0;\n  let digitSum19 = 0;\n  let digitSum20 = 0;\n  let digitSum21 = 0;\n  let digitSum22 = 0;\n  let digitSum23 = 0;\n  let digitSum24 = 0;\n  let digitSum25 = 0;\n  let digitSum26 = 0;\n  let digitSum27 = 0;\n  let digitSum28 = 0;\n  let digitSum29 = 0;\n  let digitSum30 = 0;\n  let digitSum31 = 0;\n  let digitSum32 = 0;\n  let digitSum33 = 0;\n  let digitSum34 = 0;\n  let digitSum35 = 0;\n  let digitSum36 = 0;\n  let digitSum37 = 0;\n  let digitSum38 = 0;\n  let digitSum39 = 0;\n  let digitSum40 = 0;\n  let digitSum41 = 0;\n  let digitSum42 = 0;\n  let digitSum43 = 0;\n  let digitSum44 = 0;\n  let digitSum45 = 0;\n  let digitSum46 = 0;\n  let digitSum47 = 0;\n  let digitSum48 = 0;\n  let digitSum49 = 0;\n  let digitSum50 = 0;\n  let digitSum51 = 0;\n  let digitSum52 = 0;\n  let digitSum53 = 0;\n  let digitSum54 = 0;\n  let digitSum55 = 0;\n  let digitSum56 = 0;\n  let digitSum57 = 0;\n  let digitSum58 = 0;\n  let digitSum59 = 0;\n  let digitSum60 = 0;\n  let digitSum61 = 0;\n  let digitSum62 = 0;\n  let digitSum63 = 0;\n  let digitSum64 = 0;\n  let digitSum65 = 0;\n  let digitSum66 = 0;\n  let digitSum67 = 0;\n  let digitSum68 = 0;\n  let digitSum69 = 0;\n  let digitSum70 = 0;\n  let digitSum71 = 0;\n  let digitSum72 = 0;\n  let digitSum73 = 0;\n  let digitSum74 = 0;\n  let digitSum75 = 0;\n  let digitSum76 = 0;\n  let digitSum77 = 0;\n  let digitSum78 = 0;\n  let digitSum79 = 0;\n  let digitSum80 = 0;\n  let digitSum81 = 0;\n  let digitSum82 = 0;\n  let digitSum83 = 0;\n  let digitSum84 = 0;\n  let digitSum85 = 0;\n  let digitSum86 = 0;\n  let digitSum87 = 0;\n  let digitSum88 = 0;\n  let digitSum89 = 0;\n  let digitSum90 = 0;\n  let digitSum91 = 0;\n  let digitSum92 = 0;\n  let digitSum93 = 0;\n  let digitSum94 = 0;\n  let digitSum95 = 0;\n  let digitSum96 = 0;\n  let digitSum97 = 0;\n  let digitSum98 = 0;\n  let digitSum99 = 0;\n  let digitSum100 = 0;\n  let digitSum101 = 0;\n  let digitSum102 = 0;\n  let digitSum103 = 0;\n  let digitSum104 = 0;\n  let digitSum105 = 0;\n  let digitSum106 = 0;\n  let digitSum107 = 0;\n  let digitSum108 = 0;\n  let digitSum109 = 0;\n  let digitSum110 = 0;\n  let digitSum111 = 0;\n  let digitSum112 = 0;\n  let digitSum113 = 0;\n  let digitSum114 = 0;\n  let digitSum115 = 0;\n  let digitSum116 = 0;\n  let digitSum117 = 0;\n  let digitSum118 = 0;\n  let digitSum119 = 0;\n  let digitSum120 = 0;\n  let digitSum121 = 0;\n  let digitSum122 = 0;\n  let digitSum123 = 0;\n  let digitSum124 = 0;\n  let digitSum125 = 0;\n  let digitSum126 = 0;\n  let digitSum127 = 0;\n  let digitSum128 = 0;\n  let digitSum129 = 0;\n  let digitSum130 = 0;\n  let digitSum131 = 0;\n  let digitSum132 = 0;\n  let digitSum133 = 0;\n  let digitSum134 = 0;\n  let digitSum135 = 0;\n  let digitSum136 = 0;\n  let digitSum137 = 0;\n  let digitSum138 = 0;\n  let digitSum139 = 0;\n  let digitSum140 = 0;\n  let digitSum141 = 0;\n  let digitSum142 = 0;\n  let digitSum143 = 0;\n  let digitSum144 = 0;\n  let digitSum145 = 0;\n  let digitSum146 = 0;\n  let digitSum147 = 0;\n  let digitSum148 = 0;\n  let digitSum149 = 0;\n  let digitSum150 = 0;\n  let digitSum151 = 0;\n  let digitSum152 = 0;\n  let digitSum153 = 0;\n  let digitSum154 = 0;\n  let digitSum155 = 0;\n  let digitSum156 = 0;\n  let digitSum157 = 0;\n  let digitSum158 = 0;\n  let digitSum159 = 0;\n  let digitSum160 = 0;\n  let digitSum161 = 0;\n  let digitSum162 = 0;\n  let digitSum163 = 0;\n  let digitSum164 = 0;\n  let digitSum165 = 0;\n  let digitSum166 = 0;\n  let digitSum167 = 0;\n  let digitSum168 = 0;\n  let digitSum169 = 0;\n  let digitSum170 = 0;\n  let digitSum171 = 0;\n  let digitSum172 = 0;\n  let digitSum173 = 0;\n  let digitSum174 = 0;\n  let digitSum175 = 0;\n  let digitSum176 = 0;\n  let digitSum177 = 0;\n  let digitSum178 = 0;\n  let digitSum179 = 0;\n  let digitSum180 = 0;\n  let digitSum181 = 0;\n  let digitSum182 = 0;\n  let digitSum183 = 0;\n  let digitSum184 = 0;\n  let digitSum185 = 0;\n  let digitSum186 = 0;\n  let digitSum187 = 0;\n  let digitSum188 = 0;\n  let digitSum189 = 0;\n  let digitSum190 = 0;\n  let digitSum191 = 0;\n  let digitSum192 = 0;\n  let digitSum193 = 0;\n  let digitSum194 = 0;\n  let digitSum195 = 0;\n  let digitSum196 = 0;\n  let digitSum197 = 0;\n  let digitSum198 = 0;\n  let digitSum199 = 0;\n  let digitSum200 = 0;\n  let digitSum201 = 0;\n  let digitSum202 = 0;\n  let digitSum203 = 0;\n  let digitSum204 = 0;\n  let digitSum205 = 0;\n  let digitSum206 = 0;\n  let digitSum207 = 0;\n  let digitSum208 = 0;\n  let digitSum209 = 0;\n  let digitSum210 = 0;\n  let digitSum211 = 0;\n  let digitSum212 = 0;\n  let digitSum213 = 0;\n  let digitSum214 = 0;\n  let digitSum215 = 0;\n  let digitSum216 = 0;\n  let digitSum217 = 0;\n  let digitSum218 = 0;\n  let digitSum219 = 0;\n  let digitSum220 = 0;\n  let digitSum221 = 0;\n  let digitSum222 = 0;\n  let digitSum223 = 0;\n  let digitSum224 = 0;\n  let digitSum225 = 0;\n  let digitSum226 = 0;\n  let digitSum227 = 0;\n  let digitSum228 = 0;\n  let digitSum229 = 0;\n  let digitSum230 = 0;\n  let digitSum231 = 0;\n  let digitSum232 = 0;\n  let digitSum233 = 0;\n  let digitSum234 = 0;\n  let digitSum235 = 0;\n  let digitSum236 = 0;\n  let digitSum237 = 0;\n  let digitSum238 = 0;\n  let digitSum239 = 0;\n  let digitSum240 = 0;\n  let digitSum241 = 0;\n  let digitSum242 = 0;\n  let ", "passed": 0, "run_status": 2, "passed_evalplus": 0, "run_status_evalplus": 2, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 2}
{"task_id": "JavaScript/98", "prompt": "/*\n  For a string s, the number of uppercase letters in even indexes is counted.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n", "canonical_solution": "  let p = 0\n  for (let i = 0; i < s.length; i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') { p++ }\n  }\n  return p\n}\n\n", "test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n  console.assert(countUpper('B') === 0)\n  console.assert(countUpper('U') === 1)\n  console.assert(countUpper('') === 0)\n  console.assert(countUpper('EEEE') === 2)\n}\n\ntestCountUpper()\n", "declaration": "\nconst countUpper = (s) => {\n", "example_test": "const testCountUpper = () => {\n  console.assert(countUpper('aBCdEf') === 1)\n  console.assert(countUpper('abcdefg') === 0)\n  console.assert(countUpper('dBBE') === 0)\n}\ntestCountUpper()\n", "entry_point": "countUpper", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/*\n  For a string s, the number of uppercase letters in even indexes is counted.\n  \n  For example:\n  countUpper('aBCdEf') returns 1\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i).toUpperCase() === s.charAt(i).toUpperCase()) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s and an integer n, return the number of lowercase letters in odd indexes of s.\n  \n  For example:\n  countLower('aBCdEf') returns 2\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower = (s, n) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i).toLowerCase() === s.charAt(i).toLowerCase()) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s and an integer n, return the number of uppercase letters in odd indexes of s.\n  \n  For example:\n  countUpper('aBCdEf') returns 3\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s, n) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i).toUpperCase() === s.charAt(i).toUpperCase()) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s and an integer n, return the number of lowercase letters in even indexes of s.\n  \n  For example:\n  countLower('aBCdEf') returns 2\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower = (s, n) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i).toLowerCase() === s.charAt(i).toLowerCase()) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s and an integer n, return the number of uppercase letters in even indexes of s.\n  \n  For example:\n  countUpper('aBCdEf') returns 3\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s, n) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i).toUpperCase() === s.charAt(i).toUpperCase()) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s and an integer n, return the number of lowercase letters in odd indexes of s.\n  \n  For example:\n  countLower('aBCdEf') returns 2\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower = (s, n) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i).toLowerCase() === s.charAt(i).toLowerCase()) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s and an integer n, return the number of uppercase letters in odd indexes of s.\n  \n  For example:\n  countUpper('aBCdEf') returns 3\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s, n) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i).toUpperCase() === s.charAt(i).toUpperCase()) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s and an integer n, return the number of lowercase letters in even indexes of s.\n  \n  For example:\n  countLower('aBCdEf') returns 2\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower = (s, n) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i).toLowerCase() === s.charAt(i).toLowerCase()) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s and an integer n, return the number of uppercase letters in even indexes of s.\n  \n  For example:\n  countUpper('aBCdEf') returns 3\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s, n) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i).toUpperCase() === s.charAt(i).toUpperCase()) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s and an integer n, return the number of lowercase letters in odd indexes of s.\n  \n  For example:\n  countLower('aBCdEf') returns 2\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower = (s, n) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i).toLowerCase() === s.charAt(i).toLowerCase()) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s and an integer n, return the number of uppercase letters in odd indexes of s.\n  \n  For example:\n  countUpper('aBCdEf') returns 3\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s, n) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i).toUpperCase() === s.charAt(i).toUpperCase()) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s and an integer n, return the number of lowercase letters in even indexes of s.\n  \n  For example:\n  countLower('aBCdEf') returns 2\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower = (s, n) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i).toLowerCase() === s.charAt(i).toLowerCase()) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s and an integer n, return the number of uppercase letters in even indexes of s.\n  \n  For example:\n  countUpper('aBCdEf') returns 3\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s, n) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i).toUpperCase() === s.charAt(i).toUpperCase()) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s and an integer n, return the number of lowercase letters in odd indexes of s.\n  \n  For example:\n  countLower('aBCdEf') returns 2\n  countLower('abcdefg') returns 0\n  countLower('dBBE') returns 0\n  */\nconst countLower = (s, n) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1) {\n    if (s.charAt(i).toLowerCase() === s.charAt(i).toLowerCase()) {\n      count += 1;\n    }\n  }\n  return count;\n};\n\n/*\n  Given a string s and an integer n, return the number of uppercase letters in odd indexes of s.\n  \n  For example:\n  countUpper('aBCdEf') returns 3\n  countUpper('abcdefg') returns 0\n  countUpper('dBBE') returns 0\n  */\nconst countUpper = (s, n) => {\n  let count = 0;\n  for (let i = 0; i < s.length; i += 1", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 1, "passed_ep": 0, "run_status_ep": 1}
{"task_id": "JavaScript/99", "prompt": "/* Create a function that takes a value (string) that represents a number and returns the nearest integer to it. If the number is equal to two integers, round it from zero. Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n", "canonical_solution": "  value = Number(value)\n  let t = value % 1\n  if (t < 0.5 && t > -0.5) { value -= t }\n  else { value += t }\n  return value\n}\n\n", "test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('14.5') === 15)\n  console.assert(closestInteger('-15.5') === -16)\n  console.assert(closestInteger('15.3') === 15)\n  console.assert(closestInteger('0') === 0)\n}\n\ntestClosestInteger()\n", "declaration": "\nconst closestInteger = (value) => {\n", "example_test": "const testClosestInteger = () => {\n  console.assert(closestInteger('10') === 10)\n  console.assert(closestInteger('15.3') === 15)\n}\ntestClosestInteger()\n", "entry_point": "closestInteger", "seed": 0, "perturbed": true, "gc": "<|endoftext|>/* Create a function that takes a value (string) that represents a number and returns the nearest integer to it. If the number is equal to two integers, round it from zero. Examples\n  >>> closestInteger(\"10\")\n  10\n  >>> closestInteger(\"15.3\")\n  15\n  Note:\n  Rounding away from zero means that if the given number is equidistant\n  from two integers, the one you should return is the one that is the\n  farthest from zero. For example closestInteger(\"14.5\") should\n  return 15 and closestInteger(\"-14.5\") should return -15.\n  */\nconst closestInteger = (value) => {\n  const [integer, fraction] = value.split(\".\");\n  return parseInt(integer, 10) + Math.pow(10, Math.floor(fraction.length - 1));\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseInt = value => {\n  return parseInt(value, 10);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseFloat = value => {\n  return parseFloat(value);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseInt = value => {\n  return parseInt(value, 10);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseFloat = value => {\n  return parseFloat(value);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseInt = value => {\n  return parseInt(value, 10);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseFloat = value => {\n  return parseFloat(value);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseInt = value => {\n  return parseInt(value, 10);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseFloat = value => {\n  return parseFloat(value);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseInt = value => {\n  return parseInt(value, 10);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseFloat = value => {\n  return parseFloat(value);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseInt = value => {\n  return parseInt(value, 10);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseFloat = value => {\n  return parseFloat(value);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseInt = value => {\n  return parseInt(value, 10);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseFloat = value => {\n  return parseFloat(value);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseInt = value => {\n  return parseInt(value, 10);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseFloat = value => {\n  return parseFloat(value);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseInt = value => {\n  return parseInt(value, 10);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseFloat = value => {\n  return parseFloat(value);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseInt = value => {\n  return parseInt(value, 10);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseFloat = value => {\n  return parseFloat(value);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseInt = value => {\n  return parseInt(value, 10);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseFloat = value => {\n  return parseFloat(value);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseInt = value => {\n  return parseInt(value, 10);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseFloat = value => {\n  return parseFloat(value);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseInt = value => {\n  return parseInt(value, 10);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseFloat = value => {\n  return parseFloat(value);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseInt = value => {\n  return parseInt(value, 10);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseFloat = value => {\n  return parseFloat(value);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseInt = value => {\n  return parseInt(value, 10);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseFloat = value => {\n  return parseFloat(value);\n};\n\n/**\n * Given a string, convert it to a number by parsing it into an integer and returning the result. For example, parseInt(\"10\") should return 10.\n */\nconst parseInt = value => {\n  return parseInt(", "passed": 0, "run_status": 1, "passed_evalplus": 0, "run_status_evalplus": 1, "passed_he": 0, "run_status_he": 2, "passed_ep": 0, "run_status_ep": 1}
